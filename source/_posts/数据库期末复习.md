---
title: 数据库期末复习
date: 2022-05-09 19:00:50
tags: [数据库,期末复习]
---

<meta name="referrer" content="no-referrer"/>

# 数据库期末复习重点

## 第一章 绪论

### 名词理解

#### 数据

​	描述事物的符号记录。

#### 数据库

​	概括的讲：数据库数据具有==永久存储==、==有组织==和==可共享==的三个基本特点

#### 数据库管理系统

​	是==位于用户和操作系统之间==的一层数据管理软件，和操作系统一样是计算机的基础软件。

#### 数据库系统

​	是由**数据库**、**数据库管理系统（及其应用开发工具）**、**应用程序**和**数据库管理员（DBA）**组成的==存储==、==管理==、==处理==和==维护==数据的系统。下面这张图解释了数据库系统之间各个部分之间的关系：

![image-20220509193759759](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509193759759.png)

---

#### 人工管理阶段

​	数据不保存、不共享、不具有独立性。

#### 文件系统阶段

​	可保存，但共享性差、冗余度大、独立性差。

#### 数据库管理系统阶段

​	数据库系统的出现使信息系统从==以加工数据的程序为中心==转向==围绕共享的数据库为中心==的新阶段。

​	实现了整体数据的结构化，数据的==共享性高==、==冗余度低==且==易扩充==（数据共享可以大大减少数据冗余，节约存储空间）、数据==独立性高==。

​	数据由数据库管理系统统一管理和控制。

---

#### 两类数据模型

​	概念模型+逻辑模型和物理模型（人们首先将现实世界抽象为信息世界，然后将信息世界转换为机器世界）

#### 概念模型

​	也称**信息模型**，它是按用户观点来对数据和信息建模，主要用于数据库设计，==以下直到逻辑模型都是概念模型中的说法，注意与后面逻辑模型中的说法区分==。

#### 实体

​	==客观存在==并==可相互区别==的事物。比如：人

#### 属性

​	实体所具有的==某一特征==。比如：人的鼻子、嘴巴

#### 码

​	==唯一标识实体的属性==。比如：身份证号

#### 实体型

​	用==实体名==及其==属性集合==来抽象和刻画同类实体。比如：含有鼻子和嘴巴的人

#### 实体集

​	==同一类型==实体的集合。比如：学校

#### 联系

​	实体之间的联系通常是指不同实体集之间的联系。实体之间的联系有一对一、一对多和多对多等多种联系。

​	实体内部的联系通常是指实体各属性之间的联系。

​	概念模型的一种表示方法：实体-联系方法。用E-R图来描述现实世界的概念模型，E-R方法也称为E-R模型。

![image-20220509201549307](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509201549307.png)

#### 逻辑模型

​	它是按计算机系统的观点对数据建模，主要用于数据库管理系统的实现。包括：==层次模型==、==网状模型==、==关系模型==。

![image-20220509201745152](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509201745152.png)

![image-20220509201812571](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509201812571.png)

![image-20220509201846932](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509201846932.png)

#### 物理模型

​	是对数据最底层的抽象，它描述数据在系统内部的表示方法和存取方法，或在磁盘或者磁带上的存储方式和存取方法，是面向计算机系统的。

---

*以下直到分割线都是逻辑模型中的说法，注意和之前概念模型中的说法区分开。*

#### 关系

​	一个关系对应一张表

#### 元组

​	表中的一行

#### 属性

​	表中的一列

#### 码

​	也称码键，是表中的某个属性组

#### 域

​	是一组具有相同数据类型的值的集合

#### 分量

​	元组中的一个属性

---

### 数据库系统的结构

![image-20220509202757163](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509202757163.png)

​	![image-20220509202908686](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509202908686.png)

### 数据库系统的组成

![image-20220509202946472](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509202946472.png)

---

## 第二章 关系数据库

### 关系模式（了解即可）

![image-20220509204908291](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509204908291.png)

---

### 关系操作

​	关系操作分为插入、查询、删除、修改。

​	其中查询操作分为：选择、投影、连接、除法、并、差、交、笛卡尔积。

​	查询操作的基本操作：选择、投影、并、差、笛卡尔积

---

### 关系语言的分类

​	分为关系代数语言（重点）、关系演算语言（不重要）、SQL语言（重点）。

---

### 关系代数语言

​	![image-20220509231814646](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509231814646.png)

![image-20220509231835322](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509231835322.png)

#### 交

![image-20220509231949417](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509231949417.png)

#### 并

![image-20220509232011431](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509232011431.png)

#### 差

![image-20220509232030942](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509232030942.png)

#### 笛卡尔积

![image-20220509232146062](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509232146062.png)

​	实际上就是两个关系的==全排列==，注意不要遗漏记录，而且注意==新表的属性名是有改变的==，主要是为了区分两个不同关系的属性，而且==新表的属性相对于之前的表的属性来说是没有缺失的==。

#### 选择

![image-20220509233303438](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509233303438.png)

![image-20220509233345545](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509233345545.png)

​	注意选择的时候，==条件要写在符号下面==，然后==括号里写要进行操作的表==，最后==查出来的结果是一个表==。

#### 投影

![image-20220509233739822](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509233739822.png)

​	如果说选择是选择出来了符合要求的元组组成的新表，那么投影就是选择出来了指定的属性组成的新表。选择操作是筛选行，投影操作是筛选列。==投影符号下面要写想要做投影的属性==，如果有多个，则用逗号隔开。

#### 连接

​	连接分为4种：

​	![image-20220510102632880](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220510102632880.png)

##### 自然连接

​	把共同属性进行等值连接。就是==把两个表中具有相同公共属性值的记录之间做笛卡尔积==，得到的==结果是个新表==，==结果中没有重复的属性==。

![image-20220510103253808](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220510103253808.png)

##### 悬浮元组

​	两个关系R和S在做自然连接时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃了，这些被舍弃的元组称为悬浮元组。S中被舍弃的元组也是悬浮元组。

##### 外连接

​	如果把悬浮元组也保存在结果关系中，而在其他属性上填空值Null，就叫做外连接，注意这里的悬浮元组包括左右两边的悬浮元组。

##### 左外连接

​	结果关系只保留左边关系中的悬浮元组。

##### 右外连接

​	结果关系只保留右边关系中的悬浮元组。

#### 除

​	结果关系中==保留R中满足和S具有相同的所有公共属性值的记录==，而且==去掉R中S的属性==。

![image-20220510114022738](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220510114022738.png)

![image-20220510114056226](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220510114056226.png)

---

### 关系的完整性

#### 实体完整性

​	主码唯一且非空

#### 参照完整性

​	外码要么为空，要么对应另一个表的主码。外码指的是别的表的属性，一般用来关联两个表。

#### 用户定义完整性

​	用户自己定义的关系要完整，不能有关键属性的遗漏。

---

## 第三章 SQL语言

### SQL的基本概念

![image-20220510122402291](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220510122402291.png)

下面是几种数据库管理系统（分为关系型和非关系型）：

![image-20220510122542427](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220510122542427.png)

不同数据库管理系统的SQL语言略有不同：

![image-20220510122618652](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220510122618652.png)

### SQL语言的特点

**SQL语言的关键字不区分大小写。**

![image-20220510122814270](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220510122814270.png)

### SQL的基本语法

#### SQL的数据类型（变量类型）

![image-20220510143149098](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220510143149098.png)

![image-20220510143214463](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220510143214463.png)

​	Decimal(p,d)，==p指定它由几位数字组成==，不包括小数点和符号，==d指明小数点后有几位数字==。

#### 模式定义&删除

##### 模式定义

```sql
create schema <模式名> authorization <用户名>;
```

这个语句就是为指定用户定义了一个模式。

##### 模式定义+视图

```sql
create schema <模式名> authorization <用户名> [<表定义子句>|<视图定义子句>|<授权定义子句>];
```

##### 模式删除

```sql
drop schema <模式名> <cascade|restrict>;
```

![image-20220510144857155](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220510144857155.png)

#### 表的定义和删除和修改

##### 表的定义

```sql
create table <表名>(<字段名> <数据类型> [字段约束][,<字段名> <数据类型> [字段约束]]......);
```

主键的字段约束是：primary key

##### 表的删除

```sql
drop table <表名> [restrict|cascade];
```

![image-20220510150233838](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220510150233838.png)

如果一个表有外键、视图、触发器等的话，用cascade也会强行删除该表，但是用restrict就不会删除该表。

##### 表的修改

以添加属性为例：

```sql
alter table <表名> [add [column] <新列名> <数据类型> [完整性约束]] [add <表级完整性约束>];
```

![image-20220510151910797](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220510151910797.png)

#### 索引的建立、修改和删除

**当数据量比较大的时候，查询耗 时长，建立索引可以有效减少消耗时间，索引可以建立在一列或者多列上，索引应该是独一无二的。**

##### 索引的建立

```sql
create [unique] [cluster] index <索引名> on <表名>(<列名> [<次序>][,(<列名> [<次序>]]......);
```

cluster：聚簇索引，物理顺序与索引的逻辑顺序相同

unique：唯一索引

例：

![image-20220510153031276](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220510153031276.png)

##### 索引的修改

```sql
alter index <旧索引名> rename to <新索引名>;
```

![image-20220510153306184](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220510153306184.png)

##### 索引的删除

```sql
drop index <索引名>;
```

![image-20220510153350218](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220510153350218.png)

#### 查询列

##### 查询部分列

```sql
select <列名> [as] [<别名>][,<列名> [as] [<别名>]......] from <表名> [as] [<别名>];
```

​	最后查出来的结果是由指定的列组成的表。

​	如果给列起了别名，那么最后查出来的那个表中对应列的名字是起的别名。

​	如果给表起了别名，那么以后就可以直接用别名来操作对应的表。

##### 查询所有列

```sql
select * from 表名;
```

##### 结果去重

在select后加**distinct关键字**即可。例如：

```sql
select distinct * from <表名>;
```

##### 条件查询

![image-20220511122854804](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220511122854804.png)

​	在使用条件查询的时候，在普通查询语句的后面要写一个**where关键字**，在where后面写条件表达式。最后的结果是指定表中所有符合条件表达式的记录的指定列组成的新表。例：

```sql
select distinct * from <表名> where <条件表达式>;
```



​	可以直接在select后面写条件表达式，这样最后查出来的表名是写的条件表达式，其中的值就是条件表达式的值。

​	在sql中**'%'表示匹配任意多个字符**，**'_'表示匹配任意单个字符**，这个在条件查询中构建条件正则表达式时会用到。

​	在构建条件表达式时，这些关键字的应用符合大多数编程语言构建条件表达式时的习惯，也比较符合自然语言的习惯.

#### 聚集函数

![image-20220511125537790](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220511125537790.png)

​	聚集函数通常放在select后面使用，查出来的表名是聚集函数名，查出来的值是聚集函数的值。例：

```sql
select count(*) from <表名>;
```

再补充几个聚集函数：

1、datediff(date1,date2)：求日期1和日期2差了几天。

#### 分组查询

​	分组查询**一般用于统计数据**，使用分组能让汇总结果一目了然，**一般要配合聚合函数一起使用**。

​	在普通查询的后面添加**group by关键字**然后写列名来根据指定的列名进行分组，返回的结果是所有分组的指定列的值，如果要是想根据条件筛选组的话，可以在最后添加**having关键字**然后构造条件表达式，注意having和where不同之处在于**where是对分组前的信息做筛选**而**having是对分组之后的信息做筛选**。

​	注意这个东西查出来的结果很像去重，但是实际上**不是去重**，是分组，对应列的值相同的记录且满足指定条件的分到同一组中，**前面select后面不能是'*'，可以写用来分组的列或者是一些聚集函数**，通过搭配聚集函数可以实现更高级的查询操作。例如根据deptno分组，查询每个分组sal的汇总值：

```sql
select deptno,sum(sal) from emp group by deptno [having <条件表达式>];
```

#### 表的连接

##### 非等值连接

​	即两个表之间做笛卡尔积。

```sql
select * from <表名> [<别名>] [,<表名> [<别名>]......];
```

##### 等值连接

​	在非等值连接的基础上通过where关键字来构建连接条件即可，最后的结果会把多表中满足条件表达式的记录做笛卡尔积，如果要访问表中的列，需要使用**表名(或别名).列名(或别名)**来进行访问。如果条件表达式中有类似于两表之中某属性相同这样的条件，那么查出来的结果表中，两表相同的属性会被合并。

```sql
select * from <表名> [<别名>] [,<表名> [<别名>]......] where <条件表达式>;
```

##### 自身连接

​	即一个表与自身进行连接操作，可以为同一个表起多个别名然后进行操作。

```sql
select * from <表名> <别名> , <表名> <别名>...... [where <条件表达式>];
```

##### 内连接

​	用**inner join关键字**和**on关键字**来实现两表内连接，on后面写构造的条件表达式，结果是满足条件的记录之间做内连接。

```sql
select * from <表名> [<别名>] inner join <表名> [<别名>] [on <条件表达式>];
```

##### 外连接

​	用**full outer join关键字**和**on关键字**来实现两表外连接，on后面写构造的条件表达式，结果是满足条件的记录之间做外连接。**mysql不支持满外连接！！！**

```sql
select * from <表名> [<别名>] full outer join <表名> [<别名>] [on <条件表达式>];
```

##### 左外连接

​	用**left outer join关键字**和**on关键字**来实现两表右外连接，on后面写构造的条件表达式，结果是满足条件的记录之间做左外连接。

```sql
select * from <表名> [<别名>] left outer join <表名> [<别名>] [on <条件表达式>];
```

##### 右外连接

​	用**right outer join关键字**和**on关键字**来实现两表右外连接，on后面写构造的条件表达式，结果是满足条件的记录之间做右外连接。

```sql
select * from <表名> [<别名>] right outer join <表名> [<别名>] [on <条件表达式>];
```

##### 多表连接

​	如果有两个以上的表来进行内连接、外连接、左外连接、右外连接的话，只需要在后面继续添加关键字即可。例如：

```sql
select * from <表名> [<别名>] inner join <表名> [<别名>] [on <条件表达式>] full outer join <表名> [<别名>] [on <条件表达式>]......;
```

#### 嵌套查询

​	只需要将内嵌的查询语句放到需要的位置即可，要注意查询返回的结果都是表，因此应该放到需要表作为参数的地方。例：

```sql
select * from <表名> [<别名>] where <列名> [<别名>] in (<查询语句>);
```

这样就是查出了所有对应表中列的值在内嵌查询语句查出来的表中的列。

#### 带有any、all的子查询

![image-20220511155425075](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220511155425075.png)

​	一般用在条件表达式中。例：

```sql
select * from <表名> [<别名>] where <列名> [<别名>] >all (<查询语句>);
```

#### 带exists的子查询

![image-20220511160129225](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220511160129225.png)

```sql
select * from <表名> [<别名>] where not exists (<查询语句>);
```



考试必考经典案例：

![image-20220511160728558](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220511160728558.png)

我看的有点不是很懂。。。之后看懂了再来改这个地方罢。。。

#### 集合查询

##### 并

- 通过**union关键字**来对两个查询结果做并操作。

- **UNION 语句**：用于将不同表中相同列中查询的数据展示出来；（不包括重复数据）

- **UNION ALL 语句**：用于将不同表中相同列中查询的数据展示出来；（包括重复数据）
- 下面的交、差和并的逻辑差不多，都是纵向的操作，不像连接操作是横向的操作。

```sql
<查询语句> union <查询语句> ......;
```

##### 交

​	通过**intersect关键字**来对两个查询结果做交操作。

```SQL
<查询语句> intersect <查询语句> ......;
```

##### 差

​	通过**except关键字**来对两个查询结果做差操作。

```sql
<查询语句> except <查询语句> ......;
```

#### 数据插入

```sql
insert into <表名> [(字段列表)] values (值列表)[,(值列表)......];
```

​	注意**字段列表和值列表要加括号**，不写字段列表的话默认就是给表里所有字段添加值(此时要写全字段的值，不然会报错)，可以批量添加多组值。

#### 数据修改

```sql
update <表名> set <字段名> = <值>[, <字段名> = <值>......] where <条件表达式>;
```

​	where用来找到想要修改的记录。

#### 数据删除

```sql
delete from <表名> [where <条件表达式>];
```

​	是以记录为单位进行删除，where用来找到想要删除的记录。

​	也存在一些很特别的delete语句，比如：

```sql
delete p1 from Person p1,Person p2 where <条件表达式>
```

​	这个语句实际上是删除p1中p1和p2做笛卡尔积时满足后面条件的记录。这种写法不常见。

#### 视图的概念

![image-20220512121221056](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220512121221056.png)

​	实际上这个视图区别于普通的表的地方在于，他不是在物理层中真实存在的表，只是一个虚表，**是一组数据的逻辑表示**，其**本质是对应着一条select语句**，如果要查的东西横跨好几张表，每次都现用sql语句进行连接查询的话效率太低，这种情况下就可以先把那些表连接起来组成一个视图，然后以后每次查的时候查这个视图就可以了，大大优化了查询的效率。**当基表数据发生变化时，视图的数据也会随之变化(因为本质时select语句嘛，基表数据变了，select出来的数据肯定会跟着改变)**。

​	对视图所进行的操作语句，都会被关系数据库管理系统转换为对表的操作语句，两者之间一般会有所区别。

#### 创建视图

```sql
create view <视图名> [(<列名>[,<列名>......])] as <子查询语句> [with check option];
```

​	![image-20220512122815174](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220512122815174.png)

​	加上**with check option**意味着在对视图进行insert、delete、update操作时，关系数据库管理系统会在子查询的条件表达式的基础上进行增删改，可以有效防止脏数据的产生。

#### 删除视图

```sql
drop view <视图名> [cascade];
```

​	加上**cascade（级联）**会把该视图和所有由它导出的视图一起删掉。

#### 查询视图

```sql
select * from <视图名> [where <条件表达式>];
```

​	把视图当成一个表进行查询即可，规则和查询表相同。

#### 更新视图

​	由于视图并不是真实存在的，因此我们对视图进行的操作，**最终要反映到对基本表的操作**。

```sql
update <视图名> set <字段名> = <值>[, <字段名> = <值>......] where <条件表达式>;
```

​	也是将视图当成一个表进行更新即可，规则和修改表相同。

#### if条件语句

```sql
select if(<表达式1>,<表达式2>,<表达式3>) [as <别名>] from <表名>;
```

​	以上是if条件语句的应用之一，如果表达式1的值是true，那么if语句会返回表达式2的值；如果表达式2的值是false，那么if语句会返回表达式3的值。

#### 对数据进行排序

```sql
select * from <表名> [where <条件表达式>] order by <列名>[,<列名>......] [desc];
```

​	默认升序排列，最后加**desc关键字**可以改为降序排列。

​	按照多列进行排序的时候，给出的第一个列的元素相同时才会比较第二个列，以此类推。

​	后面的列名也可以使用查出的列的列号来代替。

---

## 第四章 数据库的安全性

### 概述

#### 不安全因素

1、非授权对数据库的恶意存取和破坏。

2、数据库中重要的数据泄露。

3、安全环境的脆弱性。

#### 自主存取控制方法

```sql
grant <权限> on table <表名> to <用户>; /*授予权限*/
revoke <权限> on table <表名> from <用户>; /*撤销权限*/
create user<username> with ; /*创建用户*/
```

### 安全性控制

![image-20220512140759820](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220512140759820.png)

### 主要存取权限

![image-20220512141151384](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220512141151384.png)

​	**reference权限代表是否允许创建外键**，**all privileges权限代表授予所有权限**。

### 授权

```sql
grant <权限> on <表名>[(<列名>[,<列名>......])] to <用户名> [with grant option];
```

​	授权命令是由数据库管理员使用的，若给用户分配权限时带**with grant option**子句，则普通用户获权后，可把自己的权限授予其他用户。如果不写列名的话会把整个表的权限授予给用户。

### 回收权限

```sql
revoke <权限> on <数据对象> from <用户名> [cascade];
```

​	如果加上**cascade关键字（级联）**，关系数据库管理系统会将该用户及其分配出去的权限全部回收。

### 数据库角色

​	角色指的是一类人，可以直接给角色进行授权，然后让用户扮演对应的角色，用户就能获取对应角色的所有权限了。

#### 创建角色

```sql
create role <角色名>;
```

#### 角色授权

```sql
grant <权限> on <对象类型> <对象名> to <角色名> [, <角色名>......];
```

#### 把角色授权给用户或者其他角色

```sql
grant <角色名> to <角色或用户名> [with admin option];
```

​	如果加上**with admin option**，意味着这个用户还可以把这权限授予给其他角色或用户。

#### 回收角色权限

```sql
revoke <权限> on <对象名> from <角色名>;
```

### 视图机制

​	为不同的用户定义不同的视图，把不需要的数据给隐藏起来，这样用户就不会进行误操作。

​	总而言之就是**可以将视图当成一个数据对象来定义别的用户或者是角色对它的存取权限**，定义方式同上。

### 审计

​	把对数据库的所有操作都记录到审计日志中，然后就可以通过日志审查这个里面是否有一些非法的行为。

```sql
audit <操作语句>;/*对指定操作进行审计*/
noaudit <操作语句>;/*取消对指定操作的审计*/
```

### 数据加密

​	通过一些加密算法，把明文变成密文，这样别人就无法直接查看数据了。

---

## 第五章 数据库的完整性

### 正确性

​	符合对现实世界的描述。

### 相容性

​	同一对象在不同表里面是符合逻辑的。比如我的地址、年龄在两个表里面都应一致。

### 维护完整性

1、提供定义完整性约束条件的机制

2、提供完整性检查的方法

3、进行违约处理

### 三大完整性

#### 实体完整性

​	**主码唯一且非空**。主码应该被**not null**和**primary key**这两个约束来修饰。也可在后面用**primary key(列名)**来指定主码。例：

```sql
create table course(id int not null,time varchar(255),primary key(id));
或
create table course(id int not null primary key,time varchar(255));
```

#### 参照完整性

​	**外码要么没有，要么只有一个**。设置外键可以使用**foreign key(列名) references 表名(列名)**来进行声明，意思是将前面的那个列作为外键关联后面指定表中的列。

```sql
create table course(id int,time varchar(255),title varchar(255),teacher_id int,primary key(id),foreign key(id) references course_description(course_id));
```

#### 用户定义完整性

##### 实现非空

​	用**not null约束**来修饰码。例：

```sql
create table student(id char(9) primary key,age int not null);
```

##### 实现列值唯一

​	用**unique约束**来修饰码。例：

```sql
create table student(id char(9) primary key,age int unique);
```

##### 实现让列值满足某一个条件表达式

​	用**check子句**来修饰码。例：

```sql
create table student(id char(9) primary key,sex char(2) check(sex in ('男','女')),age int not null);
```

​	以上就实现了限定sex的值就只能是'男'或者'女'。

### 断言

​	在SQL中可以使⽤数据定义语⾔中的**create assertion语句**，通过声明性断⾔（declarative assertions）来**指定更具⼀般性的约束**。可以定义涉及多个表或聚集操作的⽐较复杂的完整性约束。**断⾔创建以后，任何对断⾔中所涉及关系的操作都会触发关系数据库管理系统对断⾔的检查，任何使断⾔不为真值得操作都会被拒绝执⾏**。

#### 创建断言

```sql
create assertion <断言名> <check子句>;
```

​	进行相关操作时，如果使check子句中的表达式的值不为真，那么对应操作会被拒绝执行。

例：

![image-20220513135614485](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220513135614485.png)

#### 删除断言

```sql
drop assertion <断言名>;
```

### 触发器

​	触发器也叫做**事件->条件->动作 规则**，当对一个表进行增删改的时候，关系数据库管理系统会对触发器里面的条件进行检查，如果成立，就执行触发器里面的动作，否则不执行。

#### 创建触发器

```sql
create trigger <触发器名>
before|after <触发事件> on <表名> /*指明触发器激活的时间是在执行触发事件前或后*/
referencing new|oldrow as <别名> /*referencing指出引用的变量*/
for each row|statement /*定义触发器的类型，指明动作体执行的频率*/
[when <触发条件>] <触发动作体>; /*仅当触发条件为真时才执行触发动作体*/
```

例：

![image-20220513143752439](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220513143752439.png)

![image-20220513143830491](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220513143830491.png)

#### 删除触发器

```sql
drop trigger <触发器名> on <表名>;
```

---

## 第六章 关系数据库理论

### 为什么引入范式

1、数据冗余

2、更新异常

3、插入异常

4、删除异常

### 范式分类

​	设计关系数据库时，遵从不同的规范要求，这些不同的规范要求被称为不同的范式，各种范式成递次规范，**越高的范式数据库冗余越小**。

​	目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）、第五范式（5NF 又称完美范式）。

​	一般来说，数据库只需要满足第三范式（3NF）就行了。

### 依赖

![image-20220513180427888](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220513180427888.png)

![image-20220513180622793](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220513180622793.png)

​	这里的**->**的意义是**左边决定右边的部分值**，是大范围决定小范围，和数学中的定义不太一样。

### 候选码

#### 概念

​	若关系中的一个属性或属性组的值能够唯一地标识一个元组，且他的真子集不能唯一的标识一个元组，则称这个属性或属性组做*候选码*。

​	简单的说就是候选码是**最小的**可以由它**推出所有属性**的属性或属性组。

#### 如何选出候选码？

1、只出现在左边的一定是候选码

2、只出现在右边的一定不是候选码

3、左右都出现的不一定

4、左右都不出现的一定是候选码

5、再求确定的候选码的闭包，如果可以推出全部，那么当前确定的就是候选码，否则，要把每一个可能的值放进当前确定的候选码中求闭包。

![image-20220513183536740](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220513183536740.png)

### 超码

​	能表示出所有属性的**集合**。**候选码是最小的超码**。

### 主码

​	从候选码里面任意挑出一个候选码作为主码。

### 主属性

​	包含在候选码中的属性。上例为ABCDE

### 非主属性

​	不包含在候选码中的属性。上例为G

### 全码

​	若关系中只有一个候选码,且这个候选码中包含全部属性,则该候选码为全码。

### 三大范式

#### 第一范式（1NF）

​	所有字段值都是不可分解的原子值。

![image-20220513192011470](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220513192011470.png)

#### 第二范式（2NF）

​	在第一范式的基础上不包含非主属性对码的部分函数依赖。即一个表中只能保存一种数据，不可以吧多种数据保存在同一张数据库表中。

![image-20220513192349788](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220513192349788.png)

#### 第三范式（3NF）

​	在第二范式的基础上不包含非主属性对码的传递函数依赖。即确保数据表中的每一列数据都和主键直接相关，而不能间接相关。

![image-20220513192724094](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220513192724094.png)

#### 巴斯-科德范式（BCNF）

​	BCNF是对第三范式的修正，在第三范式的基础上它消除了每一属性对候选键的传递依赖。

![image-20220513193109337](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220513193109337.png)

### 公理系统

![image-20220513193243108](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220513193243108.png)

### 求最小函数的依赖值

#### 什么是依赖

​	依赖是指关系中一个或一组属性的值可以决定其它属性的值。比如A->B就是一个依赖。这里实际上就和数学中的"推出"加以区分了，数学中是从左边能推出右边，但在这里是左边能决定右边的部分值，前者是小推大，后者是大决定小。

#### 如何求最小依赖集

1、**将右边有多个元素的依赖拆分成右边只有单个元素的依赖**。比如A->BC拆为A->B和A->C

2、**依次选择依赖集中的所有依赖**，每次选中后，先**暂时屏蔽掉当前的依赖**，然后**求当前依赖左边的闭包**，看看**是否能推出当前依赖的右边**，如果不能推出，说明只能通过当前依赖来推得右边，因此保留当前依赖；如果能推出，意味着通过别的方式也能得到当前依赖的右边，因此当前依赖是多余的，要删除当前依赖。

3、使左边最小化，**选出左边有多个属性的依赖，依次遮住左边单个属性，看剩余属性能否推出被遮住的属性**，能推出意味着可以用其他方式得到被遮住的属性，因此要把被遮住的属性删除；如果不能推出，说明不能用其他方式得到被遮住的属性，因此要保留被遮住的属性。

### 模式分解

#### 准则

​	**无损连接**和**保持函数依赖**

​	无损：就是分解后再次连接，和分解之前一样。

​	保持函数依赖：分解后再次连接，函数依赖不变。

### 求保持函数依赖的3NF的分解

1、求出最小函数依赖集

2、把不在原依赖集中的属性找出来，单独作为一类

3、看求出来的最小函数依赖集，把左边相同的依赖分成一类，去掉中间的'->'。比如如果左边有A的只有A->D这一个依赖，那么分类后就是{AD}；如果左边有A的有A->B和A->C，那么分类后就是{ABC}。

4、求候选码，如果候选码没有出现在分离后的结果里，则把任意一个候选码作为一类。

5、将刚才分的所有类写到一起，就是分解的答案。

例：

![image-20220513231847404](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220513231847404.png)

![image-20220513231859400](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220513231859400.png)

---

## 第七章 数据库设计

### 数据库设计的基本步骤

1、需求分析

2、概念结构设计：ER图或者是设计数据字典

3、逻辑结构设计：把ER图转为逻辑模型

4、物理结构设计：把逻辑模型转为物理模型

5、数据库实施：写SQL代码

6、数据库运行维护：性能检测、性能优化

### ER图

​	**实体用长方形体现，属性用圆形体现，关系用菱形体现，还要要写出两个实体集之间的对应关系（1:N,1:1,N:N等），不在实体中的属性要挂载到关系上作为关系的属性**。

例：

![image-20220514134830979](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514134830979.png)

![image-20220514135212584](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514135212584.png)

### 将ER图转换为关系模式 

![image-20220514141426012](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514141426012.png)

![image-20220514141438620](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514141438620.png)

![就是将关系的属性和两边的主键组合成一个新的关系模式](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514141501633.png)

例：

![image-20220514142517629](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514142517629.png)

---

## 第八章 数据库编程

### 嵌入式SQL

​	就是把SQL语句嵌入到其他编程语言里面。

### 嵌入式SQL的处理过程

1、预编译转换为函数调用

2、主语言编译

3、变成主语言所编译的类型

### SQL与主语言的通信

1、SQL给主语言传递状态

2、主语言给SQL提供参数

3、SQL把查询结果交给主语言处理（通过游标和主变量实现）

---

## 第九章 关系查询处理和优化

### 查询过程

![image-20220514151513608](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514151513608.png)

### 查询优化的四个阶段

1、查询分析

2、查询检查

3、查询优化

4、查询执行

查询优化包括代数优化、物理优化。

### 如何进行代数优化

1、选择运算尽量先做

2、把投影运算和选择运算同时执行

3、把投影同它前后的双目运算符连接起来

例：

![image-20220514152307831](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514152307831.png)

感觉就是让连接的内容尽量少，可能是连接比较消耗资源？

---

## 第十章 数据恢复技术

### 事务

#### 事务的四大特性（ACID）

A：原子性（atom），要么全做，要么全不做。

C：一致性（consistent），一个或多个事务执行后，原来一致的数据和数据库仍然是一致的。一致性与原子性密切相关，要么全做要么全不做，否则就会造成数据不一致，比如说：银行汇钱，两边都需要有操作，才能保证数据的一致，不然可能出现账户多出或减少钱的情况。

I：隔离性（isolate），一个事务的执行不能被其他事务所干扰。

D：持久性（duration），数据库的改变是永久的。比如要落入磁盘。

### 故障种类

1、事务内部故障，可采取REDO重做和UNDO撤销技术。

2、系统故障，比如系统突然停转，可以采取系统重启的方式。

3、介质故障，比如硬件损坏。

4、计算机病毒。

### 恢复方式

#### 数据转储

​	对失败的事务重新执行。

#### 日志文件

​	记录事务对数据的更新操作的文件。

### 恢复策略

#### 事务故障的恢复

​	事务异常终止，那么就撤销之前的所有操作。

#### 系统故障的恢复

​	还没执行完的事务UNDO撤销、丢失的事务REDO重做。

#### 介质故障的恢复

​	重装数据库，重做已经完成的事务。

例：

![image-20220514155741270](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514155741270.png)

---

## 第十一章 并发控制

​	并发实际上在这里就是指多个事务同时执行，而这样做会带来很多问题。

### 并发带来的问题

#### 丢失修改

​	指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。比如原价99，我改价格为299，与此同时有人把价格改成了49，那我最后读到的是49，我自己的修改没有生效。

#### 脏读

​	脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，还没提交事务的时候，事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的，值得注意的是，脏读一般是针对于update操作的。对脏数据进行的操作可能是不正确的。

#### 不可重复读

​	指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

#### 幻读

​	幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

### 解决方法

​	可以通过上锁解决以上问题，即在一个事务进行操作的时候，别的事务无法对相关数据进行操作，保证了第一个事务可以顺利完成。

#### 排它锁

​	也叫**写锁**、**X锁**。

#### 共享锁

​	也叫**读锁**、**S锁**。

### 封锁协议

#### 一级封锁协议

​	修改时必须加X锁，直到当前事务结束提交。

​	解决了丢失修改。

#### 二级封锁协议

​	读的时候加S锁，读完就放开S锁。

​	解决了脏读。

#### 三级封锁协议

​	读的时候加S锁，直到当前事务结束提交。

​	解决了不可重复读。

![image-20220514163231101](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514163231101.png)

### 可串行性

​	假设多种顺序执行事务都可以，获得所有顺序执行事务的结果，如果并发执行的结果满足得到的任意一个结果，那么就说明这些事务满足可串行性。

![image-20220514163850934](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514163850934.png)

---

完结撒花，以后有补充再回来更新吧。



# 收集一下SQL内置函数

## concat(string1,string2)

​	拼接两个字符串。

## substring(string,num1,num2)

​	截取一个字符串的一部分，返回一个新的截取后的字符串，num1指定从第几个字符开始(字符从1开始计数)，num2指定截取几位字符。

## upper(string)

​	将指定字符串的字符全部变成大写。

## lower(string)

​	将指定字符串的字符全部变成小写。

## datediff(date1,date2)

​	计算date1和date2差了多少天，前减后。

## group_concat()

​	完整语法：

```sql
group_concat([DISTINCT] <要连接的字段> [Order BY ASC|DESC] [Separator '分隔符']);
```

要进行连接的字段处可以写列名，这样整个列的数据都会被连接起来，**默认的连接分隔符是','**，别的聚集函数传参的时候也是同理，传入**distinct关键字**可以实现参数去重。


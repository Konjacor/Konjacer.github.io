---
title: 算法刷题心得
date: 2022-09-13 19:12:44
tags: [算法,刷题]
---

<meta name="referrer" content="no-referrer"/>

# 2022/9/13 一维数组专题

- 其实今天的题都是很基础的题，但是其中有一道题确实是让我懂了一点新的东西，下面就给出这道题。

## 合并区间

![image-20220913204141478](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220913204141478.png)

- 看一眼数据量，可以跑O(n^2)的算法，而且目测如果对二维数组的第一维进行排序后会更好做一点，排序之后用两个变量left和right记录一次合并的左端点和右端点，直到遇到不进行合并的集合，然后把当前的left和right作为一组数据加入到最后的数据集中，再更新left和right为当前集合的左右端点，然后继续往后遍历，遍历到最后推出循环后还要再记录一次答案，因为最后那个答案还没收录进答案中。
- 这当中要注意，每次做完合并之后都要把当前位置的数组的右端点设置为right的值，因为后面的数组是要和前面合并后的大数组进行比较的，大数组咱又不好拿出来，只好用部分替代整体，反正只用到了大数组的右端点。

- 源码：

  ```java
  class Solution {
      public int[][] merge(int[][] intervals) {
          if(intervals.length==0) return intervals;
          ArrayList<int[]> list = new ArrayList<>();
          Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));
          int idx = 1;
          int left=intervals[0][0],right=intervals[0][1];
          for(int i=idx;i<intervals.length;++i){
              if(intervals[i][0]<=intervals[i-1][1]){
                  right = Math.max(intervals[i][1],intervals[i-1][1]);
                  intervals[i][1] = right;
              }else{
                  list.add(new int[]{left,right});
                  left = intervals[i][0];
                  right = intervals[i][1];
              }
          }
          list.add(new int[]{left,right});
          int[][] ans = new int[list.size()][2];
          int ans_i=0;
          for(int[] a : list){
              ans[ans_i][0] = a[0];
              ans[ans_i++][1] = a[1];
          }
          return ans;
      }
  }
  ```

### 创建匿名数组并赋值

- 要这样写(示例)：**new int[]{1,2,3}**，要注意中括号里不能填具体的长度。

### 定义数组并初始化的两种方式

1. int[] a = new int[]{1,2,3};
2. int[] a = {1,2,3};

### 以多维数组中的其中一维给多维数组排序

- 主要是用到了Comparator类的方法、lambda表达式和函数式接口的相关知识，我看了看Comparator的源码也没看出多少道道来，之后再分析吧，下面是以第一维给二维数组排序的代码。

  ```java
  Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));
  ```

## 罕见的定义数组的方式

- 今天还真是长见识了。。。

![image-20220913205514046](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220913205514046.png)

# 2022/10/4 Morris遍历

- 搞了二叉树的简单题，用递归倒是随便写，用非递归想要尝试尝试昨天新学的Morris遍历来优化空间复杂度，所以就尝试写了写试试。

## 对称二叉树

![image-20221004204500176](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221004204500176.png)

![image-20221004204516138](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221004204516138.png)

- 思路主要就是**同时从两个方向来遍历，不过由于是轴对称，所以遍历时候的左右优先级要对称而非相同**，剩下的就是看代码怎么写了，写了一手Morris，没有很细致的进行优化，重点都写注释里了：

  ```java
  class Solution125{
      boolean ans = true;
      TreeNode left,right,mostRight,mostLeft;
      public boolean isSymmetric(TreeNode root) {
          if(root==null) return false;//特殊情况
          left = root.left;right = root.right;//left遍历左子树，right遍历右子树，由于判断的是轴对称，所有左子树遍历的时候左子树优先，右子树遍历的时候右子树优先，或者是采用其他的轴对称遍历方式。
          while (left!=null&&right!=null){//每次循环都是一次访问到下一个节点的操作，如果循环退出说明至少有一方走到了null(即那一方遍历完了)
              if(left.val!=right.val){//判断遍历到的位置的值是否相等，如果不相等就可以直接判断为非轴对称
                  ans = false;
                  break;
              }
              mostRight=left.left;mostLeft = right.right;//左子树要找最右边的节点，右子树要找最左边的节点（都是找他们那棵树上最后访问到的节点）
              if(mostRight!=null&&mostLeft!=null) {//有左子树/右子树的情况，要找最右/最左的节点（即最晚遍历到的节点），来设置线索
                  while (mostRight.right != null && mostRight.right != left) {//找最右边的节点
                      mostRight = mostRight.right;
                  }
                  while (mostLeft.left != null && mostLeft.left != right){//找最左边的节点
                      mostLeft = mostLeft.left;
                  }
                  if(mostRight.right==null){//没有线索，说明没有遍历过左子树，故设置线索为当前节点后向左遍历
                      mostRight.right = left;
                      left = left.left;
                  }else{//有线索，说明遍历过左子树了，故洗掉线索然后向右遍历
                      mostRight.right = null;
                      left = left.right;
                  }
                  if(mostLeft.left==null){//没有线索，说明没有遍历过右子树，故设置线索为当前节点后向右遍历
                      mostLeft.left = right;
                      right = right.right;
                  }else{//有线索，说明遍历过右子树了，故洗掉线索然后向左遍历
                      mostLeft.left = null;
                      right = right.left;
                  }
              }else{//没有左子树/右子树的情况,直接向右/左转移
                  if(mostRight!=mostLeft){//由于至少有一方为null，所以如果两者不相等，可以直接判定不是轴对称
                      ans = false;
                      break;
                  }
                  left = left.right;
                  right = right.left;
              }
          }
          if(left!=right){//最后做个判断，如果这俩相等说明是同时遍历完的，如果不相等说明有一边先遍历完了，就不是轴对称了。
              ans = false;
          }
          return ans;
      }
  }
  ```

- 感觉这个算法要是理解了本质的话不算难，写起来也挺顺手的，算法的详细信息见《数据结构与算法》博客。

# 2022/10/5 知两种顺序的遍历结果重建二叉树

## 从中序与后序遍历序列构造二叉树

- 这题主要考察对二叉树中序遍历和后序遍历的理解，**后序遍历的最后一个元素一定是这个二叉树的顶点，知道顶点之后，去中序遍历中找到顶点所在的位置，顶点左边是左子树的遍历结果，顶点右边是右子树的遍历结果，分别再对两边的遍历结果递归执行上面的操作即可**。

- 其中要注意由于中序遍历和后序遍历都遵循着**先遍历左子树再遍历右子树**的原则，所以右子树的遍历结果都出现在遍历结果比较偏后的部分，所以**后序遍历结果的倒数第二个元素是顶点的右子树的顶点，同理，后序遍历结果的倒数第三个元素是顶点的右子树的右子树的顶点，但是想要通过后序遍历结果找到左子树的顶点需要有一个右子树数量的偏移量，偏移一次之后再以步长为1向前访问就能依次访问到所有左子树的顶点了**。

  ![image-20221005233039617](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005233039617.png)

- 详细信息写在代码的注释中了：

  ```java
  class Solution {
      TreeNode ans;
      public TreeNode buildTree(int[] inorder, int[] postorder) {
          ans = new TreeNode();//新建个树
          dfs(inorder,postorder,postorder.length-1,ans);
          return ans;
      }
      void dfs(int[] subTree,int[] postorder,int postorder_i,TreeNode now){//subTree是当前子树，now是当前正在构建的节点，postorder_i是当前子树的顶点在postorder中的索引
          //System.out.println(Arrays.toString(subTree));
          if(subTree.length==1) {//如果当前子树只有一个节点，那么这个节点在要构建的树上是个叶节点，直接赋值然后返回
              now.val = subTree[0];
              return;
          }
          for(int i=0;i<subTree.length;++i){//在当前子树的中序遍历中找到顶点的索引进行下一步dfs
              if(subTree[i]==postorder[postorder_i]){//找到了顶点
                  //System.out.println(subTree[i]);
                  now.val = subTree[i];//给当前正在构建的节点赋值
                  if(subTree.length>i+1) {//如果满足这个条件说明这个节点还有右节点，因为中序遍历数组的顶点右边还有遍历记录
                      now.right = new TreeNode();//新建右节点，待会儿当参数传进去
                      dfs(Arrays.copyOfRange(subTree, i + 1, subTree.length), postorder, postorder_i - 1, now.right);//将右边的遍历结果当成一个树继续dfs，postorder由于是后序遍历结果，所以右子树的遍历结果在偏后边，所以往前访问一个即是新的树的顶点
                  }
                  if(i>0) {//如果满足这个条件说明这个节点还有左节点，因为中序遍历数组的顶点左边还有遍历记录
                      now.left = new TreeNode();//新建右节点，待会儿当参数传进去
                      dfs(Arrays.copyOfRange(subTree, 0, i), postorder, postorder_i - 1-(subTree.length-(i+1)), now.left);//将左边的遍历结果当成一个树继续dfs，postorder由于是后序遍历结果，所以左子树的遍历结果在偏前边，所以往前访问的时候要跳过右子树的节点才是新的树的顶点
                  }
              }
          }
      }
  }
  ```

## 从前序与中序遍历序列构造二叉树

- 类比上面那个，顺序啥的换一下就行了。

  ![image-20221005233327985](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005233327985.png)

- 注释还都是用的上面那个的：

  ```java
  class Solution {
      TreeNode ans;
      public TreeNode buildTree(int[] preorder,int[] inorder) {
          ans = new TreeNode();//新建个树
          dfs(inorder,preorder,0,ans);
          return ans;
      }
      void dfs(int[] subTree,int[] preorder,int preorder_i,TreeNode now){//subTree是当前子树，now是当前正在构建的节点，postorder_i是当前子树的顶点在postorder中的索引
          //System.out.println(Arrays.toString(subTree));
          if(subTree.length==1) {//如果当前子树只有一个节点，那么这个节点在要构建的树上是个叶节点，直接赋值然后返回
              now.val = subTree[0];
              return;
          }
          for(int i=0;i<subTree.length;++i){//在当前子树的中序遍历中找到顶点的索引进行下一步dfs
              if(subTree[i]==preorder[preorder_i]){//找到了顶点
                  //System.out.println(subTree[i]);
                  now.val = subTree[i];//给当前正在构建的节点赋值
                  if(i>0) {//如果满足这个条件说明这个节点还有左节点，因为中序遍历数组的顶点左边还有遍历记录
                      now.left = new TreeNode();//新建右节点，待会儿当参数传进去
                      dfs(Arrays.copyOfRange(subTree, 0, i), preorder, preorder_i + 1, now.left);//将左边的遍历结果当成一个树继续dfs，postorder由于是后序遍历结果，所以左子树的遍历结果在偏前边，所以往前访问的时候要跳过右子树的节点才是新的树的顶点
                  }
                  if(subTree.length>i+1) {//如果满足这个条件说明这个节点还有右节点，因为中序遍历数组的顶点右边还有遍历记录
                      now.right = new TreeNode();//新建右节点，待会儿当参数传进去
                      dfs(Arrays.copyOfRange(subTree, i + 1, subTree.length), preorder, preorder_i +1+(i-0), now.right);//将右边的遍历结果当成一个树继续dfs，postorder由于是后序遍历结果，所以右子树的遍历结果在偏后边，所以往前访问一个即是新的树的顶点
                  }
              }
          }
      }
  }
  ```


# 2022/10/10 二叉树的最近公共祖先(LCA)

![image-20221010195910781](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010195910781.png)

![image-20221010195928345](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010195928345.png)

## 递归解决

- 由于这个题指定了这个树是二叉树，每个节点的度小于等于2，所以我们可以利用递归进行解题，思路就是**利用递归的先自顶向下，再自底向上的特性**，在**自顶向下的时候寻找目标节点**，在**自底向上的时候将答案带回**。

- 每到一个节点都向左右方向递归，如果**遇到null或者p或者q就进行返回，记录左右递归的结果**，**如果两者都为null，那就返回null**，说明这个子树中没有目标值；**如果两者都不为null，那就返回当前节点**，因为两者都不为null说明分别在左右两边找到了目标值，那么当前节点就是他们的公共祖先，由于递归的返回阶段是自底向上的，所以可以确定当前节点就是他们的最近公共祖先；**如果两者中其中一个为null，那么就返回那个不为null的值**，这样可以保证答案或者找到的节点送到上层。

- 代码实现：

  ```java
  /**
   * Definition for a binary tree node.
   * public class TreeNode {
   *     int val;
   *     TreeNode left;
   *     TreeNode right;
   *     TreeNode(int x) { val = x; }
   * }
   */
  class Solution {
      public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
          TreeNode cur = root;
          if(cur == null||cur == p||cur == q) return cur;//找到节点或者到头了，就返回当前节点
          TreeNode left = lowestCommonAncestor(cur.left,p,q);//向左递归
          TreeNode right = lowestCommonAncestor(cur.right,p,q);//向右递归
          //向上传null或者是找到的p/q
          if(left==null) return right;
          if(right==null) return left;
          //左右都不为null，说明当前节点是最近公共祖先，将当前节点向上传
          return cur;
      }
  }
  ```

## 非递归解决

- 非递归的方法不仅可以解决二叉树的LCA问题，**对于任何树的LCA问题都能解决**，具有普适性。

- 首先我们**需要一个方法来取得当前节点在树中的深度**，然后**遍历树直到将两个目标节点遍历完，记录下两个节点深度，然后比较两个节点的深度，将比较深的那个节点的指针向上移动直到和另外一个节点处于同一层，然后将两个节点指针同时向上移动直到两个节点指针碰头，此时两个节点指针指向的节点就是两个目标节点的最近公共祖先**。

- 优化方面可以**考虑向上移动的时候使用倍增**。

- 代码实现：

  ```java
  
  ```
  

# 2022/10/11 二叉树的序列化和反序列化

## 二叉树的序列化和反序列化

![image-20221011212529671](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011212529671.png)

![image-20221011212544238](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011212544238.png)

- 看到这题的时候实际上就是有两种思路，**第一种使用层序遍历并还原**的方式，但是处理其中的null相对比较复杂，不如**第二种使用递归遍历并还原的方式**，使用先序遍历或者中序遍历或者后序遍历**记录下含有null的字符串**，解析的时候再用相同的遍历顺序构建树即可，注意做好特殊情况的处理。

- 受之前知两种顺序的遍历结果重建二叉树那题的影响，搞得我以为必须要两种遍历结果才能还原二叉树，实际上对于不含null的遍历结果确实是这样的，因为只知道一种遍历结果无法准确定位空节点，但是**对于含有null的遍历结果，只知道它是怎样的遍历顺序，就能用同样的顺序重建二叉树，因为其中的null保证了你可以准确知道空节点的位置**。

- 代码实现：

  ```java
  public class Codec {
  
      ArrayList<Integer> temp = new ArrayList<>();
      int i = 0;
      TreeNode ans = new TreeNode();
      // Encodes a tree to a single string.
      public String serialize(TreeNode root) {
          dfsBefore(root);
          //dfsMid(root);
  //        char[] shift = new char[temp.size()];
  //        int i=0;
  //        for(int num:temp){
  //            shift[i++] = (char)num;
  //        }
          return temp.toString();
      }
  
      // Decodes your encoded data to tree.
      public TreeNode deserialize(String data) {
          if(data.equals("[null]")) return null;
          System.out.println(data);
          data = data.substring(1,data.length()-1);
          String[] dataArray = data.split(", ");
          buildTree(dataArray,ans);
          return ans;
      }
      public void dfsBefore(TreeNode cur){
          if(cur == null){
              temp.add(null);
              return;
          }
          temp.add(cur.val);
          dfsBefore(cur.left);
          dfsBefore(cur.right);
      }
      public void buildTree(String[] data,TreeNode cur){//前序重建二叉树
          if(i>=data.length){//没有节点了就返回
              return;
          }
          cur.val = Integer.parseInt(data[i]);//给当前节点赋值
          if(!data[i+1].equals("null")){//下一个元素（即左儿子）如果不为空就开空间然后往下递归。
              i++;
              cur.left = new TreeNode();
              buildTree(data,cur.left);
          }else i++;//左儿子为空就不开空间跳过
          if(i>=data.length){//防止下面访问数组越界，再检查一遍
              return;
          }
          if(!data[i+1].equals("null")){//下一个元素（即右儿子）如果不为空就开空间然后往下递归。
              i++;
              cur.right = new TreeNode();
              buildTree(data,cur.right);
          }else i++;//右儿子为空就不开空间跳过。
      }
  }
  // Your Codec object will be instantiated and called as such:
  // Codec ser = new Codec();
  // Codec deser = new Codec();
  // TreeNode ans = deser.deserialize(ser.serialize(root));
  ```


# 2022/10/17 旋转矩阵&交换两数的原地算法

## 旋转矩阵

![image-20221017210609463](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221017210609463.png)

- 可以**将旋转操作转换为先对角线翻转然后再水平翻转**，但是怎么做到原地算法呢？这就涉及到一个很巧妙的**原地将两个变量的值做交换的算法**了，这个算法充分利用到了两数之和的性质，算法描述如下：

  ```java
  /*******************交换a和b的值************************/
  a += b;
  b = a - b;
  a -= b;
  ```

- 代码实现：

  ```java
  class Solution {
      public void rotate(int[][] matrix) {
          //对角线翻转
          for(int i=0;i<matrix.length;++i){
              for(int j=i+1;j<matrix[i].length;++j){
                  matrix[i][j] += matrix[j][i];
                  matrix[j][i] = matrix[i][j] - matrix[j][i];
                  matrix[i][j] -= matrix[j][i];
              }
          }
          //水平翻转
          for(int k=0;k<matrix.length;++k){
              for(int i=0,j=matrix[k].length-1;i<j;++i,--j){
                  matrix[k][i] += matrix[k][j];
                  matrix[k][j] = matrix[k][i] - matrix[k][j];
                  matrix[k][i] -= matrix[k][j];
              }
          }
      }
  }
  ```


# 2022/10/25 阶乘后的零

## 阶乘后的零

- 又是个数学题。。。

![image-20221026110923001](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221026110923001.png)

- 先来考虑什么情况下才会在末尾贡献0，很明显，**只有2、5两个因子相乘的时候才会在结尾贡献0**，而5因子一定比2因子要少，所以只需要找这个阶乘中有几个5因子就知道末尾有几个零了。

- 由于阶乘的乘法运算的顺序是按照数字顺序且步长为1的，所以参照**自然数中每过5个数就可以分解出一个5因子，n的阶乘中第一轮分解出来的5因子的个数就是n/5**，让n=n/5，从现在开始n就指代这一轮分解出来的5因子的个数了，**分解出来的每个含有5因子的数，每隔5个又会分解出来一个5因子，这个对应的就是那些是25的倍数的数**，以此类推，直到无法再分解出5因子来了，表现为n=0。

- 代码示例：

  ```java
  class Solution {
      public int trailingZeroes(int n) {
          int ans = 0;
          while(n>0){
              ans += n/5;//每隔五个数就有一个因子5
              n /= 5;//选出有因子5的数中每隔五个数又有一个因子5
          }
          return ans;
      }
  }
  ```

  

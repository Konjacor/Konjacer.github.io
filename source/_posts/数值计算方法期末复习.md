---
title: 数值计算方法期末复习
date: 2022-05-18 14:51:57
tags: [计算方法,期末复习]
---

<meta name="referrer" content="no-referrer"/>

# 拉格朗日插值多项式

## 构造拉格朗日插值基函数

![image-20220518150435192](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220518150435192.png)

​	构造出来的拉格朗日插值基函数可以为后面构造拉格朗日插值多项式服务。

## 构造拉格朗日插值多项式

​	构造拉格朗日插值多项式，首先要求各元素的拉格朗日插值基函数，然后再进行组合。

![image-20220531105316326](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220531105316326.png)

# 牛顿插值多项式

## 牛顿均差与均差表

![image-20220531110742082](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220531110742082.png)

## 利用均差表构造牛顿插值多项式

![image-20220531111044594](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220531111044594.png)

​	一阶均差后面乘上一次多项式，二阶均差后面乘上二次多项式，以此类推，多项式的因式里减去的常数是X0到Xi-1。

# 数值导数

## 数值导数的基本问题

![image-20220531112920540](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220531112920540.png)

## 应用举例

![image-20220531113754951](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220531113754951.png)

​	核心思想就是构造插值表达式来近似替代原来未知的函数。

# 数值积分公式的构造

## 数值积分公式的形象

![image-20220531115018579](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220531115018579.png)

## 代数精度的概念

![image-20220531114219127](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220531114219127.png)

## 用待定系数法构造数值积分公式

例：

![image-20220531115509459](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220531115509459.png)

# 矩阵的直接三角分解法解线性方程组

## 矩阵的直接三角分解（LU分解）

![image-20220531144616517](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220531144616517.png)

例：

![image-20220531145903709](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220531145903709.png)

1、在左边和上边画上两条边界，边界右下的所有元素均为未进行变换的元素，方便进行变换。

2、开始变换紧贴边界的一行一列，首先变换一行，如果是一开始，直接将对应的一行抄下来即可；如果不是一开始，那就将当前元素减去对应边界位置的左边和上面的两个向量（以最左边和最上边为向量的起点）的向量积（对应元素相乘再相加），直到变换完这一行所有的元素。

3、再变换一列，如果是一开始，则直接将所有的列元素都除以刚才得到的变换后的行上的第一个元素（即变换后的行在矩阵对角线上的那个元素）；如果不是一开始，那么就要先将当前元素减去对应边界位置的左边和上面的两个向量（以最左边和最上边为向量的起点）的向量积（对应元素相乘再相加），然后再除以刚才得到的变换后的行上的第一个元素（即变换后的行在矩阵对角线上的那个元素）。

4、一行一列变换完之后，将边界往右下角推一个单位，继续进行上面的流程，直到整个矩阵变换完毕。

5、最后得到的矩阵就是L矩阵和U矩阵拼接成的矩阵，按照格式拆解后即可得到L矩阵和U矩阵。

## 利用直接三角分解（LU分解）解方程组

![image-20220531153143339](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220531153143339.png)

例：

![image-20220531153702803](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220531153702803.png)

# 迭代法解线性方程组

## 迭代法的思想

![image-20220601102627746](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601102627746.png)

## 线性方程的迭代法

![image-20220601103244923](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601103244923.png)

![image-20220601103451606](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601103451606.png)

![image-20220601103645051](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601103645051.png)

![image-20220601103817027](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601103817027.png)

![image-20220601104253359](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601104253359.png)

![image-20220601104331627](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601104331627.png)

右边那个迭代公式可以用上面例一证明收敛的步骤来证明它的误差是不断放大的。

可得一般结论：

![image-20220601104608358](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601104608358.png)

系数B表明后一项的误差是前一项的B倍。

## 线性方程组的迭代法

![image-20220601105138836](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601105138836.png)

![image-20220601105433980](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601105433980.png)

![image-20220601110432326](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601110432326.png)

定理第二条指的是B的谱半径小于1，B的谱半径是矩阵B的特征值的绝对值的最大值。

### 如何求矩阵的特征值

​	设矩阵为J,求解方程**| λI-J | = 0**，求出来的λ就是矩阵J的所有特征值，其中I为单位矩阵。

### 各种常用范数

![image-20220601164255288](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601164255288.png)

![image-20220601164320615](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601164320615.png)



### Jacobi迭代法（雅可比迭代法）

![image-20220601160342031](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601160342031.png)

​	用谱半径判断是充要条件，用范数判断是充分不必要的条件。

​	这样做的好处在于对于对角矩阵来说，求它的逆矩阵是相对比较简单的：**对角矩阵中，如果对角线上的元素都不为0，那么这个对角阵是可逆的。其逆矩阵也是一个对角阵，对角线上的元素恰好是对应的原矩阵对角线上元素的倒数**，可以利用逆矩阵的初等变换法证明。

例：

![image-20220601164204488](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601164204488.png)

### Gauss-Seidel迭代法（高斯-塞德尔迭代法）

![image-20220601165226329](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601165226329.png)

​	用谱半径判断是充要条件，用范数判断是充分不必要的条件。

​	这样做求矩阵的逆的时候相对于对角矩阵来讲比较困难，当矩阵为A时，要用到**A^-1 = (1/|A|) X  A***来求逆矩阵，如果A是三角矩阵，那么|A|的值就是对角线的乘积。A*的求法比较复杂，对于每一个A中的元素，先划掉它所在的行和列，然后剩下的元素组成行列式求行列式的值N，假设当前元素在a行b列，如果a+b是奇数，则最后的值是-N，如果是偶数，则最后的值是N，如果当前元素在对角线上，则把最后的值放到元素对应的位置，如果当前元素不在对角线上，那么要把最后的值放到与当前元素关于对角线对称的位置上，对所有元素做完上述步骤后得到的就是伴随矩阵。

例：

![image-20220601171051260](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601171051260.png)

### 容易判断的收敛条件

![image-20220601171141120](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220601171141120.png)

# 非线性方程数值解法

![image-20220603144056891](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220603144056891.png)

## 二分法

![image-20220603144452148](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220603144452148.png)

缺点：

1、对于重根问题可能解决不了（因为可能没有异号区间）

2、没有充分利用到函数值的大小，效率不高

## 插值型方法

### 思想

![image-20220603145340003](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220603145340003.png)

### 牛顿法（切线法）

![image-20220603145407123](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220603145407123.png)

### 割线法（弦截法）

![image-20220603145716502](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220603145716502.png)

### 抛物线法（密勒法）

![image-20220603145829083](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220603145829083.png)

## 不动点迭代

### 回顾线性方程的处置方法

![image-20220603152539962](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220603152539962.png)

### 非线性方程的处置方法

![image-20220603155226256](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220603155226256.png)

运用了微积分的切线近似思想。**最后的结论得出误差的系数是φ(x)的导数**

例：

![image-20220603160803358](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220603160803358.png)

![image-20220603160824892](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220603160824892.png)

![image-20220603160856435](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220603160856435.png)

![image-20220603160918125](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220603160918125.png)

### 收敛阶的计算（反应收敛速度）

![image-20220603161258317](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220603161258317.png)

### 总结

![image-20220603161311949](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220603161311949.png)

# 函数逼近

![image-20220603164630177](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220603164630177.png)

## 函数逼近的基本概念

### 函数逼近的最原始的表述

![image-20220604161723974](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220604161723974.png)

### 函数空间

![image-20220604161751648](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220604161751648.png)

![image-20220604161811867](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220604161811867.png)

### 函数逼近的较明确的表述

![image-20220604162148344](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220604162148344.png)

### 向量逼近的例子

![image-20220604162720180](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220604162720180.png)

![image-20220604163347120](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220604163347120.png)

![image-20220604163405165](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220604163405165.png)

**核心就是误差正交于以线性无关的α1和α2为基底的平面。**

### 与超定方程的关系

![image-20220604164031967](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220604164031967.png)

## 最佳平方逼近

![image-20220604165611453](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220604165611453.png)

**这是对一个区间进行拟合，而最小二乘拟合是对离散的点做拟合，所以两者会略有不同。**

![image-20220604170227396](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220604170227396.png)

**求内积时要做乘积之后再进行积分，积分上下限是x的范围。**

### 解题步骤

![image-20220604170300370](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220604170300370.png)

## 最小二乘拟合

### 问题描述

![image-20220604172310634](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220604172310634.png)

**这是对一堆离散的点做拟合，而最佳平方逼近是对一段区间做拟合，所以对于内积的定义等会有所区别。**

### 求解方法

![image-20220604172548044](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220604172548044.png)

**和最佳平方逼近的区别主要在于内积的定义不同。**

![image-20220604173445260](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220604173445260.png)

**求内积时，要将小括号内所有元素当成方程，然后将离散的点带入算出每个方程结果然后做乘积，有权值的还要乘上权值，直到求出所有的点后全部相加即得内积。**

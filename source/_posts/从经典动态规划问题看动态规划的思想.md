---
title: 从经典动态规划问题看动态规划的思想
date: 2022-05-08 15:04:43
tags: [动态规划,算法]
---

<meta name="referrer" content="no-referrer"/>

# 摘要

​	今天在力扣随便选了一道~~好欺负的~~题来完成自己慵懒周末的每日划水打卡，选的那题确实很简单，只是我第一时间没有想到去用动态规划，后面才想到了动态规划的解法，但是也只是想到了可以用动态规划，实际上我自己都并不是怎么很确定这道题可以用动态规划的方式去解，也算是蒙着做蒙对了，写完这道题之后我不禁在思考，是什么让我对这道题是否使用动态规划这件事这么不确定，想了想觉得应该是自己对于动态规划的思想还并不是很熟悉，因此想要专门写这么一篇博文来专门记录一下自己对于动态规划思想循序渐进的理解，会持续更新。

# 正文

## 最大子数组和

![image-20220509191921760](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220509191921760.png)

​	看下面的数据范围，1e5，肯定不能用普通的时间复杂度为O(n^2^)的算法，因此要求我们必须使用时间复杂度为O(n)的算法，我第一时间想到的是利用**前缀和**数组来计算出答案，然后写了半天最后只能通过不到200个样例，之后我发现只利用前缀和是无法彻底解决这个问题的，于是我想到了动态规划的方法，根据平时做dp题的经验~~（其实就是凭感觉随缘）~~，我想到了应该把dp数组中的状态定义为：**从起始元素到当前元素这一段的最大子数组和**，这样的定义实际上就相当于把整个大问题拆解成了一个个小问题，**dp数组中的每个元素都对应着一个子问题**，在解决完这些子问题之后我们才能通过这些子问题的答案得到正确答案。

​	定义好了状态，我们可以去想状态转移方程了，由于题目中说**子序列是连续的，因此当前的状态必须是由前一状态转移而来的**，如果两个状态之间并不是紧挨着的，那么说明进行状态转移的那段数据也不是连续的，这样就不符合题意了。

​	因此我们考虑当前状态的前一个状态向当前状态怎么转移，实际上**抉择点就在当前元素上**，可以**把之前的状态加上当前的元素组成当前的状态**，这样做实际上就相当于选择了之前最优的一段数据后又加上了当前元素；同时也可以**把当前的元素当成一个新的状态**，这样做就相当于放弃了之前最优的一段数据，把当前元素当成了目前为止最优的一段数据，就这样以此类推直到最后一个状态求完，这样我们就得到了大问题拆解成的所有小问题的答案，接下来只需要考虑怎么通过这一堆答案得到大问题的答案即可。

​	结果很显然易见，dp数组最后一个元素不一定是正确的答案，因为**最后一个状态实际上是在抉择最后一个元素的去留**，但是如果答案出现在中间一段，就完全没必要去管最后一个元素，因此答案完全有可能出现在之前的状态上，所以最后对整个dp数组找个最大值返回即可。

​	到此为止，这道题实际上就已经解决了，上面的流程就是我平时遇到动态规划题目的基本思考框架，实际上我感觉**最难的步骤是如何将一个子问题抽象成一个状态数组的数据**，就像上面这道题，就是将选取一段最优数据这一子问题抽象成了一个和，通过改变这个和实际上就相当于对宏观的状态进行了转移。下面是java代码，没有优化空间复杂度：

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int ans = dp[0];
        for(int i=1;i<nums.length;++i){
            dp[i] = Math.max(dp[i-1]+nums[i],nums[i]);
            if(ans<dp[i]) ans = dp[i];
        }
        return ans;
    }
}
```

​	但是做完这道题之后我一直在思考，总觉得我没想明白一些事情，我通过抉择当前元素的去留而得到的状态真的是最优的吗？因为我感觉每次状态转移好像默认确保了第一个元素在选中的数据段中，后来仔细想了一下终于想明白了，第一个元素会在第一次抛弃之前最优段并留下当前元素的选择中被抛掉，在这之后状态的转移实际上就是把当前这个元素当成数据段中的第一个元素了，这样就不会有遗漏的情况了。

​	b+c>a+b+c的情况也是不可能出现的，因为a+b本身就是在c之前最优的组合，如果加上c更优了，那么去掉a就会让这个更优变得不那么优，因为加上a会使b更优，a是个正面buff，因此可以直接不用考虑这种情况。

# 如何理解动态规划中的"无后效性"

- 李煜东著《算法竞赛进阶指南》，摘录如下：

  >为了保证计算子问题能够按照顺序、不重复地进行，**动态规划要求已经求解的子问题不受后续阶段的影响**。这个条件也被叫做「无后效性」。换言之，动态规划对状态空间的遍历构成一张有向无环图，遍历就是该有向无环图的一个拓扑序。有向无环图中的节点对应问题中的「状态」，图中的边则对应状态之间的「转移」，转移的选取就是动态规划中的「决策」。

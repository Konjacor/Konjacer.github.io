---
title: 搭建问卷系统的基本流程
date: 2022-09-03 21:17:51
tags: [问卷系统,项目]
---

<meta name="referrer" content="no-referrer"/>

# 摘要

- 实验室最近要做个新的项目，是在实验室老项目的基础上增加一个问卷系统，我是其中的开发者之一，所以想要借这个机会，写个博客，熟悉一下软件项目从头开始的搭建流程，学习一下过程中用到的新的技术和思想。

# 需求分析阶段

- 在这个阶段，主要是分析一下将要做的软件的基本功能，可以画一个数据流图(DFD)来说明我们应该"怎么做"，一张质量好的DFD可以让开发事半功倍（我画的比较拉），矩形为实体，双横线为数据存储的地方，箭头代表数据的流向，圆形代表对数据的处理。：

  ![image-20220903212534563](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220903212534563.png)

- 然后可以画一下ER图来说明数据库各表之间的逻辑和各表的设计规范，ER图可以画成描述型的或者是图解型的，大文本最好用text类型：

  ![image-20220903212948506](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220903212948506.png)

- 然后就是要根据之前画好的ER图开始建各种数据库的实体表，不过在这之前出现了一些问题，就是由于历史遗留原因，用户的表是两种类型的，这两种类型的表分别对应着不同的人群，但是在这个项目中，如果每次都需要联表增删改查未免有些不方便，因此我们想到**可以将两个表中相同的部分抽取出来做成一个视图，然后放到redis里面供操作**，但是这样又出现了一个问题，由于视图的select语句使用到了union，所以这就使得这个视图不支持增删改操作了，所以暂时是建立一个视图仅用于查询，添加操作还是对原表进行操作。

# 后端基本crud的搭建

- 首先用代码生成器生成相关表的代码，没什么好说的。

- 然后就是编写每个表对应的基础crud操作，要注意**controller层是面向service层进行编程**，所以与service层无关的操作尽量不要出现在controller层中，要将具体的操作细节写道service层中。
## 自动注释生成

- 在编写代码的时候，可以在每个api上用**IDEA的自动生成注释的功能(敲/\*\*加回车)**，通过注释来说明这个api的参数、返回值的具体信息。

  ![image-20220905170140754](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220905170140754.png)

# 编写后端业务接口

- 根据前端具体的需求来完善后端接口，复杂的sql语句需要依靠mybatis框架来实现。

## 一对多的查询需求实现

- 业务需求中有一个需求是通过问卷id来查询id对应问卷的结构，由于一个问卷对应着多个问题，每个问题又可能对应着多个选项，因此这是一个**一对多的查询需求**，可以使用mybatis的分步查询来实现。

- 在编写代码之前先要在springboot的配置文件中对mybatisplus进行一些配置，要注意在配置实体类别名的时候，后面的路径不用引号包裹，直接写，包裹反而会报错，这个可能是properties文件的规范：

  ```properties
  #设置mybatis延迟加载和下划线命名自动映射为驼峰命名
  mybatis-plus.configuration.map-underscore-to-camel-case=true
  #按需加载
  #mybatis-plus.configuration.lazy-loading-enabled=true
  #mybatis-plus.configuration.aggressive-lazy-loading=false
  
  #设置entity下的实体类的别名为其类名而非全类名
  mybatis-plus.type-aliases-package=com.sdnu.iosclub.qvs.entity
  
  #开mybatisplus的日志
  mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
  ```

- 然后controller-service那一套都比较熟练了，主要看看mapper和mapper的配置文件，通过源码可以分析出service自带的baseMapper实际上就是那个service对应表的mapper，通过直接调用mapper中的方法可以实现crud功能，不过不知道mapper是在哪通过类似cglib代理的方式产生实现类的。

  ![image-20220909150006488](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909150006488.png)

![image-20220909150018123](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909150018123.png)

- 然后就是在mapper中写接口，然后再mapper的配置文件中配置sql语句，写接口的时候注意**属性用@param("")注解来修饰**，比较规范，然后就是在写resultMap的时候，其**type属性为返回值要映射到的实体类**，这个由于写resultMap的目的就是要自定义字段和属性的映射，所以就算返回值是一个带泛型的list或者别的什么东西，这个**type也要写泛型的类型**，因为毕竟要做映射，你传个list让人家怎么映射嘛。还有就是在写resultMap的时候，如果别的字段能保证映射到属性上，那么在resultMap里面对应的配置可以省略不写，但是**id属性必须在resultMap中显式声明**，不然会出现id查不出来的情况。还有就是**collection或者association标签中的column属性是用来指明以当前实体的什么属性作为参数来执行下一步的查询，所以写的应该是当前实体中的具有唯一性的属性**。

  ```xml
  <resultMap id="getSurveyInfoByIdResultMap" type="QvsSurvey">
      <id column="id" property="id"/>
      <collection
              property="questions"
              column="id"
              select="com.sdnu.iosclub.qvs.mapper.QvsQuestionMapper.getQuestionById"
              ofType="QvsQuestion">
          <id property="id" column="id"/>
      </collection>
  </resultMap>
  
  <select id="getSurveyInfoById" resultMap="getSurveyInfoByIdResultMap">
      select * from qvs_survey where id = #{id} order by update_time desc
  </select>
  ```

- 由于查出来的question要放到QvsSurvey的实体类中，但是实体类中没有这个属性，所以要添加一个，其他的类也应该如法炮制，但是添加之后又会出现默认的查询方法中会将自定义添加的属性作为字段来填充sql语句，所以要使用**@TableField(exist = false)**显式声明一下忽略该成员变量和数据库字段之间的映射，来表明自定义添加的这个属性不在数据库中：

  ![image-20220909151056743](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909151056743.png)

- 然后按照上面的注意事项来完成这个**一对多的分步查询功能**就好了，下面给出三个mapper接口和三个xml文件的部分内容：

  ![image-20220909151705423](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909151705423.png)

  ![image-20220909151750148](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909151750148.png)

![image-20220909151832747](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909151832747.png)

![image-20220909151846534](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909151846534.png)

![image-20220909151904457](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909151904457.png)

![image-20220909151915488](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909151915488.png)

## 多对一的需求实现

- 主要是用mybatis配置文件中的resultMap中的**association标签**来实现，属性啥的和上面写到的collection差不多，只不过**ofType要改成javaType代表返回值类型**，如果要从别的地方查实体中的某个属性，可以用这个标签。

- 而且association标签好像必须在collection标签的上面

- 实例：要查question的数量

  1. 在resultMap中写好association

     ![image-20220912180420467](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220912180420467.png)

  2. 在question mapper中写好对应的方法并绑定到之前的association中（**在方法名上右键点击Copy-Copy Reference可以直接复制到全类名**）

     ![image-20220912180547798](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220912180547798.png)
     3.在question mapper的配置文件中写好实现
  
     ![image-20220912180813976](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220912180813976.png)

# 打通前端和后端的连接

## 关于在测试阶段启动nacos的相关事项

- 在测试阶段启动nacos需要进入nacos的bin目录下使用命令**./startup.cmd -m standalone**进行单机启动，因为在nacos1.4以上默认是以集群启动，所以直接启动是以集群启动，需要手动使用以上命令进行单机启动以进行测试。

## 封装网络请求类

- 主要是用flutter框架作移动端的开发，flutter中有个关于网络请求的库是dio，这个库用起来很方便，我写了个很捞的封装了dio库的请求类，配置单独一个文件，肯定有很多问题，之后再改吧：

  ```dart
  class Config {
    static const String qvsHost = "http://127.0.0.1:8003/";
  }
  ```

  ```dart
  import 'package:dio/dio.dart';
  import 'Config.dart';
  
  class Request {
    static Future<T> request<T>(String url,
        {String method = 'get', Map<String, dynamic>? params}) async {
      url = Config.qvsHost + url;
      try {
        if (method.toLowerCase().compareTo("get") == 0) {
          Response response = await Dio().get(url,
              queryParameters: params,
              options:
                  new Options(contentType: 'application/json;charset=utf-8'));
          //print(response);
          return response.data;
        } else if (method.toLowerCase().compareTo("post") == 0) {
          //print(params);
          var response = await Dio().post(url,
              data: params,
              options:
                  new Options(contentType: 'application/json;charset=utf-8'));//数据类型
          return response.data;
        } else if (method.toLowerCase().compareTo("put") == 0) {
          var response = await Dio().put(url,
              data: params,
              options:
                  new Options(contentType: 'application/json;charset=utf-8'));
          return response.data;
        } else if (method.toLowerCase().compareTo("delete") == 0) {
          var response = await Dio().delete(url,
              data: params,
              options:
                  new Options(contentType: 'application/json;charset=utf-8'));
          return response.data;
        } else {
          throw Exception();
        }
      } catch (e) {
        return Future.error(e);
      }
      //return Future.error(new Exception());
    }
  }
  ```

## 出现跨域问题

- 然后就是通过调用写好的网络请求接口来实现对接口的访问并拿到返回的数据，但是在调用本机的接口时出现了这个问题：

  ![image-20220918225354061](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220918225354061.png)

​		后来一查是个跨域的问题，在后端controller代码中加上允许跨域访问的注解（**@CrossOrigin**）即可。

​		![image-20220918225507786](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220918225507786.png)

## 前端处理后端返回的数据

- 然后就是处理返回的数据，由于封装的网络请求方法的返回值是个Future\<T>，所以在调用这个方法的时候应该使用异步方法的处理方式进行处理，通过**.then((res) => {})**来获取到返回值，返回值是json格式，需要通过解析成dart对象后才能使用，但是在对返回值进行**json.decode()**的时候却出现了问题：

  ![image-20220919090947141](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220919090947141.png)

  这意思大概是形参是String类型的，但是实参是_JsonMap类型的，这个\_JsonMap网上也没查到相关的资料，初步推测**它本身就是一个dart的map对象**，可以直接使用操作map的方式操作里面的数据，然后我就试了试，结果还真是这样，通过map的访问方式，访问到其中的列表，可以直接赋值给另外一个List类型的变量：

  ![image-20220919091148010](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220919091148010.png)

- 经过上面的步骤之后发现**dataList总是取不到值**，因为**异步内容在页面渲染之后到达**，所以页面渲染的时候dataList就是空，什么也渲染不出来，这种情况**应该在异步内容到达后让页面重新渲染**，应该**使用setState()方法来对dataList进行赋值**，**这样在dataList赋值后会让页面重新渲染**，这样页面就能渲染出异步请求的数据了。

  ![image-20220919105528017](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220919105528017.png)

## 后端接收前端发送的数据（List类型）

- 做完问卷填写页面之后要写提交页面的逻辑，由于后端的添加结果的方法是批量添加，所以不得不去**发送一个经过json.encode之后的List集合**，但是后端怎么接收这个List集合呢，上网上搜了搜，是**用@RequestBody先接收请求体的json数据放到String类型的形参中**，然后**再用fastjson的相关方法来将这个json数据解析成List集合**，然后就能用了，以下是代码示例：

  ```java
  /**
   * 批量添加选择题答题结果
   * @param data 选择题答题结果集合json数据
   * @return 是否添加成功
   */
  @ApiOperation("批量添加选择题答题结果")
  @PostMapping("addResultByBatch")
  public R addResultByBatch(@RequestBody String data){
      JSONObject jsonObject = JSONObject.parseObject(data);
      List<QvsResult> list = JSON.parseArray(jsonObject.get("list").toString(),QvsResult.class);
      return qvsResultService.saveBatch(list)?R.ok().message("添加成功"):R.error().message("添加失败");
  }
  ```


## 在向数据库存入对象后获得其自动生成的id

- 写需求的时候碰到了这样的问题，想要获得存入对象自动生成的id，难道要重新查一遍不成？实际上不用，应该是**mybatis先将生成的id赋值给了传入对象的id属性后再执行的sql语句，所以直接通过传入对象的引用访问id就可以访问到了**。

  ![image-20220922160514745](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220922160514745.png)

# SpringBoot项目中整合Redis实现数据缓存

- 准备在项目中引入Redis非关系型数据库来当作缓存使用，这样可以大大优化查询效率，大大提升在高并发的情况下进行查询的效率和系统的健壮性。

## 在maven中引入依赖

```xml
<dependencies>
	<!-- redis -->
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-pool2</artifactId>
        <version>2.6.0</version>
    </dependency>
    <!-- spring2.X集成redis所需common-pool2-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>

</dependencies>
```

## 在SpringBoot的配置文件中进行相关配置

```properties
#Redis服务器地址
spring.redis.host=127.0.0.1
#Redis服务器连接端口
spring.redis.port=6379
#Redis数据库索引（默认为0）
spring.redis.database= 0
#连接超时时间（毫秒）
spring.redis.timeout=1800000
#连接池最大连接数（使用负值表示没有限制）
spring.redis.lettuce.pool.max-active=20
#最大阻塞等待时间(负数表示没限制)
spring.redis.lettuce.pool.max-wait=-1
#连接池中的最大空闲连接
spring.redis.lettuce.pool.max-idle=5
#连接池中的最小空闲连接
spring.redis.lettuce.pool.min-idle=0
```

## 添加Redis的配置类

- 至于这个配置类的作用还是之后再分析吧

```java
import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.CachingConfigurerSupport;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.cache.RedisCacheManager;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

import java.time.Duration;

/**
 * @author Konjacer
 * @create 2022-09-24 20:45
 */
@EnableCaching
@Configuration
public class RedisConfig extends CachingConfigurerSupport {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        RedisSerializer<String> redisSerializer = new StringRedisSerializer();
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        template.setConnectionFactory(factory);
//key序列化方式
        template.setKeySerializer(redisSerializer);
//value序列化
        template.setValueSerializer(jackson2JsonRedisSerializer);
//value hashmap序列化
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        return template;
    }

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisSerializer<String> redisSerializer = new StringRedisSerializer();
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
//解决查询缓存转换异常的问题
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
// 配置序列化（解决乱码的问题）,过期时间600秒
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofSeconds(600))
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))
                .disableCachingNullValues();
        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)
                .cacheDefaults(config)
                .build();
        return cacheManager;
    }
}
```

## 在Service的实现类上开启缓存

- 通过**@CacheConfig注解**来声明当前的类开启缓存，其中的**cacheNames属性可能和Redis缓存的命名**有关，至于有啥关系还是之后再说吧。

  ```java
  @Service
  @CacheConfig(cacheNames = "survey")
  public class QvsSurveyServiceImpl extends ServiceImpl<QvsSurveyMapper, QvsSurvey> implements QvsSurveyService {
      ......
  }
  ```

## 在想要做缓存的方法上开启缓存

- 需要在对应的方法上加上**@Cacheable注解**，这样做之后，对应方法的查询结果会被放到缓存中，下次查询的时候会直接从缓存中取，不用再查数据库了，可以开MyBaits的日志输出来验证。

  ```java
  @Override
  @Cacheable
  public List<QvsSurvey> getAllSurvey() {
      QueryWrapper<QvsSurvey> wrapper = new QueryWrapper<>();
      wrapper.orderByDesc("update_time");
      return this.list(wrapper);
  }
  ```

  
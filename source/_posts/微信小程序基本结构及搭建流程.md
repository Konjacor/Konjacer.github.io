---
title: 微信小程序基本结构及搭建流程
date: 2022-07-27 10:26:29
tags: [微信小程序]
---

<meta name="referrer" content="no-referrer"/>

# 什么是微信小程序

- 微信小程序，简称小程序，英文名 Mini Program，是一种不需要下载安装即可使用的应用( 张小龙对其的定义是无需安装，用完即走，实际上是需要安装的，只不过小程序的体积特别小， 下载速度很快，用户感觉不到下载的过程 )
- 小程序刚发布的时候要求压缩包的体积不能大于 1M,，否则无法通过，在 2017 年 4 月做了改进，由原来的 1M 提升到 2M；不过后面介绍了可以利用分包的方式将整个体积扩大到最大16M。

# 小程序可以干什么

- 同 App 进行互补，提供同 app 类型的功能，比 app 使用方便简洁
- 通过扫一扫或者在微信搜索即可下载
- 用户使用频率不高，但又不得不用的功能软件，目前看来小程序是首选
- 连接线上线下
- 开发门槛低， 成本低

# 小程序开发前的准备

1. 可下载官方的微信开发工具来进行开发，[下载地址](https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=2018315)，也可以使用vscode、idea等传统的IDE来进行开发，不过最好还是用官方的开发工具，因为官方的开发工具对小程序的开发做了很多优化和适配，以及开放了很多方便的接口功能以及功能选项供开发者使用。
2. 用自己的微信号在**微信公众平台**注册一个小程序的帐号。[官网](https://mp.weixin.qq.com/)
3. 这次示例的小程序开发流程属于大前端的开发，因此开发之前需要已经写好的后端接口配合进行开发，这次示例用到的后端接口是从尚硅谷那毛的一个用js写的后端，跑在nodejs上，其中用到了网易云音乐的官方api，详情api文档可以去网易云音乐的官方api文档进行查阅。
4. 在开发过程中遇到前端框架的任何问题都可以去**查阅微信小程序开发的官方文档**。

# 开发小程序的储备知识

## Flex布局简介

### 什么是flex布局

- Flex是Flexible Box的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性。
- 任何一个容器都可以使用css属性**display:'flex'**来将其指定为Flex布局

![image-20220731122820575](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731122820575.png)

### flex属性

- flex-direction：
  - row（默认值）：主轴为水平方向，起点在左端。
  - row-reverse：主轴为水平方向，起点在右端。
  - column：主轴为垂直方向，起点在上沿。
  - column-reverse：主轴为垂直方向，起点在下沿。

### 学习地址

- [跳转至学习地址](http://www.runoob.com/w3cnote/flex-grammar.html)

## 移动端相关知识

### 物理像素

- 屏幕的分辨率的单位就是物理像素
- 物理像素是设备能控制显示的最小单元，可以把物理像素看成是对应的像素点。

### 设备独立像素和css像素

- 设备独立像素（也叫密度无关像素），可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用并控制的**虚拟像素**(比如：CSS 像素,只是在 android 机中 CSS 像素就不叫”CSS 像素”了而是叫”设备独立像素”)，然后由相关系统换算为物理像素。

### DPR、DPI、PPI

- DPR（Device Pixel Ratio）：设备像素比，物理像素/设备独立像素 = dpr， 一般以 Iphone6 的 dpr 为准 dpr = 2，这就意味着一个设备独立像素换算到iphone6上是两个物理像素。
- DPI（dots per inch）：最早指的是打印机在单位面积上打印的墨点数，墨点越多越清晰，现在也指图像每英寸长度内的点数。这个点数的意义在不同语境下不同，通常指物理像素，经常和PPI混用。
- PPI（pixels per inch）：一英寸显示屏上的像素点个数。

![image-20220731125004837](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731125004837.png)

![image-20220731125017853](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731125017853.png)

## 移动端适配方案

### viewport适配

- 为什么作viewport适配：
  1. 手机厂商在生产手机的时候大部分手机默认页面宽度为 980px
  2. 手机实际视口宽度都要小于 980px，如: iphone6 为 375px
  3. 开发需求： 需要将 980 的页面完全显示在手机屏幕上且没有滚动条

- 实现：**\<meta name="viewport" content="width=device-width,initial-scale=1.0">**

### rem适配

- 为什么做rem适配：
  1. 机型太多，不同的机型屏幕大小不一样
  2. 需求： 一套设计稿的内容在不同的机型上呈现的效果一致，根据屏幕大小不同的变化，页面中的内容也相应变化

- 实现：

  ```javascript
  function remRefresh() {
  	let clientWidth = document.documentElement.clientWidth; 
      // 将屏幕等分 10 份
  	let rem = clientWidth / 10;
  	document.documentElement.style.fontSize = rem + 'px';
  	document.body.style.fontSize = '12px'; 
  }
  window.addEventListener('pageshow', () => {
  	remRefresh()
  })
  // 函数防抖
  let timeoutId;
  window.addEventListener('resize', () => {
  	timeoutId && clearTimeout(timeoutId);
  	timeoutId = setTimeout(() =>{
  		remRefresh()
  	}, 300)
  })
  ```

- 第三方库实现：lib-flexible + px2rem-loader

# 小程序特点

## 小程序特点概述

- 没有DOM
- 组件化开发：是具备特定功能效果的代码集合
- 体积小，单个压缩包体积不能大于2M，否则无法上线

## 小程序的四个重要的文件

- *.js ----> 用来定义 view 逻辑 -----> 类比 js 文件
- *.wxml ---> 用来定义 view 结构 ----> 类比 html 文件
- *.wxss ---> 用来定义 view 样式 -----> 类比 css 文件
- *. json ----> 用来定义 view 数据 -----> 类比 json 文件

## 小程序的适配方案：rpx（responsive pixel 响应式像素单位）

- 小程序的适配单位：rpx
- 规定**任何屏幕下宽度为750rpx**
- 小程序会根据屏幕的宽度不同自动计算rpx值的大小
- iphone6下：1rpx = 1物理像素 = 0.5px

![image-20220731161640776](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731161640776.png)

## 小程序配置

### 全局配置：app.json

- 作用：用于为整个应用进行选项设置
- 关于app.json的详细描述和具体参数说明可以查阅官方文档的**框架-小程序配置-全局配置**。[官方文档链接](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html)

![image-20220731162002242](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731162002242.png)

### 页面配置：页面名称.json

- 作用：用于为指定的页面进行配置相关参数
- 注意事项：**页面配置的优先级高于全局配置**
- 关于页面配置的详细描述和具体参数说明可以查阅官方文档的**框架-小程序配置-页面配置**。[官方文档链接](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html)

![image-20220731163423780](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731163423780.png)

### sitemap配置：sitemap.json

- 作用：用于被微信搜索爬取页面
- 详情可查阅官方文档的**框架-小程序配置-sitemap配置**。[官方文档链接](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html)

![image-20220731163721098](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731163721098.png)

## 小程序框架接口

### App

- 全局app.js中执行App()以**生成当前应用的实例对象**，用getApp()可以获取全局应用实例。
- 详细信息可在官方文档的**框架-框架接口**中进行查阅。[官方文档链接](https://developers.weixin.qq.com/miniprogram/dev/reference/api/App.html)

### Page

- 在页面.js中执行Page()以**生成当前页面的实例对象**，可以通过getCurrentPages()获取当前页面实例。
- 详细信息可在官方文档的**框架-框架接口**中进行查阅。[官方文档链接](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html)

# wxml语法

## 数据绑定

### 初始化数据

- 可在页面.js的Page实例对象的data选项中定义作用域为当前页面的数据：

  ![image-20220731165506400](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731165506400.png)

### 使用数据

- 模板结构中使用双大括号**{{message}}**来进行数据的**单向绑定**。

  ```html
  <view>{{message}}</view>
  ```

### 修改数据

- 在对数据进行修改的时候不能直接用this.data进行修改，而是应该使用**this.setData({message: ‘修改之后的数据’}, callback)**方法来进行修改。

- 用this.setData()方法修改数据的特点：

  1. 同步修改：this.data的值被同步修改

  2. 异步更新：**异步**将setData函数用于将数据从逻辑层发送到视图层

     ![image-20220731170228051](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731170228051.png)

## 事件绑定

### 事件分类

- 冒泡事件：
  - 定义：当一个组件上的事件被触发后，该事件会向父节点传递。
  - [冒泡事件列表](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/event.html)

- 非冒泡事件：
  - 定义：当一个组件上的事件被触发后，该事件不会向父节点传递。
  - [非冒泡事件](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/event.html)：表单事件和自定义事件通常是非冒泡事件。

- 事件冒泡示例：

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>事件冒泡</title>
    <style>
          #boxOne{
              width: 300px;
              height: 300px;
              border:1px solid red;
          }
          #boxTwo{
              width: 200px;
              height: 200px;
              border: 1px solid green;
          }
          #boxthree{
              width: 100px;
              height: 100px;
              background-color: aquamarine;
          }
      </style>
  </head>
  <body>
      <div id="boxOne" onclick="alert('我是最外层')"> 
      <div id="boxTwo" onclick="alert('我是中间层！')"> 
      <a id="boxthree" 
   href="http://www.baidu.com"mce_href="http://www.baidu.com" onclick="alert('我是最里层！')">点击我</a> 
      
  </body>
  </html>
  ```

  上面的页面分为三层：boxOne是第外层，boxTwo中间层，boxthree是最里层; 
  他们都有各自的click事件，最里层a标签还有href属性。

  运行页面，点击“点击我”,会依次弹出：我是最里层---->我是中间层---->我是最外层---->然后再链接到百度. 
  这就是事件冒泡，本来我只点击ID为boxthree的标签，但是确执行了三个alert操作。 
  事件冒泡过程（以标签ID表示）：boxthree---->boxTwo---->boxOne。从最里层冒泡到最外层。

### 绑定事件

- **bind事件名**绑定：事件绑定不会阻止冒泡事件向上冒泡。

  ```html
  <view bindtap="handleTap" class='start_container'>
  	<text class='start'>开启小程序之旅</text>
  </view>
  ```

- **catch事件名**绑定：事件绑定可以阻止冒泡事件向上冒泡。

  ```html
  <view catchtap="handleTap" class='start_container'>
  	<text class='start'>开启小程序之旅</text>
  </view>
  ```

### 向事件对象传参

- 语法：**data-key=value**

  ![image-20220731172234787](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731172234787.png)

- 获取事件对象内的参数：**event.target.dataset.key 或 event.currentTarget.dataset.key**

  ![image-20220731172339526](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731172339526.png)

- **event.target** 和 **event.currentTarget**的区别

  1. **event.target 是触发事件的对象，但不一定是绑定事件的对象**，如： 

     事件委托，冒泡。如果一个绑定的冒泡事件被触发了，那么因为冒泡而被触发的别的事件就和绑定事件不同了。

  2. **event.currentTarget 代表的触发事件的对象一定是绑定事件的对象**， 没有事件委托，这也就以为着无论触发事件对象是谁，都能用event.currentTarget找到它的绑定事件对象。

## 列表渲染

### 语法说明

- **wx:for='{{array}}'**
- **wx:key='{{唯一值}}'**

### 注意事项

- 默认的个体变量名称：**item**
- 默认的下标变量名称：**index**
- 自定义个体变量名称：**wx:for-item='myItem'**
- 自定义下标变量名称：**wx:for-index='myIndex'**

## 条件渲染

### 语法说明

- 可能和vue的条件渲染一样，联动的条件标签之间不能出现元素节点？不确定，之后确定了再回来改。

- **wx:if='条件'**

- **wx:elif='条件'**

- **wx:else**

  ![image-20220731174500980](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731174500980.png)

### wx:if  和 hidden

- hidden用法：`<view hidden='{{true}}' ></view>`
- wx:if 等同于 v-if, 条件为 false 的时候不加载，条件切换的时候决定元素销毁或者重新加载渲染
- hidden 等同于 v-show, 始终加载元素, 条件切换的时候决定元素的显示和隐藏

## 模板使用

### 定义模板

![image-20220731175053505](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731175053505.png)

### 引入模板

- wxml中引入模板结构：**\<import src='模板结构相对路径' />**
- wxss中引入模板样式：**@Import '模板样式路径'**

### 使用模板

![image-20220731175434239](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731175434239.png)

### 向模板导入数据并使用数据

![image-20220731175513766](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731175513766.png)

- 上面导入数据时使用的三点运算符**...**是将对象表达式按照“key-value”的方式进行展开。

## 生命周期

### 对应阶段说明

- **onLoad(Object query)**
  - 页面加载时触发。一个页面在销毁前只会调用一次，可以在onLoad的参数中获取打开当前页面路径中的参数
  - 参数：**Object query 代表打开当前页面路径中的参数**

- **onShow()**
  - 页面显示/切入前台时触发
  - 在页面销毁之前可能会执行多次

- **onReady()**
  - 页面初次渲染完成时触发。一个页面在销毁前只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。

- **onHide()**

  - 页面隐藏/切入后台时触发。如 wx.navigateTo 或底部 tab 切换到其他页面，小

    程序切入后台等。

- **onUnload()**
  - 页面卸载（销毁）时触发。如 wx.redirectTo 或 wx.navigateBack 到其他页面时。

### 官网图示说明

![image-20220731181058746](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731181058746.png)

- [官网对应地址](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page-life-cycle.html)

# 小程序API

## API使用说明

- 小程序提供了很多实用的方法供开发者使用
- 小程序全局对象是：wx
- **所有的API都保存在wx对象中**

- 详情可在官方文档的API栏内查阅

  ![image-20220731181720857](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731181720857.png)

## 常用API

### 界面交互

- 显示消息提示框：wx.showToast()
- 显示消息加载框: wx.showLoading()
- 关闭消息提示框: wx.hideToast()
- 关闭消息加载框: wx.hideLoading()

### 路由跳转

- wx.navigateTo()
- wx.redirectTo()
- wx.switchTab()
- 这三者之间存在不小的差异，详情可见官方文档

### 网络请求

- wx.request()

### 本地存储

- wx.setStorage()
- wx.setStorageSync()
- wx.getStorage()
- wx.getStorageSync()

### 媒体

- wx.getBackgroundAudioManager()
- wx.playVoice()

## 快速查找技巧

- 当在小程序中想要实现某一种布局，查看：组件
- 当在小程序中想要实现某一个功能，查看: API
- 当在小程序中想要进行某一个配置或者某一种页面语法，查看: 框架 + 指南
- 最好是将要使用的 API 的相关内容看完整，因为 API 的配置及限制较多

# 小程序重点知识汇总

## 小程序本地存储

### 语法说明

- 存入数据

  - wx.setStorage() 异步存入

  - wx.setStorageSync() 同步存入

    ![image-20220731184127969](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731184127969.png)

- 读取数据

  - wx.getStorage() 异步读取

  - wx.getStorageSync() 同步读取

    ![image-20220731184204024](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731184204024.png)

- 删除数据

  - wx.removeStorage() 异步删除

  - wx.removeStroageSync() 同步删除

    ![image-20220731184237497](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731184237497.png)

- 清空数据

  - wx.clearStorage() 异步清空

  - wx.clearStorageSync() 同步清空

    ![image-20220731184313592](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731184313592.png)

### 注意事项

- 属于永久存储，同H5的localStorage一样，除非用户主动删除或因存储空间原因被系统清理，否则数据都一直可用
- 单个 key 允许存储的最大数据长度为 1MB
- 所有数据存储上限为 10MB
- **建议存储的数据是json数据，但是注意存取的时候要进行转换**。
- [官网对应地址](https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorage.html)

![image-20220731184449513](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731184449513.png)

## 小程序前后端交互

### 语法说明

- wx.request()

  ![image-20220731185015735](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731185015735.png)

### 相关配置

- 出于安全考虑，每个微信小程序需要事先设置通讯域名，小程序**只可以跟指定的域名进行网络通信**。
- 服务器域名可在 「小程序后台-开发-开发设置-服务器域名」 中进行配置
- 默认超时事件和最大超时时间都是**60s**
- 超时时间可以在 app.json 中通过 networktimeout 配置

### 注意事项

- 小程序为了安全起见只支持https请求

- wx.request最大并发限制10个

- [官网对应地址](https://developers.weixin.qq.com/miniprogram/dev/api/storage/wx.setStorage.html)

  ![image-20220731185420077](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731185420077.png)

## 小程序页面通信

### 路由传参

- 传参方式
  - 路由地址+query参数
  - 示例：url?a=123

- 获取参数

  - 跳转目标页面的onLoad函数中的options实参中获取

    ![image-20220731192837014](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731192837014.png)

### 消息订阅发布

- 使用第三方库：pubsub-js
- 安装：npm install pubsub-js
- 使用：
  - 引入pubsub-js：Import PubSub from 'pubsub-js'
  - 订阅消息：PubSub.subscribe('eventName', callback)
  - 发布消息：PubSub.publish('eventName', data)
  - 取消订阅：PubSub.unsubscribe('eventName')

### eventChannel事件通道实现消息的订阅和发布

- 订阅事件

  - wx.navigateTo()跳转的时候在 events 选项中定义事件名及事件对应的回调

    ![image-20220731193811999](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731193811999.png)

- 获取事件总线对象
  - 目标页面中使用：**实例.getOpenerEventChannel()**
  - 示例：const eventChannel = this.getOpenerEventChannel()

- 触发事件（发布）

  - **eventChannel.emit('事件名', data)**

    ![image-20220731194118232](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731194118232.png)

## 小程序自定义组件

### 创建组件

- 开发工具中在指定文件夹中右键点新建组件

- 组件对应的 json 文件中设置: component: true

  ![image-20220731195152867](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731195152867.png)

### 使用组件

- 在使用组件的页面的json文件中注册使用组件

  ![image-20220731195242746](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731195242746.png)

## 小程序使用npm包

### 初始化package.json

- 在根目录下使用**npm init**

### 勾选允许使用npm

![image-20220731195443101](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731195443101.png)

### 下载npm包

- 在根目录下使用**npm install packageName**

### 构建npm

- 开发工具 ---> 工具 ---> 构建npm
- 点击构建npm后，开发工具会将 node_modules 中的包打包到 miniprogram_npm 中

## 小程序获取用户基本信息

### 首次登录获取

- Button 组件设置 open-type 属性为 getUserInfo

- \<button open-type='getUserInfo'>\</button>

- 设置后首次登录点击button可以弹出授权窗口

- 注意： 授权的动作只发生一次，除非清除缓存，点击 butotn 授权一次之后再点击

  失效，不会弹出授权窗口

- [官网对应地址](https://developers.weixin.qq.com/miniprogram/dev/component/button.html)

  ![image-20220731200245302](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731200245302.png)

### 授权之后获取

- wx.getUserInfo()

- [官网对应地址](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserInfo.html)

  ![image-20220731200349717](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731200349717.png)

## 小程序获取用户唯一标识（openId）

### 官网图解

![image-20220731200441850](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731200441850.png)

### 获取流程

- wx.login()

  ![image-20220731200533037](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731200533037.png)

- 发送code给服务器端
- 服务器端发送请求携带参数(code, appSecret, appId)给微信服务器获取 openId
  - 接口地址：

- appSecret，appId在小程序首页获取

  ![image-20220731201024219](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731201024219.png)

- 服务器获取openId后进行加密返回给前端

### 获取接口地址

- 请求方法：GET
- https://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code

## 小程序分包流程

### 为什么要分包

- 小程序要求压缩包体积不能大于 2M，否则无法发布
- 实际开发中小程序体积如果大于 2M 就需要使用分包机制进行发布上传
- 分包后可解决 2M 限制，并且能分包加载内容，提高性能
- **分包后单个包的体积不能大于 2M**
- **分包后所有包的体积不能大于 16M**

### 分包形式

- 常规分包
- 独立分包
- 分包预下载

### 常规分包

- 开发者通过在 app.json subpackages 字段声明项目分包结构
- 特点：
  - 加载小程序的时候先加载主包，当需要访问分包的页面时候才加载分包内容
  - 分包的页面可以访问主包的文件，数据，图片等资源
  - 主包：
    - 主包来源： 除了分包以外的内容都会被打包到主包中
    - 通常放置启动页/tabBar 页面

![image-20220731201652245](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731201652245.png)

![image-20220731201706881](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731201706881.png)

![image-20220731201720124](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731201720124.png)

### 独立分包

- 设置 independent 为 true
- 特点：
  - 独立分包可单独访问分包的内容，不需要下载主包
  - 独立分包不能依赖主包或者其他包的内容

- 使用场景：
  - 通常某些页面和当前小程序的其他页面关联不大的时候可进行独立分包
  - 如：临时加的广告页 || 活动页

![image-20220731201941504](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731201941504.png)

### 分包预下载

- 配置
  - app.json 中设置 preloadRule 选项
  - key(页面路径): {packages: [预下载的包名 || 预下载的包的根路径])}

![image-20220731202048824](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731202048824.png)

![image-20220731202057311](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731202057311.png)

- 特点：
  - 在加载当前包的时候可以设置预下载其他的包
  - 缩短用户等待时间，提高用户体验

### 分包效果演示

![image-20220731222630296](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731222630296.png)

- [官网对应地址](https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages.html)

## 小程序转发分享

### 分享实现

- Button 组件设置 open-type 为 share
- \<button open-type='share' >\</button>

### 自定义分享内容

- 生命周期回调中 onShareAppMessage 回调中 return 对象设置自定义内容

![image-20220731222851968](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731222851968.png)

### 设置体验权限

- 开发阶段分享给微信好友，默认没有体验权限，无法打开分享小程序，需要在开发

  页面设置，最多添加 15 个微信好友。

![image-20220731222929398](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731222929398.png)

## 小程序支付流程

### 支付流程官网图解

![image-20220731223002541](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220731223002541.png)

### 支付流程详细说明

1. 用户在小程序客服端下单(包含用户及商品信息)
2. 小程序客户端发送下单支付请求给商家服务器
3. 商家服务器同微信服务器对接获取唯一标识 openID
4. 商家服务器根据 openId 生成商户订单(包含商户信息)
5. 商家服务器发送请求调用统一下单 API 获取预支付订单信息
   - 接口地址： https://api.mch.weixin.qq.com/pay/unifiedorder

6. 商家对预支付信息签名加密后返回给小程序客户端
   - 签名方式： MD5
   - 签名字段：小程序 ID, 时间戳， 随机串，数据包，签名方式
   - [参考地址](https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_7&index=3)

7. 用户确认支付（鉴权调起支付）
   - API：wx.requestPayment()

8. 微信服务器返回支付结果给小程序客户端
9. 微信服务器推送支付结果给商家服务器端
10. [官网对应地址](https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_3&index=1)

# 扩展内容

## 事件流的三个阶段

1. 捕获：从外向内
2. 执行目标阶段
3. 冒泡：从内向外

## 事件委托

1. 什么是事件委托
   - 将子元素的事件委托(绑定)给父元素

2. 事件委托的好处
   - 减少绑定的次数
   - 后期新添加的元素也可以享用之前委托的事件

3. 事件委托的原理
   - 事件冒泡

4. 触发事件的是谁
   - 子元素

5. 如何找到触发事件的对象
   - 用event.target

6. event.currentTarget 和 event.target
   - currentTarget要求绑定事件的元素一定是触发事件的元素
   - target绑定事件的元素不一定是触发事件的元素

## 定义事件相关

1. 分类
   - 标准DOM事件
   
   - 自定义事件
2. 标准DOM事件
   - 举例： click，input。。。
   
   - 事件名固定的，事件由浏览器触发
3. 自定义事件
   
   1. 绑定事件
      - 事件名
      
      - 事件的回调
      
      - 订阅方: PubSub.subscribe(事件名，事件的回调)
      
      - 订阅方式接受数据的一方
   2. 触发事件
      - 事件名
      
      - 提供事件参数对象， 等同于原生事件的event对象
      
      - 发布方: PubSub.publish(事件名，提供的数据)
      
      - 发布方是提供数据的一方

# 示例项目：云音乐

- 本示例项目主要是为了展现一个微信小程序的**基本结构**、**搭建流程**以及一些**常用技巧**

- 本示例项目使用官方的微信小程序开发工具进行开发，在开发之前默认用户已经注册微信公众平台和通过了小程序的认证拿到了相关开发凭证，如果没有做好这些前置准备，可以在本篇博文的开头找到相关的内容。

- 本示例项目属于大前端开发，因此开发时使用的是别人写好的后端代码，用的也是网易云音乐的官方接口，对接口有问题可以直接去查阅后端源代码和网易云的官方api文档。
- 本示例项目默认用户已经在官方的开发工具中新建了一个新的项目了，新建项目中需要填写的AppID可以在小程序官网的后台管理界面找到。

## 成品展示

### 主页页面

![image-20220802154132515](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802154132515.png)

![image-20220802154158609](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802154158609.png)

- 这个页面用到的知识主要就是**wxss布局的相关知识**，**底部tabBar的实现**，**实现wx提供的轮播图等组件**，**使用iconfont图标**，**设置图片和图标的wxss属性**，以及**发送请求、拿到请求的数据、动态渲染页面**等。

### 视频页面

![image-20220802154525103](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802154525103.png)

- 本来视频页面是有相关的视频内容的，可是这个接口需要登录才能拿数据，而网易云的登录api可能有所变动，使得开发时使用的后端无法进行登录操作，所以也就没法拿到数据，数据也就无法被渲染到页面中，不过这个页面的框架已经准备好了，拿到数据就可以直接使用，用到的知识除了主页用到的知识外，还有关于**视频播放的api，以及优化用户体验的操作**。

### 我的页面

![image-20220802154832077](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802154832077.png)

- 这一层除了主页中用到的知识外，还用到了**wxss的动画**相关知识。

### 搜索页面

![image-20220802155110838](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802155110838.png)

- 搜索页面用来对相关歌曲进行检索，并显示实时的热搜榜和搜索记录，除了之前用到的知识，该页面还在搜索框的逻辑中用到了函数节流，接触了**函数节流和函数防抖**的概念。

### 每日推荐页面

![image-20220802155517976](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802155517976.png)

- 该页面主要是展示每日推荐的音乐，和视频一样，也是需要登录后才能通过相应接口获取数据，所以这个地方也是没有显示数据，点击音乐标签后还会跳转到相关的音乐播放界面，这个页面除了用到之前的知识，还用到了**日期相关的api**。

### 歌曲详情页面

![image-20220802163853699](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802163853699.png)

- 这个页面主要是从每日推荐页面中点击对应音乐进入的，除了之前的知识，该页面还用到了**实现动态进度条的知识**，**实现播放时圆盘旋转动画、上方把柄旋转动画的知识**，**与音乐播放相关的api**，**实现乐曲上下首切换的知识**，**优化用户播放体验的知识**等。

### 登录页面

![image-20220802160211910](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802160211910.png)

- 该页面主要**实现了一个登录界面的布局和相关的逻辑**，配合我的页面进行使用，登录成功后会自动退回到我的页面并保持登录状态，没用到什么新的知识。

### 测试获取openId的页面

![image-20220802184217493](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802184217493.png)

- 主要用来**测试模板的使用**和**尝试获取用户的唯一标识openId**。

## 成品文件结构

![image-20220802165925954](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802165925954.png)

- components文件夹中存放着自定义的组件
- 由于使用了npm，所以会出现package-lock.json、package.json、node_modules和miniprogram_npm，下载使用的包都会放在node_modules和miniprogram_npm中。
- pages文件夹中存放着主包中的页面，otherPackage和songPackage分别存放着两个分包中的页面
- static文件夹中存放着各种静态资源，比如图片、iconfont图标文件等
- template文件夹中存放着自定义的模板
- utils文件夹中存放着各种从页面中解耦出来的工具，比如request、对服务器的配置等。
- app.js用来控制整个应用程序的逻辑
- app.json中存放着整个应用程序的数据，对于一些全局配置可以在其中进行修改。
- app.wxss用来设置全局样式
- project.config.json和sitemap.json都是项目的配置文件，详情可以点开里面的官网地址进行查阅。

## app.json中的内容

- json文件中是不能写注释的，因此下面写的注释不能在json文件中出现。

```json
{
  "pages": [//这是用来声明整个app中的页面，每当创建一个新的页面后，都必须在这里进行注册，注意排在最前面的会第一时间进行显示，最后一项的末尾不能加都好，这是json格式数据的规定。
    "pages/index/index",
    "pages/search/search",
    "pages/video/video",
    "pages/personal/personal",
    "pages/login/login"
  ],
  "window": {//这里用来设置整个应用窗口的一些属性
    "backgroundTextStyle": "light",//背景文字样式为亮色
    "navigationBarBackgroundColor": "#d43c33",//窗口背景颜色
    "navigationBarTitleText": "如舸云音乐",//窗口标题
    "navigationBarTextStyle": "white"//窗口文字颜色
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json",
  "tabBar": {//在这里设置的tabBar会显示在页面的最下面
    "backgroundColor": "#fff",//背景颜色
    "color": "#333",//文字颜色
    "selectedColor": "#d43c33",//被选中的选项的文字颜色
    "list": [//这里是设置tabBar的各个选项，这里是三个选项，最多好像是五个
      {
        "pagePath": "pages/index/index",//页面js文件路径
        "text": "主页",//该选项的描述文字
        "iconPath": "/static/images/tabs/tab-home.png",//该选项的图标
        "selectedIconPath": "/static/images/tabs/tab-home-current.png"//该选项被选中时的图标
      },
      {
        "pagePath": "pages/video/video",
        "text": "视频",
        "iconPath": "/static/images/tabs/select.png",
        "selectedIconPath": "/static/images/tabs/selected.png"
      },
      {
        "pagePath": "pages/personal/personal",
        "text": "我的",
        "iconPath": "/static/images/tabs/tab-my.png",
        "selectedIconPath": "/static/images/tabs/tab-my-current.png"
      }
    ]
  },
  "requireBackgroundModes": [
    "audio"
  ],
  "subpackages": [//分包的设置
    {
      "root": "songPackage",//分包唯一标识
      "pages": [//要分到该包的页面
        "pages/recommendSong/recommendSong",
        "pages/songDetail/songDetail"
      ],
      "independent": true//是否是独立分包，如果是独立分包，则分包无法和主包共享样式等，并且独立分包无需等待主包加载完之后再进行加载。如果不是独立分包直接不写这个属性就可以了。
    },
    {
      "root": "otherPackage",
      "name": "other",
      "pages": [
        "pages/other/other"
      ]
    }
  ],
  "preloadRule": {//预加载分包
    "pages/index/index": {//在访问index时预加载songPackage和other分包
      "packages": [
        "songPackage",
        "other"
      ],
      "network": "all"//设置在任何网络下都进行预加载操作
    }
  }
}
```

## app.js中的内容

- 其中一些内容和一些页面存在着耦合，都写在注释里了。

```js
// app.js
App({//注册整个小程序，有些全局变量可以放到这里，用getApp()方法可以获取到小程序的实例，从而访问其中的方法和数据
  onLaunch() {
    // 展示本地存储能力
    const logs = wx.getStorageSync('logs') || []
    logs.unshift(Date.now())
    wx.setStorageSync('logs', logs)

    // 登录
    wx.login({
      success: res => {
        // 发送 res.code 到后台换取 openId, sessionKey, unionId
      }
    })
  },
  globalData: {//全局数据，某个页面销毁时不想销毁的数据可以放到这里，放到缓存也可以。除非整个小程序重新加载，不然这里面的全局数据不会被销毁。
    userInfo: null,
    //下面两个变量是用来解决，关闭音乐详情界面后，isPlay被销毁，但是音乐还在播放，再次打开的时候由于isPlay是默认值false，因此和音乐播放的状态相反的情况。所以考虑把音乐播放的状态变量放到全局，就不会随着音乐详情页面的销毁而销毁了。
    isMusicPlay: false,//是否有音乐在播放
    musicId: '',//正在播放音乐的id
  }
})
```

## app.wxss中的内容

- 主要是针对所有页面的或者是整个app的全局样式设置

```css
@import "/static/iconfont/iconfont.wxss";
page {/*设置page的高度为100%防止出现里面的内容撑不满而留有空白的情况*/
  height: 100%;
}
```

## utils文件夹中的内容

### config.js文件

- 用来配置服务器的相关信息

```js
// 配置服务器相关信息
export default{
  host: "http://192.168.2.241:3000"
}
```

### request.js文件

- 将ajax请求及相关处理封装成一个独立的方法，每次要使用的时候，将该方法引入并使用即可。

```js
import config from "./config"
//发送ajax请求
export default (url,data={},method="GET") => {
  return new Promise((resolve,reject) => {
      wx.request({
        url: config.host + url,
        data,
        method,
        header:{//携带cookie的写法，但是后端登录接口有点问题，所以先注释掉了
          cookie:wx.getStorageSync('cookies')?wx.getStorageSync('cookies').find(item => item.indexOf('MUSIC_U') !== -1):'',//查找cookies中含有MUSIC_U字符串的cookie赋值给cookie,用三目运算符来实现空安全
        },
        success: (res)=>{
          console.log("请求成功：",res);
          if(data.isLogin){//判断如果是登录请求
            //将cookie存储到本地
            wx.setStorage({key:"cookies",data:res.cookies});
          }
          resolve(res.data);//修改promise的状态为成功状态resolved
        },
        fail: (err)=>{
          console.log("请求失败:",err);
          reject(err);//修改promise的状态为失败状态rejected
        }
      })
    }
  )
}
```

## 自定义模板

![image-20220802183439613](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802183439613.png)

### 编写模板的wxml文件

```html
<!-- 定义模板 -->
<template name="myTmp"><!--name属性作为模板的标识，template标签括起来的内容可以在别的文件中复用。-->
  <view>
    <view class="title">这是我自定的模板内容</view>
    <view class="userInfo">
      <view class="userName">用户名： {{username}}</view><!--username和age属性来自于使用模板的地方利用模板的data属性传入的数据，这里是传了个拆包的person对象，因为已经拆包，所以可以直接访问到person对象中的属性。-->
      <view class="age">年龄： {{age}}</view>
    </view>
  </view>
</template>
```

### 编写模板的wxss文件

```css
.title {
  font-size: 40rpx;
  color: greenyellow;
}
```

### 使用模板

- 使用模板前不仅要**在wxml文件中引入模板页面，还要在wxss中引入模板样式**。

- 使用模板时要注意**配置is属性(所用模板名)和data属性(向模板中传入的参数)**

- other.wxml示例：

  ```html
  <import src="/template/myTemplate/myTemplate.wxml"/><!--引入模板页面-->
  <view class="otherContainer">
    <!-- 测试模板 -->
    <view class="otherTitle">测试使用模板</view>
    <template is="myTmp" data="{{...person}}"/><!--is属性是别的模板的名字；data属性为传入模板的数据，支持用js的三点运算符进行拆包，传入后，模板中可以使用拆包出来的属性进行动态的内容更新。-->
    <view>*******************</view>
    <view>*******************</view>
  
    <!-- 测试获取用户唯一标识openId -->
    <view class="otherTitle">测试获取用户唯一标识openId</view>
    <button bindtap="handleGetOpenId">获取openId</button>
  </view>
  ```

- other.wxss示例：

  ```css
  /* pages/other/other.wxss */
  /* 引入模板样式 */
  @import "/template/myTemplate/myTemplate.wxss";/*引入样式的语法*/
  .otherTitle {/*由于引入的模板中也有名为title的类选择器，所以如果想避免覆盖，就要另外起一个新的class属性名。不过进行样式覆盖也恰恰是模板的用处之一，模板提供默认样式，如果想要修改，只需要覆盖模板的样式即可。*/
    font-size: 50rpx;
    font-weight: bold;
    color: red;
  }
  ```

## 自定义组件

![image-20220802190133167](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802190133167.png)

### 新建组件

- 自定义组件需要在自定义的文件夹上右键，点**新建Component**，这样微信官方开发工具就会给我们生成我们自定义组件的相关文件了。

- 在组件的json文件中，需要将component属性设置为true，在要使用组件的页面的json文件中，需要将想要使用的组件配置到usingComponents属性中，具体怎么配置可以看下面的两个json文件。第一个是组件的json，第二个是使用组件的页面的json。

  ```json
  {
    "component": true,
    "usingComponents": {}
  }
  ```

  ```json
  {
    "usingComponents": {
      "NavHeader": "/components/NavHeader/NavHeader"
    }
  }
  ```

### 编写组件的wxml文件

```html
<!--components/NavHeader/NavHeader.wxml-->
<!--在要用到该组件的页面的json文件中注册组件后再使用-->
<view class="header">
    <text class="title">{{title}}</text>
    <view>
      <text>{{nav}}</text>
      <text class="more">查看更多</text>
    </view>
</view>
```

### 编写组件的wxss文件

```css
/* components/NavHeader/NavHeader.wxss */
.header{
  margin-bottom: 20rpx;/*设置指定位置的间距*/
}
.header .title{
  font-size: 32rpx;
  font-weight: bold;/*设置字体粗细程度*/
  line-height: 80rpx;
}
.header .more{
  float: right;/*向右浮动，意味着组件将出现在最右边的边界处*/
  border: 1rpx solid #333;/*设置边框*/
  padding: 10rpx 20rpx;
  font-size: 26rpx;
  border-radius: 30rpx;
}
```

### 编写组件的js文件

- 组件的js文件中主要**定义了组件的属性、组件的初始数据、组件的方法列表**，这里只展示了组件的属性的用法，在js文件中定义的组件属性可以在使用组件的时候传入，在编写wxml代码的时候也可以使用定义的组件属性来做动态的结构。

```js
// components/NavHeader/NavHeader.js
Component({
  /**
   * 组件的属性列表,这是由组件外部传入的数据，相当于vue中的props
   */
  properties: {
    title: {
      type: String,
      value: "title默认值"
    },
    nav: {
      type: String,
      value: "nav默认值"
    }
  },

  /**
   * 组件的初始数据
   */
  data: {

  },

  /**
   * 组件的方法列表
   */
  methods: {

  }
})
```

### 组件的使用

- 使用组件之前记得配置使用组件的页面的json文件，具体实现已经在新建组件那步说了。

```json
{
  "usingComponents": {
    "NavHeader": "/components/NavHeader/NavHeader"
  }
}
```

  

- 使用组件的时候只需要想使用标签一样使用即可，**设置的属性必须在组件.js文件中有定义**，这样的组件增加了代码的可复用性，让前端的代码更具有工程化的特点。

```html
<!--推荐歌曲头部区域-->
<NavHeader title="推荐歌曲" nav="为您精心推荐"></NavHeader>
```

## 使用iconfont的图标

### 登录iconfont

- iconfont是阿里的矢量图标库，如果没有相关帐号要先进行注册。

### 选择图标

- 选择自己想用的图标，点击添加入库

  ![image-20220802205958073](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802205958073.png)

- 然后在库里点击添加至项目，如果没有项目可以新建一个项目。

  ![image-20220802210047635](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802210047635.png)

- 添加到项目后可以通过**资源管理-我的项目**中查看你的所有项目。

  ![image-20220802210505767](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802210505767.png)

### 使用图标

- 首先要选中项目的Font class类，，然后点生成代码，这样生成的代码可以让我们用css的类的形式来使用图标。

  ![image-20220802210630585](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802210630585.png)

- 如果项目使用的是css，那么直接在项目中引入生成的代码即可使用，但是微信小程序不支持css代码，只支持wxss代码，所以我们**需要手动将图标代码放到本地然后再进行引用**，注意每次修改项目中的图标，都会使得代码发生改变，因此每次更新iconfont项目的时候要同步更新到自己的项目中。

- 手动将css代码放到本地，首先需要新建存放代码的文件，本项目中是存放在了/static/iconfont/iconfont.wxss中了

  ![image-20220802211030680](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802211030680.png)

- 然后复制刚才iconfont生成的代码，到浏览器进行打开，复制页面上的所有代码，然后粘贴到刚才新建的wxss文件中，这样我们就把图标代码放到本地了。

  ![image-20220802211223717](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802211223717.png)

- 在使用iconfont图标之前需要将iconfont.wxss文件进行引入，本来是在哪里用就在哪里的wxss文件中引入，但是为了方便，将iconfont.wxss文件在全局的app.wxss中引入，这样所有网页都可以直接使用了，引入后还要设置图标大小为100%。

  ![image-20220802211605742](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802211605742.png)

- 最后，直接将相应的标签类名改为想要使用的图标的类名即可使用

  ![image-20220802211731331](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802211731331.png)

![image-20220802211741903](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802211741903.png)

## 使用npm下载包并使用

### 初始化npm环境

- 在项目的根目录上使用**npm init**来初始化npm环境

  ![image-20220802212107669](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802212107669.png)

### 使用npm下载包

- 在项目的根目录上使用**npm install 包名**来下载对应的包

  ![image-20220802212231414](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802212231414.png)

### 构建npm

- 每次npm管理的包产生变化后，都要手动点击**工具-构建npm**，构建后包就会被放到miniprogram_npm中了，使用的时候先引入再使用。

  ![image-20220802212609455](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802212609455.png)

  

![image-20220802212621999](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220802212621999.png)

## 函数节流

- 如果要是在搜索框中输入内容时，每当内容改变都更新一下数据，这样会产生严重的效率问题，因此为了提高效率，可以使用函数节流或者函数防抖的方式来优化搜索的逻辑，函数节流就是每隔一段时间再执行更新操作，函数防抖就是最后输入完毕后再执行更新操作。

# 常用技巧

## 延时页面跳转

- 微信提供了**setTimeout(function,number)**方法来实现延迟事件，我们可以在页面的生命周期函数onShow()中设置一个延迟事件，使得页面在3000ms之后跳转到另外一个界面。

  ```js
  /**
   * 生命周期函数--监听页面显示
   */
  onShow() {
    setTimeout(() => {
      wx.reLaunch({
        url: '/pages/index/index',
        })
      }, 3000);
  },
  ```

## 隐藏某些路由跳转后自动生成的home键

![image-20220805112506135](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220805112506135.png)

- 在使用reLaunch和redirectTo跳转页面之后，新的页面的导航栏上左上角会显示一个home键，如果想要去除，除了自定义导航栏外，还可以使用**wx.hideHomeButton();**语句来去掉home键，不过这样做仍然会让左上角的home键一闪而过，体验一般，所以尽可能不要让这种情况出现。

  ```js
  /**
   * 生命周期函数--监听页面加载
   */
  onLoad(options) {
    wx.hideHomeButton();//去掉进行reLaunch和redirectTo之后左上角的home标志
  },
  ```

## 默认情况下组件顶不到头

![image-20220805114247488](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220805114247488.png)

- 这是因为最外层的view的class设置成了container，而app.wxss中对container的样式有默认的定义，在顶部的底部有个200rpx的padding，所以会出现这种情况，只需要修改app.wxss中的样式即可解决这个问题。

  ```css
  /**app.wxss**/
  .container {
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    padding: 200rpx 0;/*这个地方的问题，container别的地方出问题了也可以来这里找找*/
    box-sizing: border-box;
  } 
  ```

## 图片自适应

- 将图片用image标签导入后，如果不手动设置图像的宽高，那么系统就会使用image的默认宽高**height:240px;width:320px;**，但是手动设置图像的宽高使得其宽高比不变似乎又比较麻烦，所以可以考虑对image标签的mode属性进行设置，如果不手动设置mode，则默认的mode会使图片伸缩变形直到充满整个image标签，失去原有的宽高比，如果要是想维持宽高比，就要手动将mode设置为**widthFix**。

  ```html
  <image src="/static/images/character.jpg" mode="widthFix"></image>
  ```

## 自动换行显示多行文本

![image-20220805155256364](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220805155256364.png)

- 首先要在text标签外面再套一层textContainer，然后把textContainer指定一个固定的宽度，然后再在text中进行样式设置。

  ```css
  .infoContainer .textContainer{
    width: 700rpx;
  }
  
  .textContainer text{
    padding-left: 30rpx;
    padding-top: 10rpx;
    padding-bottom: 10rpx;
    /*自动换行显示多行文本*/
    display: -webkit-box;
    -webkit-box-orient: vertical;
    word-wrap: break-word;/*自动换行*/
  }
  ```

  

## 单行文本溢出隐藏，用省略号替代

- 首先要在text标签外面再套一层textContainer，然后把textContainer指定一个固定的宽度，然后再在text中进行样式设置。

  ```css
  .infoContainer .textContainer{
    width: 700rpx;
  }
  
  .textContainer text{
    padding-left: 30rpx;
    padding-top: 10rpx;
    padding-bottom: 10rpx;
    /* 单行文本溢出隐藏，省略号代替 */
    display: block;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  ```

## 多行文本溢出隐藏，用省略号替代

- 首先要在text标签外面再套一层textContainer，然后把textContainer指定一个固定的宽度，然后再在text中进行样式设置。

  ```css
  .infoContainer .textContainer{
    width: 700rpx;
  }
  
  .textContainer text{
    padding-left: 30rpx;
    padding-top: 10rpx;
    padding-bottom: 10rpx;
    /* 多行文本溢出隐藏，省略号代替 */
    overflow: hidden;/*文本溢出隐藏*/
    text-overflow: ellipsis;/*溢出的部分用省略号代替*/
    display: -webkit-box;/*设置布局格式*/
    -webkit-box-orient: vertical;/* 设置对齐模式 */
    -webkit-line-clamp: 2;/* 设置文字能显示的行数*/
  }
  ```

## 长按文本复制

- 首先要在wxml文件中给text绑定长按事件**bindlongpress="handleCopyText"**，并将想要复制的内容利用**data-**传入到event对象中，然后在js文件中使用**wx.setClipboardData**方法来设置剪切板的内容。

  ```html
  <text bindlongpress="handleCopyId" data-id="{{item.id}}">公告id:{{item.id}}</text>
  ```

  ```js
  handleCopyId(event){
    // console.log(event);
    wx.setClipboardData({
      data: event.currentTarget.dataset.id,
    });
  },
  ```

## 去掉页面最顶上自带的导航栏

- 只需在页面的json文件中添加**"navigationStyle": "custom"**

## 长按下载图片到本地

- 首先要在wxml文件中给image绑定长按事件**bindlongpress="handleDownloadPicture"**，并将想要下载的图片url利用**data-**传入到event对象中，然后在js文件中使用**wx.downloadFile和wx.saveImageToPhotosAlbum**方法来下载图片到本地。

  ```html
  <image src="{{item.picture}}" mode="widthFix" bindlongpress="handleDownloadPicture" data-url="{{item.picture}}"></image>
  ```

  ```js
  handleDownloadPicture(event){
      let url = event.currentTarget.dataset.url;
      wx.downloadFile({
        url: url,//图片的地址
        type: 'audio',
        success:function(res){
          const tempFilePath = res.tempFilePath  //如果请求成功，则通过res中的tempFilePath 得到需要下载的图片地址
          console.log(tempFilePath); //方便查看，这里打印路径，并且提示请求成功
          console.log("请求到了");
          wx.saveImageToPhotosAlbum({
            filePath: tempFilePath,  //设置下载图片的地址
            success:function(){console.log("保存成功"); //保存成功后进行的提示
            }
        })
      }
    });
    },
  ```

## 固定某一物件在屏幕上的位置不变

![image-20220806165718988](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220806165718988.png)

- 要将那一物件的**position设置为fixed**，这样我们无论如何拉动滚动条，那一物件在屏幕上的位置都不会改变。

  ```html
  <text class="iconfont icon-tianjia"></text>
  ```

  ```css
  .iconfont.icon-tianjia{
    background-color: #ffdd00;/*让人赏心悦目的黄色*/
    border-radius: 50%;/*让元素变成一个圆形*/
    z-index: 1;/*让该物件的层次高于默认层次0，可以显示在所有默认层次物件的上方*/
    position: fixed;/*固定在屏幕上的位置*/
    right: 60rpx;
    bottom: 100rpx;
  }
  ```

## 实现下拉刷新

- 首先要在相应页面的json文件中配置**"enablePullDownRefresh": true**，这个配置允许用户在相应的页面手动下拉触发下拉刷新事件。

- 然后需要编写下拉刷新的逻辑，最好是封装在一个方法中。

  ```js
  async onRefresh(){//定义下拉逻辑
    //导航条加载动画
    wx.showNavigationBarLoading();
    //loading 提示框
    wx.showLoading({
      title: 'Loading...',
    });
    //console.log("下拉刷新啦");
    //手动实现请求逻辑，因为写好的逻辑是向数组后追加，而这里的逻辑是直接用新数据覆盖，此处可以优化。
    let infoData = await request(`/notice/info/pageGetInfo/5/1`);
    this.setData({
      info:infoData.data.items,
      totalPage:infoData.data.total,
      nowPage:1
    });
    //this.pageGetInfo(5,this.data.nowPage);
    setTimeout(()=>{//一秒后触发
      wx.hideLoading();
      wx.hideNavigationBarLoading();
      //停止下拉刷新
      wx.stopPullDownRefresh();
    }, 1000);
  },
  ```

- 在下拉刷新的监视器**onPullDownRefresh()**中调用刚才写好的逻辑，注意一般页面会自动生成这个方法，如果存在自动生成的方法，你又重新写了一个，那么重新写的方法中的代码不会被执行，所以在重新写生命周期函数或者监视器函数的时候一定要看看系统是否自动生成了相应的函数。

  ```js
  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh() {
    this.onRefresh();
  },
  ```

## 实现上滑触底加载

- 编写上滑触底加载的逻辑，主要就是增加当前的页码，然后分页查询新的数据添加到已有数据中，注意js写的分页查询方法中，更新每次查完更新数据时要拼接到总数据后面而不是直接替换原数据，这样可以保证随着上滑触底的次数增多，页面上的数据就越多。

  ```js
  onReachBottomRefresh(){//页面上拉触底的逻辑
    if(this.data.nowPage*5<this.data.totalPage){
      this.setData({//更新当前页数
        nowPage: this.data.nowPage+1,
      });
      this.pageGetInfo(5,this.data.nowPage);//分页获取数据
    }else{//如果没有数据了
      wx.showToast({
        title: '没有内容了捏',
        icon: 'error'
      });
      setTimeout(() => {
        wx.hideToast();
      }, 1000);
    }
  },
  ```

- 在页面上拉触底事件的处理函数中调用上面写的触底加载的逻辑。

  ```js
  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom() {
    //console.log("1111111111");
    this.onReachBottomRefresh();
  },
  ```

## 获取用户手机号

- 流程大体如下，比较复杂，但也很安全，同时涉及到了前端、后端、微信后台三个端。

  ![image-20220806223045764](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220806223045764.png)

- 首先就是必须用按钮来进行实现，先根据官方文档的格式写个按钮。

  ```html
  <button size="mini" class="getButton" open-type="getPhoneNumber" bindgetphonenumber="getPhoneNumber"></button>
  ```

- 但是如果本来不想用按钮来实现的话，获取手机号又不得不用到按钮，怎么办？可以将按钮的背景颜色设置为透明**background-color: transparent;**，然后覆盖到你想要实现获取用户手机号的区域，并将按钮的z-index设高，这样表面上看不出来有按钮，但是按钮是覆盖在指定位置的。

  ```css
  .getButton{
    background-color: transparent;/*设置背景色为透明*/
    position: fixed;
    right: 90rpx;
    bottom: 110rpx;
    width: 200rpx;
    height: 100rpx;
    z-index: 2;
    /* border-radius: 50%; */
  }
  ```

- 当点击按钮后，会弹窗询问你是否要授权小程序获取你的手机号，先来看看点击同意后getPhoneNumber得到的数据：

![image-20220806222657013](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220806222657013.png)

- 可以看到得到的数据有四个，其中errMsg是状态信息，getPhoneNumber:ok代表用户授权了小程序获取手机号，而另外三个则需要传回到后端去做相关的工作，注意，**用wx.login()获取的code和getPhoneNumber返回的code作用不同，不能混用，这里用wx.login()返回的code做操作**，于是我们先编写后端相关的接口，首先搞个entity存放需要的全局变量。

  ```java
  package com.konjacer.notice.entity;
  
  /**
   * @author Konjacer
   * @create 2022-08-06 22:43
   */
  public class GlobalData {
      public static final String  url = "https://api.weixin.qq.com/sns/jscode2session";//微信服务器接口
      public static final String  appid = "wx9537f607a21573c9";//自己小程序的appid
      public static final String  secret = "b8e98da672f72f314de6e65ea285717e";//自己小程序的secret
      public static final String  grant_type = "authorization_code";//这样写就行
  }
  ```

- 然后需要搞一个http请求工具类

  ```java
  package com.konjacer.notice.utils;
  
  import org.springframework.http.*;
  import org.springframework.http.client.SimpleClientHttpRequestFactory;
  import org.springframework.util.MultiValueMap;
  import org.springframework.web.client.HttpClientErrorException;
  import org.springframework.web.client.RestTemplate;
  
  import java.io.IOException;
  
  /**
   * @author Konjacer
   * @create 2022-08-06 22:53
   * @description http请求工具类
   */
  public class HttpRestUtils {
      /**
       * http post
       * */
      public static String post(String url, MultiValueMap<String, String> params) throws IOException {
          return  httpRestClient(url, HttpMethod.POST, params);
      }
  
      /**
       * http get
       * */
      public static String get(String url, MultiValueMap<String, String> params) throws IOException {
          return  httpRestClient(url, HttpMethod.GET, params);
      }
  
      /**
       * HttpMethod  post/get
       * */
      private static String httpRestClient(String url, HttpMethod method, MultiValueMap<String, String> params) throws IOException {
          SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();
          requestFactory.setConnectTimeout(10*1000);
          requestFactory.setReadTimeout(10*1000);
          RestTemplate client = new RestTemplate(requestFactory);
          HttpHeaders headers = new HttpHeaders();
          // 以表单的方式提交
          headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
  //       headers.setContentType(MediaType.APPLICATION_JSON_UTF8);//不好使，不能用get方法
          HttpEntity<MultiValueMap<String, String>> requestEntity = new HttpEntity<MultiValueMap<String, String>>(params, headers);
          //  执行HTTP请求
          ResponseEntity<String> response = null;
          try{
              response = client.exchange(url, HttpMethod.POST, requestEntity, String.class);
  //            System.out.println("response="+response);
              return response.getBody();
          }
          catch (HttpClientErrorException e){
              System.out.println( "------------- 出现异常 HttpClientErrorException -------------");
              System.out.println(e.getMessage());
              System.out.println(e.getStatusText());
              System.out.println( "-------------responseBody-------------");
              System.out.println( e.getResponseBodyAsString());
              e.printStackTrace();
              return "";
          }
          catch (Exception e) {
              System.out.println( "------------- HttpRestUtils.httpRestClient() 出现异常 Exception -------------");
              System.out.println(e.getMessage());
              return "";
          }
      }
  }
  ```

- 还需要搞一个http请求业务类

  ```java
  package com.konjacer.notice.utils;
  
  import org.springframework.http.HttpMethod;
  import org.springframework.util.LinkedMultiValueMap;
  import org.springframework.util.MultiValueMap;
  
  /**
   * @author Konjacer
   * @create 2022-08-06 22:59
   * @description http请求业务类
   */
  public class PostData {
      public String PostData(String url ,String appid,String appSecret,String code,String authorization_code) {
          try {
              //post请求
              HttpMethod method = HttpMethod.GET;
              // 封装参数，千万不要替换为Map与HashMap，否则参数无法传递
              MultiValueMap<String, String> params = new LinkedMultiValueMap<String, String>();
              params.add("appid",appid);
              params.add("secret",appSecret);
              params.add("js_code",code);
              params.add("grant_type",authorization_code);
              System.out.print("发送数据：" + params.toString()+"\n");
              //发送http请求并返回结果
              String result = HttpRestUtils.get(url, params);
              System.out.print("接收反馈：" + result+"\n");
              return result;
          } catch (Exception e) {
              System.out.println("------------- " + this.getClass().toString() + ".PostData() : 出现异常 Exception -------------");
              System.out.println(e.getMessage());
              return "";
          }
      }
  }
  ```

- 引入一个相关依赖

  ```xml
  <!-- https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk16 -->
  <dependency>
      <groupId>org.bouncycastle</groupId>
      <artifactId>bcprov-jdk16</artifactId>
      <version>1.46</version>
  </dependency>
  ```

- 写一个解密工具类

  ```java
  package com.konjacer.notice.utils;
  
  import javax.crypto.Cipher;
  import javax.crypto.KeyGenerator;
  import javax.crypto.spec.IvParameterSpec;
  import javax.crypto.spec.SecretKeySpec;
  import java.security.AlgorithmParameters;
  import java.security.Key;
  import java.security.Security;
  
  /**
   * @author Konjacer
   * @create 2022-08-06 23:00
   * @description 解密工具类
   */
  public class WechatUtils {
      public static final String AES = "AES";
      public static final String AES_CBC_PADDING = "AES/CBC/PKCS7Padding";
  
      /**
       *    * 微信 数据解密<br/>
       *    * 对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充<br/>
       *    * 对称解密的目标密文:encrypted=Base64_Decode(encryptData)<br/>
       *    * 对称解密秘钥:key = Base64_Decode(session_key),aeskey是16字节<br/>
       *    * 对称解密算法初始向量:iv = Base64_Decode(iv),同样是16字节<br/>
       *    *
       *    * @param encrypted 目标密文
       *    * @param session_key 会话ID
       *    * @param iv 加密算法的初始向量
       *
       */
      public static String wxDecrypt(String encrypted, String session_key, String iv) {
          String result = null;
          byte[] encrypted64 = org.apache.commons.codec.binary.Base64.decodeBase64(encrypted);
          byte[] key64 = org.apache.commons.codec.binary.Base64.decodeBase64(session_key);
          byte[] iv64 = org.apache.commons.codec.binary.Base64.decodeBase64(iv);
          try {
              init();
              result = new String(decrypt(encrypted64, key64, generateIV(iv64)));
          } catch (Exception e) {
              e.printStackTrace();
          }
          return result;
      }
      /**
       *    * 初始化密钥
       *
       */
      public static void init() throws Exception {
          Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
          KeyGenerator.getInstance(AES).init(128);
      }
  
      /**
       *    * 生成iv
       *
       */
      public static AlgorithmParameters generateIV(byte[] iv) throws Exception {
          // iv 为一个 16 字节的数组，这里采用和 iOS 端一样的构造方法，数据全为0
          // Arrays.fill(iv, (byte) 0x00);
          AlgorithmParameters params = AlgorithmParameters.getInstance(AES);
          params.init(new IvParameterSpec(iv));
          return params;
      }
      /**
       *    * 生成解密
       *
       */
      public static byte[] decrypt(byte[] encryptedData, byte[] keyBytes, AlgorithmParameters iv)
              throws Exception {
          Key key = new SecretKeySpec(keyBytes, AES);
          Cipher cipher = Cipher.getInstance(AES_CBC_PADDING);
          // 设置为解密模式
          cipher.init(Cipher.DECRYPT_MODE, key, iv);
          return cipher.doFinal(encryptedData);
      }
  }
  ```

- 再写一个AdminController中的方法

  ```java
  @ApiOperation("解析电话号码")
  @GetMapping("/getsessionkey")
  public Result getsessionkey(String js_code,String encryptedData, String iv) throws JsonProcessingException {
      PostData PostData = new PostData();
      String responseData =  PostData.PostData(GlobalData.url, GlobalData.appid, GlobalData.secret,js_code,GlobalData.grant_type);
      //获取SessionKey 和openid
      ObjectMapper mapper = new ObjectMapper();
      JsonNode resData = mapper.readTree(responseData);
      try{
          if(resData.get("session_key").asText()!=null)
          {
              String SessionKey = resData.get("session_key").asText();
              String openid = resData.get("openid").asText();
              System.out.println("SessionKey="+SessionKey);
              System.out.println("openid="+openid);
              System.out.println("encryptedData="+encryptedData);
              System.out.println("iv="+iv);
              String wxDecrypt = WechatUtils.wxDecrypt(encryptedData,SessionKey,iv);
              System.out.println(wxDecrypt);
              return Result.ok().data("item",wxDecrypt);
          }else {
              System.out.println("请求微信服务器异常");
          }
  
      }catch (Exception e)
      {
          System.out.println("请求微信服务器异常");
      }
      return Result.error();
  }

- 为请求手机号专门写一个方法，注意得到的userInfo.data.item是个json数据，需要解析成js对象后才能使用。

  ```js
  async getPhone(js_code,encryptedData,iv){
    let userInfoData = await request('/notice/admin/getsessionkey',{js_code,encryptedData,iv,sign:'sign'});
    // console.log(userInfoData.data.item);
    //解析json数据
    let userInfo = JSON.parse(userInfoData.data.item);
    //console.log(userInfo);
    //获取电话号
    let {phoneNumber} = userInfo;
    //查询电话号是否在管理员数据库中
    let isAdminData = await request('/notice/admin/isAdmin',{wx:phoneNumber});
    if(isAdminData.success){//如果手机号在数据库中则跳转页面
      this.setData({//标记当前用户为管理员，防止重复验证，优化体验
        isAdmin: true,
      });
      wx.navigateTo({
        url: '/pages/info/info',
      });
    }else{
      wx.showToast({
        icon: 'error',
        title: '您还不是管理人员哦~'
      })
    }
    //console.log(isAdminData);
    //console.log(phoneNumber);
    //console.log(userInfo.data.item);
    //return userInfo.data.item;
  },
  ```

- 编写getPhoneNumber方法的逻辑。

  ```js
  getPhoneNumber(e){
    wx.login({
      success:(res)=>{
        let resCode = res.code;
        //console.log(resCode);
        if(e.detail.errMsg == "getPhoneNumber:ok"){//用户同意授权
          if(resCode){
            this.getPhone(resCode,e.detail.encryptedData,e.detail.iv);
            //console.log(userInfo);
          }else{
            wx.showToast({
              icon: "error",
              title: '您还未登录捏~',
            });
            return;
          }
        }else{// 用户拒绝授权
          wx.showToast({
            icon: "error",
            title: '需要获取手机号才能使用这个功能捏~',
          });
          return;
        }
      }
    });
    //console.log(resCode);
    //console.log(e.detail);
  },
  ```

### 优化

- 根据上面的写法，每次用户点击按钮系统都会询问一次是否授权，实际上这种体验非常不好，因此考虑用一个变量记录isAdmin记录下来当前用户的身份，下次点击按钮的时候只凭借isAdmin就可以直到对方是否是管理员了。首先优化button，使得在用户是管理员的时候对open-type和bindgetphonenumber解绑，让button失去询问授权的功能，并重新绑定点击事件handleTap，使其可以直接跳转。

  ```html
  <button size="mini" class="getButton" open-type="{{isAdmin ? '' : 'getPhoneNumber'}}" bindgetphonenumber="{{isAdmin ? '' : 'getPhoneNumber'}}" bindtap="{{isAdmin ? 'handleTap' : ''}}"></button>
  ```

- 编写点击事件handleTap。

  ```js
  handleTap(){
    wx.navigateTo({
      url: '/pages/info/info',
    });
  },
  ```

- 在getPhone方法中添加将当前用户设置为管理员的代码。

  ```js
  async getPhone(js_code,encryptedData,iv){
    let userInfoData = await request('/notice/admin/getsessionkey',{js_code,encryptedData,iv,sign:'sign'});
    // console.log(userInfoData.data.item);
    //解析json数据
    let userInfo = JSON.parse(userInfoData.data.item);
    //console.log(userInfo);
    //获取电话号
    let {phoneNumber} = userInfo;
    let isAdminData = await request('/notice/admin/isAdmin',{wx:phoneNumber});
    if(isAdminData.success){
      this.setData({//将当前的用户身份设置为管理员
        isAdmin: true,
      });
      wx.navigateTo({
        url: '/pages/info/info',
      });
    }else{
      wx.showToast({
        icon: 'error',
        title: '您还不是管理人员哦~'
      })
    }
    //console.log(isAdminData);
    //console.log(phoneNumber);
    //console.log(userInfo.data.item);
    //return userInfo.data.item;
  },
  ```

## 一圈实线边框

![image-20220807163015074](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220807163015074.png)

- 用css的border属性，第一个参数是粗细，第二个参数是样式，第三个参数是颜色。

  ```css
  border: 5rpx solid #d43c33;
  ```

## 获取输入框中的内容

- **在event参数中找**，event参数相当于将dom对象的所有参数封装起来了，所以找参数可以从event参数中找。

  ```html
  <textarea placeholder="请输入公告内容" class="info" bindinput="handleText"></textarea>
  ```

  ```js
  handleText(event){
    this.setData({
      text: event.detail.value,
    });
    console.log(this.data.text);
  },
  ```

## 在相册选择图片或者是拍摄照片

- 使用wx.chooseMedia方法

  ```html
  <button class="selectImg" bindtap="selectImg">选择图片</button>
  ```

  

  ```js
  selectImg(){
    wx.chooseMedia({//选择图片
      count: 1,//限选一个
      mediaType: ['image'],//只能选图片或者拍图片
      success:(res)=>{//选择成功的回调，把本地路径设置到数据中
        // console.log(res);
        this.setData({
          imgUrl: res.tempFiles[0].tempFilePath,//得到本地文件路径
        });
        // console.log(this.data.imgUrl);
      }
    });
  },
  ```

  

## 上传图片到后端

- 首先写个按钮，绑定点击事件。

  ```html
  <button class="uploadNotice" bindtap="handleUploadNotice">上传公告</button>
  ```

- 编写handleUploadNotice方法的逻辑，**使用wx.uploadFile()方法上传图片，别的json信息放到formData中，提交方式是POST，该方法默认的Content-Type是multipart/form-data，wx.request()方法默认的Content-Type是application/json。**

  ```js
  async handleUploadNotice(){
    let phoneNumber = wx.getStorageSync('phoneNumber');
    //console.log(imgFile);
    if(phoneNumber&&this.data.text&&this.data.imgUrl){//信息齐全才能进行图片的上传
      // let isDone = await request('/notice/info/addInfo',{file:imgFile,text:this.data.text,wx:phoneNumber},'POST','multipart/form-data; boundary=1634813444');
      // console.log(host+'/notice/info/addInfo');
      wx.uploadFile({//上传图片
        url: config.host+'/notice/info/addInfo',//后端接口路径
        filePath: this.data.imgUrl,//本地图片路径，需要先通过wx.chooseMedia()获取。
        name: 'file',//这个文件参数的名字
        formData: {//别的json数据
          'text': this.data.text,
          'wx': phoneNumber
        },
        success (res){
          console.log(res);
          if(JSON.parse(res.data).success){//res.data是json数据，需要解码后使用。
            wx.showToast({
              icon: 'success',
              title: '上传成功！',
            });
            setTimeout(() => {//一秒后返回
              wx.navigateBack({
                delta: 1,
              });
            }, 1000);
          }else{
            wx.showToast({
              icon: 'error',
              title: '上传失败！',
            });
          }
        },
        fail:(err)=>{
          //console.log(err);
          wx.showToast({
            icon: 'error',
            title: '上传失败！',
          });
        }
      });
    }else{
      wx.showToast({
        icon: 'error',
        title: '信息不完整哦~',
      });
    }
    //   if(isDone.success){
    //     wx.showToast({
    //       icon: 'success',
    //       title: '上传成功！',
    //     });
    //   }else{
    //     wx.showToast({
    //       icon: 'error',
    //       title: '上传失败！',
    //     });
    //   }
    // }else{
    //   wx.showToast({
    //     icon: 'error',
    //     title: '信息不完整哦~',
    //   });
    // }
    //console.log("1");
  },
  ```

- 使用multipart/form-data进行数据传输时，后端需要使用相应的注解来对接相应的数据。**@RequestPart可以按照名称获取file数据，@RequestParam可以按照名称获取formData中的数据**。

  ```java
  @ApiOperation("添加公告")
  @PostMapping("addInfo")
  public Result addInfo(@RequestPart("file") MultipartFile file,@RequestParam(name = "text") String text,@RequestParam(name = "wx") String wx){
      //检验文件格式是否是图片
      String name = file.getOriginalFilename();
      if(name.endsWith(".jpg")||name.endsWith(".png")||name.endsWith(".jpeg")||name.endsWith(".gif")) {
          return infoService.save(new Info().setPicture(ossService.uploadPicture(file)).setText(text).setWx(wx))?Result.ok():Result.error();
      }
      return Result.error().message("文件格式错误！");
  }
  ```

## 发布小程序

### 后端部署

- 首先对后端程序进行打包，先**把服务器端口号和数据库路径、用户名、密码啥的改好**，然后再使用IDEA的maven工具，一般来说是在最右边，**先执行对应模块的父模块的install程序，再执行对应模块的install程序，再执行对应模块中的Lifecycle中的clean程序，然后再执行对应模块中的Lifecycle中的package程序**，打包成功后，**jar包会输出在对应模块下的target文件夹中**。

  ![image-20220807223036943](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220807223036943.png)

![image-20220807223200774](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220807223200774.png)

- 然后就是通过远程连接的方式来在服务器上建表，首先**配置SSH，密码写服务器对应用户的密码**，再**配置常规，密码写服务器上数据库的密码**。

  ![image-20220807225949099](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220807225949099.png)

  ![image-20220807230034660](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220807230034660.png)

- 再然后就是把刚才打完的包传输到服务器上，这里主要用Xshell进行演示。

  ![image-20220807230333618](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220807230333618.png)

- 然后在服务器上修改刚才上传的jar包的权限为最高权限777，这是建立在没有什么安全隐患的基础上的操作，如果有安全隐患还是需要随机应变。

  ![image-20220807230614492](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220807230614492.png)

- 然后运行jar包，使用**nohup java -jar notice-0.0.1-SNAPSHOT.jar &**，jar包会在后台启动，可以通过**ps 进程号**来查看指定进程，也可以通过**kill -9 进程号**来强制结束进程。

  ![image-20220807231218752](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220807231218752.png)

### 前端部署

- 将测试号换成正式号，这个操作一开始就应该做，但是我不知道有正式号这个东西，所以现换，换了之后后端GlobalData中的信息也需要改，而且正式号要经过微信认证才能使用获取手机号的功能。

- 修改请求根ip为服务器ip

  ![image-20220807232041707](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220807232041707.png)

# 一些注意事项

## wxml中使用“data-参数名”传参时参数名不要出现大写字符

- 出现的大写字符会自动被转换成小写字符。

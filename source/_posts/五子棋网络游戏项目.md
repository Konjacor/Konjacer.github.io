---
title: 五子棋网络游戏项目
date: 2022-10-16 20:17:39
tags: [项目,java,网络编程,游戏]
---

<meta name="referrer" content="no-referrer"/>

# 前言

- 突然想试试不用框架来写一个几乎是纯java的C/S架构软件了，也是想应用一下自己学的设计模式和计网相关的知识吧。
- 选了个比较好写的五子棋项目，准备写个客户端，写个服务端。

# 第一天

## 搭建项目基本结构

- 采用了一种比较规范的项目结构。

![image-20221017201229777](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221017201229777.png)

## 编写棋子实体

- 先写抽象父类：

  ```java
  package com.konjacer.five.entity.pawn.abs;
  
  /**
   * @author Konjacer
   * @create 2022-10-17 10:33
   */
  public abstract class Pawn {
  
      protected int type;//棋子类型
  
      protected Pawn(int type){
          this.type = type;
      }
  
      public int getType(){
          return this.type;
      }
  
  }
  ```

- 再写子类，子类有黑棋子、白棋子还有一种用来表示没有棋子的空棋子，其中**棋子均采用基于静态内部类实现的单例模式**：

  ```java
  /***********************黑棋子*************************/
  package com.konjacer.five.entity.pawn.sub;
  
  import com.konjacer.five.entity.pawn.abs.Pawn;
  
  /**
   * @author Konjacer
   * @create 2022-10-17 10:56
   */
  public class BlackPawn extends Pawn {
  
      //private static volatile WhitePawn instance;
  
      private BlackPawn(){
          super(1);
      }
  
      private static class SingletonInstance {//利用静态内部类的加载特性实现线程安全和懒加载的单例模式
          private static final BlackPawn INSTANCE = new BlackPawn();
      }
  
      public static synchronized BlackPawn getInstance() {
          return BlackPawn.SingletonInstance.INSTANCE;
      }
  
  }
  /***********************白棋子*************************/
  package com.konjacer.five.entity.pawn.sub;
  
  import com.konjacer.five.entity.pawn.abs.Pawn;
  
  /**
   * @author Konjacer
   * @create 2022-10-17 10:56
   */
  public class WhitePawn extends Pawn {
  
      //private static volatile WhitePawn instance;
  
      private WhitePawn(){
          super(2);
      }
  
      private static class SingletonInstance {//利用静态内部类的加载特性实现线程安全和懒加载的单例模式
          private static final WhitePawn INSTANCE = new WhitePawn();
      }
  
      public static synchronized WhitePawn getInstance() {
          return SingletonInstance.INSTANCE;
      }
  
  }
  /***********************空棋子*************************/
  package com.konjacer.five.entity.pawn.sub;
  
  import com.konjacer.five.entity.pawn.abs.Pawn;
  
  /**
   * @author Konjacer
   * @create 2022-10-17 11:10
   */
  public class NullPawn extends Pawn {
  
      //private static volatile WhitePawn instance;
  
      private NullPawn(){
          super(0);
      }
  
      private static class SingletonInstance {//利用静态内部类的加载特性实现线程安全和懒加载的单例模式
          private static final NullPawn INSTANCE = new NullPawn();
      }
  
      public static synchronized NullPawn getInstance() {
          return NullPawn.SingletonInstance.INSTANCE;
      }
  
  }
  ```

## 编写棋子工厂

- 棋子工厂用来返回棋子实例，同样先需要一个抽象工厂：

  ```java
  package com.konjacer.five.factory.abs;
  
  import com.konjacer.five.entity.pawn.abs.Pawn;
  
  /**
   * @author Konjacer
   * @create 2022-10-17 11:39
   */
  public interface AbsPawnFactory {
  
      Pawn getGoods(int type);
  
  }
  ```

- 然后就是一个**基于静态内部类实现单例模式的返回棋子实例的工厂**：

  ```java
  package com.konjacer.five.factory.sub;
  
  import com.konjacer.five.entity.pawn.abs.Pawn;
  import com.konjacer.five.entity.pawn.sub.BlackPawn;
  import com.konjacer.five.entity.pawn.sub.NullPawn;
  import com.konjacer.five.entity.pawn.sub.WhitePawn;
  import com.konjacer.five.factory.abs.AbsPawnFactory;
  
  /**
   * @author Konjacer
   * @create 2022-10-17 11:36
   */
  public class PawnFactory implements AbsPawnFactory {
  
      private PawnFactory(){
  
      }
  
      @Override
      public Pawn getGoods(int type) {
          if(type==0){
              return NullPawn.getInstance();
          }else if(type==1){
              return BlackPawn.getInstance();
          }else if(type==2){
              return WhitePawn.getInstance();
          }else{
              return null;
          }
      }
  
      private static class SingletonInstance{
          private static final PawnFactory INSTANCE = new PawnFactory();
      }
  
      public static synchronized PawnFactory getInstance() {
          return PawnFactory.SingletonInstance.INSTANCE;
      }
  
  }
  ```

  

## 编写胜利监视器

- 需要一个监视器来监视棋局是否胜利，**监视器和棋盘是双分派关联的关系**，监视器内有方法判定当前棋局是否胜利，每当棋盘中的棋发生了变化，都会通知监视器来判断当前棋局是否满足胜利条件：

  ```java
  package com.konjacer.five.algorithm;
  
  import com.konjacer.five.entity.chessboard.abs.ChessBoard;
  import com.konjacer.five.entity.pawn.abs.Pawn;
  
  /**
   * @author Konjacer
   * @create 2022-10-16 20:58
   */
  public class CheckVictory {
  
      private ChessBoard chessBoard;//组合棋盘
  
      //private PawnFactory pawnFactory;//组合棋子工厂
  
      public CheckVictory(ChessBoard chessBoard){
          this.chessBoard = chessBoard;
          //pawnFactory = PawnFactory.getInstance();
      }
  
      public boolean check(int i,int j){//判断刚下完的一步棋是否满足胜利条件
          if(((Pawn)(chessBoard.getElement(i,j))).getType()!=0){//如果当前位置不是空棋子，那就开始检查当前位置是否满足获胜条件
              if(checkRow(i,j) || checkColumn(i,j) || checkLeftDiagonal(i,j) || checkRightDiagonal(i,j)){//如果任何一个方向满足获胜条件，那就返回当前的棋子表示当前棋子类型胜利
                  return true;
              }
          }
          return false;
      }
  
      private boolean checkRow(int i,int j){
          int type = ((Pawn)(chessBoard.getElement(i,j))).getType();//获取当前棋子类型
          int sum = 1;//当前获胜路线上当前棋子类型的数量
          int cur = j-1;//通过cur遍历当前获胜路线上的棋子
          while (cur>=0 && ((Pawn)(chessBoard.getElement(i,cur))).getType()==type){//向左检查
              sum++;
              cur--;
          }
          if(sum>=5) return true;//判断是否胜利
          cur = j+1;
          while (cur<chessBoard.getColumn() && ((Pawn)(chessBoard.getElement(i,cur))).getType()==type){//向右检查
              sum++;
              cur++;
          }
          if(sum>=5) return true;//判断是否胜利
          return false;
      }
  
      private boolean checkColumn(int i,int j){
          int type = ((Pawn)(chessBoard.getElement(i,j))).getType();//获取当前棋子类型
          int sum = 1;//当前获胜路线上当前棋子类型的数量
          int cur = i-1;//通过cur遍历当前获胜路线上的棋子
          while (cur>=0 && ((Pawn)(chessBoard.getElement(cur,j))).getType()==type){//向上检查
              sum++;
              cur--;
          }
          if(sum>=5) return true;//判断是否胜利
          cur = i+1;
          while (cur<chessBoard.getRow() && ((Pawn)(chessBoard.getElement(cur,j))).getType()==type){//向下检查
              sum++;
              cur++;
          }
          if(sum>=5) return true;//判断是否胜利
          return false;
      }
  
      private boolean checkLeftDiagonal(int i,int j){
          int type = ((Pawn)(chessBoard.getElement(i,j))).getType();//获取当前棋子类型
          int sum = 1;//当前获胜路线上当前棋子类型的数量
          int curi = i-1;
          int curj = j-1;
          while (curi>=0 && curj>=0 && ((Pawn)(chessBoard.getElement(curi,curj))).getType()==type){//向左上检查
              sum++;
              curi--;
              curj--;
          }
          if(sum>=5) return true;//判断是否胜利
          curi = i+1;
          curj = j+1;
          while (curi<chessBoard.getRow() && curj<chessBoard.getColumn() && ((Pawn)(chessBoard.getElement(curi,curj))).getType()==type){//向右下检查
              sum++;
              curi++;
              curj++;
          }
          if(sum>=5) return true;//判断是否胜利
          return false;
      }
  
      private boolean checkRightDiagonal(int i,int j){
          int type = ((Pawn)(chessBoard.getElement(i,j))).getType();//获取当前棋子类型
          int sum = 1;//当前获胜路线上当前棋子类型的数量
          int curi = i-1;
          int curj = j+1;
          while (curi>=0 && curj<chessBoard.getColumn() && ((Pawn)(chessBoard.getElement(curi,curj))).getType()==type){//向右上检查
              sum++;
              curi--;
              curj++;
          }
          if(sum>=5) return true;//判断是否胜利
          curi = i+1;
          curj = j-1;
          while (curi<chessBoard.getRow() && curj>=0 && ((Pawn)(chessBoard.getElement(curi,curj))).getType()==type){//向左下检查
              sum++;
              curi++;
              curj--;
          }
          if(sum>=5) return true;//判断是否胜利
          return false;
      }
  
  }
  ```

  

## 编写棋盘实体

- 五子棋是15x15的棋盘，所以用15x15的Object数组代表棋盘，和棋子一样，首先需要一个抽象父类：

  ```java
  package com.konjacer.five.entity.chessboard.abs;
  
  /**
   * @author Konjacer
   * @create 2022-10-16 21:00
   */
  public abstract class ChessBoard {
  
      protected Object[][] board;
  
      protected ChessBoard(int m,int n){
          board = new Object[m][n];
      }
  
      public void reset(){//重置棋盘，这里给出了默认实现，子类有需要可以重写该方法，虽然不符合里氏替换原则，但是使用起来更加灵活
          for(int i=0;i<board.length;++i){
              for(int j=0;j<board[i].length;++j){
                  board[i][j] = 0;
              }
          }
      }
  
      public Object getElement(int i,int j){//返回指定位置的元素
          return board[i][j];
      }
  
      public int getRow(){//返回行数
          return board.length;
      }
  
      public int getColumn(){//返回列数
          return board[0].length;
      }
  
  }
  ```

- 然后再写五子棋棋盘，它和胜利监视器是双分派的关联关系，和棋子工厂是组合的关系：

  ```java
  package com.konjacer.five.entity.chessboard.sub;
  
  import com.konjacer.five.algorithm.CheckVictory;
  import com.konjacer.five.entity.chessboard.abs.ChessBoard;
  import com.konjacer.five.factory.abs.AbsPawnFactory;
  import com.konjacer.five.factory.sub.PawnFactory;
  
  /**
   * @author Konjacer
   * @create 2022-10-17 10:46
   */
  public class FiveChessBoard extends ChessBoard {
  
      private AbsPawnFactory pawnFactory = PawnFactory.getInstance();//棋子工厂
  
      private CheckVictory checkVictory;//组合胜利监听器
  
      private int curType = 1;//当前应该轮到谁下了，1是黑子，2是白子
  
      FiveChessBoard(){
          super(15,15);
          checkVictory = new CheckVictory(this);//双分派
      }
  
      @Override
      public void reset(){
          for(int i=0;i<board.length;++i){
              for(int j=0;j<board[i].length;++i){
                  board[i][j] = pawnFactory.getGoods(0);
              }
          }
      }
  
      public boolean putBlack(int i,int j){//放黑子，放完检查是否胜利
          board[i][j] = pawnFactory.getGoods(1);
          curType = 2;
          return checkVictory.check(i,j);
      }
  
      public boolean putWhite(int i,int j){//放白子，放完检查是否胜利
          board[i][j] = pawnFactory.getGoods(2);
          curType = 1;
          return checkVictory.check(i,j);
      }
  
  }
  ```

## 编写玩家实体

- 编写抽象玩家类：

  ```java
  package com.konjacer.five.entity.player.abs;
  
  /**
   * @author Konjacer
   * @create 2022-10-17 19:44
   */
  public abstract class Player {
  
  }
  ```

- 编写五子棋玩家类：

  ```java
  package com.konjacer.five.entity.player.sub;
  
  import com.konjacer.five.entity.player.abs.Player;
  
  /**
   * @author Konjacer
   * @create 2022-10-17 19:45
   */
  public class FivePlayer extends Player {
  
      private int roleType;//角色执子，1为黑子，2为白子
  
      public FivePlayer(int roleType){
          this.roleType = roleType;
      }
  
  }
  ```

  

---
title: 数据结构与算法
date: 2022-09-25 19:54:24
tags: [数据结构,算法]
---

<meta name="referrer" content="no-referrer"/>

# 排序算法

## 常用排序算法的总结和对比

### 一张排序算法的比较图

![image-20221106091748277](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106091748277.png)

### 相关术语解释

1. 稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面；
2. 不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面；
3. 内部排序：所有排序操作都在内存中完成；
4. 外部排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；
5. 时间复杂度： 一个算法执行所耗费的时间。
6. 空间复杂度：运行完一个程序所需内存的大小。
7. n: 数据规模
8. k: “桶”的个数
9. In-place: 不占用额外内存
10. Out-place: 占用额外内存

## 新人入坑冒泡排序

- 这个是典中典了，任何学过算法的人估计都学过这个吧，它简单的算法思想也让他成为了入坑排序算法的最佳选择。

### 基本介绍

- 冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,**依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部**，就象水底下的气泡一样逐渐向上冒。
- 需要两层循环，**每次外层循环都会使得无序区域最大的一个数字到达正确的位置**，对于长度为n的序列，我们只需要将外层循环做n-1次即可使整个序列有序，**内层循环遍历整个序列的无序部分，目的是让目标元素和相邻元素做比较从而将目标元素放到它该在的地方**。

### 时间复杂度

- 由于需要两层循环来实现该算法，并且每层循环都和序列长度n有关，所以它的**时间复杂度是：O(n^2)**

### 冒泡过程图解

![image-20221105225817170](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105225817170.png)

### 对于冒泡排序的优化

- 因为排序的过程中，各元素不断接近自己的位置，**如果一趟比较下来没有进行过交换，就说明序列已经有序，就不用做后续的比较操作了**，因此要**在排序过程中设置一个标志 flag 判断元素是否进行过交换，从而减少不必要的比较**。

### 代码示例

```java
import java.util.Scanner;

/**
 * @author Konjacer
 * @create 2022-11-07 20:34
 */
public class BubbleSort {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入要排序的数字数量：");
        int n = scanner.nextInt();
        int[] num = new int[n];
        System.out.println("请依次输入要排序的数字：");
        for(int i=0;i<n;++i){
            num[i] = scanner.nextInt();
        }
        for(int i=1;i<n;++i){//归位n-1个数字即可使数组有序
            for(int j=0;j<n-i;++j){//每次内层循环需要的次数由于上次数字归位而递减
                if(num[j]>num[j+1]){//交换两数的原地算法,但是这样写在数据很大的情况下有数值溢出风险
                    num[j] += num[j+1];
                    num[j+1] = num[j] - num[j+1];
                    num[j] -= num[j+1];
                }
            }
        }
        System.out.println("排序后的数组为：");
        for(int i=0;i<n;++i){
            System.out.print(num[i]+" ");
        }
        System.out.println();
    }
}
```

## 先挑后换选择排序

- 总是和插入排序混掉，这个选择排序是从后面的序列中按一定规则挑出元素来换到前面，而插入排序是从后面的序列中取第一个数然后按一定规则插入到前面，**它们的区别在于选择排序的比较规则体现在后面的序列中，插入排序的比较规则体现在前面的序列中**。

### 基本介绍

- 选择式排序也属于内部排序法，是**从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的**。

### 选择排序思想

- 选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：**第一次从 arr[0]~arr[n-1]中选取最小值，与 arr[0]交换，第二次从 arr[1]~arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]~arr[n-1]中选取最小值，与 arr[2]交换，...，第 i 次从 arr[i-1]~arr[n-1]中选取最小值，与 arr[i-1]交换，..., 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值，与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列**。
- 和冒泡排序相似，也是两层循环，**外层循环跑一次都会让一个元素归位，内层循环遍历后面的无序序列，挑出其中最小的和无序队列的头部元素进行交换**。对于长度为n的序列，外层循环只需要跑n-1次即可使序列有序。

### 时间复杂度

- 由于是两层循环，还都和序列的长度有关，所以**时间复杂度是O(n^2)的**

### 选择排序过程图解

![image-20221105230143186](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105230143186.png)

- 对一个数组的选择排序再进行图解：

  ![image-20221105230338223](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105230338223.png)

### 代码示例

```java
import java.util.Scanner;

/**
 * @author Konjacer
 * @create 2022-11-07 20:47
 */
public class SelectionSort {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入要排序的数字数量：");
        int n = scanner.nextInt();
        int[] num = new int[n];
        System.out.println("请依次输入要排序的数字：");
        for(int i=0;i<n;++i){
            num[i] = scanner.nextInt();
        }
        for(int i=0;i<n-1;++i){//归位n-1个数字即可
            int min = num[i];//让无序区第一个元素先当min，之后动态更新
            int pos = i;//最小值对应的坐标
            for(int j=i+1;j<n;++j){//从后面的无序区域找最小的换到无序区的最前面，外面每循环一次，无序区域就减少一个单位，由于之前默认让无序区的第一元素作为最小值并知晓其坐标，所以就没必要遍历第一个元素了
                if(min>num[j]){
                    min = num[j];
                    pos = j;
                }
            }
            if(pos!=i) {//如果最小值不是无序区的头元素就原地算法交换两数，如果忘了判断最小值是不是无序区的头元素，利用原地交换算法就会出错，但是还是那个问题，如果数据过大会数值溢出
                num[i] += num[pos];
                num[pos] = num[i] - num[pos];
                num[i] -= num[pos];
            }
        }
        System.out.println("排序后的数组为：");
        for(int i=0;i<n;++i){
            System.out.print(num[i]+" ");
        }
        System.out.println();
    }
}
```

## 先取后插插入排序

- 总是和选择排序混掉，选择排序是从后面的序列中按一定规则挑出元素来换到前面，而插入排序是从后面的序列中取第一个数然后按一定规则插入到前面，**它们的区别在于选择排序的比较规则体现在后面的序列中，插入排序的比较规则体现在前面的序列中**。

### 基本介绍

- 插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。

### 插入排序思想

- 插入排序（Insertion Sorting）的基本思想是：**把 n 个待排序的元素看成为一个有序表和一个无序表**，开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，**排序过程中每次从无序表中取出第一个元素，把它的排序码依次与前面有序表元素的排序码进行比较，如果满足给定的条件就进行交换，如果中间某一次没有交换，说明该元素已经归位，这样做能将它插入到有序表中的适当位置，使之成为有序表的一部分**。
- 也是需要两层循环，**外层循环每循环一次都会将一个无序区的元素归位，内层循环主要是让选中的元素和前面的有序部分进行逐个比较好确定选中的元素应该插入的位置**。

### 时间复杂度

- 由于还是两层循环，并且每层循环都和序列长度有关，所以**时间复杂度还是O(n^2)的**。

### 插入排序过程图解

![image-20221105232220474](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105232220474.png)

### 代码示例

```java
import java.util.Scanner;

/**
 * @author Konjacer
 * @create 2022-11-07 23:11
 */
public class InsertSort2 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入要排序的数字数量：");
        int n = scanner.nextInt();
        int[] num = new int[n];
        System.out.println("请依次输入要排序的数字：");
        for(int i=0;i<n;++i){
            num[i] = scanner.nextInt();
        }
        for(int i=1;i<n;++i){//第一个元素可以看作已经归位，也就是说刚开始有序区是1，接下来把剩下的n-1个元素插入到有序区即可
            for(int j=i;j>=0;--j){//让无序区的头元素向前（也就是有序区）基于比较来进行移动，中间某一次没移动就说明归位了，退出循环
                if(num[j]<num[j-1]){//交换两数的原地算法，还是那个问题，如果数据过大会数值溢出
                    num[j] += num[j-1];
                    num[j-1] = num[j] - num[j-1];
                    num[j] -= num[j-1];
                }else break;
            }
        }
        System.out.println("排序后的数组为：");
        for(int i=0;i<n;++i){
            System.out.print(num[i]+" ");
        }
        System.out.println();
    }
}
```

## 插排优化希尔排序

### 基本介绍

- 希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。**希尔排序也是一种插入排序**，它**是简单插入排序经过改进之后的一个更高效的版本**，也称为**缩小增量排序**。

### 希尔排序思想

- 在简单插入排序中存在这样一个问题，说极端点就是如果最后一个无序元素非常小，那么它在插入到前面有序序列时的消耗是很大的，我们自然不希望看到这样的情况频繁发生，所以**希尔排序的思想就是以这一点为切入点，通过增量分组的方式，每次分组排序后都尽量让整个序列均匀，也就是每次分组排序后让整个序列尽可能有序，防止出现某个元素消耗过多的时间去比较，从而优化时间复杂度**。

- 希尔排序是**把记录按下标的一定增量分组，对每组使用直接插入排序算法排序**；随着增量逐渐减少，每组包含的关键词越来越多，**当增量减至 1 时，整个文件恰被分成一组，算法便终止**。
- 需要三层循环，**外层循环负责控制分组步长大小，步长大小从序列的长度开始，之后的每次步长都是上次步长的一半，直到步长大小变成0，退出循环**。**中层循环每次从下标为分组步长的元素开始（这个下标对应着所有分组的最前面的无序元素）负责遍历每个分组无序区的元素（步长为1挪到最后就相当于遍历了所有分组的无序元素）**。**内层循环负责对遍历到的无序元素在它们组内（体现在每次比较跨越的步长为外层循环的值，这样可以保证相互比较的值都是同一组）进行插入排序（基于比较往前挪，直到中间某一次没挪，说明归位了）**。
- 写完代码说一句：不愧是历史上时间复杂度首次突破O(n^2)的算法，这三层循环真是挺巧妙的。

### 时间复杂度

- 查前面那个表。

### 希尔排序流程图解

![image-20221106092745473](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106092745473.png)

![image-20221106092757251](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106092757251.png)

### 代码示例

```java
import java.util.Scanner;

/**
 * @author Konjacer
 * @create 2022-11-08 9:05
 */
public class ShellSort {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入要排序的数字数量：");
        int n = scanner.nextInt();
        int[] num = new int[n];
        System.out.println("请依次输入要排序的数字：");
        for(int i=0;i<n;++i){
            num[i] = scanner.nextInt();
        }
        for(int k=num.length/2;k>0;k/=2){//控制分组步长，从数组长度除2开始，每次迭代都除2，直到小于等于0，说明已经排好序了
            for(int i=k;i<num.length;++i){//为了进行插入排序，我们首先要定位到每一组无序区的头元素，而每轮的k正好是所有分组的第一组的无序区的头元素（因为第一组的有序区元素下标为0，这个下标加上步长k正好是无序区的头元素，而第一组的无序区头元素又是所有分组中最靠前的，可以保证在它之后的所有元素都是无序区的元素，在它前面的元素都是有序区的元素），之后每次i++的时候就相当于遍历到了别的分组的无序区的头元素，遍历完一轮分组之后，所有无序区的头元素归位，继续i++就是遍历所有分组的新无序区的头元素，直到最后，i可以遍历完所有分组的无序区
                for(int j=i-k;j>=0;j-=k){//把上一层循环选中的元素移动到它所在分组的有序区的正确位置，基于比较移动
                    if(j!=j+k&&num[j]>num[j+k]){//原地交换，还是那些问题，数据过大会导致数值溢出并且两边下标相同时会出现问题，总的说就是交换两个元素的时候最少需要两个单位的空间（两个元素已经占用了两个单位的空间）
                        num[j] += num[j+k];
                        num[j+k] = num[j] - num[j+k];
                        num[j] -= num[j+k];
                    }
                }
            }
        }
        System.out.println("排序后的数组为：");
        for(int i=0;i<n;++i){
            System.out.print(num[i]+" ");
        }
        System.out.println();
    }
}
```



## 期待已久的堆排序

- 堆排序这个东西，在上大一的时候就有所耳闻，然而当时写题都用c++自带的快速排序的函数，所以对这种神奇的排序方法也没有深究，这一眨眼上大三了，学校里也开了算法的课程，正好学到了这个堆排序，我听了听确实巧妙，回来之后根据自己的理解进行了实现，下面细说。

### 什么是堆

- **同时满足以下两个条件**的数据结构被称为堆：
  1. 堆是一颗**完全二叉树**
  2. 堆的**每一个节点的值都大于等于或都小于等于其子节点的值**

- 每个节点的值都大于等于其子节点的值的堆被称为**最大堆（或者是大根堆）**，剩下的那种情况被称为**最小堆（或者是小根堆）**。

### 堆的存储

- 由于二叉树特殊的访问性质，所以我们一般都**通过数组来存储堆**，可以通过二叉树的性质来对一个节点的父节点或是子节点进行访问，比如说**下标为i的节点的父节点的下标为floor((i-1)/2)**,**其子节点的下标为(i\*2+1)和(i\*2+2)**

### 堆的基本操作

#### 节点上移（ShiftUp）

- 这个操作可以**让某个节点上移直到合适的位置**，由于其父节点只可能有一个，因此只需要进行一次判断并且只有一种上移路径，其中应该格外注意在进行节点上移的时候不要发生数组越界。

- 示例代码：

  ```java
  private void shiftUp(int index){
      while (index>0 && num[index]>num[(index-1)/2]){//没越界，并且当前节点位置异常
          //System.out.println(1);
     		//下面三行是交换操作
          int temp = num[index];
          num[index] = num[(index-1)/2];
          num[(index-1)/2] = temp;
          //坐标重定向为交换过去的位置
          index = (index-1)/2;
      }
  }
  ```

#### 节点下移（ShiftDown）

- 这个操作可以**让某个节点下移直到合适的位置**，其子节点可能有多个，因此需要进行两次判断，由于有两种下移路径，我们应该**选用最合适的路径进行下移**，其中应该格外注意在进行节点下移的时候不要发生数组越界。

- 代码示例：

  ```java
  private void shiftDown(int index){
      while ((index*2+1)<len && (index*2+2)<len){//有俩孩子的情况
          //System.out.println(1);
          if(!(num[index]>=num[index*2+1]&&num[index]>=num[index*2+2])){//当前节点位置异常，选最合适的一条路径进行下移
              if(num[index*2+1]>num[index*2+2]){//第一种情况
                  int temp = num[index];
                  num[index] = num[index*2+1];
                  num[index*2+1] = temp;
                  index = index*2+1;
              }else{//第二种情况
                  int temp = num[index];
                  num[index] = num[index*2+2];
                  num[index*2+2] = temp;
                  index = index*2+2;
              }
          }else break;//注意这个地方少了会死循环
      }
      if((index*2+1)<len){//只有一个孩子的情况，顶多再下移一次了，既能保证一开始就是这样的情况，又能保证上面的代码执行完毕后剩下的是这种情况，一举两得。
          if(num[index]<num[index*2+1]){
              int temp = num[index];
              num[index] = num[index*2+1];
              num[index*2+1] = temp;
          }
      }
  }
  ```

#### 插入元素（Insert）

- 将**新元素加到堆的最后**，将**堆的规模加1**，然后**使用ShiftUp操作将新元素移动到合适的位置**上
- 代码示例：

#### 删除元素（Delete）

- 将待删除的元素与最后一个元素进行交换，将堆的大小减1（也就是**保证被删除的元素不参与元素上移或者下移的判断**），然后**再用ShiftDown操作或者ShiftUp操作来调整换上来的那个元素**以维持堆的性质。
- 代码示例：

#### 删除最大值（DeleteMax）

- **对栈顶元素进行删除元素操作**即可。
- 代码示例：

#### 创建堆（MakeHeap）

- 目的是**将一个随机排列的数组变成一个符合堆定义的数组**

- 叶节点只有他本身，没有子树，所以它本身是符合堆的定义的，那么我们就需要**从倒数第一个非叶节点开始进行操作**，因为非叶节点有子树，并不能保证它们是符合堆的性质的，因此需要**通过节点下移进行调整**，调整完毕后当前子树符合堆的性质了，再往上走**遇到节点时总能保证它的子树是符合堆定义的，但是顶点的位置不一定正常，因此只需要让顶点进行下移操作即可将其本身也调整为一个堆**，调整完所有非叶节点后，所有子树包括它本身就都符合堆的定义了，这样一个堆就建好了。

- 代码示例：

  ```java
  public void shift(){
      for(int i=(len-2)/2;i>=0;--i){//从最后一个非叶节点开始
          shiftDown(i);
      }
  }
  ```

#### 堆排序（HeapSort）

- 首先要**保证这个数组符合堆的定义才能进行堆排序**。

- 每次都**让顶点元素和最后一个元素换位置**，然后将**堆的逻辑长度减1**（也就是**不让换到最后的元素参与下移的运算**），此时除了顶点外别的部分都符合堆的定义，因此需要**对顶点进行下移操作以保证堆的性质**，这个操作完毕后第一轮就结束了，在**堆最后的有序区增加了一个元素**，一共执行这个操作n（数组长度）次，堆排序就做好了。

- 不难分析出**堆排序的时间复杂度是O(NlogN)**的，换位置的操作复杂度是O(N)，节点下移操作的复杂度是O(logN)，每次换位置的操作后都会有个下移操作，所以整体时间复杂度是O(NlogN)。

- 示例代码：

  ```java
  public void sort(){
      for(int i=0;i<num.length;++i){//做n次
          //换位
          int temp = num[0];
          num[0] = num[len-1];
          num[len-1] = temp;
          //堆的逻辑长度--，为的是不让有序区参与下移运算，只让剩下的无序部分参与下移操作
          len--;
          //使用下移操作对堆顶点进行调整
          shiftDown(0);
      }
  }
  ```
  

### 时间复杂度分析

- 很明显，在堆上做的节点上移和节点下移操作时间复杂度都是O(logN)的，而每次得到最大值的操作都有节点下移操作，得到所有元素的时间复杂度是O(N)的，所以时间复杂度应该是O(NlogN)的。

## 分而治之归并排序

### 简介

- 这种排序方式主要突出一个分而治之，**将大问题分解成小问题，等小问题解决了之后再合并成为大问题的解**，这种形式的问题就很适合用递归进行解决，每次递归都是一次解决小问题的过程，有些小问题暂时还没法解决怎么办，没事，继续往下递归，到最后层层返回后的答案就是合并后的答案。

### 基本思路

- 主要思路就是：**每次递归将数组对半分，分别对左右两半的数组进行递归保证左右两边的数组都是有序的之后，再调用双路归并的算法来对两半数组进行合并**，每次递归都执行上述操作，最后得到的答案就是排序后的数组。

### 双路归并算法

- 该算法是归并排序中合并两个有序集合的操作，具体实现是：**三个指针i，j，k分别表示左集合的头元素，右集合的头元素，结果集合的头元素，每次比较i，j指向的元素，将比较小的那个元素放到结果集合中并移动指针**，以此类推最后得到的就是合并了两个有序集合的有序集合。

### 时间复杂度分析

- 二分的时间复杂度是O(logN)的，二路归并的时间复杂度是O(N)的，每次二分之后都会有一个二路归并，所以总体的**时间复杂度是O(NlogN)的**，但是递归所造成的空间消耗是巨大的。

### 代码实现

```java
import java.util.Arrays;
import java.util.Date;
import java.util.Random;
import java.util.Scanner;

/**
 * @author Konjacer
 * @create 2022-10-06 23:10
 */
public class MergeSort {
    public static void main(String[] args) {
        System.out.println("请输入数据规模：");
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] arr = new int[n];
        Random random = new Random();
        random.setSeed(1);
        for(int i=0;i<n;++i){
            arr[i] = random.nextInt();
        }
        Date dateBefore = new Date();
        arr = sort(arr);
        //System.out.println(Arrays.toString(arr));
        System.out.println("一共用时："+((new Date().getTime()-dateBefore.getTime())/60000.0)+"分钟");
    }
    public static int[] sort(int[] arr){
        if(arr.length==1){//如果只有一个元素，那这个集合本身就是有序的，直接返回
            return arr;
        }
        int mid = arr.length/2;//二分
        return merge(sort(Arrays.copyOfRange(arr,0,mid)),sort(Arrays.copyOfRange(arr,mid,arr.length)));//保证两边的集合都有序后再合并
    }
    public static int[] merge(int[] a,int[] b){//二路归并操作
        int[] ans = new int[a.length+b.length];//结果数组的长度应该是两个数组的长度之和
        int i=0,j=0;//分别是两个数组的头指针
        for(int k=0;k<ans.length;++k){//对结果数组中的每个元素进行赋值
            if(i<a.length&&j<b.length) {//两个数组都没到头的时候
                ans[k] = a[i] < b[j] ? a[i++] : b[j++];//赋值为较小的那个并移动指针
            }else{//其中至少有一个数组遍历到头了，就把剩下的元素都塞到后面即可
                for(;i<a.length;++i){
                    ans[k++] = a[i];
                }
                for(;j<b.length;++j){
                    ans[k++] = b[j];
                }
                break;
            }
        }
        return ans;
    }
}
```

## 用得最多快速排序

### 简介

- 快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。
- 效率很高，**平均时间复杂度可以达到O(NlogN)**，但是通常情况下都要比这个快。

### 基本思路

- 也是有一个分治的思想在里面，不过每次调整序列的时候是用了效率比较高的方式，其思想是**选中序列中的一个数作为基准数**，我们要调整当前序列为：**所有在基准数左边的数都比基准数要小，所有在基准数右边的数都比基准数要大**。**调整完毕后，再递归地对其左右边的序列继续上面的步骤**，最后递归层层返回后得到的结果就是排序好的序列。
- 怎么调整序列呢？基本思路是：**设置i，j两个指针分别指向序列的头和尾，选取尾部元素作为基准数，提前记录下来，然后i开始向后扫描，扫描到比基准数小的就过，扫描到比基准数大的就把i当前的值赋值给j位置的值，并让j--，由于j位置的值就是基准数，而基准数被提前记录了，所以在这个操作中没有数据的损失；做完上述步骤之后，换为j向前扫描，扫描到比基准数大的就过，扫描到比基准数小的就把j当前的值赋值给i位置的值，并让i++，由于i位置的值在上一步中已经被记录到之前j所在的位置，所以在这个操作中也没有数据的损失，之后就是一直重复上面的步骤直至i和j汇合，此时的位置就是基准数应该在的位置，将基准数赋值给这个位置，调整完毕**。
- 为什么上述方式可以保证调整成功呢？是因为最后i和j汇合的地方是基准数的位置，所以在汇合之前，i和j所在的区域都应该是满足调整成功的序列的条件的，所以**无论是谁在扫描序列，在碰上不符合这个区域的条件的元素时，我们就要拜托远在另一个区域的“兄弟”把当前这个不符合条件的数字处理掉，由于处理掉之后产生了空位（至少从逻辑上是这样的，因为当前位置留下的那个数字冗余了），所以当前空位上的指针还要处理一下这个空位，于是它就一直等待它远在另外一个区域的“兄弟”帮它找到一个符合条件的元素来给它处理一下这个空位，而此时另外那个兄弟因为解决了空位问题所以继续扫描，周而复始就能解决所有空位，并能使两边的区域中的元素都符合条件，最后一个空位兄弟俩一起解决，将最开始的那个元素填入，至此调整完毕**。

### 时间复杂度分析

- 最坏情况下每次比较都需要交换位置，所以最坏情况下的时间复杂度是O(N^2)的。
- 最好情况下和平均情况下的时间复杂度都是O(NlogN)的
- 正是因为有如此优秀的平均时间复杂度和较小的空间开销，才使得快速排序立于不败之地。

### 代码实现

```java
import java.util.Arrays;
import java.util.Date;
import java.util.Random;
import java.util.Scanner;

/**
 * @author Konjacer
 * @create 2022-10-07 12:06
 */
public class QuickSort {
    static int[] arr;
    public static void main(String[] args) {
        System.out.println("请输入数据规模：");
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        arr = new int[n];
        Random random = new Random();
        random.setSeed(1);
        for(int i=0;i<n;++i){
            arr[i] = random.nextInt();
        }
        Date dateBefore = new Date();
        //System.out.println(Arrays.toString(arr));
        sort(0,arr.length-1);
        //System.out.println(Arrays.toString(arr));
        System.out.println("一共用时："+((new Date().getTime()-dateBefore.getTime())/60000.0)+"分钟");
    }
    public static void sort(int begin,int end){//begin是处理的当前区间的左界，end是处理的当前区间的右界
        //System.out.println(begin+" "+end);
        if(begin>=end) return;//如果出现只有一个元素或者没有元素的情况在逻辑上就是有序的，直接返回即可
        int i=begin,j=end,p=arr[end];//设置左右哨兵，记录最后一个值为基准数，准备扫描
        boolean shift = true;//为true时i往后扫描，为false时j往前扫描
        while (i<j){//没有碰头时说明基准数的位置还没定下来
            if(shift){//i往后扫描
                if(arr[i]>p){//找到了异端，拜托j处理掉它，i在此等待填坑
                    arr[j] = arr[i];//处理异端
                    j--;//j的坑填完了可以继续扫描了
                    shift = false;//让j扫描
                }
                else i++;//如果没找到异端就继续扫描
            }else{//j往前扫描
                if(arr[j]<p){//找到了异端，拜托i处理掉它，j在此等待填坑
                    arr[i] = arr[j];//处理异端
                    i++;//i的坑填完了可以继续扫描了
                    shift = true;//让i扫描
                }
                else j--;//如果没找到异端就继续扫描
            }
        }
        //System.out.println(i+" "+j);
        arr[i] = p;//将基准数归位
        //System.out.println(p);
        sort(begin,i-1);//处理左半截，开头是begin不是0，因为这次递归处理的是其中一个区间
        sort(i+1,end);//处理右半截，结尾是end不是arr.length-1，因为这次递归处理的是其中一个区间
    }
}
```

## 速度很快的桶排序

### 桶排序思路

-  将待排序元素划分到不同的桶。先扫描一遍序列求出最大值 maxV 和最小值 minV ，设桶的个数为 k ，则把区间 [minV, maxV] 均匀划分成 k 个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。
- 对每个桶内的元素进行排序。可以选择任意一种排序算法。
- 将各个桶中的元素合并成一个大的有序序列。
- 假设数据是均匀分布的，则每个桶的元素平均个数为 n/k 。假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为 O(n/klog(n/k)) 。总的时间复杂度为O(n)+O(k)O(n/klog(n/k)) = O(n+nlog(n/k)) = O(n+nlogn-nlogk) 。当 k 接近于 n 时，桶排序的时间复杂度就可以金斯认为是 O(n) 的。即桶越多，时间效率就越高，而桶越多，空间就越大。

### 代码示例

```java

```

## 桶数最多计数排序

### 计数排序思想

- 是一种**时间复杂度为O(n)的排序算法**，其思路是开一个长度为 maxValue-minValue+1 的数组，然后

  1. **分配**：扫描一遍原始数组，以当前值 - minValue 作为下标，将该下标的计数器增1。

  2. **收集**：扫描一遍计数器数组，按顺序把值收集起来。

- 举个例子， nums=[2, 1, 3, 1, 5] , 首先扫描一遍获取最小值和最大值， maxValue=5 , minValue=1 ，于是开一个长度为5的计数器数组 counter ，

  1. 分配。统计每个元素出现的频率，得到 counter=[2, 1, 1, 0, 1] ，例如 counter[0] 表示值 0+minValue=1 出现了2次。
  
  2. 收集。 counter[0]=2 表示 1 出现了两次，那就向原始数组写入两个1， counter[1]=1 表示 2 出现了1次，那就向原始数组写入一个2，依次类推，最终原始数组变为 [1,1,2,3,5] ，排序好了。
  
- 计数排序本质上**是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序**。
  

### 代码示例

```java
import java.util.Scanner;

/**
 * @author Konjacer
 * @create 2022-11-09 10:26
 */
public class CountingSort {
    public static final int INF = 0x3f3f3f3f;
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入要排序的数字数量：");
        int n = scanner.nextInt();
        int[] num = new int[n];
        System.out.println("请依次输入要排序的数字：");
        int min = INF;
        int max = -INF;
        for(int i=0;i<n;++i){//存储数据并找出数据中的最大值和最小值
            num[i] = scanner.nextInt();
            if(min>num[i]) min = num[i];
            if(max<num[i]) max = num[i];
        }
        int[] bucket = new int[max-min+1];//把桶子创建出来，创建max-min+1个而不是max个实际上是优化空间，但相应要在下面的步骤中多做一点操作
        for(int i=0;i<n;++i){//对桶子对应的元素进行计数，计数为几说明存在几个当前桶子对应的元素，不过记得元素减min之后再给对应桶子计数，最后遍历的时候也要将桶子对应的元素加上min，这样才能得到原数据
            bucket[num[i]-min]++;//将元素给个偏移量后放进对应的桶子中，后面输出的时候应该让桶子对应的元素把偏移量加回去
        }
        System.out.println("排序后的数组为：");
        for(int i=0;i<max-min+1;++i){//遍历桶子
            for(int j=0;j<bucket[i];++j){//根据当前桶子的计数来决定输出当前桶子对应的元素的数量，桶子大于1的计数在原数据中体现为重复的元素
                System.out.print((i+min)+" ");//记得输出的时候把偏移量加回去
            }
        }
        System.out.println();
    }
}
```



## 数位做桶基数排序

### 基数排序介绍

- 基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾名思义，**它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用**。
- 基数排序法是属于稳定性的排序，基数排序法的是**效率高的稳定性排序法**。
- **基数排序(Radix Sort)是桶排序的扩展**。
- 基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：**将整数按位数切割成不同的数字，然后按每个位数分别比较**。

### 基数排序基本思想

- **将所有待比较数值统一为同样的数位长度，数位较短的数前面补零**。然后，**从最低位开始，依次进行一次排序**。这样**从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列**。
- 实际上的原理就是**每次循环过后使得下一次循环放入同一个桶中的元素从当前数位开始到最后组成的数字有序了，而不同的桶本身就自带顺序属性，在两方有序的加持下，整体的表现就是有序**，比如123和221，经过一次循环之后221排到123前面了；那么在下一次循环中，221和123放到了同一个桶中，由于上一次循环把它们的个位数排序了，所以在这次循环中，它们从十位数开始之后的数位组成的数字是有序的，然后221又排到了123前面；再下一次循环，123和221不在一个桶中了，123又排到了221的前面，更高位数的数以此类推。实际上这么多次循环**是在解决由于放入桶中的条件减少导致的桶内元素无序的情况，每次循环都致力于让最后的桶内部的元素是有序的**。（我在说些什么。。。）
- 很明显，**外层循环次数由序列中元素的最大数位长度（十进制）决定**，**由于某个数位的大小是0-9，所以桶的数量固定为10**。
- 需要两层循环，**外层循环控制本次是用哪个数位进行桶排序，内层循环做桶排序**。

### 时间复杂度

- 虽然用到了两层循环，但是**外层循环是和最大数位长度（十进制）k有关，内层循环做桶排序和序列长度n有关**，所以**时间复杂度是O(nk)的**。

### 基数排序流程图解

![image-20221106105500208](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106105500208.png)

![image-20221106105512310](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106105512310.png)

![image-20221106105526703](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106105526703.png)

### 代码示例

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

/**
 * @author Konjacer
 * @create 2022-11-09 10:51
 */
public class RadixSort {
    public static final int INF = 0x3f3f3f3f;
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入要排序的数字数量：");
        int n = scanner.nextInt();
        int[] num = new int[n];
        System.out.println("请依次输入要排序的数字：");
        int maxDigit = -INF;
        for(int i=0;i<n;++i){//存储数据，顺便找到所有数字中最大的数位长度作为桶排序的次数
            num[i] = scanner.nextInt();
            int digit = getDigit(num[i]);//获取对应数字的数位长度
            maxDigit = maxDigit<digit?digit:maxDigit;//找最大的数位长度
        }
        List<LinkedList<Integer>> bucket = new ArrayList<>();//创建桶子
        for(int i=0;i<10;++i){//因为每个数位的大小只能是0-9，而我们要对某个数位进行桶排序，所以只需要十个桶即可。
            bucket.add(new LinkedList<>());
        }
        //bucket = bucket.stream().map((v) -> new LinkedList<Integer>()).collect(Collectors.toList());//流式操作初始化容器（好吧这样好像不太行）
        //System.out.println(bucket.size());
        for(int i=0;i<maxDigit;++i){//对每个数位进行桶排序，从0开始方便后面做相关计算
            int divisor = (int) Math.pow(10,i);//用于获取对应的数位，数字除以这个数，然后再mod10就是对应的数位
            for(int j=0;j<n;++j){//遍历数据，根据当前循环到数位往桶子里放
                bucket.get((num[j]/divisor)%10).add(num[j]);
            }
            int index = 0;//更新num用的下标
            for(int j=0;j<10;++j){//遍历桶
                while (!bucket.get(j).isEmpty()){//如果桶子里面有元素，取出元素更新num
                    num[index++] = bucket.get(j).poll();
                }
            }
        }
        System.out.println("排序后的数组为：");
        for(int i=0;i<n;++i){
            System.out.print(num[i]+" ");
        }
        System.out.println();
    }
    public static int getDigit(int num){//获取一个数字的数位长度，就是一个数字十进制下有几位数，比如123的数位长度是3，12的数位长度是2
        int ans = 0;
        while (num>0){
            ans++;
            num/=10;
        }
        return ans;
    }
}
```

# 如何创建一棵二叉树

- **首先将所有节点按照层序遍历的顺序放入一个线性结构**，然后**再遍历这个线性结构，用访问二叉树子节点的方式(左节点下标为i\*2+1，右节点下标为i\*2+2)访问当前节点的左右节点并将这些节点建立起联系**。

- 代码示例：

  ```java
  import java.util.ArrayList;
  import java.util.List;
  import java.util.Scanner;
  
  /**
   * @author Konjacer
   * @create 2022-11-10 14:49
   */
  public class CreateBinaryTree {
      public static void main(String[] args) {
          Scanner scanner = new Scanner(System.in);
  
          System.out.println("请输入树的节点(包括空节点)的数量：");
          int n = scanner.nextInt();
          if(n==0){
              System.out.println("树为空");
              return;
          }
  
          System.out.println("请输入树的层序结构（空节点用'#'表示，元素之间用空格分割）：");
          List<TreeNode> nodes = new ArrayList<>();//用线性结构先把树的节点存储起来，之后再建立节点之间的关系
          for(int i=0;i<n;++i){//输入节点
              String input = scanner.next();//这个读取String的方法可以被空格阻断
              if(input.charAt(0)=='#'){//处理空节点
                  nodes.add(null);
              }else{//处理非空节点
                  nodes.add(new TreeNode(Integer.parseInt(input)));
              }
          }
          for(int i=0;i<n;++i){//建立节点之间的联系
              TreeNode temp = nodes.get(i);//取出当前节点，准备给其左右节点赋值
              if(temp==null) continue;//如果当前节点是个空节点，就continue，不过从面向对象的角度来说，空节点也应该是一个对象，不过有点麻烦所以就没弄
              int left = i*2+1;//左节点下标
              int right = i*2+2;//右节点下标
              if(left<n){//检测左节点下标是否越界，如果越界了不用处理，默认反正就是null
                  temp.setLeft(nodes.get(left));//设置左节点
              }
              if(right<n){//检测右节点下标是否越界，如果越界了不用处理，默认反正就是null
                  temp.setRight(nodes.get(right));
              }
          }
          TreeNode root = nodes.get(0);//联系建立完毕后，线性结构中的第一个节点就是树的根节点
      }
  }
  class TreeNode{//二叉树节点
      public int val;//节点的值
      public TreeNode left;//左节点
      public TreeNode right;//右节点
      public TreeNode(){}
      public TreeNode(int val){
          this.val = val;
      }
      public void setLeft(TreeNode left){
          this.left = left;
      }
      public void setRight(TreeNode right){
          this.right = right;
      }
  }
  ```

  

# 二叉树遍历算法

## 二叉树的纵序遍历

### Morris遍历

- **以下均以先遍历左子树再遍历右子树为前提**。

#### 介绍

- 该算法巧妙地利用到了一个二叉树中叶节点的空指针，从而使空间复杂度降到了O(1)，原理是**构建了一颗线索二叉树，使得每次访问到每个子树的最后一个节点后都能找到应该回到哪里继续进行遍历**，这一线索在之前学过的遍历方法中由递归、栈提供，但在Morris遍历中利用叶节点的空指针来提供。
- morris遍历是二叉树遍历算法的超强进阶算法，morris遍历可以将非递归遍历中的空间复杂度降为O(1)。从而实现时间复杂度为O(N)，而空间复杂度为O(1)的精妙算法。**morris遍历利用的是树的叶节点左右孩子为空（树的大量空闲指针），实现空间开销的极限缩减**。

#### 实现原则

- 记当前节点为cur：
  1. 如果cur无左孩子，cur向右移动（cur=cur.right）
  2. 如果cur有左孩子，找到cur左子树上最右的节点，记为mostright：如果mostright的right指针指向空，让其指向cur，cur向左移动（cur=cur.left）；如果mostright的right指针指向cur，让其指向空，cur向右移动（cur=cur.right）。

#### 实质

- 建立一种机制，对于没有左子树的节点只到达一次，对于有左子树的节点会到达两次。
- 实际上就是**构建了一棵线索二叉树，让每个子树的最后遍历到的元素的右指针指向这颗子树的顶点，这样遍历完这颗子树后，就可以返回到顶点处（返回后要取消线索，意味着左子树已经遍历完毕）进行下一步的遍历操作了**。

#### 代码实现

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * @author Konjacer
 * @create 2022-11-10 14:49
 */
public class Morris {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.println("请输入树的节点(包括空节点)的数量：");
        int n = scanner.nextInt();
        if(n==0){
            System.out.println("树为空");
            return;
        }

        System.out.println("请输入树的层序结构（空节点用'#'表示，元素之间用空格分割）：");
        List<TreeNode> nodes = new ArrayList<>();//用线性结构先把树的节点存储起来，之后再建立节点之间的关系
        for(int i=0;i<n;++i){//输入节点
            String input = scanner.next();//这个读取String的方法可以被空格阻断
            if(input.charAt(0)=='#'){//处理空节点
                nodes.add(null);
            }else{//处理非空节点
                nodes.add(new TreeNode(Integer.parseInt(input)));
            }
        }
        for(int i=0;i<n;++i){//建立节点之间的联系
            TreeNode temp = nodes.get(i);//取出当前节点，准备给其左右节点赋值
            if(temp==null) continue;//如果当前节点是个空节点，就continue，不过从面向对象的角度来说，空节点也应该是一个对象，不过有点麻烦所以就没弄
            int left = i*2+1;//左节点下标
            int right = i*2+2;//右节点下标
            if(left<n){//检测左节点下标是否越界，如果越界了不用处理，默认反正就是null
                temp.setLeft(nodes.get(left));//设置左节点
            }
            if(right<n){//检测右节点下标是否越界，如果越界了不用处理，默认反正就是null
                temp.setRight(nodes.get(right));
            }
        }
        TreeNode root = nodes.get(0);//联系建立完毕后，线性结构中的第一个节点就是树的根节点

        TreeNode pointer = root;
        if(pointer==null) System.out.println("树为空");
        System.out.println("指定树的前序Morris遍历的结果为");
        while(pointer!=null){//Morris遍历，这里写个前序
            TreeNode mostRight = pointer.left;//mostRight用来找左子树的最右边的节点，把当前节点的左树赋给mostRight可以在后面顺便检测左树是否存在
            if(mostRight!=null){//如果左树存在
                while (mostRight.right != null && mostRight.right!=pointer){//找左子树最靠右的节点，最靠右的节点的右节点一定是null或者当前节点
                    mostRight = mostRight.right;
                }
                if(mostRight.right == null){//如果最右节点的右节点是null，说明这个左子树还没有被遍历过，就做好线索之后向左遍历，这个线索指向当前节点，为的是遍历完左子树回到当前节点并且还是作为左子树已经遍历过的标志
                    System.out.print(pointer.val+" ");//前序遍历，在向左遍历之前输出
                    mostRight.right = pointer;//建立线索
                    pointer = pointer.left;//向左遍历
                }else{//如果最右节点的右节点是当前节点，说明这个左子树已经被遍历过了，恢复右指针为null并向右遍历即可
                    //这里没有输出语句，是因为这个条件中是左子树已经被遍历过了，由于是前序遍历，所以当前节点应该已经被输出过一遍了，不用再输出一遍了。
                    mostRight.right = null;//消除线索
                    pointer = pointer.right;//向右遍历
                }
            }else{//如果左树不存在
                System.out.print(pointer.val+" ");//前序遍历，没有左子树的时候，输出再向右遍历
                pointer = pointer.right;//向右遍历
            }
        }
    }
}
class TreeNode{//二叉树节点
    public int val;//节点的值
    public TreeNode left;//左节点
    public TreeNode right;//右节点
    public TreeNode(){}
    public TreeNode(int val){
        this.val = val;
    }
    public void setLeft(TreeNode left){
        this.left = left;
    }
    public void setRight(TreeNode right){
        this.right = right;
    }
}
```

这个代码里还有个**创建一棵树**的知识点。

## 二叉树的层序遍历

### 利用队列实现

- 总体思想就是BFS的思想，先初始化队列（往队列里面放第一个值），每次从队列中poll一个元素，然后把和这个元素相邻的下一层元素再放到队列中，一直重复操作直到队列为空，不过其中有几个比较难想的点。

- 如何获取每一层的元素数量？**每一层的元素数量就是外层循环刚开始时的队列的长度，内层循环根据这个长度来poll元素即可保证poll出来的元素是同一层的**，不过内层for循环中**不要把queue.size()当作循环结束条件**，而要在for循环之前记录队列在循环刚开始时的值，因为在内层循环中队列的长度是不断变化的，不能当作循环结束的条件。

- 代码示例：

  ```java
  class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode() {}
      TreeNode(int val) { this.val = val; }
      TreeNode(int val, TreeNode left, TreeNode right) {
          this.val = val;
          this.left = left;
          this.right = right;
     }
  }
  class Solution{
      List<List<Integer>> list = new ArrayList<>();
      LinkedList<TreeNode> qu = new LinkedList<>();
      ArrayList<Integer> mid;
      public List<List<Integer>> levelOrder(TreeNode root) {
          if(root==null) return list;
          qu.add(root);
          while (!qu.isEmpty()){
              mid = new ArrayList<>();
              int size = qu.size();//本层的节点数量
              for(int i=0;i<size;++i) {
                  TreeNode temp = qu.poll();
                  mid.add(temp.val);
                  if (temp.left != null)
                      qu.add(temp.left);
                  if (temp.right != null)
                      qu.add(temp.right);
              }
              list.add(mid);
          }
          return list;
      }
  }
  ```

# 回溯算法



# 分支限界算法

## 状态空间树（解空间树）

- 状态空间树就是问题的解空间树，分为**子集树**和**排列树**。
- 状态空间树**通常是一个虚拟的树，并不需要我们实际将其构建出来，它的存在只是为了让我们能进一步理解解决问题需要计算的规模和问题的可能存在的解等，起到的是辅助的作用**。
- **对于明显不可能找到答案的分支我们可以选择不予遍历来提高效率，这样就是对状态空间树剪枝，剪枝的难点在于设计剪枝条件**。

### 子集树

- 当所给的问题是**从n个元素组成的集合set中找到满足某一条件的一个子集时，相应的解空间树称为子集树**。要注意，这个**解空间树是一个虚拟的树，并不是需要实际构建出来的**。

- **0-1背包问题的解空间树实际上就是一个很典型的子集树，因为我们实际上是想要找到所有物品这个集合中的一个子集，使得子集中的物品能全部装到背包中并且价值最大**，所以我们可以使用子集树来描述0-1背包问题的解空间。

- 对于**0-1背包问题**的子集树，我们通常**将每个节点描述为目前装载的物品，向左遍历可以再装下一个物品，向右遍历不装下一个物品**，以此类推，将所有的物品全部都决定完装或者不装之后，当前的节点也就是叶节点就可能是答案，要尝试更新答案，当将状态空间树的所有节点全部遍历一遍之后，答案也就被找出来了。

- 子集树示例：

  ![image-20221121145007229](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121145007229.png)

### 排列树

- 当所给的问题是**求n个元素的全排列的时候，相应的解空间树称为排列树**。要注意，这个**解空间树是一个虚拟的树，并不是需要实际构建出来的**。

- **TSP问题（也就是旅行商问题，求从一个节点开始走过所有其它节点一遍后返回起始节点所需的最短路径）的解空间树实际上就是一个很典型的排列树，因为我们无论如何都要走过所有其它的节点一遍，只是顺序有先后，因此我们需要遍历其所有的顺序，从中找出答案**。

- 对于**TSP问题**，我们通常**将每个节点描述为目前经过的图上节点，每一层的遍历都是尝试将所有没经过的图上节点加入到经过的图上节点中，所以一个父节点有几个孩子不一定**。最后所有图上节点都经过一遍之后，当前节点就是叶节点就可能是答案，要尝试更新答案，当将状态空间树的所有节点全部遍历一遍之后，答案也就被找出来了。

- 排列树示例：

  ![image-20221121151314120](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121151314120.png)

## 算法简介

- 如果说回溯法是使用深度优先搜索的方式遍历一个问题的状态空间树来寻找可能的答案，那么**分支限界法实际上就是使用广度优先搜索的方式遍历一个问题的状态空间树来寻找可能的答案**。
- **相比于回溯法的用递归解决问题，分支限界法常常具有更好的效率和更小的空间开销，每次都能决定状态空间树一整层节点的特性也让依赖于同层节点状态的剪枝变得相对容易一些**。
- 在优化方面可以根据具体情况进行**剪枝**；也可以看情况用**优先队列**代替做广度优先搜索用到的队列，让最有可能找出答案的节点尽量早些被遍历到。
- 对于分支限界算法来说，**如何设计状态空间树的节点是很重要的**，**状态空间树的节点中包含的属性应该可以准确描述当前状态并能为顺利构建下一个状态提供帮助，最好是还带有一些特定数据从而能更方便地实现剪枝操作**。

## 0-1背包问题的分支限界法解决

- **难点在于设计状态空间树的节点、剪枝以及使用优先队列进行优化**。
- **将所有物品按照性价比进行降序排序，然后从前往后尝试进行选择，向左遍历是选择当前物品，向右遍历时不选择当前物品**。
- 对于节点的设计，需要一个**index来指示下一个应该尝试选择的物品是第几个（在针对性价比排列过的序列中），这个属性对于顺利构建出下一个节点也有很重要的作用**；需要一个**valueNow来表示当前节点代表的状态装了价值为多少的东西**；需要一个**weightNow来表示当前节点代表的状态装了重量为多少的东西**；还需要一个**upperBound来表示当前节点表示的状态中背包的剩余空间全部利用上（装不下的可以装一部分，总之让剩余空间要全部装满）最多还能装多少价值的东西，这个属性是用来剪枝用的，如果要是valueNow+upperBound小于等于目前更新到的可能的答案，那么就可以剪枝了，因为沿着这条路走下去不可能会遍历到一个节点使得valueNow大于当前更新到的可能的答案，也就是说答案不可能在这条路上得到更新，直接剪掉就好了**。
- 还可以**用优先队列代替队列进行广度优先搜索，将最有可能得到答案的节点提前遍历，提高提前找到答案的可能性**。

- 代码示例，没有做剪枝和优先队列优化：

  ```java
  import java.util.LinkedList;
  import java.util.Scanner;
  
  /**
   * @author Konjacer
   * @create 2022-11-20 9:43
   */
  public class BranchAndBound01Backpack {
      public static void main(String[] args) {
          Scanner scanner = new Scanner(System.in);
          System.out.println("请输入背包的容量：");
          double w = scanner.nextDouble();
          System.out.println("请输入物品的数量：");
          int n = scanner.nextInt();
          double[] value = new double[n];//存物品价值
          double[] weight = new double[n];//存物品重量
          for(int i=1;i<=n;++i){
              System.out.println("请输入第"+i+"个物品的价值和重量：");
              value[i-1] = scanner.nextDouble();
              weight[i-1] = scanner.nextDouble();
          }
  
          for(int i=1;i<n;++i){//冒泡排序将物品按照性价比排序
              for(int j=0;j<n-i;++j){
                  if(value[j]/weight[j]<value[j+1]/weight[j+1]){//计算相邻两个物品的性价比，如果顺序不对就交换两个物品的位置（体现在交换两个数组的元素位置上）
                      double temp = value[j];
                      value[j] = value[j+1];
                      value[j+1] = temp;
                      temp = weight[j];
                      weight[j] = weight[j+1];
                      weight[j+1] = temp;
                  }
              }
          }
  
          double ans = -0x3f3f3f3f;
          LinkedList<Node> queue = new LinkedList<>();//队列
          queue.add(new Node(0,0,0,getUpperBound(value,weight,0,w)));//加入初始节点
          while (!queue.isEmpty()){//广度优先遍历状态空间树
              Node temp = queue.poll();
              if(temp.index>=n){//如果下标越界，说明当前可能是答案，所以对答案尝试更新
                  if(temp.valueNow>ans) ans = temp.valueNow;//尝试更新答案
                  continue;//由于下标越界，所以后面不可能有别的节点了，它是叶节点，所以不用扩展它的子节点，直接continue
              }
              //将空间状态树的两个子节点加入队列中
              if(temp.weightNow+weight[temp.index]<=w){//这是要装下一个物品的节点，如果能装下下一个物品就装，如果不能装下的话就不装，体现在程序上就是是否能计算得到下一个有效的状态节点并将其加入到队列中去
                  queue.add(new Node(temp.index+1,temp.valueNow+value[temp.index],temp.weightNow+weight[temp.index],getUpperBound(value,weight,temp.index+1,w-temp.weightNow-weight[temp.index])));
              }
              queue.add(new Node(temp.index+1,temp.valueNow,temp.weightNow,getUpperBound(value,weight,temp.index+1,w-temp.weightNow)));//这是不装下一个物品的节点，由于不装下一个节点，所以除了上界以外的属性都和它的父节点相同。
          }
          System.out.println("背包所能装下的最大价值为："+ans);//输出结果
      }
  
      public static double getUpperBound(double[] value,double[] weight,int index,double weightRest){//index是从哪开始计算，因为要算的是剩下的空间最多还能装多少价值的东西所以已经决定选或不选的元素不参与计算，weightRest是背包剩余的可以装东西的重量
          double ans = 0;
          for(int i=index;i<value.length;++i){
              if(weightRest>=weight[i]){//如果装的下就装
                  ans+=value[i];
                  weightRest-=weight[i];
              }else{//如果装不下就按照单位重量的价值计算最多能装的价值是多少
                  ans+=weightRest*(value[i]/weight[i]);
                  break;//weightRest用光了，直接退出循环
              }
          }
          return ans;
      }
  
      static class Node{
          public int index;//下一个应该判断第几个要不要装了
          public double valueNow;//装到现在的价值
          public double weightNow;//装到现在的重量
          public double upperBound;//装到现在的可能的最大价值上界（也就是理论上最多还能装的价值）
          public Node(int index,double valueNow,double weightNow,double upperBound){
              this.index = index;
              this.valueNow = valueNow;
              this.weightNow = weightNow;
              this.upperBound = upperBound;
          }
      }
  }
  ```

## TSP问题的分支限界法解决



# 动态规划算法

## DP之编辑距离

### 问题描述

- 很经典的一个问题，**编辑距离指的是从一个字符串变更为另外一个字符串所需要的最少操作数**，其中可以做三种操作：插入一个字符、删除一个字符、修改一个字符。

### DP思想

- **首先将大问题逐步分解为小问题**，以there和here两个字符串为例，大问题是there到here的编辑距离，那么所有小问题就是：t到here、th到here、the到here......
- 经过上面对于大问题的分解，我们不难发现**所有小问题的状态是需要一个m\*n的二维数组来进行表示的**，因此我们需要建立一个二维dp数组，数组元素dp[i]\[j]代表第一个字符串的前i个字符和第二个字符串的前j个字符的编辑距离，所以最后的dp[m]\[n]就是答案。
- 分解完问题之后，我们**再来看看对于每个子问题解是否满足无后效性**，也就是说每个子问题的解是否不影响后序子问题求解，很明显是不影响的。
- 再**看看子问题是否具有重叠性**。
- 然后**再确定dp的状态转移方程**，考虑中间某个值**dp[i]\[j]可以从哪些值转移过来**，以下都是以对第一个字符串做操作为基础，首先可以**从dp[i-1]\[j]+1转移过来，这个转移对应着我们对第一个字符串删除一个元素**，因为i-1能变到j，i对应的字符没用了；其次可以**从dp[i]\[j-1]+1转移过来，这个转移对应着我们对第一个字符串增加一个元素使得其和第二个字符串j位置上的字符相同**，因为都能从i变到j-1了，只需要插入一个和j对应的字符相同的字符就能成了；再者**可以从dp[i-1]\[j-1]+!(a[i]==b[j])转移过来，这个转移对应着我们对第一个字符串修改一个元素使得i对应的元素和j对应的元素相同**，因为已经可以从i-1转移到j-1了，所以只需要将剩下的俩元素修改成一样的就行了，如果剩下得俩字符本来就相同的话，那就没必要修改了，值就和dp[i-1]\[j-1]一样了。综上所述，所有的三个操作对应三个可能的转移方向，确定值的时候只需要取个最小值即可。
- 确定好状态转移方程后，我们只是确定了中间那部分子问题的求解方式，但是边界子问题的求解方式不一定和中间那部分子问题的求解方式相同，所以我们**要再确定边界子问题的求解方式**。对于边界情况，也就是从一个字符串变成空串，所需要的操作数就是这个字符串的长度，因为只需要把字符串的所有元素都删掉就能达成目标。**对于dp数组来说我们可以额外对每个维度再开出一个空间来，以保证较外层求解时可以使用中间层的求解范式而不至于造成数组越界或者是增加一些繁琐的判断操作**。
- 确定完边界子问题的求解方式后，我们要**先将边界子问题求出，这一步实际上就是初始化dp数组，然后再使用状态转移方程对其他子问题求解即可**。

### 代码实现

```java
import java.util.Scanner;

/**
 * @author Konjacer
 * @create 2022-10-15 20:41
 */
public class EditDistance {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入第一个字符串：");
        String a = scanner.nextLine();
        System.out.println("请输入第二个字符串：");
        String b = scanner.nextLine();
        int[][] dp = new int[a.length()+1][b.length()+1];//每个维度大小加一对边界初始化后方便状态转移
//        for(int i=0;i<a.length();++i){
//            System.out.print(a.indexOf(i)+" ");
//        }
//        System.out.println();
        for(int i=0;i<=a.length();++i){
            for(int j=0;j<=b.length();++j){
                if(i==0||j==0) dp[i][j] = Math.max(i,j);//边界子问题求解
                else dp[i][j] = Math.min(dp[i-1][j]+1,Math.min(dp[i][j-1]+1,dp[i-1][j-1]+(a.charAt(i-1)==b.charAt(j-1)?0:1)));//状态转移
//                System.out.print(a.indexOf(i-1)+b.indexOf(j-1)+dp[i][j]);
            }
//            System.out.println();
        }
        System.out.println("答案为："+dp[a.length()][b.length()]);
    }
}
```

## DP之TSP问题

### 问题描述

- 就是旅行商问题，问的是，给你一个图，然后求从一个节点经过剩下所有节点之后回到一开始那个节点所用的最小花费。

### DP思想

- 以下**假设是从节点0开始出发**。
- 可以**把问题描述为：从节点0开始出发，经过集合中除了节点0的剩余节点，最后再返回到节点0所需要的最小费用**。
- 然后我们可以定义子问题，每次从集合中的节点中拿出一个来当作子问题的起始节点，这样**子问题就变成了：从取出来的节点开始出发，经过集合中除了节点0和取出来的节点的剩余节点，最后回到节点0所需要的最小费用**。当从集合中把每个元素都取遍，实际上所有子问题也就被遍历过了，找到所有第一轮子问题中结果最小的那个就是答案，不过要确定第一轮子问题的答案，还需要将所有第一轮子问题分解出第二轮子问题，然后确定每一个第一轮子问题分解出的所有第二轮子问题的答案的最小值，那就是对应的第一轮子问题的答案......以此类推，直到无法再分后将答案一层层返回上来，思想像递归，不过在dp中是倒推。
- 再想想怎么进行状态转移，可以**设置二维dp数组，第一维表示节点，第二位表示当前节点最后到达节点0所通过的子集(都不包括节点0)**，对于子集更长的状态来说，应该从子集长度减一的所有状态中**距离最短的状态**中转移过来，**所以子集更长的状态转移依赖于所有子集长度减一的状态**，所以做状态转移的时候应该是**按轮进行状态转移，子集长度相同的状态在同一轮被确定下来**，这样才能为后面的状态进行确定的时候提供有效的前置状态。
- 如果是节点0作为起始点的话，最后的结果应该是dp数组中最右上角的那个元素，那个元素代表着节点0通过除了节点0的所有节点之后回到节点0的距离，**这个答案是从所有子集长度减一的有效状态中转移过来的**。

### dp数组图解

- dp状态转移方程：其中V'代表不包含它前面节点和起始节点的子集。

  ![image-20221023194550921](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221023194550921.png)

- dp数组示例：

  ![image-20221024202014918](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221024202014918.png)

### 代码实现

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;

/**
 * @author Konjacer
 * @create 2022-10-22 17:53
 */
public class TSPQuestionDP {
    public static void main(String[] args) {
        int inf = 0x3f3f3f3f;//正无穷
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入节点数量：");
        int n = scanner.nextInt();
        int[][] g = new int[n][n];//邻接矩阵存图
        int[][] dp = new int[n][1<<(n-1)];//dp数组，第一维为节点，第二维为子集
        //int[][] subSet = new int[n][n];
        for(int i=0;i<n;++i){//初始化邻接矩阵
            for(int j=0;j<n;++j){
                g[i][j] = inf;
            }
        }

        System.out.println("请输入边的数量：");
        int e = scanner.nextInt();
        for(int i=0;i<e;++i){
            System.out.println("请输入第"+(i+1 )+"条边的起点、终点、权值：");
            g[scanner.nextInt()][scanner.nextInt()] = scanner.nextInt();
        }

        //获取子集
        ArrayList<ArrayList<Integer>> subSet = new ArrayList<>();//所有子集
        HashMap<ArrayList<Integer>,Integer> map = new HashMap<>();//子集对应的访问下标
        int[] temp = new int[n-1];//用于求子集
        boolean[] vis = new boolean[n-1];//用于求子集
        for(int i=1;i<n;++i){//初始化要求子集的集合
            temp[i-1] = i;
        }
        dfs(temp,0,vis,subSet);//求子集
        subSet.sort((o1,o2) -> {//按照自定义的排序方式进行排序，返回负数表示当前两者关系是有序（升序）的，无需做调整
            if(o1.size()==o2.size()){
                for(int i=0;i<o1.size();++i){
                    if(o1.get(i)!=o2.get(i)){
                        return o1.get(i)<=o2.get(i)?-1:1;
                    }
                }
                return 0;
            }else{
                return o1.size()<=o2.size()?-1:1;
            }
        });
        for(int i=0;i<subSet.size();++i){//建立集合和下标的映射
            //System.out.println(subSet.get(i));
            map.put(subSet.get(i),i);
        }

        for(int i=1;i<n;++i){//初始化dp数组
            for(int j=0;j<n;++j){
                if(j==0){
                    dp[i][j] = g[i][0];//节点i经过空集到节点0，距离就是它们之间的距离
                }else{
                    //节点i经过集合中的单个元素（不能是当前节点）到节点0，距离就是当前节点到集合中的那个节点的距离再加上集合中的那个节点到节点0的距离
                    if(!subSet.get(j).contains(i) && g[i][subSet.get(j).get(0)]!=inf && g[subSet.get(j).get(0)][0]!=inf) dp[i][j] = g[i][subSet.get(j).get(0)] + g[subSet.get(j).get(0)][0];
                    else dp[i][j] = inf;//如果其中任意两节点无法到达，设置为正无穷，方便之后淘汰经过当前元素的转移方案。
                }
            }
        }
        for(int m = 2;m<n;++m){//由于更长的子集需要所有之前更短的子集转移出来的结果，所以每轮转移要保证子集长度都相同
            int begin = 1;//记录dp的列应该从哪继续转移
            for(int j=1;j<m;++j){//每一轮的子集数量和组合数有关
                begin += C(n-1,j);
            }
            int end = begin+C(n-1,m);//记录dp的列这一轮应该转移到哪里
            for(int i=n-1;i>=1;--i){//dp的行从下往上转移，从上往下也行，但是不转移节点0。
                //System.out.println(begin+" "+end);
                for(int j=begin;j<end;++j) {//dp的列
                    if (!subSet.get(j).contains(i)) {//通过的子集中不能包含当前节点
                        int min = inf;//用于找所有方案中最短的那个
                        for (int k = 0; k < subSet.get(j).size(); ++k) {//依次试遍所有子问题
                            int selectedNum = subSet.get(j).get(k);//被选中独立出来的元素
                            int pos = 0;//把一个元素独立出来后，剩下的子集对应的dp列的访问下标
                            for (int l = 0; l < subSet.size(); ++l) {//找独立出元素后的子集对应的dp列的访问下标
                                //先筛一波长度差一并且其中不含独立出来的元素的子集
                                if (subSet.get(l).size() + 1 == subSet.get(j).size() && !subSet.get(l).contains(selectedNum)) {
                                    boolean found = true;//是否找到
                                    for(int o=0;o<subSet.get(j).size();++o){//检查初筛出来的子集是否包含刚才独立出元素后的子集的所有剩余元素
                                        if(subSet.get(j).get(o)==selectedNum) continue;//不看独立出来的元素
                                        else{
                                            if(!subSet.get(l).contains(subSet.get(j).get(o))){//如果有一个元素不包含，那当前这个子集就不是刚才独立出元素后变成的子集，要继续找
                                                found = false;
                                                break;
                                            }
                                        }
                                    }
                                    if(found){//找到了就通过之前做的映射拿到其访问下标
                                        pos = map.get(subSet.get(l));
                                        break;
                                    }
                                }
                            }
                            //System.out.println(i+" "+j+" "+selectedNum+" "+pos);
                            if (min > dp[selectedNum][pos] + g[i][selectedNum])//尝试更新min的值
                                min = dp[selectedNum][pos] + g[i][selectedNum];
                        }
                        dp[i][j] = min;//进行状态转移，由于初始化的时候不可达设置成了正无穷，所以可以保证不会从非法的地方转移过来
                    }
                }
            }
        }
        //为得到最终的答案进行状态转移
        int min = inf;
        for(int k=0;k<subSet.get((1<<(n-1))-1).size();++k){//遍历除了节点0的全集的子问题
            int selectedNum = subSet.get((1<<(n-1))-1).get(k);//独立出一个元素来
            int pos = 0;
            for(int l=0;l<subSet.size();++l){//找独立出元素后的集合下标
                //由于全集的答案是从上一轮的子集中转移过来的，而上一轮的子集比全集只少1，因此如果一个子集不包含从全集中独立出来的那个元素，那么这个子集就是独立出元素后的全集，易证
                if(subSet.get(l).size()+1==subSet.get((1<<(n-1))-1).size()&&!subSet.get(l).contains(selectedNum)){
                    pos = map.get(subSet.get(l));//拿到下标，不过写注释写到这我发现为啥不直接用l当下标。。。
                    //System.out.println(selectedNum+" "+pos+" "+subSet.get(l));
                }
            }
            //System.out.println(dp[selectedNum][pos]+" "+g[0][selectedNum]);
            //尝试更新min
            if(min > dp[selectedNum][pos]+g[0][selectedNum]) min = dp[selectedNum][pos]+g[0][selectedNum];
        }
        dp[0][(1<<(n-1))-1] = min;//状态转移得到最后答案
        //输出dp数组
        for(int i=0;i<(1<<(n-1));++i){
            System.out.print(subSet.get(i)+" ");
        }
        System.out.println();
        for(int i=0;i<n;++i){
            System.out.print(i+" ");
            for(int j=0;j<(1<<(n-1));++j){
                System.out.print(dp[i][j]+" ");
            }
            System.out.println();
        }
        //输出结论
        System.out.println("从0号节点出发经过所有节点返回的最小距离是："+dp[0][(1<<(n-1))-1]);

    }
    public static void dfs(int[] num,int a,boolean[] vis,ArrayList<ArrayList<Integer>> subSet){//求子集
        for(int i=a;i<vis.length;++i){//回溯算法求子集
            if(!vis[i]){
                vis[i] = true;
                dfs(num,i+1,vis,subSet);
                vis[i] = false;
            }
        }
        ArrayList<Integer> list = new ArrayList<>();
        for(int i=0;i<vis.length;++i){//记录当前求得的子集
            if(vis[i]){
                list.add(num[i]);
            }
        }
        subSet.add(list);//加入子集的集合
    }
    public static int C(int down,int up){//求组合数
        int ans = 1;
        for(int i=0;i<up;++i){
            ans*=down-i;
        }
        for(int i=1;i<=up;++i){
            ans/=i;
        }
        return ans;
    }
}
```

# 最短路径算法

## Dijkstra算法

### 问题描述

- 单源无负权最短路径，即一个点到其他点的最短路径，所有的边不允许出现负权值。

### 算法思想

- 每次外层循环确定一个节点到源点的最短距离

- 每次内层循环通过确定最短路径的点对与其相邻的点到源点的距离进行“松弛”操作以确保下一次外层循环能找到正确的距离源点最短的点。
- 贪心的思想，每次找最短路径的节点来对别的节点做“松弛”。

### 算法过程

- 假设节点数量为n，那么首先我们需要一个**n x n的矩阵g来存放图，或者用邻接表、链式前向星存**，然后我们需要一个**长度为n的boolean数组vis来标识节点到源点的最短距离是否已经被确定**，然后**需要一个长度为n的整型数组dis来记录源点到其他点的最短距离**，如果要**对时间复杂度进行优化的话，我们还需要维护一个优先队列（可以用堆实现）q来表示节点到源点的距离**。

- 初始化g，除了自己到自己的距离为0，其他初始化为inf，然后根据输入的边进行调整；

  初始化vis，源点src到自己的最短距离已经确认，所以让src为true，其余为false；

  初始化dis，就是src到各点的距离，从g中拿就行。

- 然后外层循环n-1次，因为有n-1个节点到src的最短路径需要确认，外层循环每循环一次就确定一个节点到src的最短路径。

  内层先用一个循环来找到当前与src直接或间接相连的节点到src的最短路径（如果使用优先队列进行优化的话就直接取优先队列的头元素即可，不用循环了就），找到之后对应的那个节点的最短路径就被固定了，因为别的路径都必须经过本轮遍历到的其他路径，而由于没有负权值，别的路径第一段就比最短的路径大了，再加上别的段就更不用说了，因此不存在从别的路径到这轮选中的节点距离更短，所以可以确定本轮选中的节点的最短路径。

  确定后更新vis，然后再搞一层循环来更新与本轮选中的节点相邻的节点到src的最短距离，这一操作我们称为通过本轮选中的节点来对src到别的节点的距离进行“松弛”（优先队列的话要对优先队列进行更新操作），这一操作是为了在下一轮的循环中能正确找到距离src最短的节点。最后外层循环完毕，所有节点到src的最短距离也被确定下来了。

### 代码示例

```java
import java.util.Scanner;

/**
 * @author Konjacer
 * @create 2022-10-28 19:47
 */
public class Dijkstra {
    public static void main(String[] args) {
        int inf = 0x3f3f3f3f;//正无穷
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入节点数量：");
        int n = scanner.nextInt();
        int[][] g = new int[n][n];//邻接矩阵存图
        for(int i=0;i<n;++i){//初始化邻接矩阵
            for(int j=0;j<n;++j){
                if(i==j) g[i][j]=0;//自己到自己的距离为0
                else g[i][j] = inf;
            }
        }
        System.out.println("请输入边的数量：");
        int e = scanner.nextInt();
        for(int i=0;i<e;++i){
            System.out.println("请输入第"+(i+1 )+"条边的起点、终点、权值：");
            int begin = scanner.nextInt();
            int end = scanner.nextInt();
            int value = scanner.nextInt();
            //这里是无向图的写法，为了方便输入，需要有向图再改
            g[begin][end] = value;
            g[end][begin] = value;
        }
        System.out.println("请输入想要看其到别的节点最短路径的节点：");
        int src = scanner.nextInt();
        boolean[] vis = new boolean[n];//标识已经确定最小距离的节点
        for(int i=0;i<n;++i) vis[i] = false;
        vis[src] = true;//源节点到自己的距离一直是0，所以是已经确定最小距离的节点
        int[] dis = new int[n];//源节点到对应节点的最小距离，比如dis[i]就是源节点到节点i的最小距离，动态更新，更新到最后就是答案。
        for(int i=0;i<n;++i){//初始化源节点到对应节点的最小距离为源节点到对应节点的距离，然后之后再动态更新。
            dis[i] = g[src][i];
        }
        for(int i=1;i<n;++i){//还需要找到n-1个节点的最短路径，所以要循环n-1次
            int min = inf;
            int pos = 0;//每轮找到的节点下标，该节点应该是本轮中距离src最短的节点
            for(int j=0;j<n;++j){//找本轮中距离src最短的节点，由于其到src的距离是本轮最短，所以不存在另外一条路径使得被选中的节点和src的距离能更短，因为如果存在这样一条路径，那么一定会从本轮中的其他路径经过，而本轮中的其他路径在不考虑负权值的情况下一定比本轮中的最短路径要长，所以可以放心将本轮最短路径作为选中节点的最短路径。
                if(!vis[j]&&min>dis[j]){//只从还没有确定最短路径的节点中找最小值，记录下最小值和节点下标
                    min = dis[j];
                    pos = j;
                }
            }
            vis[pos] = true;//标记这一轮选中的节点已经确定了最短路径
            for(int j=0;j<n;++j){//以这一轮选中的节点作为桥梁来更新与其相邻的节点到src的最短距离
                if(g[pos][j]<inf&&j!=src){//找与这一轮选中的节点相邻的节点，不能是src
                    if(dis[j]>dis[pos]+g[pos][j]){//如果以这一轮选中的节点为桥梁能使与其相邻的节点到src的距离更短，那就更新，相当于src和那个节点间接建立起了联系，下一轮就可以通过找最小值来固定和src直接或间接有联系的点的最短距离了。
                        dis[j] = dis[pos]+g[pos][j];
                    }
                }
            }
        }
        System.out.println("节点"+src+"到各点的最短路径分别为：");
        for(int i=0;i<n;++i){
            System.out.print(dis[i]+" ");
        }
    }
}
```

# 最小生成树算法

## Prim算法

### 算法描述

- 找出一个最短路径使得图中各节点连通，对于有n个节点的图来说，最小生成树需要用n-1条边来构建，该算法在稠密图中的效率较高。
- 适用于有负权边的情况。

### 算法思想

- 每次循环选择距离已经被选中的节点组成的集合最短的节点加入集合中，然后将与其连接的路径加入最小生成树中，更新与本轮被选中的节点相邻的节点到已经被选中的节点的集合的距离，以确保下一次循环可以找到正确的需要加入集合的节点，当所有节点都被加入到集合后，最小生成树就建立了。
- 实际上就是贪心的思想，每次找到集合最短的节点加入集合。

### 算法流程

- 基本上和Dijkstra算法差不多，虽然数据结构和Dijkstra的一样，但是Prim的数据结构的含义和Dijkstra中的数据结构的含义有点出入。

- 假设节点数量为n，那么首先我们需要一个**n x n的矩阵g来存放图，或者用邻接表、链式前向星存**，然后我们需要一个**长度为n的boolean数组vis来表示已经被最小生成树选中的节点**，然后**需要一个长度为n的整型数组dis来记录已经被选中的节点的集合到其他未被选中的点的最短距离**，如果要**对时间复杂度进行优化的话，我们还需要维护一个优先队列（可以用堆实现）q来表示节点到已经被选中的节点的集合的距离**，还需要一个**变量sum来记录最小生成树的值**。

- 初始化g，除了自己到自己的距离为0，其他初始化为inf，然后根据输入的边进行调整；

  初始化vis，一开始被选中的节点集合中的节点只有源点src，所以让src为true，其余为false；

  初始化dis，就是被选中的节点的集合到各点的距离，一开始就是src到各点的距离，从g中拿就行。

- 然后外层循环n-1次，因为有n-1条边需要被选择，外层循环每循环一次就选择一条边放到最小生成树中，同时也是选中一个节点放入已经被选中的节点的集合中。

  内层先用一个循环来找到当前与被选中的节点的集合相连的节点到集合的最短路径（如果使用优先队列进行优化的话就直接取优先队列的头元素即可，不用循环了就），找到之后需要将该点加入集合中，并将该边加入最小生成树中，更新vis和sum，然后再搞一层循环来更新未被选中的节点与新集合的距离，实际上出现变动的只有与这一轮选中的节点相邻的节点，所以更新这一轮选中的节点的相邻节点到新集合的距离就好了，这一步是为了确保下一轮循环中可以正确的选中到集合的最短路径对应的节点。最后外层循环完毕，最小生成树也被确定下来了。

### 代码示例

```java
import java.util.Scanner;

/**
 * @author Konjacer
 * @create 2022-10-29 14:25
 */
public class Prim {
    public static void main(String[] args) {
        int inf = 0x3f3f3f3f;//正无穷
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入节点数量：");
        int n = scanner.nextInt();
        int[][] g = new int[n][n];//邻接矩阵存图
        for(int i=0;i<n;++i){//初始化邻接矩阵
            for(int j=0;j<n;++j){
                if(i==j) g[i][j]=0;//自己到自己的距离为0
                else g[i][j] = inf;
            }
        }
        System.out.println("请输入边的数量：");
        int e = scanner.nextInt();
        for(int i=0;i<e;++i){
            System.out.println("请输入第"+(i+1 )+"条边的起点、终点、权值：");
            int begin = scanner.nextInt();
            int end = scanner.nextInt();
            int value = scanner.nextInt();
            //这里是无向图的写法，为了方便输入，需要有向图再改
            g[begin][end] = value;
            g[end][begin] = value;
        }
        System.out.println("请输入起始节点：");
        int src = scanner.nextInt();
        boolean[] vis = new boolean[n];//标识已经确定最小距离的节点，同时也是算法工程中被最小生成树选中的节点集合
        for(int i=0;i<n;++i) vis[i] = false;
        vis[src] = true;//源节点到自己的距离一直是0，所以是已经确定最小距离的节点
        int[] dis = new int[n];//被最小生成树选中的节点集合到与其相邻节点的距离，比如dis[i]就是被最小生成树选中的节点集合到节点i的距离，动态更新。
        for(int i=0;i<n;++i){//初始化源节点（此时最小生成树选中的节点只有源节点）到所有节点的距离为源节点到对应节点的距离，然后之后再动态更新。
            dis[i] = g[src][i];
        }
        int sum = 0;//最小生成树的大小
        for(int i=1;i<n;++i){//构建最小生成树一共需要n-1条边，所以要循环n-1遍，每一轮循环选中一条边
            int min = inf;
            int pos = 0;//到已经选中的节点集合距离最短的那个节点下标
            for(int j=0;j<n;++j){//找距离已经选中的节点集合距离最短的节点
                if(!vis[j]&&min>dis[j]){//从已经选中的节点集合之外找和已经选中的节点的集合相邻的节点中距离最短的那个节点
                    min = dis[j];//记录最小值
                    pos = j;//记录下标
                }
            }
            vis[pos] = true;//将这轮被选中的节点加入到最小生成树选中节点的集合中
            sum+=dis[pos];//将本轮选中的边加入到最小生成树中
            for(int j=0;j<n;++j){//由于本轮选中的节点加入了最小生成树，所以与本轮选中节点相邻的节点与最小生成树选中的节点集合也是相邻的，所以动态更新被最小生成树选中的节点集合到其他节点的距离
                if(g[pos][j]<dis[j]&&!vis[j]){//更新与这一轮选中的节点相邻的没被最小生成树选中的节点到被最小生成树选中的节点集合的距离，方便下一轮筛选最小值加入最小生成树
                    dis[j] = g[pos][j];
                }
            }
        }
        System.out.println("最小生成树的大小为：");
        System.out.println(sum);
    }
}
```

## Kruskal算法

### 算法描述

- 找出一个最短路径使得图中各节点连通，对于有n个节点的图来说，最小生成树需要用n-1条边来构建，该算法在稀疏图中的效率较高。
- 适用于有负权边的情况。

### 算法思想

- **以贪心思想和并查集数据结构为基础**，首先将**所有边按照升序排序**，然后遍历所有边，**每当遍历到一个边就判断这条边是否能作为连接两个端点的最短边**（由于边是升序排列，所以两个端点第一次遇到的可以连接它俩的边就一定是最优的，后面能连接它俩的边都不能选了因为不是最优的。）。**如果能，那就将端点合并到已经被最小生成树选中的节点中，并将该边加入到最小生成树中，并且让选中的边数++；如果不能，就继续遍历，直到选中n-1条边后，最小生成树就形成了，退出循环即可**。

### 算法流程

- 上面描述的差不多了。。。。。。

### 代码示例

```java
import java.util.Arrays;
import java.util.Scanner;

/**
 * @author Konjacer
 * @create 2022-11-03 16:49
 */
public class Kruskal {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入点数：");
        int n = scanner.nextInt();
        int[] f = new int[n];//并查集数组,f[i]=j说明i的父亲节点是j
        for(int i=0;i<n;++i){//初始化每个节点都是独立的，即他们的father都是自己
            f[i] = i;
        }
        System.out.println("请输入边数：");
        int e = scanner.nextInt();
        Edge[] edges = new Edge[e];
        for(int i=0;i<e;++i){
            System.out.println("请输入第"+(i+1)+"条边的两个节点和权值：");
            Edge edge = new Edge();
            edge.from = scanner.nextInt();
            edge.to = scanner.nextInt();
            edge.value = scanner.nextInt();
            edges[i] = edge;
        }
        Arrays.sort(edges,(e1,e2) -> e1.value<=e2.value?-1:1);//按照边从小到大排序，返回负数不换位置，即顺序正确
        int sum = 0;//最小生成树的大小
        for(int i=0;i<e&&n>1;++i){//n可以维护已经选了多少边，当n减到1的时候说明已经选了n-1条边了，最小生成树已经生成，可以走了
            if(merge(f,edges[i].from,edges[i].to)){//如果能合并说明可以选这条边作为最小代价连接这条边对应的两个节点
                n--;
                sum+=edges[i].value;
                System.out.println("选择两个点和权值分别为"+edges[i].from+" "+edges[i].to+" "+edges[i].value+"的边");
            }
        }
        System.out.println("最小生成树的大小为："+sum);
    }
    static class Edge{//边
        public int from;
        public int to;
        public int value;
    }
    public static int find(int[] f,int v){//找一个元素的根节点
        return f[v]==v?v:(f[v] = find(f,f[v]));//如果该点独立，直接返回;如果该点不独立,往后找根节点，顺便进行路径压缩
    }
    public static boolean merge(int[] f,int u,int v){//合并操作，其中可以做优化：直接把两者的根节点合并
        return (u = find(f,u))==(v = find(f,v))?false:(f[v]=u)==u;//先找到各自的根，然后比较，如果相同说明已经合并无需再合并，返回false；如果不相同就合并，返回true
    }
}
```

# Huffman编码算法

## 算法描述

- **哈夫曼（Huffman）编码算法**是基于二叉树构建编码压缩结构的，它是数据压缩中经典的一种算法。算法根据文本字符出现的频率，重新对字符进行编码。因为为了缩短编码的长度，我们自然**希望频率越高的词，编码越短，这样最终才能最大化压缩存储文本数据的空间**。

- 假设现在我们要对下面这句歌词“we will we will r u”进行压缩。我们可以想象，如果是使用ASCII码对这句话编码结果则为：119 101 32 119 105 108 108 32 119 101 32 119 105 108 108 32 114 32 117（十进制表示）。我们可以看出需要19个字节，也就是至少需要152位的内存空间去存储这些数据。

- 很显然直接ASCII码编码是很浪费空间的，Unicode就更不用说了，下面我们先来统计一下这句话中每个字符出现的频率。如下表，按频率高低已排序：

  ![image-20221104174352182](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104174352182.png)

## 算法思想

- 让**被编码的字符全部出现在编码树的叶节点上，这样可以做到没有一个字符的编码是另外一个字符编码的前缀，这样可以防止解码的时候出现歧义**。
- **出现频率越低的字符，在树上的深度就越深，最后对于这个字符的编码就越长，最后总的编码就越短，这其中也有贪心的思想**。
- 建好哈夫曼树后，**让连接左孩子的边的编码设置为0，让连接右孩子的边的编码设置为1，从根节点开始经过若干边后找到一个字符，那个字符的编码就是经过的所有边的编码的集合**。

## 算法流程

### 初始化优先队列

- 那么我们**按字符出现频率的高低将其放入一个优先队列中，从左到右依次为频率逐渐增加**：

  ![image-20221104175410606](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104175410606.png)

- 下面我们需要将这个队列转换成哈夫曼二叉树，**哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的**。并且**哈夫曼二叉树始终保证权重越大的字符出现在越高的地方**。

### 第一步合并

- 首先我们从左到右进行合并，依次构建二叉树。**第一步取前两个字符u和r来构造初始二叉树，第一个字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新空元素，并且两者权重相加作为新元素的权重**。

  ![image-20221104180042562](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180042562.png)

- 同理，**由于合并之后优先队列仍有序，所以新元素可以和字符i再合并**，如下：

  ![image-20221104180101221](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180101221.png)

### 重新调整队列

- 上图**新元素权重相加后结果是变大了，需要对权重进行重新排序，也就是调整优先队列**：

  ![image-20221104180152267](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180152267.png)

- 然后再**依次从左到右合并，每合并一次则进行一次队列重新排序调整**。如下：

  ![image-20221104180234707](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180234707.png)

- **经过多步操作之后，优先队列中只剩一个元素，让队列中唯一的元素出队得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树**：

  ![image-20221104180311593](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180311593.png)

### 哈夫曼编码

- 有了上面带权重的二叉树之后，我们就可以进行编码了。我们**把二叉树分支中左边的支路编码为0，右边分支表示为1**，如下图：

  ![image-20221104180540694](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180540694.png)

- 这样**依次遍历这颗二叉树就可以获取得到所有字符的编码了**。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。**经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。**

- 最终我们可以得到下面这张编码表：

  ![image-20221104180640922](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180640922.png)

### 字符串编码

- 有了上面的编码表之后，”we will we will r u”这句重新进行编码就可以得到很大的压缩，编码表示为：01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100。这样最终我们只需50位内存，比原ASCII码表示节约了2/3空间，效果还是很理想的。当然**现实中不是简单这样表示的，还需要考虑很多问题**。

### 补充

- 我们需要弄明白哈夫曼二叉树概念，**它是带权路径达到最小的二叉树，也叫最优二叉树**。它**不一定是完全二叉树，也不一定是平衡二叉树，它们描述的完全不是一件事情，完全没有概念上的重叠关系**。

## 代码示例

```java
import java.util.*;

/**
 * @author Konjacer
 * @create 2022-11-03 18:13
 */
public class Huffman {
    static class Node{
        public int value;
        public Node left;
        public Node right;
        public Node father;
        public char c;
    }
    public static void main(String[] args) {
        LinkedList<Node> queue = new LinkedList<>();//用队列+排序模拟优先队列
        ArrayList<Character> charList = new ArrayList<>();//存放所有字符
        Node tree;//Huffman树
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入字符种数：");
        int n = scanner.nextInt();
        for(int i=1;i<=n;++i){
            System.out.println("请输入第"+i+"种字符以及其出现的频数：");
            Node node = new Node();
            node.c = scanner.next().charAt(0);
            charList.add(node.c);
            node.value = scanner.nextInt();
            queue.add(node);
        }
        Collections.sort(queue,(n1,n2)->n1.value<=n2.value?-1:1);//按照频数排序，返回-1说明顺序正好不用调整
        for(int i=0;i<queue.size();++i) System.out.print(queue.get(i).c);
        System.out.println();
        while (queue.size()>1){//构建哈夫曼树，频率越低的元素越再下层，对应的编码越长，最后生成的总编码就越短，每次构建都会使队列长度减一，当队列长度为1时，唯一的那个元素就是哈夫曼树
            Node temp1 = queue.poll();//取出队首第一个元素
            Node temp2 = queue.poll();//取出队首第二个元素
            //System.out.println(temp1.c+" "+temp2.c);
            Node temp = new Node();//准备进行元素合并
            temp.value = temp1.value+temp2.value;//合并权值到新的父节点
            //建立三个节点之间的关系
            temp.left = temp1;
            temp.right = temp2;
            temp1.father = temp;
            temp2.father = temp;
            queue.push(temp);//把合并后的节点加入到优先队列前面
            Collections.sort(queue,(n1,n2)->n1.value<=n2.value?-1:1);//重新排序
        }
        tree = queue.poll();//取出哈夫曼树
        for(int i=0;i<charList.size();++i){//找每个输入的字符对应的哈夫曼编码
            ArrayList<Character> code = new ArrayList<>();
            System.out.print(charList.get(i)+"的哈夫曼编码为：");
            enCode(tree,charList.get(i),code);
            System.out.println();
        }
    }
    public static void enCode(Node tree,char c,ArrayList<Character> now){//递归找字符对应的编码，第一个参数是哈夫曼树，第二个参数是字符，第三个参数是当前的编码
        if(tree==null){
            return;
        }
        //System.out.println(tree.value);
        if(tree.c==c){//找到目标了就输出
            for(char a:now){
                System.out.print(a);
            }
            return;
        }
        //回溯算法遍历左右子树，左0右1
        now.add('0');
        enCode(tree.left,c,now);
        now.remove(now.size()-1);
        now.add('1');
        enCode(tree.right,c,now);
        now.remove(now.size()-1);
    }
}
```

## 利用霍夫曼编码压缩文件

- 如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件。
- **赫夫曼编码是按字节来处理的**，因此**可以处理所有的文件(二进制文件、文本文件等)**。
- 如果一个文件中的内容，**重复的数据不多，压缩效果也不会很明显**。



## 利用霍夫曼编码解压文件



# 表达式算法

- 这个板块儿**主要是讲前缀、中缀、后缀表达式之间的转换和计算的**。

## 中缀表达式算法

### 基本介绍

- 中缀表达式就是我们平时看到的算式，例如：a+b*c，我们想要实现的就是让计算机计算中缀表达式得到正确的结果。
- 除了中缀表达式外，还有**运算符在操作数之前的前缀表达式（波兰表达式）和运算符在操作数之后的后缀表达式（逆波兰表达式）**，这两种表达式会在它们的章节细讲。

### 使用栈完成中缀表达式计算的思路

![image-20221106205752521](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106205752521.png)

- 有一个小难点就是优先级的问题，**当一个优先级小的符号想要入栈的时候要把之前的运算做了之后再入栈**。

### 代码示例

```java
```

## 逆波兰表达式算法

### 基本介绍

- **逆波兰表达式就是后缀表达式**，就是操作符在操作数的后面，至于怎么从中缀表达式转换为后缀表达式下面给出了详细的转换方式。
- 虽然对于人来说计算逆波兰表达式比较困难，但是**对于计算机来说计算逆波兰表达式是非常容易的**，计算机对逆波兰表达式进行计算用到了栈这一数据结构。

### 算法思想

- 遍历逆波兰表达式，如果**碰到数字就压入栈中，如果碰到操作符，就从栈顶出栈两个元素，对那两个元素进行对应的运算之后，将运算的结果再压入栈中**。

### 代码示例

```java
```



## 中缀表达式转换为后缀表达式

### 基本介绍

- 从上面可以看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此**在开发中，我们需要将中缀表达式转成后缀表达式**。
- 中缀表达式转换为后缀表达式的步骤比较繁琐，也**需要借助栈来实现，不过需要两个栈，其中一个存操作数，另外一个存操作符**。

### 算法步骤

1. 初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2；
2. 从左至右扫描中缀表达式；
3. 遇到操作数时，将其压 s2；
4. 遇到运算符时，比较其与 s1 栈顶运算符的优先级：
   1. 如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
   2. 否则，若优先级比栈顶运算符的高，也将运算符压入 s1；
   3. 否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4.1)与 s1 中新的栈顶运算符相比较；
5. 遇到括号时：
      1. 如果是左括号“(”，则直接压入 s1
      2. 如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃
6. 重复步骤 2 至 5，直到表达式的最右边
7. 将 s1 中剩余的运算符依次弹出并压入 s2
8. 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

- 总结：其实就是**根据运算的优先级来将每一部分的操作符放到俩操作数的后面**，比如A\*(B+C)+D，优先级最高的是小括号，所以先转换成A\*(BC+)+D，然后乘法优先级比较高，把乘号放到俩操作数的后面，即(ABC+\*)+D，最后只剩下加法运算了，把加号放到俩操作数后面，即ABC+\*D+，这样就得到后缀表达式了，从过程中可以看到，**每次都是选优先级最高的一部分，将其操作符放到它对应的俩操作数的后面**。

### 转换举例

- 将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下：

  ![image-20221106232317323](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106232317323.png)

- 因此结果为 :"1 2 3 + 4 × + 5 –"

### 代码示例

```java

```

# KMP算法

## KMP算法介绍

- KMP 是一个**解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法**。
- Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法.
- KMP 方法算法就**利用之前判断过信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间**。
- 参考资料：https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html

## KMP算法思路分析

- 举例来说，有一个字符串 Str1 = “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 =“ABCDABD”？

  1. 首先，用 Str1 的第一个字符和 Str2 的第一个字符去比较，不符合，关键词向后移动一位：

     ![image-20221114094748049](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094748049.png)

  2. 重复第一步，还是不符合，再后移：

     ![image-20221114094819926](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094819926.png)

  3. 一直重复，直到 Str1 有一个字符与 Str2 的第一个字符符合为止：

     ![image-20221114094849647](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094849647.png)

  4. 接着比较字符串和搜索词的下一个字符，还是符合：

     ![image-20221114094908612](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094908612.png)

  5. 遇到 Str1 有一个字符与 Str2 对应的字符不符合：

     ![image-20221114094927607](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094927607.png)

  6. 这时候，想到的是继续遍历 Str1 的下一个字符，重复第 1 步，如下图所示。(其实是很不明智的，因为此时 BCD 已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP 算法的想法是，**设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率**。)

     ![image-20221114095220382](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095220382.png)

  7. 怎么做到把刚刚重复的步骤省略掉？可以对 Str2 计算出一张《部分匹配表》，这张表的产生在后面介绍：

     ![image-20221114095249922](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095249922.png)

  8. 已知空格与 D 不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符 B 对应的”部分匹配值”为 2，因此按照下面的公式算出向后移动的位数：**移动位数 = 已匹配的字符数 - 对应的部分匹配值**，因为 6 - 2 等于 4，所以将搜索词向后移动 4 位：

     ![image-20221114095501622](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095501622.png)

  9. 因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为 2（”AB”），对应的”部分匹配值”为 0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移 2 位：

     ![image-20221114095519913](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095519913.png)

  10. 因为空格与 A 不匹配，str1的指针继续后移一位：

      ![image-20221114100150053](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114100150053.png)

  11. 逐位比较，直到发现 C 与 D 不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动 4 位：

      ![image-20221114095539523](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095539523.png)

  12. 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了：

      ![image-20221114095654873](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095654873.png)

## 部分匹配表（next）是如何产生的？

- 先介绍介绍前缀和后缀是什么：

  ![image-20221114100319241](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114100319241.png)

- 实际上**部分匹配值就是从数组头到当前位置这个左闭右开区间（我喜欢这样表示）所表示的字符串的最长公共前后缀，当比较到当前位置产生失配之后，当前位置的指针可以根据当前位置的部分匹配值来进行相应的移动，从而节省开销**。

  ![image-20221114100955361](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114100955361.png)

## 代码示例

```java
```

# 弗洛伊德(Floyd)算法

## 算法介绍

- 和 Dijkstra 算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名
- 弗洛伊德算法(Floyd)**计算图中各个顶点之间的最短路径**
- 迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。
- 弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。
- 也就是说**弗洛伊德算法是多源最短路算法**。

## 算法思路分析

- 其实比较简单，就是**搞三层循环，其中两层循环遍历任意两个节点，剩下的一层循环遍历除了那俩节点外的节点作为那两个节点之间的中转站尝试将那两个节点之间的距离进行”松弛“**，三层循环过后得到的二维数据的结果就是所有节点到其他节点的最短路径。

## 代码示例

```java

```

# 弗洛伊德(Floyd)判圈算法



# Boyer-Moore投票算法

## 算法介绍

- 这算法也叫摩尔投票算法，是从一个无序的投票集合中找出最多的那个票。

- 具体见下题：

  ![image-20221211114712980](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221211114712980.png)

## 算法思想

- 其实就是一个**同类相容，异类相杀**的场景，可以想象这样一个场景，有一个山顶有很多军队想要占领，如果第一个人到达了山顶，由于此时山顶没有军队占领，所以那个人就把自己所在的军队的旗帜插到山顶了以表示现在这个山顶归那个军队所有，然后山顶继续上人，如果下一个人是和自己一个军队的，那么他们就可以相容，山顶还是那个军队的；如果下一个人不是和自己一个军队的，那么目前山顶上的人会出来一个人和那个异类拼杀直至同归于尽，直到山顶上没人了，下一个到达山顶的人可以把自己所在军队的旗帜替换掉之前的旗帜，山顶的归属权发生变化，就这样一致进行下去，最后旗帜在山顶上的军队获得那个山顶的所有权。
- 我们需要一个**变量winner来标识目前山顶归谁所有**，然后需要一个**变量count来标识目前山顶归属军队在山顶的人数，如果新来了同类就++，如果新来了异类就--，如果count等于0了，说明山顶没人了，那么山顶就会在下一个人到来的时候更换归属者**，最后winner的值就是最后山顶的归属者，也就是票数最多的候选人。

## 算法证明



## 算法效率

- 摩尔投票算法有很好的时空复杂度，它只需遍历一次投票集合，所以**时间复杂度是O(n)**的，它只需要额外开两个int型变量，所以**空间复杂度是O(1)**的。

## 代码示例

- 算法介绍中的那个题的代码：

  ```java
  class Solution {
      public int majorityElement(int[] nums) {
          int winner = 0;
          int count = 0;
          for(int i=0;i<nums.length;++i){
              if(count==0) winner = nums[i];
              if(nums[i]==winner) count++;
              else count--;
          }
          return winner;
      }
  }
  ```

# 查找算法

- 就是从一组数据中找出给定的数据。

## 线性查找算法

### 基本介绍

- 就是遍历一遍数据，找到了对应元素就记下来，没啥好介绍的。

### 算法思想

- 就是遍历一遍数据，找到了对应元素就记下来，没啥思想。

### 代码示例

```java
import java.util.Scanner;

/**
 * @author Konjacer
 * @create 2022-11-11 15:07
 */
public class LinearSearch {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入集合中的数据个数：");
        int n = scanner.nextInt();
        int[] num = new int[n];
        System.out.println("请依次输入集合中的数据，数据之间用空格分隔：");
        for(int i=0;i<n;++i){
            num[i] = scanner.nextInt();
        }
        System.out.println("请输入要查找的数据：");
        int target = scanner.nextInt();

        for(int i=0;i<n;++i){
            if(num[i]==target){
                System.out.println(target+"第一次在集合中出现位置的下标是："+i);
                return;
            }
        }
        System.out.println(target+"在集合中不存在");
    }
}
```



## 二分(折半)查找算法

### 基本介绍

- 使用**二分查找的前提是数据有序**，然后**每次找数据中间的数，然后根据那个数和要找的数之间的关系来决定继续向左还是向右进行查找**。

### 算法思路

![image-20221107090928743](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107090928743.png)

### 对于中间值下标计算的优化

- 上面计算中间值的下标mid用的是(left+right)/2这个表达式，然而这个表达式实际上不够安全，**如果left和right是两个非常大的数，那么left+right这一操作可能造成数值溢出**。
- 鉴于上面的问题，我们可以**将计算中间值下标mid用到的表达式换成left+(right-left)/2**，这样由于之前的两个大数的加法转换成了两个大数的减法，所以杜绝了正常数据下数值溢出的问题。

### 代码示例

```java
import java.util.Scanner;

/**
 * @author Konjacer
 * @create 2022-11-11 15:13
 */
public class BinarySearch {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入集合中的数据个数：");
        int n = scanner.nextInt();
        int[] num = new int[n];
        System.out.println("请依次输入集合中的数据，数据有序并且数据之间用空格分隔：");//二分查找的数组必须有序
        for(int i=0;i<n;++i){
            num[i] = scanner.nextInt();
        }
        System.out.println("请输入要查找的数据：");
        int target = scanner.nextInt();

        int left = 0;//左边界
        int right = n-1;//右边界
        while(left<=right){//这里的等号是必要的，因为按照下面的写法，当两个下标重合的时候，重合处的元素还没有被判断过
            int mid = left+(right-left)/2;//这样写是为了在数据很大的情况下不至于造成算数溢出
            if(target==num[mid]){//找到了
                System.out.println(target+"在集合中出现位置对应的下标是："+mid);
                return;
            }else if(target<num[mid]){//target比num[mid]小说明target在前半段
                right = mid-1;//向前折半，注意这里由于是mid-1，所以下一轮的right是还没有被查过的，此时如果下一轮left和right重合了，还要再走一轮查重合的那个元素，所以在循环中的那个等号是必要的
            }else if(target>num[mid]){//target比num[mid]大说明target在后半段
                left = mid+1;//向后折半，注意这里由于是mid+1，所以下一轮的left是还没有被查过的，此时如果下一轮left和right重合了，还要再走一轮查重合的那个元素，所以在循环中的那个等号是必要的
            }
        }
        System.out.println(target+"在集合中不存在");
    }
}
```

## 插值查找算法

### 基本介绍

- **如果要查找的元素位于数据的头部或者尾部左右，使用二分查找的话效率会比较低**，因为每次不管数据在什么部分，对于数据的分割总是二分，这样我们就思考，**如果有一种查找方式可以在每次分割数据的时候根据要找的数据的值来自适应地向最有可能存在目标数据的区间去寻找就好了**，这就是插值查找算法的基本思路。

- 插值查找算法类似于二分查找，不同的是**插值查找每次从自适应 mid 处开始查找**。

### 算法思想

- 其思想就是**利用一个插值参数代替二分查找计算中间值表达式的1/2**，而这个插值参数是自适应的，也就是说这个插值参数揭示了要找的元素最有可能出现在哪一部分，我的数学不是很好，看着应该是利用了比例。

- 将折半查找中的求 mid 索引的公式进行修改 , low 表示左边索引 left，high 表示右边索引 right，key 就是我们想要找的数据：

  ![image-20221107092311759](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107092311759.png)

- **int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low])**这就是插值索引mid的计算方法。

### 插值查找算法举例

![image-20221107092649559](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107092649559.png)

### 插值查找注意事项

- 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快。
- 关键字分布不均匀的情况下，该方法不一定比折半查找要好。

### 代码示例

- 和二分查找差不多，只是索引mid的计算方法变了而已：

  ```java
  import java.util.Scanner;
  
  /**
   * @author Konjacer
   * @create 2022-11-11 15:39
   */
  public class InterpolationSearch {
      public static void main(String[] args) {
          Scanner scanner = new Scanner(System.in);
          System.out.println("请输入集合中的数据个数：");
          int n = scanner.nextInt();
          int[] num = new int[n];
          System.out.println("请依次输入集合中的数据，数据有序并且数据之间用空格分隔：");//插值查找的数组必须有序
          for(int i=0;i<n;++i){
              num[i] = scanner.nextInt();
          }
          System.out.println("请输入要查找的数据：");
          int target = scanner.nextInt();
  
          int left = 0;//左边界
          int right = n-1;//右边界
          while(left<=right){//这里的等号是必要的，因为按照下面的写法，当两个下标重合的时候，重合处的元素还没有被判断过
              int mid = left+(right-left)*((target-num[left])/(num[right]-num[left]));//插值看上去好像是表示某个比例，同理，这样写不至于算术溢出
              if(target==num[mid]){//找到了
                  System.out.println(target+"在集合中出现位置对应的下标是："+mid);
                  return;
              }else if(target<num[mid]){//target比num[mid]小说明target在前段
                  right = mid-1;//向前折，注意这里由于是mid-1，所以下一轮的right是还没有被查过的，此时如果下一轮left和right重合了，还要再走一轮查重合的那个元素，所以在循环中的那个等号是必要的
              }else if(target>num[mid]){//target比num[mid]大说明target在后段
                  left = mid+1;//向后折，注意这里由于是mid+1，所以下一轮的left是还没有被查过的，此时如果下一轮left和right重合了，还要再走一轮查重合的那个元素，所以在循环中的那个等号是必要的
              }
          }
          System.out.println(target+"在集合中不存在");
      }
  }
  ```

## 斐波那契(黄金分割)查找算法

### 基本介绍

- 黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是 0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不到的效果。
- 斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值0.618
- 也就是说**找目标值的时候用到的所以是利用斐波那契数列两个相邻数的比例计算出来的**。（怎么感觉这种查找这么玄学。。。）

### 算法思想

- 斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位于黄金分割点附近，即 **mid=low+F(k-1)-1（F 代表斐波那契数列）**，如下图所示：

  ![image-20221107093420069](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107093420069.png)

- 对F(k-1)-1的理解：

  1. 由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：**只要顺序表的长度为 F[k]-1，则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段，即如上图所示。从而中间位置为 mid=low+F(k-1)-1**。
  2. 类似的，每一子段也可以用相同的方式分割
  3. 但顺序表长度 n 不一定刚好等于 F[k]-1，所以**需要将原来的顺序表长度 n 增加至 F[k]-1**。这里的**k 值只要能使得 F[k]-1 恰好大于或等于 n 即可**，由以下代码得到,顺序表长度增加后，**新增的位置（从 n+1 到 F[k]-1 位置），都赋为 n 位置的值即可**。

- 

### 代码示例

```java
```

# 数据结构-树

## 二叉树

### 为什么需要树这种数据结构

- **数组存储方式**的分析：

  - **优点**：通过下标方式访问元素，速度快。对于有序数组，还可使用**二分查找提高检索速度**。

  - **缺点**：如果要检索具体某个值，或者**插入值(按一定顺序)会整体移动，效率较低**。

    ![image-20221107201028421](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107201028421.png)

- **链式存储方式**的分析：

  - **优点**：在一定程度上对数组存储方式有优化(比如：**插入**一个数值节点，只需要将插入节点，链接到链表中即可，**删除效率也很好**)。

  - **缺点**：**在进行检索时，效率仍然较低**，比如(检索某个值，需要从头节点开始遍历)

    ![image-20221107201236741](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107201236741.png)

- **树存储方式**的分析

  - 能提高数据存储，读取的效率, 比如**利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度**。

    ![image-20221107201333513](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107201333513.png)

### 树示意图

![image-20221111195315513](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111195315513.png)

### 树的常用术语

![image-20221111195347117](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111195347117.png)

- 节点：就是树的节点
- 根节点：就是最顶上那个节点
- 父节点：指向这个节点的节点是这个节点的父节点
- 子节点：被指向的节点是指向它的那个节点的子节点
- 叶子节点：没有子节点的节点
- 节点的权：就是节点的值
- 路径：一个节点的路径就是从根节点找到该节点的路线
- 层：横着看是一层，从根节点途经相同步数能到达的节点在同一层中
- 子树：在二叉树中一个节点只有两个子树，分别是左子树和右子树，左右子树都是由是左右节点直接或间接的子节点来构成的
- 树的高度：就是树的最大层数
- 森林：多棵子树构成森林

### 二叉树的概念

- 树有很多种，**每个节点最多只能有两个子节点**的一种形式称为二叉树。

- 二叉树的子节点分为左节点和右节点

- 示意图：

  ![image-20221111201052749](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201052749.png)

- 如果该二叉树的**所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数**，则我们称为**满二叉树**。

  ![image-20221111201131764](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201131764.png)

- 如果该二叉树的**所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续**，我们称为**完全二叉树**。更通俗一点的解释就是：**去掉最后一层是满二叉树，倒数第一层的节点全部紧靠在左边**。

  ![image-20221111201217766](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201217766.png)

### 二叉树遍历的说明

- 我们可以使用**层序、前序、中序和后序**等对二叉树进行遍历。
- 前序遍历：先输出父节点，再遍历左子树和右子树
- 中序遍历：先遍历左子树，再输出父节点，再遍历右子树
- 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点
- 小结: 看输出父节点的顺序，就能确定是前序，中序还是后序

### 二叉树遍历步骤

![image-20221111201731060](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201731060.png)

### 二叉树查找指定节点

- 思路分析图解：

  ![image-20221111201900016](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201900016.png)

### 二叉树删除节点

- 思路分析图解：

  ![image-20221111201942720](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201942720.png)

- 注意这里的删除思路是针对普通二叉树来说的，后面的排序二叉树、平衡二叉树等的删除思路和普通二叉树不同，后面会详细介绍。

## 顺序存储二叉树

- 堆这个数据结构会用到顺序存储二叉树

### 顺序存储二叉树的概念

- 基本说明：从数据存储来看，数组存储方式和树的存储方式可以相互转换，即**数组可以转换成树，树也可以转换成数组**，看下面的示意图：

  ![image-20221112112821494](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221112112821494.png)

- 要求：在遍历数组 arr 时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历。

- 顺序存储二叉树的特点：

  1. 顺序二叉树通常**只考虑完全二叉树**
  2. 第 n 个元素的**左子节点为 2 * n + 1**
  3. 第 n 个元素的**右子节点为 2 * n + 2**
  4. 第 n 个元素的**父节点为 (n-1) / 2**
  5. n : 表示二叉树中的第几个元素(按 0 开始编号如图所示)

### 顺序存储二叉树的遍历

- 其实思路和非顺序存储二叉树的遍历相同，也是递归，只不过就是访问左子节点和访问右子节点的方式变了一下，之前是通过指针访问，现在是通过下标访问。

- 代码示例：

  ```java
  import java.util.Scanner;
  
  /**
   * @author Konjacer
   * @create 2022-11-12 11:39
   */
  public class OrderTreeTraverse {
      public static void main(String[] args) {
          Scanner scanner = new Scanner(System.in);
          System.out.println("请输入树的节点数量（包括空节点）：");
          int n = scanner.nextInt();
          int[] tree = new int[n];
          System.out.println("请按层序输入树的节点权值，空节点用-1代替：");
          for(int i=0;i<n;++i){
              tree[i] = scanner.nextInt();
          }
          System.out.println("前序遍历的结果为：");
          before(tree,0);
          System.out.println();
          System.out.println("中序遍历的结果为：");
          mid(tree,0);
          System.out.println();
          System.out.println("后序遍历的结果为：");
          after(tree,0);
          System.out.println();
      }
      public static void before(int[] tree,int now){
          if(now>=tree.length){
              return;
          }
          if(tree[now]!=-1)//如果不是空节点就输出
              System.out.print(tree[now]+" ");
          before(tree,now*2+1);//向左遍历
          before(tree,now*2+2);//向右遍历
      }
      public static void mid(int[] tree,int now){
          if(now>=tree.length){
              return;
          }
          mid(tree,now*2+1);//向左遍历
          if(tree[now]!=-1)//如果不是空节点就输出
              System.out.print(tree[now]+" ");
          mid(tree,now*2+2);//向右遍历
      }
      public static void after(int[] tree,int now){
          if(now>=tree.length){
              return;
          }
          after(tree,now*2+1);//向左遍历
          after(tree,now*2+2);//向右遍历
          if(tree[now]!=-1)//如果不是空节点就输出
              System.out.print(tree[now]+" ");
      }
  }
  ```

  

## 线索化二叉树

- 在普通的非顺序存储的二叉树中，所有的没有两个子节点的节点会有空闲的指针没有被利用，**线索二叉树做的实际上就是利用二叉树中空闲的指针再表示一些信息，从而使得在之后的操作中受益**。比如树的Morris遍历，实际上就是利用了左子树最右节点的空闲指针从而使得遍历起来更加方便。

### 线索二叉树基本介绍

- n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。**利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为"线索"）**
- 这种**加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)**。根据线索性质的不同，线索二叉树可分为**前序**线索二叉树、**中序**线索二叉树和**后序**线索二叉树三种
- 一个结点的前一个结点，称为**前驱结点**
- 一个结点的后一个结点，称为**后继结点**

### 将二叉树线索化的流程

- 将二叉树线索化实际上就是**将特定遍历顺序中对应节点的前驱和后继记录到对应节点的空闲指针上去**。所以根据遍历顺序的不同，线索二叉树可以分为前序、中序、后序线索二叉树三种，这些都是对于线索二叉树这个抽象的实现，实际上你也可以用别的方式实现不同的线索二叉树。

- 需要两个节点指针，其中一个**node用来指向遍历到的节点**，另外一个**pre用来指向遍历到的节点的前一个遍历到的节点**。**设置当前节点的前驱节点需要让node对应节点（当前节点）的左指针指向pre对应的节点；设置当前节点的后继节点需要继续遍历到下一个节点（此时node指向了下一个遍历的节点，pre指向了当前节点）让pre对应节点（当前节点）的右指针指向node对应的节点**。

- 中序线索二叉树示例：

  ![image-20221112122030580](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221112122030580.png)

  说明：当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况:

  1. left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点。
  2. right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向的是后继节点。

- 代码示例：

  ```java
  ```


### 遍历线索化二叉树

- 因为**线索化后，各个结点指向有变化，因此原来的遍历方式不能使用**，这时需要使用新的方式遍历线索化二叉树，各个节点**可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率**。 遍历的次序应当和线索化所用的遍历次序保持一致。

- 代码示例：

  ```java
  ```

## 二叉排序(查找)树

### 先看一个需求

- 给你一个数列 (7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加

### 解决方案分析

- 使用数组：
  - 数组未排序：优点：接在数组尾添加，速度快。 缺点：查找速度慢。
  - 数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。
- 使用链式存储-链表：不管链表是否有序，查找速度都慢；添加数据速度比数组快，不需要数据整体移动。
- 使用二叉排序树：既可以保证较快的查找速度，也可以保证较高的插入效率。

### 二叉排序树介绍

- **二叉排序树：BST (Binary Sort(Search) Tree)**, 对于二叉排序树的任何一个非叶子节点，**要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大**。从更宏观的角度来看，**任何一个非叶子节点的左子树的所有值都比该节点小，右子树的所有值都比该节点大**。

- 特别说明：**如果有相同的值，可以将和父节点相同的节点放在左子节点或右子节点都可以**。

- 针对前面的数据(7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：

  ![image-20221113092545691](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113092545691.png)

### 二叉排序树的创建和插入节点

- 二叉排序树创建的时候，**对于每个要插入的节点，都要先和根节点比较，比根节点小的话就往左走，比根节点大的话就往右走，然后继续和左子节点或者右子节点比较，重复上述操作直到找到空位置进行插入**。

- 代码示例：

  ```java
  ```

### 二叉排序树查找节点

- **从根节点开始，如果要查找的节点比当前节点要小，就向左找；如果要查找的节点比当前节点要大，就向右找，重复上述操作直到找到或者没找到**。没啥好说的

- 代码示例：

  ```java
  ```

  

### 二叉排序树删除节点

- 二叉排序树的删除情况比较复杂，有下面三种情况需要考虑（以上面的数据为例）：

  1. 删除叶子节点 (比如：2, 5, 9, 12)
  2. 删除只有一颗子树的节点 (比如：1)
  3. 删除有两颗子树的节点. (比如：7, 3，10 )

- **删除叶子节点的时候，只需要将其父节点对应的指针置空即可**，没什么好说的；

- **删除只有一颗子树的节点的时候，将其父节点的对应指针指向该节点的子节点即可**，也就是要保证该节点的子树不会随着该节点的删除而丢失；

- **删除有两棵子树的节点的时候**，这种情况比较复杂但也比较巧妙，我们**需要找到该节点的左子树的最大的节点或者右子树最小的节点，将找到的符合条件的节点的值赋值给该节点，然后对找到的那个符合条件的那个节点执行删除操作。由于找到的那个节点是左/右子树的最值，根据二叉排序树的特性，它一定是叶节点，所以根据叶节点的删除方式对其删除即可**。感慨一句，真是挺巧妙的，把删除非叶节点转换成了删除叶节点同时还保证了二叉排序树的结构。

- 代码示例：

  ```java
  
  ```

## 平衡二叉树(AVL树)

- **平衡二叉树本身就是一种特殊的二叉排序树，它身上有二叉排序树的所有特性**。

### 通过一个案例来认识二叉排序树可能存在的问题

- 给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在。
- 如果让1作为根节点的话，后面所有的元素依次递增，也就是说后面的每一个元素都会是前一个元素的右子节点，这样的一颗**二叉排序树实际上就退化成链表了，查询速度明显降低**，数据一旦大起来，这样的性能折损显然是我们不能接受的。
- 就算不是上面这种非常极端的情况，平常也会出现**二叉排序树的其中某些路径的深度很深的情况，那么查询这个路径上的节点的时候效率就会较低**。
- 鉴于上面这种情况的存在，我们需要使用平衡二叉树来解决这种问题。

### 基本介绍

- 平衡二叉树也叫**平衡二叉搜索树（Self-balancing binary search tree）**又被称为 AVL 树， 可以**保证查询效率较高**。

- 平衡二叉树具有以下特点：**它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树**。平衡二叉树的常用实现方法有**红黑树、AVL、替罪羊树、Treap、伸展树等**。

- 平衡二叉树举例：

  ![image-20221113103456817](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113103456817.png)

  最右边的二叉树不是平衡二叉树，因为根节点的左右子树的高度差为2（一个是2一个是0），大于1，不符合平衡二叉树的定义。

### 平衡二叉树左旋转

- 如果要是**树的最右路径（一直往右走）长度过长的话，我们就需要对整棵树进行左旋转来尝试将最右路径的长度变短**。

- 由于在创建和维护平衡二叉树的时候，每次插入一个新的节点都会触发判断平衡二叉树是否需要进行旋转，所以**最多会出现高度差为2的不平衡**，所以只需要针对这种情况设计旋转的过程即可。

- 左旋转通过**将最右路径的高度分一个单位给最左路径来将最右路径的高度降低**，这种方式通常通过将根节点分到左边，将根节点的右子节点提升为根节点来实现。

- 具体步骤就是：**创建一个新节点，值等于根节点的右节点的值，新节点的左指针指向根节点，右指针指向根节点的右节点的右节点，然后让根节点的右节点指向根节点的右节点的左节点**。

- 上面的操作实际上就是**让新节点替代了根节点的右节点变成了整个树的根节点，根节点的右节点由于失去引用被回收了，从整体上看就相当于最右路径向左转了一下**，由于二叉排序树的性质，根节点的右节点的左子树的所有值肯定是比根节点的右节点的值要小的，那么根节点的右节点提升为根节点的话，根节点的右节点的左子树肯定要放到提升为根节点的那个节点的左边，同时由于二叉排序树的性质，根节点的右节点的左子树的所有值肯定比原来的根节点的值要大，原来的根节点降低为新根节点的左节点，同时空闲出来了右指针，所以可以把原根节点的右节点的左子树放到平衡后的原根节点的右指针上。

- 思路分析图解：

  ![image-20221113111118855](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113111118855.png)

- 代码示例：

  ```java
  
  ```

### 平衡二叉树右旋转

- 如果要是**树的最左路径（一直往左走）长度过长的话，我们就需要对整棵树进行右旋转来尝试将最左路径的长度变短**。

- 由于在创建和维护平衡二叉树的时候，每次插入一个新的节点都会触发判断平衡二叉树是否需要进行旋转，所以**最多会出现高度差为2的不平衡**，所以只需要针对这种情况设计旋转的过程即可。

- 右旋转通过**将最左路径的高度分一个单位给最右路径来将最左路径的高度降低**，这种方式通常通过将根节点分到右边，将根节点的左子节点提升为根节点来实现。

- 具体步骤就是：**创建一个新节点，值等于根节点的左节点的值，新节点的右指针指向根节点，左指针指向根节点的左节点的左节点，然后让根节点的左节点指向根节点的左节点的右节点**。

- 上面的操作实际上就是**让新节点替代了根节点的左节点变成了整个树的根节点，根节点的左节点由于失去引用被回收了，从整体上看就相当于最左路径向右转了一下**，由于二叉排序树的性质，根节点的左节点的右子树的所有值肯定是比根节点的左节点的值要大的，那么根节点的左节点提升为根节点的话，根节点的左节点的右子树肯定要放到提升为根节点的那个节点的右边，同时由于二叉排序树的性质，根节点的左节点的右子树的所有值肯定比原来的根节点的值要小，原来的根节点降低为新根节点的右节点，同时空闲出来了左指针，所以可以把原根节点的左节点的右子树放到平衡后的原根节点的左指针上。

- 思路分析图解：

  ![image-20221113111357063](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113111357063.png)

- 代码示例：

  ```java
  
  ```

### 平衡二叉树双旋转

- 如果要是**树的非最左最右路径过长的话，单用一次或右旋转或左旋转无法将树调整为平衡二叉树**，这种时候就需要使用双旋转，核心思路就是**先把长出来的部分转移到最左或者最右路径上，这一步通常需要一个旋转操作来实现，然后再进行左旋转或者右旋转**。

- **当根节点左子树的高度大于右子树且高度差大于1的时候，理应发生右旋转**，但是**如果根节点的左子树的右子树的高度大于根节点的左子树的左子树，一次右旋转无法将其调整为平衡二叉树**，这时我们就需要**先对根节点的左子树做一次左旋转，将高出来的高度旋转到最左路径上，然后就可以通过右旋转进行调整了**。

- **当根节点右子树的高度大于左子树且高度差大于1的时候，理应发生左旋转**，但是**如果根节点的右子树的左子树的高度大于根节点的右子树的右子树，一次左旋转无法将其调整为平衡二叉树**，这时我们就需要**先对根节点的右子树做一次右旋转，将高出来的高度旋转到最右路径上，然后就可以通过左旋转进行调整了**。

- 思路分析图解：

  ![image-20221113113223559](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113113223559.png)

- 代码示例：

  ```java
  
  ```

# 数据结构-多路查找树

## 多叉树与B树

### 二叉树的问题分析

- 二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树：

  ![image-20221113114141432](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113114141432.png)

- 二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如 1 亿)， 就存在如下问题：

  1. 在构建二叉树时，需要多次进行 i/o 操作(海量数据存在数据库或文件中)，**节点海量，构建二叉树时，对速度有影响**。
  2. **节点海量，也会造成二叉树的高度很大，会降低操作速度**。

### 多叉树

- 在二叉树中，每个节点有数据项，最多有两个子节点。**如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）**。

- 后面我们讲解的 2-3 树，2-3-4 树就是多叉树，**多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化**。

- 多叉树示例（下面的2-3树就是一棵多叉树）：

  ![image-20221113114500386](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113114500386.png)

### B树的基本介绍

- B树**通过重新组织节点，降低树的高度，并且通过减少I/O读写次数来提升效率**。

- B树示例：

  ![image-20221113114712207](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113114712207.png)

- 如图**B树通过重新组织节点，降低了树的高度**。

- **文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页（页的大小通常为4k），这样每个节点只需要一次I/O就可以完全载入**。

- 将树的度 M 设置为 1024，在 600 亿个元素中最多只需要 4 次 I/O 操作就可以读取到想要的元素, **B 树(B+)广泛应用于文件存储系统以及数据库系统中**。

- B树是个相对抽象的概念，2-3树、2-3-4树都是B树的一种实现。

## 2-3树

### 2-3树是最简单的B树结构

- 2-3树具有如下特点：
  1. 2-3 树的**所有叶子节点都在同一层.(只要是 B 树都满足这个条件)**
  2. **有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点**.
  3. **有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点**.
  4. 2-3 树是**由二节点和三节点构成**的树。

### 2-3树应用案例

- 将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成 2-3 树，并保证数据插入的大小顺序：

  ![image-20221114090342074](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114090342074.png)

### 2-3树节点插入规则

1. 2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件)
2. 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.
3. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点
4. 当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，**先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面 3 个条件**。
5. **对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则，除此之外，三节点内部的两个元素也应该是有序的**。

### 其它说明

- 除了 23 树，还有 234 树等，概念和 23 树类似，也是一种 B 树。 如图:

  ![image-20221114092600003](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114092600003.png)

## B树、B+树和B*树

### B树的介绍

- **B-tree 树即 B 树，B 即 Balanced，平衡的意思**。有人把 B-tree 翻译成 B-树，容易让人产生误解。会以为 B-树是一种树，而 B 树又是另一种树。实际上，**B-tree 就是指的 B 树**。

- 前面已经介绍了 2-3 树和 2-3-4 树，他们就是 B 树(英语：B-tree 也写成 B-树)，这里我们再做一个说明，我们在学习 Mysql 时，经常听到说某种类型的索引是基于 B 树或者 B+树的，如图:

  ![image-20221114092747019](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114092747019.png)

- 对B树的说明：

  1. **B树的阶：节点的最多子节点个数**。比如 2-3 树的阶是 3，2-3-4 树的阶是 4
  2. B-树的搜索，**从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点**。
  3. 关键字集合分布在整颗树中, 即**叶子节点和非叶子节点都存放数据**。
  4. **搜索有可能在非叶子结点结束**
  5. 其**搜索性能等价于在关键字全集内做一次二分查找**

### B+树的介绍

- B+树是B树的变体，也是一种多路搜索树：

  ![image-20221114093141034](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114093141034.png)

- 对B+树的说明：

  1. B+树的搜索与 B 树也基本相同，区别是**B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找**。
  2. **所有关键字都出现在叶子结点的链表中**（即**数据只能在叶子节点**【也叫**稠密索引**】），且**链表中的关键字(数据)恰好是有序的**。
  3. **不可能在非叶子结点命中**
  4. **非叶子结点相当于是叶子结点的索引（稀疏索引）**，**叶子结点相当于是存储（关键字）数据的数据层**
  5. 更**适合文件索引系统**
  6. B 树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.

### B*树的介绍

- B*树是 B+树的变体，**在B+树的非根和非叶子结点再增加指向兄弟的指针**：

  ![image-20221114093538855](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114093538855.png)

- 对B*树的说明：

  1. B\*树定义了**非叶子结点关键字个数至少为(2/3)\*M**，即**块的最低使用率为 2/3**，而**B+树的块的最低使用率为的1/2**。
  2. 从第 1 个特点我们可以看出，**B\*树分配新结点的概率比B+树要低，空间使用率更高**。

# 数据结构-并查集

## 基本介绍

- 并查集作为一种简洁而优雅的树形数据结构，主要用于解决一些**元素分组**的问题，它**管理着一系列不相交的集合**，并支持两种操作：
  1. **合并（Union）**：把两个不相交的集合合并为一个集合。
  2. **查询（Find）**：查询两个元素是否在同一个集合中。

## 实现方式

### 数据结构

- 在最基础的应用中，抽象后的点集都是按顺序的数字，此时我们只**需要一个一维数组f来表示元素之间的关系**，如果**f[i]=j说明i的父节点是j**，那么它们肯定有相同的根节点，也就是说明i和j是属于同一组的，在这个一维数组中，**两者拥有相同根节点的元素都是属于同一组的**。

- 对于一维数组f的初始化，应该**把每个元素的值初始化成它的下标，表示刚开始的时候所有元素彼此独立**，互相之间没有从属关系，所以**如果后面出现一个元素的值为它的下标，说明它是独立的**。

  ```java
  int[] f = new int[n];//并查集数组,f[i]=j说明i的父亲节点是j
  	for(int i=0;i<n;++i){//初始化每个节点都是独立的，即他们的father都是自己
  	    f[i] = i;
  	}
  ```

  

### 方法

- 首先来看**查询（Find）操作**，这个操作的最终目的是查询两个元素是否在同一个集合中，那么我们不妨**把这个操作的粒度降低，让每次Find操作都查询一个元素的根节点，这样可以在后续编码时带来更高的灵活性**，判定两个元素是否同一组就是判断两个元素的根节点是否相同。

  ```java
  public static int find(int[] f,int v){//找一个元素的根节点
          return f[v]==v?v:(f[v] = find(f,f[v]));//如果该点独立，直接返回;如果该点不独立,往后找根节点，顺便进行路径压缩
      }
  ```

  在上面的代码中，我们**通过递归去找元素对应的根节点**，实际上**在递归的过程中做了一个路径压缩的优化**，路径压缩就是说**把递归过程中经过的所有节点的父节点都变成它们的根节点，这样做可以使后面再次查找这条递归链上元素根节点的时间复杂度降低，由于递归过程中经过的节点拥有相同的根节点，所以保证了该操作的正确性**。

- 再来看**合并（Union）操作**，这个操作的目的是**如果两个元素本来不是同一组的，那么就将两个元素合并到同一组中**，反映到数据结构上就是让一个元素变成另外一个元素的父亲。

  ```java
  public static boolean merge(int[] f,int u,int v){//合并操作，其中可以做优化：直接把两者的根节点合并
          return (u = find(f,u))==(v = find(f,v))?false:(f[v]=u)==u;//先找到各自的根，然后比较，如果相同说明已经合并无需再合并，返回false；如果不相同就合并，返回true
      }
  ```

  本来是让其中一个元素的根节点合并到另外一个元素上面的，但是上面的代码中也做了一个优化，那就是**直接把两者的根节点合并，可以缩短递归链的长度，优化时间复杂度**。

# 数据结构-稀疏数组（sparsearray）

## 需求场景示例

- 编写一个五子棋程序，有存盘退出的功能和续上盘的功能。

  ![image-20221031201730800](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031201730800.png)

- 问题分析：要想实现这些功能，就需要对棋局进行持久化，而大部分情况下棋局对应的二维数组都是比较稀疏的，因此有很多没有意义的数据，这些没有意义的数据如果做持久化，就会对空间产生额外的消耗，因此为了应对这种情况，我们**可以使用稀疏数组来对数组进行存储，在特定情况下使用可以减少空间的开销**。

## 基本介绍

- 当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。
- 稀疏数组的处理方法是:
  1. 在稀疏数组的**第一个元素中存放原数组的行数、列数、元素数**。
  2. 在稀疏数组**除了第一个元素后面的每一个空间中记录原数组的一个元素所在的行数、列数和值**。

- 稀疏数组举例说明：

  ![image-20221031202328310](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031202328310.png)

## 应用实例

- 使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)

- 把稀疏数组存盘，并且可以重新恢复原来的二维数组。

- 整体思路分析：

  ![image-20221031202449600](https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031202449600.png)

- 代码实现：

  ```java
  package com.atguigu.sparsearray;
  public class SparseArray {
  	public static void main(String[] args) {
  		// 创建一个原始的二维数组 11 * 11
  		// 0: 表示没有棋子， 1 表示 黑子 2 表蓝子
  		int chessArr1[][] = new int[11][11];
  		chessArr1[1][2] = 1;
  		chessArr1[2][3] = 2;
  		chessArr1[4][5] = 2;
  		// 输出原始的二维数组
  		System.out.println("原始的二维数组~~");
  		for (int[] row : chessArr1) {
  			for (int data : row) {
  				System.out.printf("%d\t", data);
  			}
  			System.out.println();
  		}
  		// 将二维数组 转 稀疏数组的思
  		// 1. 先遍历二维数组 得到非 0 数据的个数
  		int sum = 0;
  		for (int i = 0; i < 11; i++) {
  			for (int j = 0; j < 11; j++) {
  				if (chessArr1[i][j] != 0) {
  					sum++;
  				}
  			}
  		}
  		// 2. 创建对应的稀疏数组
  		int sparseArr[][] = new int[sum + 1][3];
  		// 给稀疏数组赋值
  		sparseArr[0][0] = 11;
  		sparseArr[0][1] = 11;
  		sparseArr[0][2] = sum;
  		// 遍历二维数组，将非 0 的值存放到 sparseArr 中
  		int count = 0; //count 用于记录是第几个非 0 数据
  		for (int i = 0; i < 11; i++) {
  			for (int j = 0; j < 11; j++) {
  				if (chessArr1[i][j] != 0) {
  					count++;
  					sparseArr[count][0] = i;
  					sparseArr[count][1] = j;
  					sparseArr[count][2] = chessArr1[i][j];
  				}
  			}
  		}
  		// 输出稀疏数组的形式
  		System.out.println();
  		System.out.println("得到稀疏数组为~~~~");
  		for (int i = 0; i < sparseArr.length; i++) {
  			System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]);
  		}
  		System.out.println();
  		//将稀疏数组 --》 恢复成 原始的二维数组
  		/*
  		 * 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2 = int[11][11]
  		   2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.
  		 */
  		//1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组
  		int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];
  		//2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可
  		for(int i = 1; i < sparseArr.length; i++) {
  			chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
  		}
  		// 输出恢复后的二维数组
  		System.out.println();
  		System.out.println("恢复后的二维数组");
  		for (int[] row : chessArr2) {
  			for (int data : row) {
  				System.out.printf("%d\t", data);
  			}
  			System.out.println();
  		}
  	}
  }
  ```

  

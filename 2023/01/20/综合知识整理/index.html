<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>综合知识整理 | 孤舟</title><meta name="keywords" content="综合知识"><meta name="author" content="Konjacer,1175590069@qq.com"><meta name="copyright" content="Konjacer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java基础Java 语言有哪些特点? 简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 可靠性； 安全性； 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅">
<meta property="og:type" content="article">
<meta property="og:title" content="综合知识整理">
<meta property="og:url" content="https://konjacor.github.io/2023/01/20/%E7%BB%BC%E5%90%88%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="孤舟">
<meta property="og:description" content="Java基础Java 语言有哪些特点? 简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 可靠性； 安全性； 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://konjacor.github.io/img/background.jpeg">
<meta property="article:published_time" content="2023-01-20T03:24:03.000Z">
<meta property="article:modified_time" content="2023-03-15T13:10:21.766Z">
<meta property="article:author" content="Konjacer">
<meta property="article:tag" content="综合知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://konjacor.github.io/img/background.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://konjacor.github.io/2023/01/20/%E7%BB%BC%E5%90%88%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '综合知识整理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-15 21:10:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="孤舟" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/xiaozhai.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">孤舟</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">综合知识整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-20T03:24:03.000Z" title="发表于 2023-01-20 11:24:03">2023-01-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-15T13:10:21.766Z" title="更新于 2023-03-15 21:10:21">2023-03-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="综合知识整理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"/>

<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Java-语言有哪些特点"><a href="#Java-语言有哪些特点" class="headerlink" title="Java 语言有哪些特点?"></a>Java 语言有哪些特点?</h2><ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>
<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存；</li>
</ol>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ul>
<li>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</li>
<li><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</li>
<li>OS运行在硬件之上，JVM运行在OS之上。</li>
</ul>
<h2 id="JDK和JRE"><a href="#JDK和JRE" class="headerlink" title="JDK和JRE"></a>JDK和JRE</h2><ol>
<li>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</li>
<li>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</li>
<li>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</li>
</ol>
<h2 id="什么是字节码？采用字节码的好处是什么？"><a href="#什么是字节码？采用字节码的好处是什么？" class="headerlink" title="什么是字节码？采用字节码的好处是什么？"></a>什么是字节码？采用字节码的好处是什么？</h2><ul>
<li><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），<strong>它不面向任何特定的处理器，只面向虚拟机（也就是说字节码是跑在虚拟机上的）</strong>。Java 语言通过字节码的方式，<strong>在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点</strong>。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，<strong>由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行</strong>。</p>
</li>
<li><p>Java 程序从源代码到运行的过程如下图所示：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230218183516012.png" alt="image-20230218183516012"></p>
</li>
<li><p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 <strong>JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢</strong>。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。<strong>当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用</strong>。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p>
</li>
<li><p>JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。</p>
</li>
</ul>
<h2 id="为什么不全部使用AOT呢？"><a href="#为什么不全部使用AOT呢？" class="headerlink" title="为什么不全部使用AOT呢？"></a>为什么不全部使用AOT呢？</h2><ul>
<li>长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，<strong>CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了</strong>。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</li>
</ul>
<h2 id="为什么说Java语言“编译与解释并存”？"><a href="#为什么说Java语言“编译与解释并存”？" class="headerlink" title="为什么说Java语言“编译与解释并存”？"></a>为什么说Java语言“编译与解释并存”？</h2><ul>
<li>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</li>
</ul>
<h2 id="Oracle-JDK和OpenJDK"><a href="#Oracle-JDK和OpenJDK" class="headerlink" title="Oracle JDK和OpenJDK"></a>Oracle JDK和OpenJDK</h2><ul>
<li>OpenJDK开源；Oracle JDK闭源，11之后，个人使用免费，但是商用收费。</li>
<li>Oracle JDK 比 OpenJDK 更稳定</li>
<li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能</li>
</ul>
<h2 id="Java和C-的区别？"><a href="#Java和C-的区别？" class="headerlink" title="Java和C++的区别？"></a>Java和C++的区别？</h2><ul>
<li>Java 不提供指针来直接访问内存，程序内存更加安全。</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li>
<li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li>
</ul>
<h2 id="Java中的三种移位运算符"><a href="#Java中的三种移位运算符" class="headerlink" title="Java中的三种移位运算符"></a>Java中的三种移位运算符</h2><ul>
<li><code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。</li>
<li><code>&gt;&gt;</code> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。</li>
<li><code>&gt;&gt;&gt;</code> :无符号右移，忽略符号位，空位都以 0 补齐。</li>
<li>由于 <code>double</code>，<code>float</code> 在二进制中的表现比较特殊，因此不能来进行移位操作。</li>
<li>移位操作符实际上支持的类型只有<code>int</code>和<code>long</code>，编译器在对<code>short</code>、<code>byte</code>、<code>char</code>类型进行移位前，都会将其转换为<code>int</code>类型再操作。</li>
<li>如果移位的位数超过数值所占有的位数会怎样？</li>
<li>当 int 类型左移&#x2F;右移位数大于等于 32 位操作时，会先求余（%）后再进行左移&#x2F;右移操作。也就是说左移&#x2F;右移 32 位相当于不进行移位操作（32%32&#x3D;0），左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位（42%32&#x3D;10）。当 long 类型进行左移&#x2F;右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。</li>
</ul>
<h2 id="成员变量和局部变量的区别？"><a href="#成员变量和局部变量的区别？" class="headerlink" title="成员变量和局部变量的区别？"></a>成员变量和局部变量的区别？</h2><ul>
<li><strong>语法形式</strong> ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li>
<li><strong>存储方式</strong> ：从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li><strong>生存时间</strong> ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li>
<li><strong>默认值</strong> ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ul>
<h2 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h2><ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<h2 id="重载和重写的区别？"><a href="#重载和重写的区别？" class="headerlink" title="重载和重写的区别？"></a>重载和重写的区别？</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul>
<li>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</li>
</ul>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><ul>
<li><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
</li>
<li><p><strong>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类</strong>。</p>
</li>
<li><p><strong>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明（此时两个重名的static方法没有任何关系）</strong>。</p>
</li>
<li><p>构造方法无法被重写</p>
</li>
<li><p><strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230218190352463.png" alt="image-20230218190352463"></p>
</li>
<li><p>方法的重写要遵循“<strong>两同两小一大</strong>”：</p>
<ul>
<li>“两同”即方法名相同、形参列表相同；</li>
<li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li>
<li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li>
</ul>
</li>
</ul>
<h2 id="可变长参数遇到方法重载怎么办？会优先匹配固定参数还是可变参数的方法呢？"><a href="#可变长参数遇到方法重载怎么办？会优先匹配固定参数还是可变参数的方法呢？" class="headerlink" title="可变长参数遇到方法重载怎么办？会优先匹配固定参数还是可变参数的方法呢？"></a>可变长参数遇到方法重载怎么办？会优先匹配固定参数还是可变参数的方法呢？</h2><ul>
<li>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</li>
<li>另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 <code>class</code>文件就可以看出来了。</li>
</ul>
<h2 id="Java中的基本数据类型"><a href="#Java中的基本数据类型" class="headerlink" title="Java中的基本数据类型"></a>Java中的基本数据类型</h2><ul>
<li><p>6 种数字类型：</p>
<ul>
<li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li>2 种浮点型：<code>float</code>、<code>double</code></li>
</ul>
</li>
<li><p>1 种字符类型：<code>char</code></p>
</li>
<li><p>1 种布尔型：<code>boolean</code></p>
</li>
<li><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230218190858669.png" alt="image-20230218190858669"></p>
</li>
<li><p>对于 <code>boolean</code>，官方文档未明确定义，它<strong>依赖于 JVM 厂商的具体实现</strong>。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p>
</li>
<li><p>另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。<strong>这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一</strong>。</p>
</li>
<li><p>注意：</p>
<ol>
<li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li>
<li>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code></li>
</ol>
</li>
</ul>
<h2 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h2><ol>
<li>成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li>
<li>包装类型可用于泛型，而基本类型不可以。</li>
<li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道<strong>几乎所有对象实例都存在于堆中</strong>。</li>
<li>相比于对象类型， 基本数据类型占用的空间非常小。</li>
</ol>
<ul>
<li>注意 ： <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</li>
</ul>
<h2 id="所有的对象实例都存在堆中吗？"><a href="#所有的对象实例都存在堆中吗？" class="headerlink" title="所有的对象实例都存在堆中吗？"></a>所有的对象实例都存在堆中吗？</h2><ul>
<li>不是，是几乎所有对象实例都存在堆中，<strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，<strong>如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</strong>。</li>
<li><strong>标量替换</strong>：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是<strong>将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样随着方法调用结束，栈帧也会销毁。有效的减少了堆中创建对象及gc的次数</strong></li>
</ul>
<h2 id="包装类型的缓存机制了解么？"><a href="#包装类型的缓存机制了解么？" class="headerlink" title="包装类型的缓存机制了解么？"></a>包装类型的缓存机制了解么？</h2><ul>
<li><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p>
</li>
<li><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
</li>
<li><p>如果<strong>超出对应范围仍然会去创建新的对象</strong>，缓存的范围区间的大小只是在性能和资源之间的权衡。</p>
</li>
<li><p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p>
</li>
<li><p>Integer缓存源码（自动装箱用的就是valueOf方法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<span class="comment">//如果范围在缓存中，直接返回缓存的数据</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);<span class="comment">//否则新建对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230218193854172.png" alt="image-20230218193854172"></p>
</li>
</ul>
<h2 id="自动装箱与拆箱了解吗？原理是什么？"><a href="#自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="自动装箱与拆箱了解吗？原理是什么？"></a>自动装箱与拆箱了解吗？原理是什么？</h2><ul>
<li>从字节码中，我们发现<strong>装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法</strong>。</li>
<li>因此：<ul>
<li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li>
<li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li>
</ul>
</li>
<li>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></li>
</ul>
<h2 id="为什么浮点数运算的时候会有精度丢失的风险？"><a href="#为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="为什么浮点数运算的时候会有精度丢失的风险？"></a>为什么浮点数运算的时候会有精度丢失的风险？</h2><ul>
<li><p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且<strong>计算机在表示一个数字时，宽度是有限的</strong>，<strong>无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示</strong>。</p>
</li>
<li><p>比如十进制的0.2要存放在计算机中，那肯定要转换成2进制来存储，而转成的二进制可能是无限长的，所以必须截断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span></span><br><span class="line"><span class="comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span> <span class="comment">//第一位二进制小数，取整数部分0，余下的参与下次运算</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> -&gt; <span class="number">0</span> <span class="comment">//第二位二进制小数，取整数部分0，余下的参与下次运算</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> -&gt; <span class="number">1</span> <span class="comment">//第三位二进制小数，取整数部分1，余下的参与下次运算</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> -&gt; <span class="number">1</span> <span class="comment">//第四位二进制小数，取整数部分1，余下的参与下次运算</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span>（发生循环）<span class="comment">//第五位二进制小数，取整数部分0，余下的参与下次运算，在这里发生循环，也就意味着0.2转换成的二进制将会是无限循环的，所以必须截断</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="如何解决浮点数运算的精度丢失问题？"><a href="#如何解决浮点数运算的精度丢失问题？" class="headerlink" title="如何解决浮点数运算的精度丢失问题？"></a>如何解决浮点数运算的精度丢失问题？</h2><ul>
<li><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</li>
<li>BigDecimal中提供各种各样的方法来实现BigDecimal对象之间的运算，所以运算的时候要使用其中的方法。</li>
</ul>
<h2 id="超过long整型的数据应该如何表示？"><a href="#超过long整型的数据应该如何表示？" class="headerlink" title="超过long整型的数据应该如何表示？"></a>超过long整型的数据应该如何表示？</h2><ul>
<li>在 Java 中，64 位 long 整型是最大的整数类型。超过了可以用<code>BigInteger</code> ，其内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。和BigDecimal一样，其中提供了各种供对象间进行运算的方法。</li>
<li>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</li>
</ul>
<h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><ul>
<li>两者的主要区别在于解决问题的方式不同：<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li>
</ul>
</li>
<li>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</li>
</ul>
<h2 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>创建一个对象用什么运算符?对象实体与对象引用有何不同?</h2><ul>
<li>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（就是指针，指向对象实例的位置）。</li>
<li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li>
</ul>
<h2 id="对象相等和引用相等的区别？"><a href="#对象相等和引用相等的区别？" class="headerlink" title="对象相等和引用相等的区别？"></a>对象相等和引用相等的区别？</h2><ul>
<li>对象的相等一般比较的是内存中存放的内容是否相等。</li>
<li>引用相等一般比较的是他们指向的内存地址是否相等。</li>
</ul>
<h2 id="类的构造方法的作用是什么"><a href="#类的构造方法的作用是什么" class="headerlink" title="类的构造方法的作用是什么?"></a>类的构造方法的作用是什么?</h2><ul>
<li>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</li>
</ul>
<h2 id="如果一个类没有声明构造方法，该程序能正确执行吗？"><a href="#如果一个类没有声明构造方法，该程序能正确执行吗？" class="headerlink" title="如果一个类没有声明构造方法，该程序能正确执行吗？"></a>如果一个类没有声明构造方法，该程序能正确执行吗？</h2><ul>
<li>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</li>
</ul>
<h2 id="构造方法有哪些特点？是否可被-override"><a href="#构造方法有哪些特点？是否可被-override" class="headerlink" title="构造方法有哪些特点？是否可被 override?"></a>构造方法有哪些特点？是否可被 override?</h2><ul>
<li>构造方法特点如下：<ol>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
</li>
<li>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</li>
</ul>
<h2 id="面向对象四大特征"><a href="#面向对象四大特征" class="headerlink" title="面向对象四大特征"></a>面向对象四大特征</h2><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><ul>
<li>就是指一种思想，我们可以将客观存在的一切事物都抽象成java类，其中属性表示事物的状态信息，方法表示事物可以有的行为。</li>
</ul>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li>封装是指<strong>把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性</strong>。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。<strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率</strong>。</li>
<li>关于继承如下 3 点请记住：<ol>
<li>子类拥有父类对象所有的属性和方法（<strong>包括私有属性和私有方法</strong>），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
</li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</li>
<li>多态的特点：<ol>
<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>
<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ol>
</li>
</ul>
<h2 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h2><ul>
<li>共同点：<ol>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li>
</ol>
</li>
<li>区别：<ol>
<li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li>
</ol>
</li>
</ul>
<h2 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h2><ul>
<li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li>
<li><strong>引用拷贝</strong>：引用拷贝就是两个不同的引用指向同一个对象。</li>
</ul>
<h2 id="Object类的常见方法有哪些？"><a href="#Object类的常见方法有哪些？" class="headerlink" title="Object类的常见方法有哪些？"></a>Object类的常见方法有哪些？</h2><ul>
<li><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作，第一次回收触发这个方法，然后会将对象放到一个队列中，此时对象的内存并没有被真正释放；第二次回收的时候会判断队列中的对象是否通过finalize方法重新建立起了引用，如果有，那就不回收了，如果没有，直接回收掉，这次是真回收，会释放内存空间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="x3D-x3D-和equals-的区别"><a href="#x3D-x3D-和equals-的区别" class="headerlink" title="&#x3D;&#x3D;和equals()的区别"></a>&#x3D;&#x3D;和equals()的区别</h2><ul>
<li><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
</li>
<li>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</li>
<li><strong><code>equals()</code></strong> <strong>不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等（这个相等的定义是自己定义的）</strong>。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</li>
<li><code>equals()</code> 方法存在两种使用情况：<ol>
<li><strong>类没有重写 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li>
<li><strong>类重写了 <code>equals()</code>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li>
</ol>
</li>
</ul>
<h2 id="hashCode-有什么用？"><a href="#hashCode-有什么用？" class="headerlink" title="hashCode()有什么用？"></a>hashCode()有什么用？</h2><ul>
<li><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</li>
<li><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</li>
<li>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></li>
<li>可以<strong>优化对象比较大小时的速度</strong>，通过先比较hashcode，如果hashcode不同，那么这两个对象一定是不同的，如果hashcode相同，再通过equals()方法来进一步比较确定两者是否相同。</li>
</ul>
<h2 id="为什么要有-hashCode？"><a href="#为什么要有-hashCode？" class="headerlink" title="为什么要有 hashCode？"></a>为什么要有 hashCode？</h2><ul>
<li><p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 <code>hashCode</code>？</p>
</li>
<li><p>下面这段内容摘自我的 Java 启蒙书《Head First Java》:</p>
<blockquote>
<p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>
</blockquote>
<p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p>
</li>
<li><p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p>
</li>
<li><p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p>
</li>
<li><p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p>
</li>
<li><p>总结下来就是 ：</p>
<ol>
<li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li>
</ol>
</li>
</ul>
<h2 id="为什么重写equals-时必须重写hashCode-方法？"><a href="#为什么重写equals-时必须重写hashCode-方法？" class="headerlink" title="为什么重写equals()时必须重写hashCode()方法？"></a>为什么重写equals()时必须重写hashCode()方法？</h2><ul>
<li>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>
<li>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</li>
<li><strong>思考</strong> ：重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</li>
<li><strong>总结</strong> ：<ul>
<li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li>
<li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li>
</ul>
</li>
</ul>
<h2 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h2><h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h3><ul>
<li><p><code>String</code> 是不可变的（后面会详细分析原因）。</p>
</li>
<li><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">      <span class="type">char</span>[] value;</span><br><span class="line">      <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">return</span> appendNull();</span><br><span class="line">          <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">          ensureCapacityInternal(count + len);</span><br><span class="line">          str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">          count += len;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    	<span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">### 线程安全性</span><br><span class="line"></span><br><span class="line">- `String` 中的对象是不可变的，也就可以理解为常量，线程安全。`AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。**`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的**。</span><br><span class="line"></span><br><span class="line">### 性能</span><br><span class="line"></span><br><span class="line">- 每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。**`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用**。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 <span class="number">10</span>%~<span class="number">15</span>% 左右的性能提升，但却要冒多线程不安全的风险。</span><br><span class="line"></span><br><span class="line">### 对于三者使用的总结</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 操作少量的数据: 适用 `String`</span><br><span class="line"><span class="number">2.</span> 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`</span><br><span class="line"><span class="number">3.</span> 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`</span><br><span class="line"></span><br><span class="line">## String为什么是不可变的？</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 保存字符串的字符数组（jdk1<span class="number">.9</span>之后是字节数组）被 `<span class="keyword">final</span>` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。</span><br><span class="line"><span class="number">2.</span> `String` 类被 `<span class="keyword">final</span>` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。</span><br><span class="line"></span><br><span class="line">## String不可变的好处？</span><br><span class="line"></span><br><span class="line">### 便于实现String常量池</span><br><span class="line"></span><br><span class="line">- 在程序编写过程中往往会大量用到String常量，如果每次都为新的String常量申请内存空间的话会对空间造成很大的浪费，所以我们需要字符串常量池来对String常量做一个优化，把之前用过的String保存下来，以后如果再用的话可以直接拿。</span><br><span class="line">- 从上面我们知道了我们需要一个字符串常量池来对使用String做优化，而只有当字符串是不可变的，字符串池才有可能实现。**字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变**。</span><br><span class="line"></span><br><span class="line">### 可以很方便地作为Map的key</span><br><span class="line"></span><br><span class="line">- 以String作为HashMap的key，String的不可变性保证了其hash值的不可变性，防止出现key值发生变化导致key对象的hash值发生变化，之后再用key的那个对象在map中找对应的value就找不到了（因为hash值变了，找的位置就不对了）。</span><br><span class="line"></span><br><span class="line">### 避免网络安全问题</span><br><span class="line"></span><br><span class="line">- 如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。</span><br><span class="line"></span><br><span class="line">### 使多线程安全</span><br><span class="line"></span><br><span class="line">- 因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</span><br><span class="line"></span><br><span class="line">### 避免本地安全性问题</span><br><span class="line"></span><br><span class="line">- 类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。</span><br><span class="line"></span><br><span class="line">### 加快字符串处理速度</span><br><span class="line"></span><br><span class="line">- 因为字符串是不可变的，所以在它创建的时候hashcode就被缓存在对象头中了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</span><br><span class="line"></span><br><span class="line">## Java9为何要将String的底层实现由<span class="type">char</span>[]改成了<span class="type">byte</span>[]？</span><br><span class="line"></span><br><span class="line">- 新版的 String 其实支持两个编码方案： Latin-<span class="number">1</span> 和 UTF-<span class="number">16</span>。JDK 官方就说了绝大部分字符串对象只包含 Latin-<span class="number">1</span> 可表示的字符。如果字符串中包含的汉字没有超过 Latin-<span class="number">1</span> 可表示范围内的字符，那就会使用 Latin-<span class="number">1</span> 作为编码方案。Latin-<span class="number">1</span> 编码方案下，`<span class="type">byte</span>` 占一个字节(<span class="number">8</span> 位)，`<span class="type">char</span>` 占用 <span class="number">2</span> 个字节（<span class="number">16</span>），`<span class="type">byte</span>` 相较 `<span class="type">char</span>` 节省一半的内存空间。</span><br><span class="line">- 如果字符串中包含的汉字超过 Latin-<span class="number">1</span> 可表示范围内的字符，`<span class="type">byte</span>` 和 `<span class="type">char</span>` 所占用的空间是一样的。</span><br><span class="line"></span><br><span class="line">## 字符串拼接用“+”还是StringBuilder？</span><br><span class="line"></span><br><span class="line">- Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</span><br><span class="line">- 通过编译后形成的字节码文件的内容可以看出，**字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 **。</span><br><span class="line">- 不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：**编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象**。</span><br><span class="line">- 所以**推荐在循环中拼接字符串时应该事先在循环外面声明好StringBuilder然后在循环中使用StringBuilder的append()方法**。</span><br><span class="line"></span><br><span class="line">## 字符串常量池的作用了解吗？</span><br><span class="line"></span><br><span class="line">- **字符串常量池（jdk1<span class="number">.7</span>之前在方法区的常量池中，jdk1<span class="number">.7</span>的时候字符串常量池被从常量池中单独拎出来放到了堆中；jdk1<span class="number">.8</span>的时候原本在方法区中的每个类特有的静态域也被放到了堆中，具体存放在堆中类在加载阶段生成的class对象的尾部）** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，**主要目的是为了避免字符串的重复创建**。</span><br><span class="line"></span><br><span class="line">## <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);这句话创建了几个字符串对象？</span><br><span class="line"></span><br><span class="line">- 会创建 <span class="number">1</span> 或 <span class="number">2</span> 个字符串对象。</span><br><span class="line">- 如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中（看这说法应该默认是jdk1<span class="number">.7</span>之后的版本）创建 <span class="number">2</span> 个字符串对象“abc”；反之则只会创建<span class="number">1</span>个。</span><br><span class="line"></span><br><span class="line">## intern方法有什么作用？</span><br><span class="line"></span><br><span class="line">- `String.intern()` 是一个 <span class="keyword">native</span>（本地）方法，**其作用是将指定的字符串对象的引用保存在字符串常量池中**，可以简单分为两种情况：</span><br><span class="line">  <span class="number">1.</span> 如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</span><br><span class="line">  <span class="number">2.</span> 如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</span><br><span class="line"></span><br><span class="line">## String 类型的引用和字面量做“+”运算时发生了什么？</span><br><span class="line"></span><br><span class="line">- 先来看字符串不加 `<span class="keyword">final</span>` 关键字拼接的情况（JDK1<span class="number">.8</span>）：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">  System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">  System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">  System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对于编译期可以确定值的字符串，也就是字面量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串字面量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p>
</li>
<li><p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。<strong>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中</strong>，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p>
</li>
<li><p>所以，对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p>
</li>
<li><p>不过要注意，<strong>并不是所有的常量&#x2F;变量都会进行折叠，只有编译器在程序编译期就可以确定值的常量&#x2F;变量才可以</strong>：</p>
<ul>
<li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串的字面量。</li>
<li><code>final</code> 修饰的基本数据类型和字符串引用</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ul>
</li>
<li><p><strong>引用的值在程序编译期是无法确定的（因为值是地址，非final的地址程序不跑起来定不下来），编译器无法对其进行优化（除非引用是final的，final的引用的值在编译期是确定的）。</strong></p>
</li>
<li><p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。所以我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p>
</li>
<li><p>不过，<strong>字符串引用使用的都是被 <code>final</code> 关键字修饰的字符串引用时，可以让编译器把这个引用当做字面量来做优化处理，因为final引用的值在编译期就会被确定</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p>
</li>
<li><p>如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> getStr();</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 在堆上创建的新的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>总之就是一点，看编译时变量&#x2F;常量的值是否能被确定，如果能，那么编译器就会做常量折叠优化；反之则不做优化</strong>。</p>
</li>
</ul>
<h2 id="Java异常类层次结构图概览"><a href="#Java异常类层次结构图概览" class="headerlink" title="Java异常类层次结构图概览"></a>Java异常类层次结构图概览</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230220221230590.png" alt="image-20230220221230590"></p>
<h2 id="Exception和Error有什么区别？"><a href="#Exception和Error有什么区别？" class="headerlink" title="Exception和Error有什么区别？"></a>Exception和Error有什么区别？</h2><ul>
<li>在 Java 中，<strong>所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类</strong>。<code>Throwable</code> 类有两个重要的子类:<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
</li>
</ul>
<h2 id="Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="Checked Exception 和 Unchecked Exception 有什么区别？"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h2><ul>
<li><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</li>
<li><strong>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常</strong>。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…</li>
<li><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</li>
<li><strong><code>RuntimeException</code> 及其子类都统称为非受检查异常</strong>，常见的有（建议记下来，日常开发中会经常用到）：<ul>
<li><code>NullPointerException</code>(空指针错误)</li>
<li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li>
<li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li>
<li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li>
<li><code>ClassCastException</code>（类型转换错误）</li>
<li><code>ArithmeticException</code>（算术错误）</li>
<li><code>SecurityException</code> （安全错误比如权限不够）</li>
<li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li>
<li>……</li>
</ul>
</li>
</ul>
<h2 id="Throwable类常用方法有哪些？"><a href="#Throwable类常用方法有哪些？" class="headerlink" title="Throwable类常用方法有哪些？"></a>Throwable类常用方法有哪些？</h2><ul>
<li><code>String getMessage()</code>: 返回异常发生时的简要描述</li>
<li><code>String toString()</code>: 返回异常发生时的详细信息</li>
<li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h2 id="try-catch-finally如何使用？"><a href="#try-catch-finally如何使用？" class="headerlink" title="try-catch-finally如何使用？"></a>try-catch-finally如何使用？</h2><ul>
<li><code>try</code>块 ： 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><code>catch</code>块 ： 用于处理 try 捕获到的异常。</li>
<li><code>finally</code> 块 ： 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到</li>
<li><code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li>
<li><strong>注意：尽量不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</li>
</ul>
<h2 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h2><ul>
<li><p>不一定的！在某些情况下，finally 中的代码不会被执行。就比如说 <strong>finally 之前虚拟机被终止运行</strong>的话，finally 中的代码就不会被执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 终止当前正在运行的Java虚拟机</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//Try to do something</span></span><br><span class="line"><span class="comment">//Catch Exception -&gt; RuntimeException</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p>
<ol>
<li><strong>程序所在的线程死亡</strong>。</li>
<li><strong>关闭 CPU</strong>。</li>
</ol>
</li>
</ul>
<h2 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h2><ul>
<li><p><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</p>
</li>
<li><p><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</p>
</li>
<li><p>《Effective Java》中明确指出：</p>
<blockquote>
<p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p>
</blockquote>
</li>
<li><p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p>
</li>
<li><p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">       <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">      <span class="type">int</span> b;</span><br><span class="line">      <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">          bout.write(b);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">## 异常使用有哪些需要注意的地方？</span><br><span class="line"></span><br><span class="line">- **不要把异常定义为静态变量**，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 <span class="keyword">new</span> 一个异常对象抛出。</span><br><span class="line">- 抛出的异常信息一定**要有意义**。</span><br><span class="line">- 建议**抛出更加具体的异常**比如字符串转换为数字格式错误的时候应该抛出`NumberFormatException`而不是其父类`IllegalArgumentException`。</span><br><span class="line">- **使用日志打印异常之后就不要再抛出异常了**（两者不要同时存在一段代码逻辑中）。</span><br><span class="line">- ......</span><br><span class="line"></span><br><span class="line">## 什么是泛型？有什么作用？</span><br><span class="line"></span><br><span class="line">- **Java 泛型（Generics）** 是 JDK <span class="number">5</span> 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</span><br><span class="line">- 编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 `ArrayList&lt;Person&gt; persons = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;()` 这行代码就指明了该 `ArrayList` 对象只能传入 `Person` 对象，如果传入其他类型的对象就会报错。</span><br><span class="line">- 并且，原生 `List` 返回类型是 `Object` ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</span><br><span class="line">- 说白了**使用泛型其实就是在编译期编译器帮我们保证泛型中泛型参数的类型正确**，如果不使用泛型，我们需要自己来做这些事情，由于泛型只在编译期体现，在运行时泛型的类型参数会被擦除，泛型参数的类型会转换成上界的类型，所以我感觉泛型也是个语法糖。</span><br><span class="line"></span><br><span class="line">## 泛型的使用方式有哪几种？</span><br><span class="line"></span><br><span class="line">- 泛型一般有三种使用方式:**泛型类**、**泛型接口**、**泛型方法**。</span><br><span class="line"></span><br><span class="line">### 泛型类</span><br><span class="line"></span><br><span class="line">- 代码示例：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line">  <span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">private</span> T key;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.key = key;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> key;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如何实例化泛型类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><ul>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，不指定具体类型参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现泛型接口，指定具体类型参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">         System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意: <code>public static &lt;E&gt; void printArray( E[] inputArray )</code> 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以<strong>静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code></strong></p>
</li>
</ul>
<h2 id="项目中哪里用到了泛型？"><a href="#项目中哪里用到了泛型？" class="headerlink" title="项目中哪里用到了泛型？"></a>项目中哪里用到了泛型？</h2><ul>
<li>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</li>
<li>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型</li>
<li>构建集合工具类（参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法）。</li>
<li>……</li>
</ul>
<h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><ul>
<li>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它<strong>赋予了我们在运行时分析类以及执行类中方法的能力</strong>。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</li>
</ul>
<h2 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点?"></a>反射的优缺点?</h2><ul>
<li>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</li>
<li>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li>
</ul>
<h2 id="反射的应用场景？"><a href="#反射的应用场景？" class="headerlink" title="反射的应用场景？"></a>反射的应用场景？</h2><ul>
<li>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring&#x2F;Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</li>
<li><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></li>
<li>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。为什么使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？这些都是因为<strong>可以基于反射分析类，然后获取到类&#x2F;属性&#x2F;方法&#x2F;方法的参数上的注解。获取到注解之后，就可以做进一步的处理</strong>，所以说注解其实就是一个标识，通过反射分析注解这个标识来进行相应的处理。</li>
</ul>
<h2 id="什么是注解？"><a href="#什么是注解？" class="headerlink" title="什么是注解？"></a>什么是注解？</h2><ul>
<li><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，<strong>可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用</strong>。</p>
</li>
<li><p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JDK提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p>
</li>
</ul>
<h2 id="注解的解析方法有哪几种？"><a href="#注解的解析方法有哪几种？" class="headerlink" title="注解的解析方法有哪几种？"></a>注解的解析方法有哪几种？</h2><ul>
<li>注解只有被解析之后才会生效，常见的解析方法有两种：<ol>
<li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li>
</ol>
</li>
</ul>
<h2 id="什么是SPI？"><a href="#什么是SPI？" class="headerlink" title="什么是SPI？"></a>什么是SPI？</h2><ul>
<li>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：<strong>专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口</strong>。</li>
<li>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</li>
<li>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</li>
</ul>
<h2 id="SPI和API有什么区别？"><a href="#SPI和API有什么区别？" class="headerlink" title="SPI和API有什么区别？"></a>SPI和API有什么区别？</h2><h2 id="SPI的优缺点？"><a href="#SPI的优缺点？" class="headerlink" title="SPI的优缺点？"></a>SPI的优缺点？</h2><ul>
<li>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：<ol>
<li>需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</li>
<li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li>
</ol>
</li>
</ul>
<h2 id="什么是序列化？什么是反序列化？"><a href="#什么是序列化？什么是反序列化？" class="headerlink" title="什么是序列化？什么是反序列化？"></a>什么是序列化？什么是反序列化？</h2><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="说一下synchronized锁升级的机制？"><a href="#说一下synchronized锁升级的机制？" class="headerlink" title="说一下synchronized锁升级的机制？"></a>说一下synchronized锁升级的机制？</h2><ul>
<li>首先在JDK1.6之前，synchronized锁是一个重量级锁，其依赖于操作系统的mutex lock命令，而这个命令呢，是内核态的命令，所以跑在用户态的进程需要将自己切换成内核态之后再去进行系统调用，这样做会有很大的性能损耗，特别是在争抢锁的线程较少的情况下，所以在JDK1.6之后，设计师们引入了偏向锁和轻量级锁来实现synchronized的锁升级机制。</li>
<li>当只有一个线程来拿锁的时候，synchronized是一个偏向锁的机制，<strong>偏向锁会把提供监视器的对象的对象头中记录下当前线程的id</strong>，当下次这个线程来拿锁的时候，可以直接获取到，这样实际上就是对单线程条件下的优化。</li>
<li>当之后多个线程来的时候，synchronized会升级成<strong>用CAS+自旋实现的轻量级锁</strong>，所有没有获取到锁的线程会进行自旋尝试获取到锁，这样的操作不会阻塞线程，但是如果线程较多的情况下，线程为了获取到锁进行的自旋次数也会变多，这样的自旋是很耗费cpu的性能的。</li>
<li>如果自旋次数过多还没能获取到锁，synchronized会升级成重量级锁，<strong>重量级锁就是之前说过的依赖于操作系统的mutex lock命令，在JVM层面上是依赖于monitorenter和monitorexit命令来获取对象的同步监视器monitor</strong>，这俩命令一个指向同步代码段的开头，一个指向结尾，当线程想要获取锁的时候，要先检查monitor的计数器是否是0，如果是0说明可以获取，让计数器++，如果不是0，那么线程阻塞等待。</li>
</ul>
<h2 id="为什么ConcurrentHashMap的key和value不能为空？"><a href="#为什么ConcurrentHashMap的key和value不能为空？" class="headerlink" title="为什么ConcurrentHashMap的key和value不能为空？"></a>为什么ConcurrentHashMap的key和value不能为空？</h2><ul>
<li>这是为了<strong>避免在多线程的情况下产生歧义</strong>，因为在多线程的条件下，如果我们尝试去获取ConcurrentHashMap的key或者value返回了null，那么我们是不能确定到底是key或者value不存在还是本身那个值就是null，如果在单线程下，我们可以通过containsKey这样的方法来求证，但是在多线程下，使用containsKey方法的时候，另外一个线程可以将键值对插入到了那个位置，这就导致containsKey可能返回的值不确定，也就无法求证到底是那两种情况的哪种情况，这样的问题实际上是一个线程同步问题，而ConcurrentHashMap又是线程安全的，所以ConcurrentHashMap不允许出现这样的问题。</li>
</ul>
<h2 id="为什么ThreadLocalMap的key是弱引用？"><a href="#为什么ThreadLocalMap的key是弱引用？" class="headerlink" title="为什么ThreadLocalMap的key是弱引用？"></a>为什么ThreadLocalMap的key是弱引用？</h2><ul>
<li>我们都知道ThreadLocalMap的key是ThreadLocal的弱引用，为什么要这样设计呢？实际上这是<strong>为了防止内存泄漏</strong>而设计的。</li>
<li>想象一个场景，我们在使用ThreadLocal的时候，我们new了一个ThreadLocal对象，然后用一个强引用指向了它，同时这个ThreadLocal也被Thread中的ThreadLocalMap的key指向了，如果key是强引用，那么当我们不想用这个ThreadLocal从而将我们自己创建的那个强引用改变指向之后，由于还有强引用指向那个ThreadLocal，所以它的空间是永远不会被gc的，在极端情况下就会出现内存泄漏，所以我们将key设置成ThreadLocal的弱引用，这样在ThreadLocal不存在外界的强引用的时候，在下一次gc中会被回收，减少出现内存泄漏问题的概率。</li>
</ul>
<h2 id="为什么ThreadLocalMap的value不是弱引用？"><a href="#为什么ThreadLocalMap的value不是弱引用？" class="headerlink" title="为什么ThreadLocalMap的value不是弱引用？"></a>为什么ThreadLocalMap的value不是弱引用？</h2><ul>
<li>因为<strong>大多数情况下外界不对value有强引用</strong>，我们归根结底还是要通过ThreadLocal这个key从ThreadLocalMap得到value的，这个可以想一下我们平时使用ThreadLocal的场景，我们是通过ThreadLocal这个key来去找value，所以value通常在外界没有强引用，所以如果value是弱引用的话，很容易就被gc掉了，这就导致我们使用ThreadLocal的get方法的时候返回值是null，这显然不是我们期望的结果。</li>
</ul>
<h2 id="ThreadLocal在我的项目中的使用"><a href="#ThreadLocal在我的项目中的使用" class="headerlink" title="ThreadLocal在我的项目中的使用"></a>ThreadLocal在我的项目中的使用</h2><ul>
<li>在使用Feign进行远程调用的时候，http header中的信息会重置，因为Feign本质上是创建了一个新的http报文来进行远程通信，那么如果我们想要Feign在进行远程调用的时候保留http header怎么办？</li>
<li>Feign提供了拦截器组件，拦截器链会在创建http报文之前执行，所以我们只需要向IOC容器中加入一个继承了Feign提供的拦截器类的类，然后重写拦截器方法，指定Feign创建http报文的header，那么问题又来了，这个header去哪取？</li>
<li>很明显我们需要从当前线程中获取，所以我们可以在请求打过来的时候使用Spring MVC的拦截器来拦截请求，并使用ThreadLocal来记录这个请求的header，然后再在Feign的拦截器中取出这个header给新的header赋值。</li>
</ul>
<h2 id="线程池怎么关闭？"><a href="#线程池怎么关闭？" class="headerlink" title="线程池怎么关闭？"></a>线程池怎么关闭？</h2><ul>
<li>JDK1.8中，线程池的停止一般使用shutdown()、shutdownNow()方法。</li>
</ul>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h3><ul>
<li>有序关闭，已提交的任务继续执行</li>
<li>不接受新任务</li>
</ul>
<h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h3><ul>
<li>尝试停止所有正在执行的任务</li>
<li>停止等待执行的任务，并返回等待执行的任务列表</li>
</ul>
<h3 id="shutdown-和shutdownNow-的异同"><a href="#shutdown-和shutdownNow-的异同" class="headerlink" title="shutdown()和shutdownNow()的异同"></a>shutdown()和shutdownNow()的异同</h3><ul>
<li>调用 shutdown() 和 shutdownNow() 方法关闭线程池，线程池都无法接收新的任务。</li>
<li>shutdown() 方法会继续执行正在执行未完成的任务，shutdownNow() 方法会尝试停止所有正在执行的任务。</li>
<li>shutdown() 方法没有返回值，shutdownNow() 方法返回等待执行的任务列表。</li>
<li>awaitTermination(long timeout, TimeUnit unit) 方法可以获取线程池是否已经关闭，需要配合 shutdown() 使用。</li>
<li>shutdownNow() 不一定能够立马结束线程池，该方法会尝试停止所有正在执行的任务，通过调用 Thread.interrupt() 方法来实现的，如果线程中没有 sleep() 、wait()、Condition、定时锁等应用，interrupt() 方法是无法中断当前的线程的。</li>
</ul>
<h2 id="阻塞队列有哪些？"><a href="#阻塞队列有哪些？" class="headerlink" title="阻塞队列有哪些？"></a>阻塞队列有哪些？</h2><ol>
<li><p><strong>ArrayBlockingQueue ：由数组结构组成的有界阻塞队列</strong>。用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下 不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当 队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入 元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐 量。我们可以使用以下代码创建一个公平的阻塞队列：ArrayBlockingQueue fairQueue &#x3D; new  ArrayBlockingQueue(1000,true);  </p>
</li>
<li><p><strong>LinkedBlockingQueue ：由链表结构组成的有界阻塞队列</strong>。基于链表的阻塞队列，同ArrayListBlockingQueue类似，此队列按照先进先出（FIFO）的原则对 元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者 端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费 者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br>LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE）。 </p>
</li>
<li><p><strong>PriorityBlockingQueue ：支持优先级排序的无界阻塞队列</strong>。是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现 compareTo()方法来指定元素进行排序规则，或者初始化 PriorityBlockingQueue 时，指定构造 参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。 </p>
</li>
<li><p><strong>DelayQueue：使用优先级队列实现的无界阻塞队列</strong>。是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实 现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将DelayQueue运用在以下应用场景： </p>
<ul>
<li>缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。<br>定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从 DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。</li>
</ul>
</li>
<li><p><strong>SynchronousQueue：不存储元素的阻塞队列</strong>。是一个<strong>不存储元素</strong>的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。 SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给 另外一个线程使用，SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue</p>
</li>
<li><p><strong>LinkedTransferQueue：由链表结构组成的无界阻塞队列</strong>。是一个由链表结构组成的无界阻塞 TransferQueue 队列。相对于其他阻塞队列， LinkedTransferQueue多了 tryTransfer 和transfer方法。</p>
<ul>
<li>transfer 方法：如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的 poll()方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如 果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素 被消费者消费了才返回。</li>
<li>tryTransfer 方法：则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费 者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否 接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。 </li>
<li>对于带有时间限制的tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传 入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时 还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</li>
</ul>
</li>
<li><p><strong>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</strong>。是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。 双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其 他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast， peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队 列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的后一个元素。另 外插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同 于takeFirst，不知道是不是Jdk的bug，使用时还是用带有First和Last后的方法更清楚。 在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在 “工作窃取”模式中。</p>
</li>
</ol>
<h1 id="JVM-1"><a href="#JVM-1" class="headerlink" title="JVM"></a>JVM</h1><h2 id="java对象在堆中的结构"><a href="#java对象在堆中的结构" class="headerlink" title="java对象在堆中的结构"></a>java对象在堆中的结构</h2><ul>
<li>主要是分为三部分：<strong>对象头、实例数据、对齐填充</strong></li>
</ul>
<h3 id="对象头（header）"><a href="#对象头（header）" class="headerlink" title="对象头（header）"></a>对象头（header）</h3><ul>
<li>分为两大块，第一块是<strong>占8个字节的markword，其中存放着锁信息、hashcode、GC信息</strong>，第二块是<strong>占4个字节（压缩前是8个字节，默认压缩）的类型指针（class pointer），这个没啥好说的，就是存放的是这个对象的类的元数据（在方法区中）的地址</strong>。</li>
<li>也就是说一般情况下对象头占12个字节。</li>
<li>平时所说的拿到了对象的锁，实际上从底层来看就是修改了对象头中的markword中的锁信息</li>
<li>在调用一次hashcode方法之后，这个对象的hashcode就会被记录到对象头的markword中，下次使用到的时候可以直接拿</li>
<li>对象头的markword中的GC信息记录的是这个对象的GC分代年龄</li>
</ul>
<h3 id="实例数据（instance-data）"><a href="#实例数据（instance-data）" class="headerlink" title="实例数据（instance data）"></a>实例数据（instance data）</h3><ul>
<li>这一部分<strong>存放着对象的所有实例属性</strong>。</li>
</ul>
<h3 id="对齐填充（padding）"><a href="#对齐填充（padding）" class="headerlink" title="对齐填充（padding）"></a>对齐填充（padding）</h3><ul>
<li>所有对象的大小（以字节为单位）都是8的倍数，这是为了契合64位处理器的位宽，这也是64位处理器能一次处理的数据大小（也就是一个字长的大小），所以对于那些前两个部分加起来不是8的倍数的对象，我们要<strong>补齐最后一段，从而让对象的大小是8的倍数</strong>，这一部分仅作补齐，没有其他含义。</li>
</ul>
<h2 id="对象如何定位"><a href="#对象如何定位" class="headerlink" title="对象如何定位"></a>对象如何定位</h2><ul>
<li>当用一个引用指向一个对象的时候，这个引用是如何找到那个对象的呢？</li>
</ul>
<h3 id="通过指针直接定位"><a href="#通过指针直接定位" class="headerlink" title="通过指针直接定位"></a>通过指针直接定位</h3><ul>
<li>这种方式也是hotspot虚拟机使用的方式，<strong>引用中存放着的是对象的地址</strong>，通过引用可以直接访问到对象。</li>
<li>好处就是<strong>访问效率高</strong>，坏处就是GC的时候对象会移动，而引用的值也要随之而改变，<strong>GC效率相较间接定位的方式偏低</strong>。</li>
</ul>
<h3 id="通过句柄间接定位"><a href="#通过句柄间接定位" class="headerlink" title="通过句柄间接定位"></a>通过句柄间接定位</h3><ul>
<li>这种方式，<strong>引用中存放的是一个句柄的地址</strong>，而这个<strong>句柄中又有两个直接指针分别指向对象和它的类的元数据</strong>，这种方式相当于通过句柄间接访问对象。</li>
<li>句柄通常存放在句柄池中，而<strong>句柄池通常是在堆中</strong>。</li>
<li>这种方式的好处在于，在进行GC的时候，内存中的对象的位置通常会发生改变（），而使用这种间接定位的方式，由于引用指向的是句柄，而句柄的位置不变，所以引用的值不需要改变，由于引用的值控制着很多GC的参数，所以它不变的话<strong>可以提高GC的效率</strong>。坏处就在于需要两次才能定位对象，<strong>定位的效率相较直接定位方式偏低</strong>。</li>
</ul>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="谈谈你对IO多路复用的理解？"><a href="#谈谈你对IO多路复用的理解？" class="headerlink" title="谈谈你对IO多路复用的理解？"></a>谈谈你对IO多路复用的理解？</h2><ul>
<li>IO多路复用是一种同步的IO模型，利用IO多路复用模型，我们可以使用一个或多个线程处理多个TCP连接而无需创建和维护过多的线程，IO多路复用有三种实现模型，分别是select模型、poll模型、epoll模型。</li>
<li></li>
</ul>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring中Bean的Scope是Singleton的时候Bean是单例模式吗？"><a href="#Spring中Bean的Scope是Singleton的时候Bean是单例模式吗？" class="headerlink" title="Spring中Bean的Scope是Singleton的时候Bean是单例模式吗？"></a>Spring中Bean的Scope是Singleton的时候Bean是单例模式吗？</h2><ul>
<li>是，但是这里的单例模式的作用范围非常小，只是作用在相同名字的范围，而并非我们通常说的单例模式一样是作用在同一类型上的，也就是说，<strong>平时我们说的单例模式是指一个类的对象只能有一个，而Spring中Bean的Singleton是指相同名字的对象只能有一个</strong>，也就是说如果我们新建一个Bean也是同一个类的对象，但是名字不同，这俩对象是不同的，如果说是我们平时说的那种单例模式的话，这俩对象就应该是相同的。</li>
</ul>
<h2 id="Spring中Bean的生命周期？"><a href="#Spring中Bean的生命周期？" class="headerlink" title="Spring中Bean的生命周期？"></a>Spring中Bean的生命周期？</h2><ul>
<li><strong>推断构造器</strong>：对于Spring来说，想要创建一个Bean的实例，首先就要推断用那个类的哪个构造器，如果其中只有一个构造器，那么Spring就会用唯一的哪个构造器；如果其中有多个构造方法，那么Spring会尝试去找无参构造器，如果找到了就用，如果没找到，Spring就会不知道使用哪个构造器，只能报错。同时我们也<strong>可以在我们想要使用的构造器上加上@Autowired注解来手动指定我们想用的构造器</strong>。</li>
<li><strong>实例化</strong>：Spring会使用上一步选中的构造器来实例化对应的Bean。</li>
<li>—————————————————–以上是Bean的实例化，以下是Bean的初始化———————————————————-</li>
<li><strong>填充属性</strong>：对Bean中使用了依赖注入注解的属性注入依赖。</li>
<li><strong>处理Aware回调</strong>：如果Bean的类实现了类似于BeanFactoryAware这样的接口，那么Spring会在这一步调用Bean中重写的那些接口中的方法，相当于是Spring把其内部的一些东西暴露给开发者来进行使用。</li>
<li><strong>初始化前，处理@PostConstruct注解</strong>：如果Bean中有方法上面有@PostConstruct注解，那么Spring会在这一步调用被那个注解修饰的方法。</li>
<li><strong>初始化，处理InitializingBean接口</strong>：如果Bean的类实现了InitializingBean接口，那么类中就要重写afterPropertiesSet方法，那个方法就是在这一步被Spring调用。当然也可以在xml文件中指定这一步要调用的方法。这一步可以做一些属性校验。</li>
<li><strong>初始化后，进行AOP</strong>：通过织入切面得到代理对象，此时Bean初始化完成，这个代理对象就是后面我们要使用的Bean。如果没有要织入的切面，那就直接使用Bean对象。</li>
</ul>
<h2 id="Spring-AOP是如何实现的？它和AspectJ有什么区别？"><a href="#Spring-AOP是如何实现的？它和AspectJ有什么区别？" class="headerlink" title="Spring AOP是如何实现的？它和AspectJ有什么区别？"></a>Spring AOP是如何实现的？它和AspectJ有什么区别？</h2><ul>
<li><strong>Spring AOP是使用了动态代理技术</strong>，如果Bean的类没有实现接口，那么使用的是<strong>Cglib动态代理</strong>，它用的是ASM字节码增强技术，这个技术会在解释运行字节码文件的时候动态对字节码进行改变（这也是为什么不使用AOT的原因），不需要被代理的类实现接口，因为其原理是生成一个被代理类的子类作为代理类，所以如果被代理类是final的就不能使用Cglib动态代理了；如果Bean的类实现了接口，那么使用的是<strong>JDK动态代理</strong>来生成被实现接口的代理对象。</li>
<li><strong>AspectJ是增强的静态代理</strong>，在<strong>对java文件进行编译的时候，会把切面织入到切入点中，也就是说编译形成的字节码文件本身就带着通知的逻辑</strong>，这就是作用在编译期的静态代理，使用AspectJ<strong>需要使用针对AspectJ的特殊编译器来编译文件</strong>。增强体现在相对于普通的静态代理，它不要求被代理类实现接口。</li>
<li><strong>Spring AOP沿用了AspectJ的部分注解</strong>，比如@Before、@After、@Around等，但是它们的底层原理是截然不同的。</li>
</ul>
<h2 id="Spring中的事务是如何实现的？"><a href="#Spring中的事务是如何实现的？" class="headerlink" title="Spring中的事务是如何实现的？"></a>Spring中的事务是如何实现的？</h2><h2 id="Spring事务什么时候失效？"><a href="#Spring事务什么时候失效？" class="headerlink" title="Spring事务什么时候失效？"></a>Spring事务什么时候失效？</h2><ul>
<li>由于Spring事务是使用Spring AOP实现的，而Spring AOP的原理又是动态代理，如果使用的是Cglib动态代理，那么生成的代理类是被代理类的子类，而对原方法的增强是通过代理类重写被代理类的方法来实现的，这也就意味着<strong>被代理类中的private方法和final方法是无法被代理的</strong>，因为生成的代理类中压根无法重写目标方法来对其进行增强。</li>
<li>如果<strong>在事务方法中手动调用本类中的其他方法</strong>，事务也会失效，因为这样做相当于通过this来调用本类的方法，而this是当前类的实例而非代理对象，所以调用的方法是没有事务特性的。</li>
<li>如果<strong>对象未注册到IOC容器中</strong>，事务注解也会失效，因为无法生成代理Bean</li>
<li><strong>错误的事务传播特性</strong>也会导致事务失效</li>
<li><strong>内部处理了异常没有往外抛或者手动抛了除指定外的其他异常</strong>，spring的事务也会失效</li>
</ul>
<h2 id="Spring是如何解决循环依赖的？"><a href="#Spring是如何解决循环依赖的？" class="headerlink" title="Spring是如何解决循环依赖的？"></a>Spring是如何解决循环依赖的？</h2><ul>
<li>多个Bean中相互持有对方的引用，就会产生循环依赖问题，循环依赖会导致Bean在依赖注入的时候造成死循环，有三种基本的形态，第一种是两个Bean之间互相依赖，第二种是三个以上的Bean之间互相依赖，第三种是一个Bean自己依赖自己。</li>
<li>Spring设计了三级缓存去解决循环依赖的问题，<strong>一级缓存存放已经初始化完成的Bean，二级缓存存放刚实例化完成的Bean，三级缓存存放对应Bean的工厂</strong></li>
<li>当获取一个Bean的时候，Spring会先从一级缓存去找，然后再从二级缓存去找，如果都没有找到，说明当前要获取的这个Bean还没有实例化，于是Spring会先对这个Bean进行实例化操作（注意只是实例化操作，初始化操作没有做，这也就意味着这个Bean中的属性还没有被注入依赖），然后Spring会判断这个Bean是否存在循环依赖问题，如果不存在，那么直接执行下面的内容直到Bean初始化完之后放到一级缓存中，如果存在，那么Spring会先把当前这个刚实例化完的Bean放入到二级缓存中，然后去尝试创建它依赖的那个Bean，那个Bean依赖着之前那个Bean，但是由于之前那个Bean的半成品已经进二级缓存了，所以这个Bean就能顺利走完初始化步骤，然后进入一级缓存，这时又回到了之前那个Bean的初始化步骤，从一级缓存中拿到依赖的那个Bean往下走，初始化完之后也进入一级缓存并从二级缓存中删掉它的引用。</li>
<li>上面说的情况是两个Bean不存在创建代理对象步骤的时候，如果需要创建代理对象，那么就不能用上面的方法解决循环依赖问题了，因为创建代理对象是在初始化后做的，而它们互相依赖的都是它们的代理对象，前面把实例化后的半成品放到二级缓存中会让后面的Bean引用前面的Bean本身而不是它的代理，这种情况就需要前面的Bean在实例化完之后把自己的一个工厂放到三级缓存中，当后面的Bean想要注入依赖的时候需要从三级缓存中用对应的工厂来得到前面的Bean，这个<strong>工厂实际上会执行AOP步骤中的提前创建代理对象的方法，也就是会提前创建好代理对象，把提前创建好的代理对象放到二级缓存中</strong>，然后后面的Bean就可以使用了。所以这样做就解决了Spring循环依赖的问题。</li>
</ul>
<h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><h2 id="叙述一下Spring-Boot自动装配机制的原理？"><a href="#叙述一下Spring-Boot自动装配机制的原理？" class="headerlink" title="叙述一下Spring Boot自动装配机制的原理？"></a>叙述一下Spring Boot自动装配机制的原理？</h2><ul>
<li>自动装配简单来说就是<strong>自动去把第三方组件的Bean装载到IOC容器中</strong>，不需要开发人员再去写bean相关配置，要想开启自动装配，我们只需要在启动类上加上@SpringBootApplication注解就可以实现自动装配了，但是这个注解是个复合注解，实际上自动装配是<strong>通过使用@EnableAutoConfiguration注解来进行开启</strong>的。</li>
<li>自动装配的实现主要依靠三个核心的关键技术：<ol>
<li>引入Starter启动依赖组件的时候，这个组件中必须包含一个带有**@Configuration注解的配置类<strong>，在这个配置类中我们需要使用</strong>@Bean注解来声明需要装配到IOC容器里面的Bean对象**。</li>
<li>这个配置类是放在第三方的jar包中的，然后通过Spring Boot中<strong>约定大于配置</strong>的理念，去把这个<strong>配置类的全路径放在classpath:&#x2F;META-INF&#x2F;spring.factories文件中</strong>，这样spring就可以知道这个配置类在第三方jar包中的位置，这个步骤主要是用到了spring中<strong>SpringFactoriesLoader</strong>来完成的。</li>
<li>Spring Boot在拿到所有第三方jar包里面声明的配置类之后，再通过spring提供的<strong>ImportSelector接口</strong>来实现对这些配置类的<strong>动态加载</strong>从而去完成动态装配的动作。</li>
</ol>
</li>
<li>在我看来，SpringBoot是约定优于配置这一理念下的一个产物，所以在很多地方都能看到这样的思想，它的出现可以<strong>让开发人员更多地聚焦在业务代码的编写上，而不需要去关心和业务无关的配置</strong>。</li>
<li>@EnableXxxxxx注解的实现实际上也是帮我们去自动完成相关Bean的注入而不需要我们去手动配置需要的Bean。</li>
</ul>
<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><ul>
<li>MyBatis中提供的这两种占位符都是去实现动态SQL的一种方式，通过这两种方式可以把参数传递到SQL语句里面，在执行操作之前，MyBatis会对这两个占位符进行动态的解析，#占位符等同于jdbc里面的一个?占位符，它相当于向PreparedStatement的里面的预处理语句设置参数，而PreparedStatement里面的SQL语句是经过预编译的，在这个SQL语句中使用到了占位符来规定SQL语句的结构，并且<strong>在设置参数的时候如果有特殊字符会自动进行转义，如果参数是表名什么的还会自动加上单引号</strong>，所以#占位符可以防止SQL注入，因为语法的特殊字符给转义了；而使用$号传参相当于直接把参数拼接到了原始SQL里面，MyBatis不会对它进行任何的特殊处理，所以会存在SQL注入的风险。</li>
<li>所以$和#的区别在于，前者是动态参数，后者是占位符，动态参数无法防止SQL注入的一个问题，所以在实际应用中应该尽可能地去使用#占位符，另外$符号的动态传参可以适合应用在一些动态SQL的场景里面，比如说动态传递表明或者动态设置排序字段等。</li>
</ul>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI-七层模型是什么？每一层的作用是什么？"><a href="#OSI-七层模型是什么？每一层的作用是什么？" class="headerlink" title="OSI 七层模型是什么？每一层的作用是什么？"></a>OSI 七层模型是什么？每一层的作用是什么？</h2><ul>
<li>应用层：为计算机用户提供服务</li>
<li>表示层：数据处理（编解码、加密解密、压缩解压缩）</li>
<li>会话层：管理（建立、维护、重连）应用程序之间的会话</li>
<li>传输层：为两台主机进程之间的通信提供的通用的数据传输服务</li>
<li>网络层：路由和寻址（决定数据在网络上的游走路径）</li>
<li>数据链路层：对数据进行封装成帧、透明传输、差错校验（CRC循环冗余校验）</li>
<li>物理层：确定如何表示比特（比如高电平表示1，低电平表示0），确定比特如何传输（通过光缆、同轴电缆等），透明地传输比特流数据</li>
</ul>
<h2 id="TCP-x2F-IP-四层模型是什么？每一层的作用是什么？"><a href="#TCP-x2F-IP-四层模型是什么？每一层的作用是什么？" class="headerlink" title="TCP&#x2F;IP 四层模型是什么？每一层的作用是什么？"></a>TCP&#x2F;IP 四层模型是什么？每一层的作用是什么？</h2><h2 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h2><ul>
<li>HTTP传输的数据是明文，很容易出现安全问题，而HTTPS传输的数据是密文，它结合了<strong>SSL&#x2F;TLS和TCP协议</strong>，对通信数据进行了加密。</li>
<li>对于SSL&#x2F;TLS协议来说，为了安全起见，应该使用非对称加密机制来保证数据的安全，也就是说发送方使用公钥进行加密，接收方使用私钥进行解密。</li>
<li>但是由于非对称加密体制需要的计算量较大，所以这样做数据传输效率会比较低，所以<strong>实际上SSL&#x2F;TLS协议是使用对称加密机制来保证数据安全的</strong>，也就是说通信双方都通过同一个公钥进行加密和解密，这样做数据的安全性实际上就是依赖于公钥的保密程度，因为加密和解密算法通常是公开的。</li>
<li>但是采用这种对称的加密方案的话，公钥的传输又是一个问题，因为接收方如果想要解析数据，就需要发送方发送的公钥，当发送方发送公钥的时候，如果敌手截取了发送方发送的公钥，那么敌手可以伪造一个公钥给接收方发过去，这样接收方之后发送消息都会通过这个伪造的公钥进行加密，这样敌手获取这个数据之后通过自己的私钥进行解密，就能获得明文了，而发送方和接收方对于这个敌手一无所知。</li>
<li>所以我们引入了<strong>第三方可信的证书颁发机构CA</strong>，如果发送方想要给接收方发送公钥，就要先向CA申请一个证书，CA会把包括要发送的<strong>公钥</strong>在内的数据做成<strong>证书</strong>，然后使用<strong>报文摘要算法</strong>对证书进行计算得到<strong>散列码</strong>，同时CA使用自己的<strong>私钥</strong>对得到的散列码进行<strong>加密</strong>，这样生成的数据就是CA对这个证书的<strong>数字签名</strong>，这个数字签名可以用来判断证书是否有效。</li>
<li>CA做完上面的操作之后把证书+签名交给发送方，发送方把这些数据发送给接收方，接收方收到之后会使用CA的<strong>公钥</strong>来对数字签名进行<strong>解密</strong>，并对证书数据进行相同的<strong>报文摘要算法</strong>，将计算结果和解密后的数字签名<strong>进行比较</strong>，如果相同，说明证书有效，如果不相同，说明证书无效。</li>
<li>当引入CA之后，如果敌手截获了CA的证书+签名，那么敌手也没有什么可以做的，敌手如果篡改证书数据而不改签名的话，接收方就会发现证书无效而不予使用，如果敌手想要篡改证书数据又篡改签名的话，由于不知道CA的私钥，所以无法对生成的散列码进行加密，这种情况同样也会被接收端验证出来证书无效。</li>
<li>总的来说<strong>SSL&#x2F;TLS是通过对称加密数据和通过证书发送公钥的方式来实现数据的安全传输的</strong>。</li>
</ul>
<h2 id="HTTP1-0、1-1、2-0、3-0之间的区别？"><a href="#HTTP1-0、1-1、2-0、3-0之间的区别？" class="headerlink" title="HTTP1.0、1.1、2.0、3.0之间的区别？"></a>HTTP1.0、1.1、2.0、3.0之间的区别？</h2><h2 id="TCP网络传输中的粘包问题是什么意思？"><a href="#TCP网络传输中的粘包问题是什么意思？" class="headerlink" title="TCP网络传输中的粘包问题是什么意思？"></a>TCP网络传输中的粘包问题是什么意思？</h2><ul>
<li>首先明确<strong>TCP协议是流式协议</strong>，这也就意味着使用TCP协议传输数据的话，数据是以字节流来进行传输的，此时<strong>如果我们不用一种机制来确定信息的边界，就会出现粘包问题</strong>，比如A向B发消息，第一个消息转换成字节流是50个字节，第二个消息转换成字节流是100个字节，如果消息的边界无法确认，接收端就可能一次性接收150个字节，这样信息就乱了，两个包像是粘在一起了一样，所以叫粘包。</li>
<li>所以如果想实现两端的正常通信，只使用TCP协议是不行的，还需要去规定一些额外的东西，应用层用到TCP的协议（比如HTTP、FTP等）都在TCP协议的基础上规定了很多额外的东西，正是因为有这些规定，应用层协议的功能才能得以实现。</li>
</ul>
<h2 id="如何解决TCP网络传输中的粘包问题？"><a href="#如何解决TCP网络传输中的粘包问题？" class="headerlink" title="如何解决TCP网络传输中的粘包问题？"></a>如何解决TCP网络传输中的粘包问题？</h2><ul>
<li>既然粘包问题是由于接收方无法确定信息边界而产生的，所以要解决这个问题可以从这个方面着手：<ol>
<li>我们可以<strong>约定一个包的大小</strong>，也就是发送方发送和接收方解析都按照这个固定大小来进行解析，这种通信协议的<strong>格式简单但灵活性差</strong>。<strong>如果包内容不足指定的字节数，剩余的空间需要填充特殊的信息</strong>，如 \0（如果不填充特殊内容，如何区分包里面的正常内容与填充信息呢？）；<strong>如果包内容超过指定字节数，又得分包分片</strong>，需要增加额外处理逻辑——在发送端进行分包分片，在接收端重新组装包片。</li>
<li>我们还可以<strong>指定特定的字符（串）为包的结束标志</strong>，这种协议包比较常见，即字节流中遇到特殊的符号值时就认为到一个包的末尾了。例如，我们熟悉的 FTP协议，发邮件的 SMTP 协议，一个命令或者一段数据后面加上”\r\n”（即所谓的 <strong>CRLF</strong>）表示一个包的结束。对端收到后，每遇到一个”\r\n“就把之前的数据当做一个数据包。这种协议一般用于一些包含各种命令控制的应用中，其<strong>不足之处就是如果协议数据包内容部分需要使用包结束标志字符，就需要对这些字符做转码或者转义操作，以免被接收方错误地当成包结束标志而误解析（数据链路层的透明传输也是这个思路）</strong>。</li>
<li>我们还可以<strong>使用包头+包体的格式来构建一个包</strong>，这种格式的包一般分为两部分，即包头和包体，包头是固定大小的，且包头中必须含有一个字段来说明接下来的包体有多大。各协议对包头的定义各不相同，而且解包和处理需要进行额外的操作，这也是各协议需要设计的地方。</li>
</ol>
</li>
</ul>
<h2 id="为什么有HTTP1-1不用，要用RPC协议？"><a href="#为什么有HTTP1-1不用，要用RPC协议？" class="headerlink" title="为什么有HTTP1.1不用，要用RPC协议？"></a>为什么有HTTP1.1不用，要用RPC协议？</h2><ul>
<li>因为RPC协议的<strong>定制化程度更高</strong>，可以<strong>采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据</strong>，同时也<strong>不需要像 HTTP 那样考虑各种浏览器行为</strong>，比如 302 重定向跳转啥的。</li>
<li>总而言之就是从微服务的互相调用来看，RPC协议的性能比HTTP1.1要好</li>
<li>但是在2015年HTTP出了2.0版本，这个版本在HTTP1.1上做了优化，性能较RPC更好，但是由于它出的晚，很多公司内部已经使用RPC好多年了，所以也没必要大费周章地换了。</li>
</ul>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h2><ol>
<li>操作系统是管理计算机硬件与软件资源的程序，是计算机的基石。</li>
<li></li>
</ol>
<h2 id="多级反馈队列调度算法了解吗？"><a href="#多级反馈队列调度算法了解吗？" class="headerlink" title="多级反馈队列调度算法了解吗？"></a>多级反馈队列调度算法了解吗？</h2><ul>
<li>多级反馈队列调度算法实际上是一种<strong>进程调度算法</strong>，它很好地<strong>融合了先来先服务、短作业优先、优先级、时间片轮转这几种进程调度算法的优势</strong>，这种进程调度算法<strong>使得优先级高的进程能快速得到响应的同时又保证了短作业能快速完成</strong>，这也是Unix系统中使用的进程调度算法。</li>
<li>其工作原理主要就是<strong>划分了多个优先级队列</strong>，每个队列存放不同优先级的进程，然后<strong>每个队列都有属于自己的时间片长度</strong>，<strong>优先级越高的队列时间片的长度越小</strong>（这样其实就是保证了高优先级作业能快速得到响应但是不一定会被处理完，而由于不用等待前面的作业处理完后再处理后面的作业，所以低优先级的短作业会很快被处理完）。</li>
<li>进行进程调度时会<strong>先从优先级高的队列开始</strong>，用<strong>先来先服务</strong>的方式去<strong>使用队列对应的时间片</strong>来让进程运行，如果在<strong>一个时间片内</strong>运行完毕，那个进程就可以直接退出系统了，如果在一个时间片内没有运行完毕，那么这个进程将会<strong>进入下一个队列的队尾中</strong>，以此类推，直到进程进入最后一个队列的队尾，该算法<strong>对最后一个队列的进程采用的时间片轮转的调度方法</strong>。</li>
<li>只有在<strong>处理完一个队列之后才会处理下一个队列</strong>，但是如果在处理优先级较低的队列时有优先级较高的进程进入了优先级较高的队列，那么处理机会将当前处理的进程放在当前队列的队尾，然后<strong>立即去处理刚来的较高优先级的进程</strong>。</li>
</ul>
<h2 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h2><ul>
<li>我认为虚拟内存是操作系统<strong>对于物理内存的抽象和封装</strong>，也就是说操作系统通过抽象和封装物理内存来<strong>给进程提供一个逻辑上连续且完整的地址空间</strong>，而这些所谓连续且完整的内存空间<strong>可能在物理层面是离散的</strong>，而且<strong>可能有部分是使用的磁盘上的空间</strong>，这样的做法使得<strong>计算机好像为用户提供了比实际内存大得多的内存空间</strong>，这实际上就是虚拟内存的概念。</li>
<li>这样做的好处主要有三个：<ol>
<li>首先就是我们在编写大型应用程序的时候，我们面向的地址空间是操作系统给我们提供的虚拟内存空间，这个空间总是<strong>连续且完整</strong>的，这<strong>给我们进行软件开发带来了极大的便利</strong>。</li>
<li>其次就是<strong>防止出现地址冲突的问题</strong>，如果操作系统直接将物理地址暴露给进程，那么进程可能会有意或无意地触碰到那些已经在使用地内存空间，这样可能会造成别的进程乃至操作系统的崩溃，但是如果进程面向的是虚拟内存空间就不会出现这种情况，因为虚拟地址会通过操作系统的调控再转换为物理地址，操作系统不会让这种情况发生。</li>
<li>再者就是使用虚拟内存<strong>消除了计算机同时运行多个程序带来的安全问题</strong>，如果操作系统将物理内存暴露，那么不同的人在编写应用程序的时候可能使用了相同的物理内存，这样不同的程序在同一个计算机上运行的时候就会出现问题，使用虚拟内存就不会出现这样的问题，因为操作系统会动态调控。</li>
</ol>
</li>
<li>基于<strong>局部性原理</strong>，在程序装入时，可以<strong>将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行</strong>。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。<strong>在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序</strong>。另一方面，<strong>操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息</strong>。这样，计算机好像为用户提供了一个比实际内存大得多的存储器——<strong>虚拟内存</strong>。</li>
<li>我觉得虚拟内存同样是一种<strong>时间换空间</strong>的策略：你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。</li>
</ul>
<h2 id="虚拟内存技术的实现？"><a href="#虚拟内存技术的实现？" class="headerlink" title="虚拟内存技术的实现？"></a>虚拟内存技术的实现？</h2><ul>
<li>虚拟内存技术的实现需要<strong>建立在离散分配的内存管理方式的基础上</strong>，虚拟内存的实现有以下三种方式：<ol>
<li><strong>请求分页存储管理</strong> ：<strong>建立在分页管理之上</strong>，为了支持虚拟存储器功能而<strong>增加了请求调页功能和页面置换功能</strong>。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，<strong>在作业开始运行之前，仅装入当前要执行的部分段即可运行</strong>。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法<strong>将要用的页面调入到主存</strong>，同时操作系统也可以<strong>将暂时不用的页面置换到外存</strong>中。</li>
<li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，<strong>增加了请求调段功能、分段置换功能</strong>。请求分段储存管理方式就如同请求分页储存管理方式一样，<strong>在作业开始运行之前，仅装入当前要执行的部分段即可运行</strong>；在执行过程中，可<strong>使用请求调入中断动态装入要访问但又不在内存的程序段</strong>；当内存空间已满，而又需要装入新的段时，<strong>根据置换功能适当调出某个段，以便腾出空间而装入新的段</strong>。</li>
<li><strong>请求段页式存储管理</strong></li>
</ol>
</li>
<li>这里多说一下，很多人容易搞混请求分页与分页存储管理，两者有何不同呢？<ul>
<li>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</li>
<li>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</li>
</ul>
</li>
<li>不管是上面那种实现方式，我们一般都需要：<ol>
<li><strong>一定容量的内存和外存</strong>：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li>
<li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li>
<li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li>
</ol>
</li>
</ul>
<h2 id="常见的页面置换算法有哪些？"><a href="#常见的页面置换算法有哪些？" class="headerlink" title="常见的页面置换算法有哪些？"></a>常见的页面置换算法有哪些？</h2><ul>
<li><strong>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断</strong> 。<strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</li>
<li>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。<strong>用来选择淘汰哪一页的规则叫做页面置换算法</strong>，我们可以把页面置换算法看成是淘汰页面的规则，页面置换算法主要有以下几种：<ol>
<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法<strong>所选择的被淘汰页面将是以后永不使用的</strong>，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而<strong>该算法无法实现</strong>。一般作为衡量其他置换算法的方法。</li>
<li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即<strong>选择在内存中驻留时间最久的页面进行淘汰</strong>。</li>
<li><strong>LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU 算法赋予每个页面一个访问字段，用来<strong>记录一个页面自上次被访问以来所经历的时间 T</strong>，当须淘汰一个页面时，<strong>选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰</strong>。</li>
<li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法<strong>选择在之前时期使用最少的页面作为淘汰页</strong>。</li>
</ol>
</li>
</ul>
<h1 id="数据库理论"><a href="#数据库理论" class="headerlink" title="数据库理论"></a>数据库理论</h1><h2 id="一些数据库术语"><a href="#一些数据库术语" class="headerlink" title="一些数据库术语"></a>一些数据库术语</h2><ul>
<li><strong>关系</strong>：一个关系对应一张表</li>
<li><strong>元组</strong>：表中的一行</li>
<li><strong>属性</strong>：表中的一列</li>
<li><strong>码</strong>：也称码键，是表中的某个可以唯一标识一个元组的属性</li>
<li><strong>候选码</strong>：若关系中的一个属性或属性组的值能够唯一地标识一个元组，且他的真子集不能唯一的标识一个元组，则称这个属性或属性组做候选码。</li>
<li><strong>主码</strong>：从候选码里面任意挑出一个候选码作为主码。</li>
<li><strong>主属性</strong>：包含在候选码中的属性。</li>
<li><strong>非主属性</strong>：不包含在候选码中的属性。</li>
<li>全码：若关系中只有一个候选码,且这个候选码中包含全部属性,则该候选码为全码。</li>
<li>超码：能表示出所有属性的集合。候选码是最小的超码。</li>
<li>域：是一组具有相同数据类型的值的集合</li>
<li>分量：元组中的一个属性</li>
</ul>
<h2 id="数据库关系的完整性有哪三种？"><a href="#数据库关系的完整性有哪三种？" class="headerlink" title="数据库关系的完整性有哪三种？"></a>数据库关系的完整性有哪三种？</h2><ol>
<li>实体完整性：主码唯一且为空。</li>
<li>参照完整性：外码要么为空，要么对应另一个表的主码。外码指的是别的表的属性，一般用来关联两个表。</li>
<li>用户定义完整性：用户自己定义的关系要完整，不能有关键属性的遗漏。</li>
</ol>
<h2 id="怎么将ER图转换为关系模式？"><a href="#怎么将ER图转换为关系模式？" class="headerlink" title="怎么将ER图转换为关系模式？"></a>怎么将ER图转换为关系模式？</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514141426012.png" alt="image-20220514141426012"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514141438620.png" alt="image-20220514141438620"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514141501633.png" alt="就是将关系的属性和两边的主键组合成一个新的关系模式"></p>
<h2 id="如何对sql进行代数优化？"><a href="#如何对sql进行代数优化？" class="headerlink" title="如何对sql进行代数优化？"></a>如何对sql进行代数优化？</h2><ol>
<li>选择运算尽量先做</li>
<li>把投影运算和选择运算同时执行</li>
<li>把投影同它前后的双目运算符连接起来</li>
</ol>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="什么是快照读？什么是当前读？"><a href="#什么是快照读？什么是当前读？" class="headerlink" title="什么是快照读？什么是当前读？"></a>什么是快照读？什么是当前读？</h2><ul>
<li>快照读和当前读是读取数据的不同方式，这两种方式<strong>都能保证一定的事务隔离性</strong>，但是它们的<strong>底层实现不同</strong>。</li>
<li><strong>当前读</strong>又叫锁定读，顾名思义是用<strong>锁</strong>实现的，读到的是<strong>最新的数据</strong>；<strong>快照读</strong>又叫非锁定读，是使用<strong>MVCC</strong>技术实现的，读到的<strong>不一定是最新的数据</strong>。</li>
<li>快照读（非锁定读）举例：select * from table</li>
<li>当前读（锁定读）举例：select * from table <strong>lock in share mode</strong>、select * from table <strong>for update</strong>、insert操作、update操作、delete操作</li>
</ul>
<h2 id="介绍一下MVCC？"><a href="#介绍一下MVCC？" class="headerlink" title="介绍一下MVCC？"></a>介绍一下MVCC？</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>MVCC是<strong>多版本并发控制</strong>的意思，InnoDB中使用这个技术和锁技术一起保证事务的隔离性，这个技术主要是能<strong>让事务在不使用锁的前提下保证其隔离性</strong>，由于没有使用到锁，所以<strong>使用MVCC时的并发性能是比较高的</strong>，这也是InnoDB<strong>快照读</strong>的实现原理。</li>
<li>在<strong>RC</strong>的事务隔离级别下MVCC可以<strong>防止出现脏读</strong>，在<strong>RR</strong>的事务隔离级别下MVCC可以<strong>防止出现脏读、不可重复读和部分幻读</strong>，如果想要解决全部的幻读问题需要搭配<strong>临键锁</strong>来实现。</li>
</ul>
<h3 id="技术依赖"><a href="#技术依赖" class="headerlink" title="技术依赖"></a>技术依赖</h3><ul>
<li><p>InnoDB对MVCC的实现主要依赖于<strong>记录的隐藏字段、Read View和undo log</strong></p>
</li>
<li><p>先说一下隐藏字段，起主要作用的主要就是仨：</p>
<ol>
<li><strong>DB_TRX_ID</strong>：表示最后一次插入、删除或更新该行的事务 id。</li>
<li><strong>DB_ROLL_PTR</strong>：指向undo log中的之前这个记录的版本，如果该行无历史版本，则这个字段为空</li>
<li>DB_ROW_ID：记录的唯一id，如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引</li>
</ol>
</li>
<li><p>再说一下Read View，生成它的时机在不同的隔离级别中也是不同的，在<strong>RC隔离级别中，在事务中的每个select语句执行之前都会生成一个Read View</strong>；而在<strong>RR隔离级别中，在事务中只有第一个select语句执行之前会生成Read View</strong>，剩下的select语句都使用之前生成的Read View。那么这个Read View中有什么作用呢？我觉得可以把它看成一个<strong>事务状态快照</strong>，在生成它的时候得到当前时刻各事务的状态，然后<strong>根据这些信息和DB_TRX_ID来判断undo log中哪些版本是可见的</strong>。那么Read View中有些什么值呢？起主要作用的有四个字段：</p>
<ol>
<li><strong>m_low_limit_id</strong>：<strong>目前出现过的最大的事务 ID+1</strong>，即下一个将被分配的事务 ID。<strong>大于等于这个 ID 的数据版本均不可见</strong></li>
<li><strong>m_up_limit_id</strong>：<strong>活跃事务列表 m_ids中最小的事务 ID</strong>，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。<strong>小于这个 ID 的数据版本均可见</strong>。</li>
<li><strong>m_ids</strong>：<strong>Read View创建时其他未提交的活跃事务 ID 列表</strong>。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<strong>m_ids 不包括当前事务自己和已提交的事务（正在内存中）</strong></li>
<li><strong>m_creator_trx_id</strong>：<strong>创建该 Read View的事务 ID</strong></li>
</ol>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230306173026267.png" alt="image-20230306173026267"></p>
</li>
<li><p>最后说一下undo log，这个日志中<strong>保存着各记录的历史版本</strong>，<strong>各历史版本之间通过记录中的隐藏字段DB_ROLL_PTR来链接</strong>。</p>
</li>
</ul>
<h3 id="如何使用Read-View和DB-TRX-ID字段来判断记录的可见性"><a href="#如何使用Read-View和DB-TRX-ID字段来判断记录的可见性" class="headerlink" title="如何使用Read View和DB_TRX_ID字段来判断记录的可见性"></a>如何使用Read View和DB_TRX_ID字段来判断记录的可见性</h3><ol>
<li>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的</li>
<li>如果 DB_TRX_ID &gt;&#x3D; m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5</li>
<li>m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</li>
<li>如果 m_up_limit_id &lt;&#x3D; DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的<strong>二分查找</strong>，因为是有序的）<ul>
<li>如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5</li>
<li>在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见</li>
</ul>
</li>
<li>在该记录行的 DB_ROLL_PTR 指针所指向的 <code>undo log</code> 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空</li>
</ol>
<ul>
<li>总之就是先判断DB_TRX_ID是否大于最大id，如果是，那就顺着版本链在undo log中找符合条件的历史版本，如果不是，再判断DB_TRX_ID是否小于最小id，如果是，那就直接将该记录加入结果中，如果不是，再去m_ids中找是否有当前DB_TRX_ID的值，如果没有，那就直接将该记录加入到结果中，如果有，就顺着版本链在undo log中找符合条件的历史版本。</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul>
<li>在事务中进行更新、删除、插入记录的时候，undo log会<strong>把最新的记录状态记录下来</strong>，让隐藏字段DB_TRX_ID字段的值等于操作的事务ID，然后让隐藏字段DB_ROLL_PTR指向之前的那个记录版本。</li>
<li>在事务中进行快照读的时候，如果是RC隔离级别，那么在读之前会创建一个新的Read View；如果是RR隔离级别，那么在读之前会判断Read View是否已经生成，如果已经生成则使用已有的Read View，如果没有生成就创建一个新的Read View。然后每当读到一条记录的时候，都会<strong>通过DB_TRX_ID和Read View来判断记录的可见性（上面提到了具体步骤）</strong>，如果可见，就加入到结果中，如果不可见，就从undo log中找历史版本加入到结果中，如果没有满足条件的历史版本，那就跳过当前记录。</li>
</ul>
<h2 id="为什么InnoDB引擎规定页的默认大小是16kb？"><a href="#为什么InnoDB引擎规定页的默认大小是16kb？" class="headerlink" title="为什么InnoDB引擎规定页的默认大小是16kb？"></a>为什么InnoDB引擎规定页的默认大小是16kb？</h2><ul>
<li>&#x2F;&#x2F;todo 不知道下面这个说法对不对，我看着还挺合理</li>
<li>我们都知道页是存储引擎读写的基本单位，但是为什么InnoDB规定页的默认大小是16kb呢？主要是<strong>利用到了局部性原理</strong>，<strong>分页式管理内存的操作系统一般规定页的默认大小是4kb</strong>，而根据空间局部性原理，一个被访问的地址空间周围的地址空间通常也会马上被访问到，所以我们就<strong>将那一页的周围三页一起读取当成存储引擎的一页读到存储引擎的缓冲池中</strong>，这样可以防止频繁IO。</li>
</ul>
<h2 id="日常工作中怎么优化SQL？"><a href="#日常工作中怎么优化SQL？" class="headerlink" title="日常工作中怎么优化SQL？"></a>日常工作中怎么优化SQL？</h2><ol>
<li><strong>对合适的列加索引</strong>：<ul>
<li>被频繁查询的字段：利用索引的B+树结构加快查询效率</li>
<li>被作为条件查询的字段：利用索引的B+树结构加快查询效率</li>
<li>频繁需要排序的字段：可以利用索引的有序性，加快排序的查询时间</li>
<li>被频繁用于连接的字段：提高多表连接查询的效率</li>
</ul>
</li>
<li><strong>避免索引失效的场景</strong>：<ul>
<li>使用 <code>SELECT *</code> 进行查询;</li>
<li>创建了组合索引，但查询条件未遵守最左匹配原则;</li>
<li>在索引列上进行计算、函数、类型转换等操作;</li>
<li>以 <code>%</code> 开头的 LIKE 查询比如 <code>like &#39;%abc&#39;</code>;</li>
<li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li>
<li>发生隐式转换</li>
</ul>
</li>
<li><strong>避免返回不必要的数据列</strong>，减少返回的数据列可以增加查询的效率</li>
<li><strong>根据查询分析器适当优化SQL的结构</strong>，比如是否走全表扫描、避免子查询等</li>
<li><strong>分库分表</strong>：在单表数据量较大或者并发连接数过高的情况下，通过这种方式可以有效提升查询效率</li>
<li><strong>读写分离</strong>：针对读多写少的场景，这样可以保证写操作的数据库承受更小的压力，也可以缓解独占锁和共享锁的竞争</li>
</ol>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>—————————————————————————–Redis基础————————————————————————————–</p>
<h2 id="对于Redis，你的理解是什么？"><a href="#对于Redis，你的理解是什么？" class="headerlink" title="对于Redis，你的理解是什么？"></a>对于Redis，你的理解是什么？</h2><ul>
<li>Redis是一个<strong>基于内存</strong>实现的<strong>Key-Value数据结构</strong>的<strong>NoSQL数据库</strong>，由于数据是存储在内存之中，所以数据的IO效率是非常高的，当然Redis还提供了一些持久化策略来避免内存数据丢失的问题。NoSQL实际上就是非关系型数据库，这类数据库主要是考虑数据的扩展性、性能和大数据量的存储，弥补了关系型数据库的短板。通常用在分布式系统中做缓存中间件，同时对于企业级应用来说，Redis还提供了主从复制+哨兵+集群的方式来实现高可用，同时通过哈希槽的机制来实现了数据的分片，进一步提升了系统整体的性能和可扩展性。</li>
</ul>
<h2 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h2><ul>
<li>Redis是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 <strong>Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据</strong>。</li>
<li>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap）。并且，Redis 还支持事务 、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</li>
<li>Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。</li>
</ul>
<h2 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h2><ul>
<li>Redis 内部做了非常多的性能优化，比较重要的主要有下面 3 点：<ol>
<li>Redis <strong>基于内存</strong>，内存的访问速度是磁盘的上千倍；</li>
<li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是<strong>单线程事件循环和 IO 多路复用</strong>（Redis 线程模式后面会详细介绍到）；</li>
<li>Redis <strong>内置了多种优化过后的数据结构实现</strong>，性能非常高。</li>
</ol>
</li>
</ul>
<h2 id="Redis和Memcached的区别和共同点"><a href="#Redis和Memcached的区别和共同点" class="headerlink" title="Redis和Memcached的区别和共同点"></a>Redis和Memcached的区别和共同点</h2><ul>
<li>现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据。</li>
</ul>
<h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol>
<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k&#x2F;v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k&#x2F;v 数据类型。</li>
<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li>
<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>
<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>
<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li>
<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型（仅IO和执行命令是单线程，其实Redis服务端本身是多线程的）。</strong> （Redis 6.0 引入了多线程 IO ）</li>
<li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li>
<li><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li>
</ol>
<h2 id="为什么要用Redis-x2F-为什么要用缓存？"><a href="#为什么要用Redis-x2F-为什么要用缓存？" class="headerlink" title="为什么要用Redis&#x2F;为什么要用缓存？"></a>为什么要用Redis&#x2F;为什么要用缓存？</h2><ul>
<li>主要是从<strong>高性能</strong>和<strong>高并发</strong>两点来分析。</li>
</ul>
<h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><ul>
<li>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，<strong>如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中</strong>。</li>
<li>这样有什么好处呢？ 那就是<strong>保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快</strong>。</li>
</ul>
<h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><ul>
<li>一般像 MySQL 这类的数据库的 QPS（服务器每秒可以执行的查询次数） 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。</li>
<li>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑<strong>把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发</strong>。</li>
</ul>
<h2 id="Redis除了做缓存之外，还能做什么？"><a href="#Redis除了做缓存之外，还能做什么？" class="headerlink" title="Redis除了做缓存之外，还能做什么？"></a>Redis除了做缓存之外，还能做什么？</h2><ul>
<li><strong>分布式锁</strong> ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。</li>
<li><strong>限流</strong> ：一般是通过 Redis + Lua 脚本的方式来实现限流。</li>
<li><strong>消息队列</strong> ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>
<li><strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li>
<li>……</li>
</ul>
<h2 id="Redis可以做消息队列吗？"><a href="#Redis可以做消息队列吗？" class="headerlink" title="Redis可以做消息队列吗？"></a>Redis可以做消息队列吗？</h2><ul>
<li>Redis 5.0 新增加的一个数据结构 <code>Stream</code> 可以用来做消息队列，<code>Stream</code> 支持：<ol>
<li>发布 &#x2F; 订阅模式</li>
<li>按照消费者组进行消费</li>
<li>消息持久化（ RDB 和 AOF）</li>
</ol>
</li>
<li>不过，和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议是不使用 Redis 来做消息队列的，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</li>
</ul>
<h2 id="如何基于Redis实现分布式锁？"><a href="#如何基于Redis实现分布式锁？" class="headerlink" title="如何基于Redis实现分布式锁？"></a>如何基于Redis实现分布式锁？</h2><p>—————————————————————————–Redis数据结构——————————————————————————-</p>
<h2 id="Redis常用的数据结构有哪些？"><a href="#Redis常用的数据结构有哪些？" class="headerlink" title="Redis常用的数据结构有哪些？"></a>Redis常用的数据结构有哪些？</h2><ul>
<li><strong>5 种基础数据结构</strong> ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>
<li><strong>3 种特殊数据结构</strong> ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li>
<li>赶不上（GBS）临淄（LZ）黄昏时（HHS）</li>
</ul>
<h2 id="String-的应用场景有哪些？"><a href="#String-的应用场景有哪些？" class="headerlink" title="String 的应用场景有哪些？"></a>String 的应用场景有哪些？</h2><ul>
<li>常规数据（比如 session、token、、序列化后的对象）的缓存；</li>
<li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li>
<li>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li>
<li>……</li>
</ul>
<h2 id="存储对象数据使用String还是Hash更好？"><a href="#存储对象数据使用String还是Hash更好？" class="headerlink" title="存储对象数据使用String还是Hash更好？"></a>存储对象数据使用String还是Hash更好？</h2><ul>
<li><strong>String 存储的是序列化后的对象数据，存放的是整个对象</strong>。<strong>Hash 是对对象的每个字段单独存储</strong>，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。<strong>如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合</strong>。</li>
<li><strong>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半</strong>。并且，存储具有多层嵌套的对象时也方便很多。<strong>如果系统对性能和资源消耗非常敏感的话，String 就非常适合</strong>。</li>
<li>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</li>
</ul>
<h2 id="String的底层实现是什么？"><a href="#String的底层实现是什么？" class="headerlink" title="String的底层实现是什么？"></a>String的底层实现是什么？</h2><ul>
<li><p>Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 <code>\0</code> 结尾的字符数组），而是<strong>自己编写了 SDS（Simple Dynamic String，简单动态字符串） 来作为底层实现</strong>。</p>
</li>
<li><p>SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。</p>
</li>
<li><p>Redis7.0 的 SDS 的部分源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。<strong>Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用</strong>：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>位</th>
</tr>
</thead>
<tbody><tr>
<td>sdshdr5</td>
<td>&lt; 1</td>
<td>&lt;8</td>
</tr>
<tr>
<td>sdshdr8</td>
<td>1</td>
<td>8</td>
</tr>
<tr>
<td>sdshdr16</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>sdshdr32</td>
<td>4</td>
<td>32</td>
</tr>
<tr>
<td>sdshdr64</td>
<td>8</td>
<td>64</td>
</tr>
</tbody></table>
</li>
<li><p>对于后四种实现都包含了下面这 4 个属性：</p>
<ol>
<li><code>len</code> ：字符串的长度也就是已经使用的字节数</li>
<li><code>alloc</code>：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小</li>
<li><code>buf[]</code> ：实际存储字符串的数组</li>
<li><code>flags</code> ：低三位保存类型标志</li>
</ol>
</li>
<li><p>SDS 相比于 C 语言中的字符串有如下提升：</p>
<ol>
<li><strong>可以避免缓冲区溢出</strong> ：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li>
<li><strong>获取字符串长度的复杂度较低</strong> ： C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li>
<li><strong>减少内存分配次数</strong> ： 为了避免修改（增加&#x2F;减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li>
<li><strong>二进制安全</strong> ：C 语言中的字符串以空字符 <code>\0</code> 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</li>
</ol>
</li>
<li><p>多提一嘴，很多文章里 SDS 的定义是下面这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，<code>len</code> 和 <code>free</code> 的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。</p>
</li>
</ul>
<h2 id="购物车信息用String还是Hash存储更好呢？"><a href="#购物车信息用String还是Hash存储更好呢？" class="headerlink" title="购物车信息用String还是Hash存储更好呢？"></a>购物车信息用String还是Hash存储更好呢？</h2><ul>
<li><p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p>
<ul>
<li><p>用户 id 为 key</p>
</li>
<li><p>商品 id 为 field，商品数量为 value</p>
</li>
</ul>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223155104792.png" alt="image-20230223155104792"></p>
</li>
<li><p>那用户购物车信息的维护具体应该怎么操作呢？</p>
<ul>
<li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li>
<li>查询购物车信息就是遍历对应的 Hash；</li>
<li>更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li>
<li>删除商品就是删除 Hash 中对应的 field；</li>
<li>清空购物车直接删除对应的 key 即可。</li>
</ul>
</li>
<li><p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。</p>
</li>
</ul>
<h2 id="使用Redis实现一个排行榜怎么做？"><a href="#使用Redis实现一个排行榜怎么做？" class="headerlink" title="使用Redis实现一个排行榜怎么做？"></a>使用Redis实现一个排行榜怎么做？</h2><ul>
<li>Redis 中有一个叫做 <strong><code>sorted set</code> 的数据结构经常被用在各种排行榜的场景</strong>，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li>
<li>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li>
</ul>
<h2 id="使用Set实现抽奖系统需要用到什么命令？"><a href="#使用Set实现抽奖系统需要用到什么命令？" class="headerlink" title="使用Set实现抽奖系统需要用到什么命令？"></a>使用Set实现抽奖系统需要用到什么命令？</h2><ul>
<li><code>SPOP key count</code> ： 随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li>
<li><code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li>
</ul>
<h2 id="使用Bitmap统计活跃用户怎么做？"><a href="#使用Bitmap统计活跃用户怎么做？" class="headerlink" title="使用Bitmap统计活跃用户怎么做？"></a>使用Bitmap统计活跃用户怎么做？</h2><ul>
<li><p>使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</p>
</li>
<li><p>初始化数据：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SETBIT 20210308 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">SETBIT 20210308 2 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">SETBIT 20210309 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计 20210308~20210309 总活跃用户数:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITOP and desk1 20210308 20210309</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; BITCOUNT desk1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计 20210308~20210309 在线活跃用户数:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITOP or desk2 20210308 20210309</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; BITCOUNT desk2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="使用HyperLogLog统计页面UV怎么做？"><a href="#使用HyperLogLog统计页面UV怎么做？" class="headerlink" title="使用HyperLogLog统计页面UV怎么做？"></a>使用HyperLogLog统计页面UV怎么做？</h2><ol>
<li><p>将访问指定页面的每个用户ID添加到HyperLogLog中：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFADD PAGE_1:UV USER1 USER2 ...... USERn</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计指定页面的UV。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT PAGE_1:UV</span><br></pre></td></tr></table></figure></li>
</ol>
<p>—————————————————————————–Redis线程模型——————————————————————————-</p>
<h2 id="Redis单线程模型了解吗？"><a href="#Redis单线程模型了解吗？" class="headerlink" title="Redis单线程模型了解吗？"></a>Redis单线程模型了解吗？</h2><ul>
<li><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于<strong>文件事件处理器（file event handler）是单线程方式运行的</strong>，所以我们一般都说 Redis 是单线程模型。</li>
</ul>
<blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。</p>
<ul>
<li>文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I&#x2F;O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
</blockquote>
<ul>
<li><p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p>
</li>
<li><p>这样的好处非常明显： <strong>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p>
</li>
<li><p>文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ol>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ol>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223160742563.png" alt="image-20230223160742563"></p>
</li>
</ul>
<h2 id="Redis6-0之前为什么不使用多线程？"><a href="#Redis6-0之前为什么不使用多线程？" class="headerlink" title="Redis6.0之前为什么不使用多线程？"></a>Redis6.0之前为什么不使用多线程？</h2><ul>
<li>虽然说 Redis 是单线程模型，但是，实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></li>
<li>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。</li>
<li>为此，Redis 4.0 之后新增了<code>UNLINK</code>（可以看作是 <code>DEL</code> 的异步版本）、<code>FLUSHALL ASYNC</code>（清空所有数据库的所有 key，不仅仅是当前 <code>SELECT</code> 的数据库）、<code>FLUSHDB ASYNC</code>（清空当前 <code>SELECT</code> 数据库中的所有 key）等异步命令。大体上来说，Redis 6.0 之前主要还是单线程处理。</li>
<li><strong>那 Redis6.0 之前为什么不使用多线程？</strong> 我觉得主要原因有 3 点：<ol>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ol>
</li>
</ul>
<h2 id="Redis6-0之后为什么引入了多线程"><a href="#Redis6-0之后为什么引入了多线程" class="headerlink" title="Redis6.0之后为什么引入了多线程"></a>Redis6.0之后为什么引入了多线程</h2><ul>
<li><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>
</li>
<li><p>虽然，Redis6.0 引入了多线程，但是 <strong>Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行</strong>。因此，你也不需要担心线程安全问题。</p>
</li>
<li><p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置IO线程数 &gt; 1，需要修改 redis 配置文件 <code>redis.conf</code> ：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads 4 <span class="comment">#设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>另外：</p>
<ul>
<li>io-threads的个数一旦设置，不能通过config动态设置</li>
<li>当设置ssl后，io-threads将不工作</li>
</ul>
</li>
<li><p>开启多线程后，默认只会使用多线程进行IO写入writes，即发送数据给客户端，如果需要开启多线程IO读取reads，同样需要修改 redis 配置文件 <code>redis.conf</code> :</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads-do-reads <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启</p>
</li>
</ul>
<p>—————————————————————————–Redis内存管理——————————————————————————-</p>
<h2 id="Redis给缓存数据设置过期时间有什么用？"><a href="#Redis给缓存数据设置过期时间有什么用？" class="headerlink" title="Redis给缓存数据设置过期时间有什么用？"></a>Redis给缓存数据设置过期时间有什么用？</h2><ul>
<li><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p>
</li>
<li><p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire key 60 <span class="comment"># 数据在 60s 后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value <span class="comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key <span class="comment"># 查看数据还有多久过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 56</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：<strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p>
</li>
<li><p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong>很多时候，我们的<strong>业务场景就是需要某个数据只在某一时间段内存在</strong>，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
</li>
</ul>
<h2 id="Redis是如何判断数据是否过期的呢？"><a href="#Redis是如何判断数据是否过期的呢？" class="headerlink" title="Redis是如何判断数据是否过期的呢？"></a>Redis是如何判断数据是否过期的呢？</h2><ul>
<li><p>Redis 通过一个叫做<strong>过期字典（可以看作是 hash 表）来保存数据过期的时间</strong>。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223164436724.png" alt="image-20230223164436724"></p>
</li>
<li><p>过期字典是存储在 redisDb 这个结构里的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    dict *dict;     <span class="comment">//数据库键空间,保存着数据库中所有键值对</span></span><br><span class="line">    dict *expires   <span class="comment">// 过期字典,保存着键的过期时间</span></span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="过期的数据的删除策略了解吗？"><a href="#过期的数据的删除策略了解吗？" class="headerlink" title="过期的数据的删除策略了解吗？"></a>过期的数据的删除策略了解吗？</h2><ul>
<li>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</li>
<li>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：<ol>
<li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
</li>
<li>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 。</li>
<li>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</li>
<li>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></li>
</ul>
<h2 id="Redis内存淘汰机制了解吗？"><a href="#Redis内存淘汰机制了解吗？" class="headerlink" title="Redis内存淘汰机制了解吗？"></a>Redis内存淘汰机制了解吗？</h2><ul>
<li>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</li>
<li>Redis 提供 6 种数据淘汰策略：<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
</li>
<li>4.0 版本后增加以下两种：<ol start="7">
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ol>
</li>
</ul>
<p>—————————————————————————–Redis持久化机制——————————————————————————-</p>
<h2 id="怎么保证Redis挂掉之后再重启数据可以进行恢复？"><a href="#怎么保证Redis挂掉之后再重启数据可以进行恢复？" class="headerlink" title="怎么保证Redis挂掉之后再重启数据可以进行恢复？"></a>怎么保证Redis挂掉之后再重启数据可以进行恢复？</h2><ul>
<li>很多时候我们需要<strong>持久化数据也就是将内存中的数据写入到硬盘里面</strong>，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</li>
<li>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</li>
</ul>
<h2 id="什么是RDB持久化？"><a href="#什么是RDB持久化？" class="headerlink" title="什么是RDB持久化？"></a>什么是RDB持久化？</h2><ul>
<li><p>Redis 可以<strong>通过创建快照来获得存储在内存里面的数据在某个时间点上的副本</strong>。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
</li>
<li><p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           <span class="comment">#在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。</span></span><br><span class="line"></span><br><span class="line">save 300 10          <span class="comment">#在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。</span></span><br><span class="line"></span><br><span class="line">save 60 10000        <span class="comment">#在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="RDB创建快照时会阻塞主线程吗？"><a href="#RDB创建快照时会阻塞主线程吗？" class="headerlink" title="RDB创建快照时会阻塞主线程吗？"></a>RDB创建快照时会阻塞主线程吗？</h2><ul>
<li><p><strong>默认是子线程执行创建快照的动作，不会阻塞主线程</strong>。</p>
</li>
<li><p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li><code>save</code> : 主线程执行，会阻塞主线程；</li>
<li><code>bgsave</code> : 子线程执行，不会阻塞主线程，默认选项。</li>
</ul>
</li>
</ul>
<h2 id="什么是AOF持久化？"><a href="#什么是AOF持久化？" class="headerlink" title="什么是AOF持久化？"></a>什么是AOF持久化？</h2><ul>
<li><p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。<strong>默认情况下 Redis 没有开启 AOF（append only file）方式的持久化</strong>，可以通过 appendonly 参数开启：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件</strong>。</p>
</li>
<li><p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p>
</li>
<li><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    <span class="comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span></span><br><span class="line">appendfsync everysec  <span class="comment">#每秒钟同步一次，显式地将多个写命令同步到硬盘</span></span><br><span class="line">appendfsync no        <span class="comment">#让操作系统决定何时进行同步</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响</strong>。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
</li>
</ul>
<h2 id="AOF日志是如何实现的？"><a href="#AOF日志是如何实现的？" class="headerlink" title="AOF日志是如何实现的？"></a>AOF日志是如何实现的？</h2><ul>
<li><p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223170909801.png" alt="image-20230223170909801"></p>
</li>
<li><p><strong>为什么是在执行完命令之后记录日志呢？</strong></p>
<ol>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
</ol>
</li>
<li><p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>
<ol>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li>
</ol>
</li>
</ul>
<h2 id="AOF重写了解吗？"><a href="#AOF重写了解吗？" class="headerlink" title="AOF重写了解吗？"></a>AOF重写了解吗？</h2><ul>
<li>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，<strong>新旧两个文件所保存的数据库状态是相同的，但是新的AOF文件不会包含任何浪费空间的冗余命令，通常体积会较旧AOF文件小很多</strong>。</li>
<li>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</li>
<li>在执行 <code>BGREWRITEAOF</code> 命令时，<strong>Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作</strong>。</li>
<li>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，<strong>重写期间到达的所有写入命令都会写入磁盘两次</strong>。</li>
</ul>
<h2 id="如何选择RDB和AOF？"><a href="#如何选择RDB和AOF？" class="headerlink" title="如何选择RDB和AOF？"></a>如何选择RDB和AOF？</h2><ul>
<li>建议两者都开，不建议只开AOF。如果对数据不敏感可以只开RDB。如果只是做缓存，可以都不开。</li>
</ul>
<h3 id="RDB比AOF优秀的地方"><a href="#RDB比AOF优秀的地方" class="headerlink" title="RDB比AOF优秀的地方"></a>RDB比AOF优秀的地方</h3><ol>
<li><strong>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会必 RDB 文件大很多</strong>。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li>
<li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，<strong>与 AOF 相比，恢复大数据集的时候，RDB 速度更快</strong>。</li>
</ol>
<h3 id="AOF比RDB优秀的地方"><a href="#AOF比RDB优秀的地方" class="headerlink" title="AOF比RDB优秀的地方"></a>AOF比RDB优秀的地方</h3><ol>
<li><strong>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据</strong>。生成 RDB 文件的过程是比繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li>
<li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以<strong>存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题</strong>。</li>
<li><strong>AOF 以一种易于理解和解析的格式包含所有操作的日志，也就是可读性强</strong>。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li>
</ol>
<h2 id="Redis-4-0-对于持久化机制做了什么优化？"><a href="#Redis-4-0-对于持久化机制做了什么优化？" class="headerlink" title="Redis 4.0 对于持久化机制做了什么优化？"></a>Redis 4.0 对于持久化机制做了什么优化？</h2><ul>
<li>由于 RDB 和 AOF 各有优势，于是，<strong>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）</strong>。</li>
<li><strong>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据</strong>。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，<strong>可读性较差</strong>。</li>
</ul>
<p>—————————————————————————–Redis事务———————————————————————————–</p>
<h2 id="如何使用Redis事务？"><a href="#如何使用Redis事务？" class="headerlink" title="如何使用Redis事务？"></a>如何使用Redis事务？</h2><ul>
<li><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET PROJECT</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;JavaGuide&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>MULTI</code>命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了<code>EXEC</code>命令后，再执行所有的命令</strong>。</p>
</li>
<li><p>这个过程是这样的：</p>
<ol>
<li>开始事务（<code>MULTI</code>）；</li>
<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；</li>
<li>执行事务(<code>EXEC</code>)。</li>
</ol>
</li>
<li><p>你也可以<strong>通过<code>DISCARD</code>命令取消一个事务，它会清空事务队列中保存的所有命令</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET PROJECT</span><br><span class="line">QUEUED</span><br><span class="line">&gt; DISCARD</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
</li>
<li><p>你可以<strong>通过 <code>WATCH</code> 命令监听指定的 Key，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的 Key 被 其他客户端&#x2F;Session 修改的话，整个事务都不会被执行</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端 1</span></span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;RustGuide&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; WATCH PROJECT</span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端 2</span></span><br><span class="line"><span class="comment"># 在客户端 1 执行 EXEC 命令提交事务之前修改 PROJECT 的值</span></span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;GoGuide&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端 1</span></span><br><span class="line"><span class="comment"># 修改失败，因为 PROJECT 的值被客户端2修改了</span></span><br><span class="line">&gt; EXEC</span><br><span class="line">(nil)</span><br><span class="line">&gt; GET PROJECT</span><br><span class="line"><span class="string">&quot;GoGuide&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不过，<strong>如果 WATCH与事务在同一个 Session 里，并且被WATCH监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的</strong>。</p>
</li>
<li><p>事务内部修改 WATCH 监视的 Key：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; WATCH PROJECT</span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide1&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide2&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide3&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">127.0.0.1:6379&gt; GET PROJECT</span><br><span class="line"><span class="string">&quot;JavaGuide3&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>事务外部修改 WATCH 监视的Key：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; WATCH PROJECT</span><br><span class="line">OK</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide2&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; GET USER</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Redis支持原子性吗？"><a href="#Redis支持原子性吗？" class="headerlink" title="Redis支持原子性吗？"></a>Redis支持原子性吗？</h2><ul>
<li>Redis 的事务和我们平时理解的关系型数据库的事务不同。</li>
<li><strong>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行</strong>。并且，<strong>Redis 是不支持回滚（roll back）操作</strong>的。因此，<strong>Redis 事务其实是不满足原子性的（而且不满足持久性）</strong>。</li>
<li>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得<strong>没必要支持回滚，这样更简单便捷并且性能更好</strong>。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</li>
<li>你可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></li>
<li><strong>除了不满足原子性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为（使用lua脚本优化）</strong>。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。因此，<strong>Redis 事务是不建议在日常开发中使用的</strong>。</li>
</ul>
<h2 id="如何解决Redis事务的缺陷？"><a href="#如何解决Redis事务的缺陷？" class="headerlink" title="如何解决Redis事务的缺陷？"></a>如何解决Redis事务的缺陷？</h2><ul>
<li>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们<strong>可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销</strong>。</li>
<li>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</li>
<li><strong>如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的</strong>。因此，<strong>严格来说，通过 Lua 脚本来批量执行 Redis 命令也是不满足原子性的</strong>。</li>
<li>另外，Redis 7.0 新增了Redis functions特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。</li>
<li>总之<strong>Lua脚本解决的是redis事务中的命令无法送至redis服务端批量执行的问题，并没有完全解决redis事务不具备原子性的特点</strong>。</li>
</ul>
<p>—————————————————————————–Redis性能优化———————————————————————————–</p>
<h2 id="什么是bigkey？"><a href="#什么是bigkey？" class="headerlink" title="什么是bigkey？"></a>什么是bigkey？</h2><ul>
<li>简单来说，<strong>如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey</strong>。具体多大才算大呢？有一个不是特别精确的参考标准：<strong>string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）</strong>。</li>
</ul>
<h2 id="bigkey有什么危害？"><a href="#bigkey有什么危害？" class="headerlink" title="bigkey有什么危害？"></a>bigkey有什么危害？</h2><ul>
<li>除了会消耗更多的内存空间，bigkey 对性能也会有比较大的影响。</li>
<li>因此，我们应该尽量避免写入 bigkey！</li>
</ul>
<h2 id="如何发现bigkey？"><a href="#如何发现bigkey？" class="headerlink" title="如何发现bigkey？"></a>如何发现bigkey？</h2><ol>
<li><p><strong>使用 Redis 自带的 <code>--bigkeys</code> 参数来查找</strong>：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-cli -p 6379 --bigkeys</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Scanning the entire keyspace to find biggest keys as well as</span></span><br><span class="line"><span class="comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span></span><br><span class="line"><span class="comment"># per 100 SCAN commands (not usually needed).</span></span><br><span class="line"></span><br><span class="line">[00.00%] Biggest string found so far <span class="string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> with 4437 bytes</span><br><span class="line">[00.00%] Biggest list   found so far <span class="string">&#x27;&quot;my-list&quot;&#x27;</span> with 17 items</span><br><span class="line"></span><br><span class="line">-------- summary -------</span><br><span class="line"></span><br><span class="line">Sampled 5 keys <span class="keyword">in</span> the keyspace!</span><br><span class="line">Total key length <span class="keyword">in</span> bytes is 264 (avg len 52.80)</span><br><span class="line"></span><br><span class="line">Biggest   list found <span class="string">&#x27;&quot;my-list&quot;&#x27;</span> has 17 items</span><br><span class="line">Biggest string found <span class="string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> has 4437 bytes</span><br><span class="line"></span><br><span class="line">1 lists with 17 items (20.00% of keys, avg size 17.00)</span><br><span class="line">0 hashs with 0 fields (00.00% of keys, avg size 0.00)</span><br><span class="line">4 strings with 4831 bytes (80.00% of keys, avg size 1207.75)</span><br><span class="line">0 streams with 0 entries (00.00% of keys, avg size 0.00)</span><br><span class="line">0 sets with 0 members (00.00% of keys, avg size 0.00)</span><br><span class="line">0 zsets with 0 members (00.00% of keys, avg size 0.00</span><br></pre></td></tr></table></figure>

<p>从这个命令的运行结果，我们可以看出：<strong>这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响</strong>。并且，这种方式<strong>只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）</strong>。</p>
</li>
<li><p><strong>通过软件分析RDB文件</strong>来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p>
</li>
</ol>
<h2 id="大量key集中过期的问题"><a href="#大量key集中过期的问题" class="headerlink" title="大量key集中过期的问题"></a>大量key集中过期的问题</h2><ul>
<li>我在上面提到过：对于过期 key，Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 策略。</li>
<li><strong>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成</strong>，因为这个这个<strong>定期任务线程是在 Redis 主线程中执行的</strong>。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</li>
<li>如何解决呢？下面是两种常见的方法：<ol>
<li>给 key <strong>设置随机过期时间</strong>。</li>
<li>开启 <strong>lazy-free（惰性删除&#x2F;延迟释放） <strong>。lazy-free 特性是 Redis 4.0 开始引入的，指的是</strong>让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程</strong>。</li>
</ol>
</li>
<li>建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</li>
</ul>
<p>—————————————————————————–Redis生产问题———————————————————————————–</p>
<h2 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h2><ul>
<li><p>缓存穿透说简单点就是<strong>大量请求的 key 是不合理的，根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223190624286.png" alt="image-20230223190624286"></p>
</li>
<li><p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p>
</li>
</ul>
<h2 id="如何解决缓存穿透问题？"><a href="#如何解决缓存穿透问题？" class="headerlink" title="如何解决缓存穿透问题？"></a>如何解决缓存穿透问题？</h2><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<h3 id="缓存无效key"><a href="#缓存无效key" class="headerlink" title="缓存无效key"></a>缓存无效key</h3><ul>
<li><p><strong>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间</strong>，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，<strong>如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key</strong>。很明显，<strong>这种方案并不能从根本上解决此问题</strong>。如果非要用这种方式来解决穿透问题的话，<strong>尽量将无效的 key 的过期时间设置短一点比如 1 分钟</strong>。</p>
</li>
<li><p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p>
</li>
<li><p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObjectInclNullById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheValue</span> <span class="operator">=</span> cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">storageValue</span> <span class="operator">=</span> storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="使用布隆过滤器"><a href="#使用布隆过滤器" class="headerlink" title="使用布隆过滤器"></a>使用布隆过滤器</h3><ul>
<li><p>布隆过滤器是一个非常神奇的数据结构，通过它我们<strong>可以非常方便地判断一个给定数据是否存在于海量数据中</strong>。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>
</li>
<li><p>具体是这样做的：<strong>把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程</strong>。</p>
</li>
<li><p>加入布隆过滤器之后的缓存处理流程图如下：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223191446498.png" alt="image-20230223191446498"></p>
</li>
<li><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判（哈希碰撞）。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
</li>
<li><p>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</p>
</li>
<li><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（<strong>一般会有多个哈希函数，有几个哈希函数得到几个哈希值</strong>）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
</li>
<li><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
</li>
<li><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>
</li>
</ul>
<h2 id="什么是缓存击穿？"><a href="#什么是缓存击穿？" class="headerlink" title="什么是缓存击穿？"></a>什么是缓存击穿？</h2><ul>
<li><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223192036582.png" alt="image-20230223192036582"></p>
</li>
<li><p>举个例子 ：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
</li>
</ul>
<h2 id="如何解决缓存击穿问题？"><a href="#如何解决缓存击穿问题？" class="headerlink" title="如何解决缓存击穿问题？"></a>如何解决缓存击穿问题？</h2><ol>
<li><p>设置热点数据<strong>永不过期或者过期时间比较长</strong>。</p>
</li>
<li><p>针对热点数据<strong>提前预热</strong>，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</p>
</li>
<li><p>请求数据库写数据到缓存之前，先<strong>获取互斥锁</strong>，保证只有一个请求会落到数据库上，减少数据库的压力。</p>
</li>
<li><p>实例，用分布式锁和双重检查解决缓存击穿：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(key = &quot;#id&quot;)</span><span class="comment">//key中追加一个id，防止出现歧义</span></span><br><span class="line"><span class="keyword">public</span> QvsSurvey <span class="title function_">getSurveyInfoById</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="comment">//加分布式锁防止缓存穿透</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;qvs-survey-getSurveyInfoById&quot;</span>);</span><br><span class="line">    redisLock.lock();<span class="comment">//不指定TTL的时候默认30s的TTL，10s之后如果锁还没放开，那么TTL会重新续满，这是看门狗机制</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;qvs-survey::&quot;</span> + id);<span class="comment">//先尝试从redis中获取数据</span></span><br><span class="line">    <span class="keyword">if</span>(!StringUtils.isEmpty(data))&#123;<span class="comment">//如果能获取到数据，说明数据在缓存中已经存在，如果存在直接返回，不存在再查数据库，保证只有一个线程查数据库，这是防止缓存击穿的关键</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> om.readValue(data,QvsSurvey.class);<span class="comment">//json反序列化</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;qvs-survey-getSurveyInfoById:&quot;</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">QvsSurvey</span> <span class="variable">qvsSurvey</span> <span class="operator">=</span> <span class="built_in">this</span>.baseMapper.getSurveyInfoById(id);</span><br><span class="line">    redisLock.unlock();<span class="comment">//解锁</span></span><br><span class="line">    <span class="keyword">return</span> qvsSurvey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="缓存穿透和缓存击穿有什么区别？"><a href="#缓存穿透和缓存击穿有什么区别？" class="headerlink" title="缓存穿透和缓存击穿有什么区别？"></a>缓存穿透和缓存击穿有什么区别？</h2><ol>
<li>缓存穿透中，请求的 key <strong>既不存在于缓存中，也不存在于数据库中</strong>。</li>
<li>缓存击穿中，请求的 key 对应的是<strong>热点数据</strong> ，该数据<strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</li>
</ol>
<h2 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h2><ul>
<li><p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上:</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223192507611.png" alt="image-20230223192507611"></p>
</li>
<li><p>举个例子 ：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
</li>
</ul>
<h2 id="如何解决缓存雪崩问题？"><a href="#如何解决缓存雪崩问题？" class="headerlink" title="如何解决缓存雪崩问题？"></a>如何解决缓存雪崩问题？</h2><h3 id="针对Redis服务不可用的情况"><a href="#针对Redis服务不可用的情况" class="headerlink" title="针对Redis服务不可用的情况"></a>针对Redis服务不可用的情况</h3><ol>
<li>采用 Redis <strong>集群</strong>，避免单机出现问题整个缓存服务都没办法使用。</li>
<li><strong>限流</strong>，避免同时处理大量的请求。</li>
</ol>
<h3 id="针对热点缓存失效的情况"><a href="#针对热点缓存失效的情况" class="headerlink" title="针对热点缓存失效的情况"></a>针对热点缓存失效的情况</h3><ol>
<li>设置不同的失效时间比如<strong>随机设置缓存的失效时间</strong>。</li>
<li>缓存永不失效（不太推荐，实用性太差）。</li>
<li>设置<strong>二级缓存</strong>。</li>
</ol>
<h2 id="缓存雪崩和缓存击穿有什么区别？"><a href="#缓存雪崩和缓存击穿有什么区别？" class="headerlink" title="缓存雪崩和缓存击穿有什么区别？"></a>缓存雪崩和缓存击穿有什么区别？</h2><ul>
<li>缓存雪崩和缓存击穿比较像，但<strong>缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong>。</li>
</ul>
<h2 id="如何保证缓存和数据库数据的一致性？"><a href="#如何保证缓存和数据库数据的一致性？" class="headerlink" title="如何保证缓存和数据库数据的一致性？"></a>如何保证缓存和数据库数据的一致性？</h2><ul>
<li>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</li>
<li>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache （还有另外一种方案好像是更新db后再更新cache）。</li>
<li>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加 cache 更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ol>
</li>
</ul>
<p>—————————————————————————Redis集群———————————————————————————–</p>
<h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>主机数据更新后根据配置和策略， 自动同步到备机的<strong>master&#x2F;slaver机制</strong>，<strong>Master以写为主，Slave以读为主</strong>。</li>
</ul>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><strong>读写分离，性能扩展</strong></li>
<li><strong>容灾快速恢复</strong></li>
</ul>
<h3 id="如何配置"><a href="#如何配置" class="headerlink" title="如何配置"></a>如何配置</h3><ul>
<li>默认所有redis实例都是主机，可以使用<code>slaveof &lt;ip&gt; &lt;port&gt;</code>命令来指定该主机为从机并指定好其归属的主机，从机下面也能配置从机，使用命令设置的话重启后会失效，可以配置在配置文件中永久生效。</li>
<li>使用<code>slaveof no one</code>将从机变为主机。</li>
<li>配置好后，主机上可以写数据，从机上只能读数据，如果在从机上写数据会报错。</li>
<li>主机挂了之后重启即可；从机挂了之后如果没有在配置文件中配置其主从关系，那么就需要重新使用命令来建立从属关系。</li>
</ul>
<h3 id="复制延时问题"><a href="#复制延时问题" class="headerlink" title="复制延时问题"></a>复制延时问题</h3><ul>
<li>由于<strong>所有的写操作都是先在Master上操作，然后同步更新到Slave上</strong>，所以<strong>从Master同步到Slave机器有一定的延迟</strong>，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li><p><strong>Slave启动成功连接到master后会发送一个sync命令</strong>。</p>
</li>
<li><p>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，<strong>master将传送整个数据文件到slave,以完成一次完全同步</strong>。</p>
</li>
<li><p><strong>全量复制</strong>：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p>
</li>
<li><p><strong>增量复制</strong>：Master继续将新的所有收集到的修改命令依次传给slave,完成同步。</p>
</li>
<li><p>但是<strong>只要是重新连接master,一次完全同步（全量复制)将被自动执行</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101757180.png" alt="image-20221015101757180"></p>
</li>
</ul>
<h2 id="常用的三种主从结构"><a href="#常用的三种主从结构" class="headerlink" title="常用的三种主从结构"></a>常用的三种主从结构</h2><h3 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015100717323.png" alt="image-20221015100717323"></p>
<h3 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h3><ul>
<li><p>上一个Slave可以是下一个slave的Master，<strong>Slave同样可以接收其他slaves的连接和同步请求</strong>，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</p>
</li>
<li><p>用 slaveof  &lt;ip&gt; &lt;port&gt;进行配置</p>
<p>中途变更转向:会清除之前的数据，重新建立拷贝最新的</p>
<p>风险是一旦某个slave宕机，后面的slave都没法备份</p>
<p>主机挂了，从机还是从机，无法写数据了</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101147373.png" alt="image-20221015101147373"></p>
</li>
</ul>
<h3 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h3><ul>
<li><strong>当一个master宕机后，后面的slave可以立刻升为master</strong>，其后面的slave不用做任何修改。</li>
<li>用<strong>slaveof no one</strong>将从机变为主机。</li>
</ul>
<h2 id="哨兵模式（sentinel）"><a href="#哨兵模式（sentinel）" class="headerlink" title="哨兵模式（sentinel）"></a>哨兵模式（sentinel）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p>这是<strong>反客为主的自动版</strong>，哨兵能够<strong>后台监控主机是否故障</strong>，如果故障了<strong>根据投票数自动将从库转换为主库</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101935319.png" alt="image-20221015101935319"></p>
</li>
</ul>
<h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><ul>
<li>这个需要额外配置一个哨兵，先<strong>在配置文件目录下新建sentinel.conf文件</strong>。</li>
<li>然后在sentinel.conf中填写内容：<strong>sentinel monitor mymaster 127.0.0.1 6379 1</strong>，其中<strong>mymaster为监控对象起的服务器名称</strong>， <strong>1为至少有多少个哨兵同意迁移的数量</strong>。</li>
<li>最后在redis的安装目录下执行<strong>redis-sentinel  &#x2F;myredis&#x2F;sentinel.conf</strong>来启动哨兵</li>
</ul>
<h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><ul>
<li><p>优先级在redis.conf中默认：slave-priority 100，<strong>值越小优先级越高</strong></p>
</li>
<li><p><strong>偏移量是指获得原主机数据最全的</strong></p>
</li>
<li><p>每个redis实例启动后都会<strong>随机生成一个40位的runid</strong></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015103154028.png" alt="image-20221015103154028"></p>
</li>
</ul>
<h2 id="什么是redis集群？"><a href="#什么是redis集群？" class="headerlink" title="什么是redis集群？"></a>什么是redis集群？</h2><ul>
<li>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，<strong>将整个数据库分布存储在这N个节点中，每个节点存储总数据的1&#x2F;N</strong>。</li>
<li>Redis 集群<strong>通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求</strong>。</li>
<li>上面的主从结构可以是集群的一部分。</li>
</ul>
<h2 id="redis集群如何分配节点？"><a href="#redis集群如何分配节点？" class="headerlink" title="redis集群如何分配节点？"></a>redis集群如何分配节点？</h2><ul>
<li><strong>一个集群至少要有三个主节点</strong>。</li>
<li>选项 <strong>–cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点</strong>。</li>
<li>分配原则<strong>尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上</strong>。</li>
</ul>
<h2 id="什么是Slots？"><a href="#什么是Slots？" class="headerlink" title="什么是Slots？"></a>什么是Slots？</h2><ul>
<li><p>就是用来分布式存储数据的结构。</p>
</li>
<li><p>一个 Redis 集群包含 16384 个插槽（hash slot）， <strong>数据库中的每个键都属于这 16384 个插槽的其中一个</strong>，<strong>一个插槽中可以有多个键，但一个键只对应一个插槽</strong>。</p>
</li>
<li><p><strong>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽</strong>， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p>
</li>
<li><p><strong>集群中的每个节点负责处理一部分插槽</strong>。 举个例子， 如果一个集群可以有主节点， 其中：</p>
<p>节点 A 负责处理 0 号至 5460 号插槽。</p>
<p>节点 B 负责处理 5461 号至 10922 号插槽。</p>
<p>节点 C 负责处理 10923 号至 16383 号插槽。</p>
</li>
</ul>
<h2 id="redis集群的故障恢复"><a href="#redis集群的故障恢复" class="headerlink" title="redis集群的故障恢复"></a>redis集群的故障恢复</h2><ul>
<li><p>如果主节点下线？从节点能否自动升为主节点？答：能，注意：<strong>15秒超时</strong></p>
</li>
<li><p>主节点恢复后，主从关系会如何？答：主节点回来会变成从机。</p>
</li>
<li><p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p>
<p><strong>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉。</strong></p>
<p><strong>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</strong></p>
<p>redis.conf中的参数  cluster-require-full-coverage</p>
</li>
</ul>
<h2 id="redis集群的好处？"><a href="#redis集群的好处？" class="headerlink" title="redis集群的好处？"></a>redis集群的好处？</h2><ul>
<li><strong>实现扩容</strong></li>
<li><strong>分摊压力</strong></li>
<li><strong>无中心配置相对简单</strong></li>
</ul>
<h2 id="redis集群的不足？"><a href="#redis集群的不足？" class="headerlink" title="redis集群的不足？"></a>redis集群的不足？</h2><ul>
<li><strong>多键操作是不被支持的</strong>，因为多个键所在的slot可能不同。</li>
<li><strong>多键的Redis事务是不被支持的，lua脚本不被支持</strong>。</li>
<li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而<strong>代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大</strong>。</li>
</ul>
<p>————————————————————–Redis三种常用的缓存读写策略———————————————————————-</p>
<h2 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h2><ul>
<li><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></li>
<li>Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。</li>
<li>下面我们来看一下这个策略模式下的缓存读写步骤。</li>
</ul>
<h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><ul>
<li><p>先更新db，然后直接删除cache：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223205824427.png" alt="image-20230223205824427"></p>
</li>
</ul>
<h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><ul>
<li><p>从 cache 中读取数据，读取到就直接返回；cache 中读取不到的话，就从 db 中读取数据返回。最后再把数据放到 cache 中：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223205919248.png" alt="image-20230223205919248"></p>
</li>
</ul>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul>
<li><p>比如说面试官很可能会追问：“<strong>在写数据的过程中，可以先删除 cache ，后更新 db 么？</strong>”</p>
<p><strong>答案：</strong> 那肯定是不行的！因为这样可能会造成 <strong>数据库（db）和缓存（Cache）数据不一致</strong>的问题。</p>
<p>举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。这个过程可以简单描述为：请求 1 先把 cache 中的 A 数据删除 -&gt; 请求 2 从 db 中读取数据-&gt;请求 1 再把 db 中的 A 数据更新</p>
</li>
<li><p>当你这样回答上面的问题之后，面试官可能会紧接着就追问：“<strong>在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？</strong>”</p>
<p><strong>答案：</strong> 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。</p>
<p>举例：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。这个过程可以简单描述为：请求 1 从 db 读数据 A-&gt; 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） -&gt; 请求 1 将数据 A 写入 cache</p>
</li>
</ul>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ol>
<li><strong>首次请求数据一定不在 cache 的问题</strong>。解决办法：<ul>
<li>可以将热点数据可以提前放入 cache 中。</li>
</ul>
</li>
<li><strong>写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率。</strong>解决办法：<ul>
<li>数据库和缓存数据强一致场景 ：更新 db 的时候同样更新 cache，不过我们需要加一个锁&#x2F;分布式锁来保证更新 cache 的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>
</ul>
</li>
</ol>
<h2 id="Read-x2F-Write-Through-Pattern（读写穿透模式）"><a href="#Read-x2F-Write-Through-Pattern（读写穿透模式）" class="headerlink" title="Read&#x2F;Write Through Pattern（读写穿透模式）"></a>Read&#x2F;Write Through Pattern（读写穿透模式）</h2><ul>
<li>Read&#x2F;Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</li>
<li>这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入 db 的功能。</li>
</ul>
<h3 id="写（Write-Through）"><a href="#写（Write-Through）" class="headerlink" title="写（Write Through）"></a>写（Write Through）</h3><ul>
<li><p>先查 cache，cache 中不存在，直接更新 db；cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223211749415.png" alt="image-20230223211749415"></p>
</li>
</ul>
<h3 id="读（Read-Through）"><a href="#读（Read-Through）" class="headerlink" title="读（Read Through）"></a>读（Read Through）</h3><ul>
<li><p>从 cache 中读取数据，读取到就直接返回 ；读取不到的话，先从 db 加载，写入到 cache 后返回响应：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223211840069.png" alt="image-20230223211840069"></p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 <strong>Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache</strong>，而 <strong>Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的</strong>。</li>
<li>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不在 cache 的问题，对于热点数据可以提前放入缓存中。</li>
</ul>
<h2 id="Write-Behind-Pattern（异步缓存写入模式）"><a href="#Write-Behind-Pattern（异步缓存写入模式）" class="headerlink" title="Write Behind Pattern（异步缓存写入模式）"></a>Write Behind Pattern（异步缓存写入模式）</h2><ul>
<li>Write Behind Pattern 和 Read&#x2F;Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。</li>
<li>但是，两个又有很大的不同：<strong>Read&#x2F;Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</strong></li>
<li>很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。</li>
<li>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。</li>
<li>Write Behind Pattern 下 db 的写性能非常高，非常<strong>适合一些数据经常变化又对数据一致性要求没那么高的场景</strong>，比如浏览量、点赞量。</li>
</ul>
<p>————————————————————————Redis基本数据结构详解—————————————————————————</p>
<h2 id="Redis基本数据结构的底层数据结构是什么？"><a href="#Redis基本数据结构的底层数据结构是什么？" class="headerlink" title="Redis基本数据结构的底层数据结构是什么？"></a>Redis基本数据结构的底层数据结构是什么？</h2><ul>
<li><p>Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p>
</li>
<li><p>这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、HashTable（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。</p>
</li>
<li><p>Redis 基本数据结构的底层数据结构实现如下：</p>
<table>
<thead>
<tr>
<th>String</th>
<th>List</th>
<th>Hash</th>
<th>Set</th>
<th>Zset</th>
</tr>
</thead>
<tbody><tr>
<td>SDS（简单动态字符串）</td>
<td>LinkedList（双向链表）&#x2F;ZipList（压缩列表）&#x2F;QuickList（快速列表）</td>
<td>HashTable（哈希表）、ZipList（压缩列表）</td>
<td>ZipList（压缩列表）、Intset（整数集合）</td>
<td>ZipList（压缩列表）、SkipList（跳跃表）</td>
</tr>
</tbody></table>
</li>
<li><p>Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。</p>
</li>
</ul>
<h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>String 是 Redis 中最简单同时也是最常用的一个数据结构。</p>
</li>
<li><p>String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220142410.png" alt="image-20230223220142410"></p>
</li>
<li><p>虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（Simple Dynamic String，<strong>SDS</strong>）。相比于 C 的原生字符串，<strong>Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出</strong>。</p>
</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220438634.png" alt="image-20230223220438634"></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>需要<strong>存储常规数据</strong>的场景：<ul>
<li>举例 ：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。</li>
<li>相关命令 ： <code>SET</code>、<code>GET</code>。</li>
</ul>
</li>
<li>需要<strong>计数</strong>的场景：<ul>
<li>举例 ：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li>
<li>相关命令 ：<code>SET</code>、<code>GET</code>、 <code>INCR</code>、<code>DECR</code> 。</li>
</ul>
</li>
<li><strong>分布式锁</strong>：<ul>
<li>利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁（存在一些缺陷，<strong>通常不建议这样实现分布式锁</strong>）。</li>
</ul>
</li>
</ul>
<h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>Redis 中的 List 其实就是链表数据结构的实现。</p>
</li>
<li><p>许多高级编程语言都内置了链表的实现比如 Java 中的 <code>LinkedList</code>，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 List 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220254844.png" alt="image-20230223220254844"></p>
</li>
</ul>
<h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220502834.png" alt="image-20230223220502834"></p>
<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><strong>信息流展示</strong>：<ul>
<li>举例 ：最新文章、最新动态。</li>
<li>相关命令 ： <code>LPUSH</code>、<code>LRANGE</code>。</li>
</ul>
</li>
<li><strong>消息队列</strong>：<ul>
<li>Redis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。</li>
<li>相对来说，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</li>
</ul>
</li>
</ul>
<h2 id="Hash（哈希表）"><a href="#Hash（哈希表）" class="headerlink" title="Hash（哈希表）"></a>Hash（哈希表）</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</p>
</li>
<li><p>Hash 类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220743151.png" alt="image-20230223220743151"></p>
</li>
</ul>
<h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220809369.png" alt="image-20230223220809369"></p>
<h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><strong>对象数据存储场景</strong>：<ul>
<li>举例 ：用户信息、商品信息、文章信息、购物车信息。</li>
<li>相关命令 ：<code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）。</li>
</ul>
</li>
</ul>
<h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>Redis 中的 Set 类型是一种<strong>无序集合，集合中的元素没有先后顺序但都唯一</strong>，有点类似于 Java 中的 <code>HashSet</code> 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p>
</li>
<li><p>你可以基于 Set 轻易实现交集、并集、差集的操作，比如你<strong>可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223222643653.png" alt="image-20230223222643653"></p>
</li>
</ul>
<h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223222716378.png" alt="image-20230223222716378"></p>
<h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><strong>需要存放的数据不能重复的场景</strong>：<ul>
<li>举例：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</li>
<li>相关命令：<code>SCARD</code>（获取集合数量） 。</li>
</ul>
</li>
<li><strong>需要获取多个数据源交集、并集和差集的场景</strong>：<ul>
<li>举例 ：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集） 、订阅号推荐（差集+交集） 等场景。</li>
<li>相关命令：<code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）。</li>
</ul>
</li>
<li><strong>需要随机获取数据源中的元素的场景</strong>：<ul>
<li>举例 ：抽奖系统、随机。</li>
<li>相关命令：<code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）。</li>
</ul>
</li>
<li><strong>可以用于解决接口幂等性的问题</strong>：<ul>
<li>给调用接口要执行的操作一个uuid存到redis的set中，然后如果这次没有调用完又来了一次调用，那么这次调用的时候就能通过set中的uuid来判断是否是同一个请求，如果是，就拒绝这次请求，这样就实现了接口的幂等性。</li>
</ul>
</li>
</ul>
<h2 id="Sorted-Set（有序集合）"><a href="#Sorted-Set（有序集合）" class="headerlink" title="Sorted Set（有序集合）"></a>Sorted Set（有序集合）</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>Sorted Set 类似于 Set，但和 Set 相比，<strong>Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表</strong>。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223223030914.png" alt="image-20230223223030914"></p>
</li>
</ul>
<h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223223054604.png" alt="image-20230223223054604"></p>
<h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong>：<ul>
<li>举例 ：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li>
<li>相关命令 ：<code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li>
</ul>
</li>
<li><strong>需要存储的数据有优先级或者重要程度的场景</strong>：<ul>
<li>举例 ：优先级任务队列。</li>
<li>相关命令 ：<code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li>
</ul>
</li>
</ul>
<p>————————————————————————Redis特殊数据结构详解—————————————————————————</p>
<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, <strong>只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身</strong> 。我们知道 8 个 bit 可以组成一个 byte，所以 <strong>Bitmap 本身会极大的节省储存空间</strong>。</p>
</li>
<li><p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223223400243.png" alt="image-20230223223400243"></p>
</li>
</ul>
<h3 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223223428295.png" alt="image-20230223223428295"></p>
<h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><strong>需要保存状态信息（0&#x2F;1 即可表示）的场景</strong>：<ul>
<li>举例 ：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li>
<li>相关命令 ：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>。</li>
</ul>
</li>
<li><strong>实现布隆过滤器</strong>：<ul>
<li>&#x2F;&#x2F;todo</li>
</ul>
</li>
</ul>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li>HyperLogLog 是一种有名的<strong>基数计数概率算法</strong> ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。</li>
<li>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素。这是真的厉害，这就是数学的魅力么！并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：<ul>
<li><strong>稀疏矩阵</strong> ：计数较少的时候，占用空间很小。</li>
<li><strong>稠密矩阵</strong> ：计数达到某个阈值的时候，占用 12k 的空间。</li>
</ul>
</li>
<li>基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code>0.81%</code> 。）。</li>
</ul>
<h3 id="常用命令-6"><a href="#常用命令-6" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223224557133.png" alt="image-20230223224557133"></p>
<h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><strong>数量量巨大（百万、千万级别以上）的计数场景</strong>：<ul>
<li>举例 ：热门网站每日&#x2F;每周&#x2F;每月访问 ip 数统计、热门帖子 uv 统计、</li>
<li>相关命令 ：<code>PFADD</code>、<code>PFCOUNT</code> 。</li>
</ul>
</li>
</ul>
<h2 id="Geospatial-index"><a href="#Geospatial-index" class="headerlink" title="Geospatial index"></a>Geospatial index</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>Geospatial index（地理空间索引，简称 GEO） 主要<strong>用于存储地理位置信息</strong>，<strong>基于 Sorted Set 实现</strong>，GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。通过 GEO 我们可以轻松<strong>实现两个位置距离的计算、获取指定位置附近的元素</strong>等功能。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223224817449.png" alt="image-20230223224817449"></p>
</li>
</ul>
<h3 id="常用命令-7"><a href="#常用命令-7" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223224838093.png" alt="image-20230223224838093"></p>
<h3 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li><strong>需要管理使用地理空间数据的场景</strong>：<ul>
<li>举例：附近的人。</li>
<li>相关命令: <code>GEOADD</code>、<code>GEORADIUS</code>、<code>GEORADIUSBYMEMBER</code> 。</li>
</ul>
</li>
</ul>
<p>————————————————————————Redis内存碎片详解—————————————————————————</p>
<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h2><ul>
<li>我们可以把消息队列看作是<strong>一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可</strong>。由于队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。</li>
<li>参与消息传递的双方称为生产者和消费者，<strong>生产者负责发送消息，消费者负责处理消息</strong>。</li>
<li>我们知道操作系统中的进程通信的一种很重要的方式就是消息队列。我们这里提到的消息队列稍微有点区别，更多指的是各个服务以及系统内部各个组件&#x2F;模块之前的通信，属于一种中间件。</li>
<li>随着分布式和微服务系统的发展，消息队列在系统设计中有了更大的发挥空间，<strong>使用消息队列可以降低系统耦合性、实现任务异步、有效地进行流量削峰</strong>，是分布式和微服务系统中重要的组件之一。</li>
</ul>
<h2 id="消息队列有什么用？"><a href="#消息队列有什么用？" class="headerlink" title="消息队列有什么用？"></a>消息队列有什么用？</h2><ul>
<li>通常来说，使用消息队列能为我们的系统带来下面三点好处：<ol>
<li><strong>通过异步处理提高系统性能（减少响应所需时间）。</strong></li>
<li><strong>削峰&#x2F;限流</strong></li>
<li><strong>降低系统耦合性。</strong></li>
</ol>
</li>
<li>如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的简历上涉及到消息队列这方面的内容，这个时候推荐你结合你自己的项目来回答。</li>
</ul>
<h3 id="通过异步处理提高系统性能（减少响应所需时间）"><a href="#通过异步处理提高系统性能（减少响应所需时间）" class="headerlink" title="通过异步处理提高系统性能（减少响应所需时间）"></a>通过异步处理提高系统性能（减少响应所需时间）</h3><ul>
<li><strong>将用户的请求数据存储到消息队列之后就立即返回结果。随后，系统再对消息进行消费</strong>。</li>
<li>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，<strong>使用消息队列进行异步处理之后，需要适当修改业务流程进行配合</strong>，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</li>
</ul>
<h3 id="削峰-x2F-限流"><a href="#削峰-x2F-限流" class="headerlink" title="削峰&#x2F;限流"></a>削峰&#x2F;限流</h3><ul>
<li><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。</strong></li>
</ul>
<h3 id="降低系统耦合度"><a href="#降低系统耦合度" class="headerlink" title="降低系统耦合度"></a>降低系统耦合度</h3><ul>
<li>使用消息队列还可以<strong>降低系统耦合度</strong>。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。</li>
<li>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。</li>
<li><strong>消息队列使用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</li>
<li>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</li>
<li>另外，为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</li>
<li><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了 5 种消息模型。</li>
</ul>
<h2 id="使用消息队列产生的问题？"><a href="#使用消息队列产生的问题？" class="headerlink" title="使用消息队列产生的问题？"></a>使用消息队列产生的问题？</h2><ul>
<li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li>
<li><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li>
<li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li>
</ul>
<h2 id="AMQP是什么？"><a href="#AMQP是什么？" class="headerlink" title="AMQP是什么？"></a>AMQP是什么？</h2><ul>
<li>AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制。</li>
<li><strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></li>
</ul>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="相关名词介绍"><a href="#相关名词介绍" class="headerlink" title="相关名词介绍"></a>相关名词介绍</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029093829448.png" alt="image-20221029093829448"></p>
<ul>
<li><strong>Broker（代理）</strong>：<strong>接收和分发消息的应用</strong>，RabbitMQ Server 就是 Message Broker。</li>
<li><strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP（协议）的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。<strong>当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</strong>。</li>
<li><strong>Connection</strong>：<strong>publisher／consumer 和 broker 之间的 TCP 连接</strong>。</li>
<li><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。<strong>Channel 是在 connection 内部建立的逻辑连接</strong>，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的Connection极大减少了操作系统建立TCP connection的开销</strong>。</li>
<li><strong>Exchange</strong>：message 到达 broker 的第一站，<strong>根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去</strong>。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</li>
<li><strong>Queue</strong>：<strong>消息最终被送到这里等待 consumer 取走</strong>。</li>
<li><strong>Binding</strong>：<strong>exchange 和 queue 之间的虚拟连接</strong>，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</li>
</ul>
<h2 id="RabbitMQ是什么？"><a href="#RabbitMQ是什么？" class="headerlink" title="RabbitMQ是什么？"></a>RabbitMQ是什么？</h2><ul>
<li>RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</li>
<li>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个Broker构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。</li>
<li>PS:也可能直接问什么是消息队列？<strong>消息队列就是一个使用队列来通信的组件</strong>。</li>
</ul>
<h2 id="RabbitMQ的特点？"><a href="#RabbitMQ的特点？" class="headerlink" title="RabbitMQ的特点？"></a>RabbitMQ的特点？</h2><ul>
<li><strong>可靠性</strong>: RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。</li>
<li><strong>灵活的路由</strong> : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个 交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。</li>
<li><strong>扩展性</strong>: 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。</li>
<li><strong>高可用性</strong> : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。</li>
<li><strong>多种协议</strong>: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息 中间件协议。</li>
<li><strong>多语言客户端</strong> :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。</li>
<li><strong>管理界面</strong> : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。</li>
<li><strong>插件机制</strong> : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。</li>
</ul>
<h2 id="AMQP是什么？-1"><a href="#AMQP是什么？-1" class="headerlink" title="AMQP是什么？"></a>AMQP是什么？</h2><ul>
<li>AMQP的全称为：Advanced Message Queuing Protocol（高级消息队列协议）</li>
<li>RabbitMQ 就是 AMQP 协议的 <code>Erlang</code> 的实现(当然 RabbitMQ 还支持 <code>STOMP2</code>、 <code>MQTT3</code> 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定 。</li>
<li>RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相应的概念。目前 RabbitMQ 最新版本默认支持的是 AMQP 0-9-1。</li>
</ul>
<h3 id="AMQP协议的三层结构"><a href="#AMQP协议的三层结构" class="headerlink" title="AMQP协议的三层结构"></a>AMQP协议的三层结构</h3><ol>
<li><strong>Module Layer</strong>:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。</li>
<li><strong>Session Layer</strong>:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。</li>
<li><strong>TransportLayer</strong>:最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。</li>
</ol>
<h3 id="AMQP模型的三大组件"><a href="#AMQP模型的三大组件" class="headerlink" title="AMQP模型的三大组件"></a>AMQP模型的三大组件</h3><ol>
<li><strong>交换器 (Exchange)</strong> ：消息代理服务器中用于把消息路由到队列的组件。</li>
<li><strong>队列 (Queue)</strong> ：用来存储消息的数据结构，位于硬盘或内存中。</li>
<li><strong>绑定 (Binding)</strong> ：一套规则，告知交换器消息应该将消息投递给哪个队列。</li>
</ol>
<h2 id="说说生产者Producer和消费者Consumer？"><a href="#说说生产者Producer和消费者Consumer？" class="headerlink" title="说说生产者Producer和消费者Consumer？"></a>说说生产者Producer和消费者Consumer？</h2><ul>
<li><strong>生产者</strong> :<ul>
<li>消息生产者，就是投递消息的一方。</li>
<li>消息一般包含两个部分：消息体（<code>payload</code>)和标签(<code>Label</code>)。</li>
</ul>
</li>
<li><strong>消费者</strong> ：<ul>
<li>消费消息，也就是接收消息的一方。</li>
<li>消费者连接到 RabbitMQ 服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。</li>
</ul>
</li>
</ul>
<h2 id="说说-Broker-服务节点、Queue-队列、Exchange-交换器？"><a href="#说说-Broker-服务节点、Queue-队列、Exchange-交换器？" class="headerlink" title="说说 Broker 服务节点、Queue 队列、Exchange 交换器？"></a>说说 Broker 服务节点、Queue 队列、Exchange 交换器？</h2><ul>
<li><strong>Broker</strong> ：可以看做 RabbitMQ 的服务节点。一般请下一个 Broker 可以看做一个 RabbitMQ 服务器。</li>
<li><strong>Queue</strong> : RabbitMQ 的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时<strong>队列中的消息会被平摊（轮询）给多个消费者进行处理</strong>。</li>
<li><strong>Exchange</strong> : 生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。</li>
</ul>
<h2 id="什么是死信队列？"><a href="#什么是死信队列？" class="headerlink" title="什么是死信队列？"></a>什么是死信队列？</h2><ul>
<li><strong>DLX，全称为 <code>Dead-Letter-Exchange</code>，死信交换器</strong>，死信邮箱。当消息在一个队列中变成死信 (<code>dead message</code>) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，<strong>绑定 DLX 的队列就称之为死信队列</strong>。</li>
</ul>
<h2 id="死信是如何导致的？"><a href="#死信是如何导致的？" class="headerlink" title="死信是如何导致的？"></a>死信是如何导致的？</h2><ol>
<li>消息被拒（<code>Basic.Reject /Basic.Nack</code>) 且 <code>requeue = false</code>。</li>
<li>消息 TTL 过期。</li>
<li>队列满了，无法再添加。</li>
</ol>
<h2 id="什么是延迟队列？"><a href="#什么是延迟队列？" class="headerlink" title="什么是延迟队列？"></a>什么是延迟队列？</h2><ul>
<li>延迟队列指的是存储对应的延迟消息，消息被发送以后，并不想让消费者立刻拿到消息，而是<strong>等待特定时间后，消费者才能拿到这个消息进行消费</strong>。</li>
</ul>
<h2 id="RabbitMQ怎么实现延迟队列？"><a href="#RabbitMQ怎么实现延迟队列？" class="headerlink" title="RabbitMQ怎么实现延迟队列？"></a>RabbitMQ怎么实现延迟队列？</h2><ul>
<li>RabbitMQ本身是没有延迟队列的，要实现延迟消息，一般有两种方式：<ol>
<li>通过RabbitMQ本身队列的特性来实现，需要使用RabbitMQ的死信交换机（Exchange）和消息的存活时间TTL（Time To Live）。</li>
<li>在RabbitMQ 3.5.7及以上的版本提供了一个插件（rabbitmq-delayed-message-exchange）来实现延迟队列功能。同时，插件依赖Erlang&#x2F;OPT 18.0及以上。</li>
</ol>
</li>
<li>也就是说，AMQP 协议以及RabbitMQ本身没有直接支持延迟队列的功能，但是可以通过TTL和DLX模拟出延迟队列的功能。</li>
</ul>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ul>
<li><p>先来个架构图，需要<strong>手动给队列配置它的死信队列</strong>：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117110145349.png" alt="image-20221117110145349"></p>
</li>
<li><p>具体是怎么实现呢？首先我们可以<strong>给队列或者发的消息设置TTL，阻塞掉那个队列的所有消费者，这样消息就能在队列中自然过期，然后被送到死信交换机中，然后被路由到死信队列中，真正的消费者是消费死信队列中的消息，这样就达到了延时队列的效果</strong>。</p>
</li>
<li><p>关于消息和队列TTL的几个问题：首先就是如果一个消息设置了TTL，它所去的队列也设置了TTL，那么<strong>较小的那个值会被使用</strong>。然后就是如果<strong>设置了队列的TTL，那么一旦消息过期，消息会立刻被丢弃</strong>；如果<strong>只是设置了消息的TTL，那么即使消息过期也不一定会被马上丢弃，因为消息会等它被消费到的时候判断是否过期</strong>，过期就丢弃，不过期就消费。</p>
</li>
</ul>
<h2 id="什么是优先级队列？"><a href="#什么是优先级队列？" class="headerlink" title="什么是优先级队列？"></a>什么是优先级队列？</h2><ul>
<li>RabbitMQ 自 V3.5.0 有优先级队列实现，优先级高的队列会先被消费。</li>
<li>可以通过<code>x-max-priority</code>参数来实现优先级队列。不过，当消费速度大于生产速度且 Broker 没有堆积的情况下，优先级显得没有意义。</li>
</ul>
<h2 id="RabbitMQ有哪些工作模式？"><a href="#RabbitMQ有哪些工作模式？" class="headerlink" title="RabbitMQ有哪些工作模式？"></a>RabbitMQ有哪些工作模式？</h2><ul>
<li><p><strong>简单模式</strong>：一个生产者，一个消费者，中间通过一个队列直接连接。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230224114922728.png" alt="image-20230224114922728"></p>
</li>
<li><p><strong>work 工作模式</strong>：就是<strong>有多个消费者消费队列里的消息，队列里的消息只能被一个消费者消费，这样多部署几个消费者，就可以缓解压力</strong>，比如过年的时候抢票，抢票成功后会给你发短信，这个时候就可以把发短信的任务放入队列里，然后有多个发短信的服务来处理队列里的任务。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230224114937419.png" alt="image-20230224114937419"></p>
</li>
<li><p><strong>pub&#x2F;sub 发布订阅模式</strong>：用到一个Exchange交换机角色来帮助我们把消息发给所有订阅我们的消费者。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230224115119733.png" alt="image-20230224115119733"></p>
</li>
<li><p><strong>Routing 路由模式</strong>：路由模式就是交换机并不是给所有订阅他的队列发送消息了，而是<strong>根据路由键来确定应该给哪个队列发送消息，队列和交换机绑定的时候需要通过路由键，而生产者发送消息的时候也需要指定路由键</strong>，这样就可以确定给哪个队列发送消息了。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230224115144791.png" alt="image-20230224115144791"></p>
</li>
<li><p><strong>Topic 主题模式</strong>：主题模式就相当于模糊匹配，假如我想给姓张的发送消息，那么我就可以通过主题模式给所有姓张的发送消息。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230224115222685.png" alt="image-20230224115222685"></p>
</li>
</ul>
<h2 id="RabbitMQ消息怎么传输？"><a href="#RabbitMQ消息怎么传输？" class="headerlink" title="RabbitMQ消息怎么传输？"></a>RabbitMQ消息怎么传输？</h2><ul>
<li>由于 TCP 链接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈，所以 <strong>RabbitMQ 使用信道的方式来传输数据</strong>。信道（Channel）是生产者、消费者与 RabbitMQ 通信的渠道，<strong>信道是建立在 TCP 链接上的虚拟链接，且每条 TCP 链接上的信道数量没有限制</strong>。就是说 RabbitMQ 在一条 TCP 链接上建立成百上千个信道来达到多个线程处理，<strong>这个 TCP 被多个线程共享，每个信道在 RabbitMQ 都有唯一的 ID，保证了信道私有性，每个信道对应一个线程使用</strong>。</li>
</ul>
<h2 id="如何保证消息的可靠性？"><a href="#如何保证消息的可靠性？" class="headerlink" title="如何保证消息的可靠性？"></a>如何保证消息的可靠性？</h2><ul>
<li>可能出现这几种问题：消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。</li>
<li>生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：<strong>事务机制和 Confirm 机制是互斥的，两者不能共存</strong>，会导致 RabbitMQ 报错。</li>
<li>RabbitMQ 自身：持久化、集群、普通模式、镜像模式。</li>
<li>RabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制。</li>
</ul>
<h2 id="如何保证RabbitMQ消息的顺序性？"><a href="#如何保证RabbitMQ消息的顺序性？" class="headerlink" title="如何保证RabbitMQ消息的顺序性？"></a>如何保证RabbitMQ消息的顺序性？</h2><ul>
<li>拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是**多一些 queue (消息队列)**而已，确实是麻烦点；</li>
<li>或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 <strong>consumer(消费者)内部用内存队列做排队</strong>，然后分发给底层不同的 worker 来处理。</li>
</ul>
<h2 id="如何保证RabbitMQ的高可用？"><a href="#如何保证RabbitMQ的高可用？" class="headerlink" title="如何保证RabbitMQ的高可用？"></a>如何保证RabbitMQ的高可用？</h2><ul>
<li>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：<strong>单机模式、普通集群模式、镜像集群模式</strong>。</li>
</ul>
<h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><ul>
<li>Demo 级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。</li>
</ul>
<h3 id="普通集群模式"><a href="#普通集群模式" class="headerlink" title="普通集群模式"></a>普通集群模式</h3><ul>
<li>意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你<strong>创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据</strong>（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。</li>
<li>你消费的时候，实际上<strong>如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来</strong>。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</li>
</ul>
<h3 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h3><ul>
<li>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，<strong>在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思</strong>。然后每次你写消息到 queue 的时候，都会<strong>自动把消息同步到多个实例的 queue 上</strong>。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</li>
<li>这样的<strong>好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据</strong>。<strong>坏处在于，性能开销太大，消息需要同步到所有机器上，导致网络带宽压力和消耗很重</strong>！镜像集群下，每个节点都存放着所有 queue 的完整数据。</li>
</ul>
<h2 id="如何解决消息挤压问题？"><a href="#如何解决消息挤压问题？" class="headerlink" title="如何解决消息挤压问题？"></a>如何解决消息挤压问题？</h2><ul>
<li><strong>临时紧急扩容</strong>。先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</li>
</ul>
<h2 id="如何解决消息队列的延时以及过期失效问题？"><a href="#如何解决消息队列的延时以及过期失效问题？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？"></a>如何解决消息队列的延时以及过期失效问题？</h2><ul>
<li>RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是<strong>批量重导</strong>，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，<strong>将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来</strong>。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://Konjacor.github.io">Konjacer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://konjacor.github.io/2023/01/20/%E7%BB%BC%E5%90%88%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/">https://konjacor.github.io/2023/01/20/%E7%BB%BC%E5%90%88%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Konjacor.github.io" target="_blank">孤舟</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BB%BC%E5%90%88%E7%9F%A5%E8%AF%86/">综合知识</a></div><div class="post_share"><div class="social-share" data-image="/img/background.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/01/MySQL/"><img class="prev-cover" src="/img/background.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/22/%E8%B4%BE%E5%B2%9B%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"><img class="next-cover" src="/img/background.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">贾岛项目开发日志</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/xiaozhai.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Konjacer</div><div class="author-info__description">真我不拘于形</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">80</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Konjacor" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1175590069@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/Konjacor" target="_blank" title="Gitee"><i class="fa-solid fa-g"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">Java 语言有哪些特点?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-number">1.2.</span> <span class="toc-text">JVM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK%E5%92%8CJRE"><span class="toc-number">1.3.</span> <span class="toc-text">JDK和JRE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E8%8A%82%E7%A0%81%EF%BC%9F%E9%87%87%E7%94%A8%E5%AD%97%E8%8A%82%E7%A0%81%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">什么是字节码？采用字节码的好处是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%85%A8%E9%83%A8%E4%BD%BF%E7%94%A8AOT%E5%91%A2%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">为什么不全部使用AOT呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Java%E8%AF%AD%E8%A8%80%E2%80%9C%E7%BC%96%E8%AF%91%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%B9%B6%E5%AD%98%E2%80%9D%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">为什么说Java语言“编译与解释并存”？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Oracle-JDK%E5%92%8COpenJDK"><span class="toc-number">1.7.</span> <span class="toc-text">Oracle JDK和OpenJDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">Java和C++的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.9.</span> <span class="toc-text">Java中的三种移位运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">成员变量和局部变量的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%E9%9D%9E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">1.11.</span> <span class="toc-text">静态方法为什么不能调用非静态成员?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">重载和重写的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">1.12.1.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99"><span class="toc-number">1.12.2.</span> <span class="toc-text">重写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%E9%81%87%E5%88%B0%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F%E4%BC%9A%E4%BC%98%E5%85%88%E5%8C%B9%E9%85%8D%E5%9B%BA%E5%AE%9A%E5%8F%82%E6%95%B0%E8%BF%98%E6%98%AF%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95%E5%91%A2%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">可变长参数遇到方法重载怎么办？会优先匹配固定参数还是可变参数的方法呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.14.</span> <span class="toc-text">Java中的基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.15.</span> <span class="toc-text">基本类型和包装类型的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E9%83%BD%E5%AD%98%E5%9C%A8%E5%A0%86%E4%B8%AD%E5%90%97%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">所有的对象实例都存在堆中吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">包装类型的缓存机制了解么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.18.</span> <span class="toc-text">自动装箱与拆箱了解吗？原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E6%9C%89%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E7%9A%84%E9%A3%8E%E9%99%A9%EF%BC%9F"><span class="toc-number">1.19.</span> <span class="toc-text">为什么浮点数运算的时候会有精度丢失的风险？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.20.</span> <span class="toc-text">如何解决浮点数运算的精度丢失问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E8%BF%87long%E6%95%B4%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%A1%A8%E7%A4%BA%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">超过long整型的数据应该如何表示？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.22.</span> <span class="toc-text">面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%94%A8%E4%BB%80%E4%B9%88%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-number">1.23.</span> <span class="toc-text">创建一个对象用什么运算符?对象实体与对象引用有何不同?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%E5%92%8C%E5%BC%95%E7%94%A8%E7%9B%B8%E7%AD%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.24.</span> <span class="toc-text">对象相等和引用相等的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.25.</span> <span class="toc-text">类的构造方法的作用是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%A3%B0%E6%98%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AF%A5%E7%A8%8B%E5%BA%8F%E8%83%BD%E6%AD%A3%E7%A1%AE%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">1.26.</span> <span class="toc-text">如果一个类没有声明构造方法，该程序能正确执行吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%AB-override"><span class="toc-number">1.27.</span> <span class="toc-text">构造方法有哪些特点？是否可被 override?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">1.28.</span> <span class="toc-text">面向对象四大特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.28.1.</span> <span class="toc-text">抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.28.2.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.28.3.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.28.4.</span> <span class="toc-text">多态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.29.</span> <span class="toc-text">接口和抽象类有什么共同点和区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="toc-number">1.30.</span> <span class="toc-text">深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.31.</span> <span class="toc-text">Object类的常见方法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x3D-x3D-%E5%92%8Cequals-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.32.</span> <span class="toc-text">&#x3D;&#x3D;和equals()的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashCode-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">1.33.</span> <span class="toc-text">hashCode()有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-hashCode%EF%BC%9F"><span class="toc-number">1.34.</span> <span class="toc-text">为什么要有 hashCode？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99hashCode-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.35.</span> <span class="toc-text">为什么重写equals()时必须重写hashCode()方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.36.</span> <span class="toc-text">String、StringBuffer、StringBuilder 的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">1.36.1.</span> <span class="toc-text">可变性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE%E6%A6%82%E8%A7%88"><span class="toc-number">1.37.</span> <span class="toc-text">Java异常类层次结构图概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exception%E5%92%8CError%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.38.</span> <span class="toc-text">Exception和Error有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Checked-Exception-%E5%92%8C-Unchecked-Exception-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.39.</span> <span class="toc-text">Checked Exception 和 Unchecked Exception 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Throwable%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.40.</span> <span class="toc-text">Throwable类常用方法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-catch-finally%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">1.41.</span> <span class="toc-text">try-catch-finally如何使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finally-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">1.42.</span> <span class="toc-text">finally 中的代码一定会执行吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-try-with-resources-%E4%BB%A3%E6%9B%BFtry-catch-finally%EF%BC%9F"><span class="toc-number">1.43.</span> <span class="toc-text">如何使用 try-with-resources 代替try-catch-finally？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.43.1.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.43.2.</span> <span class="toc-text">泛型方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.44.</span> <span class="toc-text">项目中哪里用到了泛型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-number">1.45.</span> <span class="toc-text">什么是反射？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.46.</span> <span class="toc-text">反射的优缺点?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">1.47.</span> <span class="toc-text">反射的应用场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%A8%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.48.</span> <span class="toc-text">什么是注解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%A3%E6%9E%90%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">1.49.</span> <span class="toc-text">注解的解析方法有哪几种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSPI%EF%BC%9F"><span class="toc-number">1.50.</span> <span class="toc-text">什么是SPI？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E5%92%8CAPI%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.51.</span> <span class="toc-text">SPI和API有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SPI%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.52.</span> <span class="toc-text">SPI的优缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-number">1.53.</span> <span class="toc-text">什么是序列化？什么是反序列化？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC"><span class="toc-number">2.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8Bsynchronized%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">说一下synchronized锁升级的机制？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ConcurrentHashMap%E7%9A%84key%E5%92%8Cvalue%E4%B8%8D%E8%83%BD%E4%B8%BA%E7%A9%BA%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">为什么ConcurrentHashMap的key和value不能为空？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ThreadLocalMap%E7%9A%84key%E6%98%AF%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">为什么ThreadLocalMap的key是弱引用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ThreadLocalMap%E7%9A%84value%E4%B8%8D%E6%98%AF%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">为什么ThreadLocalMap的value不是弱引用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E5%9C%A8%E6%88%91%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.5.</span> <span class="toc-text">ThreadLocal在我的项目中的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%80%8E%E4%B9%88%E5%85%B3%E9%97%AD%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">线程池怎么关闭？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdown"><span class="toc-number">2.6.1.</span> <span class="toc-text">shutdown()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdownNow"><span class="toc-number">2.6.2.</span> <span class="toc-text">shutdownNow()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdown-%E5%92%8CshutdownNow-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">2.6.3.</span> <span class="toc-text">shutdown()和shutdownNow()的异同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">阻塞队列有哪些？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM-1"><span class="toc-number">3.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%AF%B9%E8%B1%A1%E5%9C%A8%E5%A0%86%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">java对象在堆中的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%B4%EF%BC%88header%EF%BC%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">对象头（header）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE%EF%BC%88instance-data%EF%BC%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">实例数据（instance data）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85%EF%BC%88padding%EF%BC%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">对齐填充（padding）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.2.</span> <span class="toc-text">对象如何定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E7%9B%B4%E6%8E%A5%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.2.1.</span> <span class="toc-text">通过指针直接定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E9%97%B4%E6%8E%A5%E5%AE%9A%E4%BD%8D"><span class="toc-number">3.2.2.</span> <span class="toc-text">通过句柄间接定位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO"><span class="toc-number">4.</span> <span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">谈谈你对IO多路复用的理解？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring"><span class="toc-number">5.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%ADBean%E7%9A%84Scope%E6%98%AFSingleton%E7%9A%84%E6%97%B6%E5%80%99Bean%E6%98%AF%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%90%97%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">Spring中Bean的Scope是Singleton的时候Bean是单例模式吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">Spring中Bean的生命周期？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F%E5%AE%83%E5%92%8CAspectJ%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">Spring AOP是如何实现的？它和AspectJ有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">Spring中的事务是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">Spring事务什么时候失效？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%EF%BC%9F"><span class="toc-number">5.6.</span> <span class="toc-text">Spring是如何解决循环依赖的？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Boot"><span class="toc-number">6.</span> <span class="toc-text">Spring Boot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%99%E8%BF%B0%E4%B8%80%E4%B8%8BSpring-Boot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">叙述一下Spring Boot自动装配机制的原理？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MyBatis"><span class="toc-number">7.</span> <span class="toc-text">MyBatis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">#{}和${}的区别是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">8.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.1.</span> <span class="toc-text">OSI 七层模型是什么？每一层的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-x2F-IP-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">TCP&#x2F;IP 四层模型是什么？每一层的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">HTTP和HTTPS的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP1-0%E3%80%811-1%E3%80%812-0%E3%80%813-0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.4.</span> <span class="toc-text">HTTP1.0、1.1、2.0、3.0之间的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">TCP网络传输中的粘包问题是什么意思？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3TCP%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E4%B8%AD%E7%9A%84%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">8.6.</span> <span class="toc-text">如何解决TCP网络传输中的粘包问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89HTTP1-1%E4%B8%8D%E7%94%A8%EF%BC%8C%E8%A6%81%E7%94%A8RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">8.7.</span> <span class="toc-text">为什么有HTTP1.1不用，要用RPC协议？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">9.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">什么是操作系统？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">多级反馈队列调度算法了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">9.3.</span> <span class="toc-text">什么是虚拟内存？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">9.4.</span> <span class="toc-text">虚拟内存技术的实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">9.5.</span> <span class="toc-text">常见的页面置换算法有哪些？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA"><span class="toc-number">10.</span> <span class="toc-text">数据库理论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%AF%E8%AF%AD"><span class="toc-number">10.1.</span> <span class="toc-text">一些数据库术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%9C%89%E5%93%AA%E4%B8%89%E7%A7%8D%EF%BC%9F"><span class="toc-number">10.2.</span> <span class="toc-text">数据库关系的完整性有哪三种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%B0%86ER%E5%9B%BE%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">10.3.</span> <span class="toc-text">怎么将ER图转换为关系模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9sql%E8%BF%9B%E8%A1%8C%E4%BB%A3%E6%95%B0%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">10.4.</span> <span class="toc-text">如何对sql进行代数优化？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-number">11.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BD%93%E5%89%8D%E8%AF%BB%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">什么是快照读？什么是当前读？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BMVCC%EF%BC%9F"><span class="toc-number">11.2.</span> <span class="toc-text">介绍一下MVCC？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">11.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">11.2.2.</span> <span class="toc-text">技术依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Read-View%E5%92%8CDB-TRX-ID%E5%AD%97%E6%AE%B5%E6%9D%A5%E5%88%A4%E6%96%AD%E8%AE%B0%E5%BD%95%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">11.2.3.</span> <span class="toc-text">如何使用Read View和DB_TRX_ID字段来判断记录的可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">11.2.4.</span> <span class="toc-text">实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88InnoDB%E5%BC%95%E6%93%8E%E8%A7%84%E5%AE%9A%E9%A1%B5%E7%9A%84%E9%BB%98%E8%AE%A4%E5%A4%A7%E5%B0%8F%E6%98%AF16kb%EF%BC%9F"><span class="toc-number">11.3.</span> <span class="toc-text">为什么InnoDB引擎规定页的默认大小是16kb？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96SQL%EF%BC%9F"><span class="toc-number">11.4.</span> <span class="toc-text">日常工作中怎么优化SQL？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-number">12.</span> <span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8ERedis%EF%BC%8C%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.1.</span> <span class="toc-text">对于Redis，你的理解是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedis%EF%BC%9F"><span class="toc-number">12.2.</span> <span class="toc-text">什么是Redis？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">12.3.</span> <span class="toc-text">Redis为什么这么快？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%92%8CMemcached%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">12.4.</span> <span class="toc-text">Redis和Memcached的区别和共同点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">12.4.1.</span> <span class="toc-text">共同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">12.4.2.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Redis-x2F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">12.5.</span> <span class="toc-text">为什么要用Redis&#x2F;为什么要用缓存？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD"><span class="toc-number">12.5.1.</span> <span class="toc-text">高性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="toc-number">12.5.2.</span> <span class="toc-text">高并发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%99%A4%E4%BA%86%E5%81%9A%E7%BC%93%E5%AD%98%E4%B9%8B%E5%A4%96%EF%BC%8C%E8%BF%98%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.6.</span> <span class="toc-text">Redis除了做缓存之外，还能做什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%8F%AF%E4%BB%A5%E5%81%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%90%97%EF%BC%9F"><span class="toc-number">12.7.</span> <span class="toc-text">Redis可以做消息队列吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="toc-number">12.8.</span> <span class="toc-text">如何基于Redis实现分布式锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">12.9.</span> <span class="toc-text">Redis常用的数据结构有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">12.10.</span> <span class="toc-text">String 的应用场景有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E4%BD%BF%E7%94%A8String%E8%BF%98%E6%98%AFHash%E6%9B%B4%E5%A5%BD%EF%BC%9F"><span class="toc-number">12.11.</span> <span class="toc-text">存储对象数据使用String还是Hash更好？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.12.</span> <span class="toc-text">String的底层实现是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AD%E7%89%A9%E8%BD%A6%E4%BF%A1%E6%81%AF%E7%94%A8String%E8%BF%98%E6%98%AFHash%E5%AD%98%E5%82%A8%E6%9B%B4%E5%A5%BD%E5%91%A2%EF%BC%9F"><span class="toc-number">12.13.</span> <span class="toc-text">购物车信息用String还是Hash存储更好呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Redis%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%8E%92%E8%A1%8C%E6%A6%9C%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">12.14.</span> <span class="toc-text">使用Redis实现一个排行榜怎么做？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Set%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%A5%96%E7%B3%BB%E7%BB%9F%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-number">12.15.</span> <span class="toc-text">使用Set实现抽奖系统需要用到什么命令？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Bitmap%E7%BB%9F%E8%AE%A1%E6%B4%BB%E8%B7%83%E7%94%A8%E6%88%B7%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">12.16.</span> <span class="toc-text">使用Bitmap统计活跃用户怎么做？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8HyperLogLog%E7%BB%9F%E8%AE%A1%E9%A1%B5%E9%9D%A2UV%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F"><span class="toc-number">12.17.</span> <span class="toc-text">使用HyperLogLog统计页面UV怎么做？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">12.18.</span> <span class="toc-text">Redis单线程模型了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis6-0%E4%B9%8B%E5%89%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">12.19.</span> <span class="toc-text">Redis6.0之前为什么不使用多线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis6-0%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">12.20.</span> <span class="toc-text">Redis6.0之后为什么引入了多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%BB%99%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">12.21.</span> <span class="toc-text">Redis给缓存数据设置过期时间有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">12.22.</span> <span class="toc-text">Redis是如何判断数据是否过期的呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">12.23.</span> <span class="toc-text">过期的数据的删除策略了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">12.24.</span> <span class="toc-text">Redis内存淘汰机制了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81Redis%E6%8C%82%E6%8E%89%E4%B9%8B%E5%90%8E%E5%86%8D%E9%87%8D%E5%90%AF%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E6%81%A2%E5%A4%8D%EF%BC%9F"><span class="toc-number">12.25.</span> <span class="toc-text">怎么保证Redis挂掉之后再重启数据可以进行恢复？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRDB%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F"><span class="toc-number">12.26.</span> <span class="toc-text">什么是RDB持久化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB%E5%88%9B%E5%BB%BA%E5%BF%AB%E7%85%A7%E6%97%B6%E4%BC%9A%E9%98%BB%E5%A1%9E%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-number">12.27.</span> <span class="toc-text">RDB创建快照时会阻塞主线程吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAOF%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F"><span class="toc-number">12.28.</span> <span class="toc-text">什么是AOF持久化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF%E6%97%A5%E5%BF%97%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">12.29.</span> <span class="toc-text">AOF日志是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF%E9%87%8D%E5%86%99%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">12.30.</span> <span class="toc-text">AOF重写了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9RDB%E5%92%8CAOF%EF%BC%9F"><span class="toc-number">12.31.</span> <span class="toc-text">如何选择RDB和AOF？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E6%AF%94AOF%E4%BC%98%E7%A7%80%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">12.31.1.</span> <span class="toc-text">RDB比AOF优秀的地方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E6%AF%94RDB%E4%BC%98%E7%A7%80%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">12.31.2.</span> <span class="toc-text">AOF比RDB优秀的地方</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-4-0-%E5%AF%B9%E4%BA%8E%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">12.32.</span> <span class="toc-text">Redis 4.0 对于持久化机制做了什么优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Redis%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="toc-number">12.33.</span> <span class="toc-text">如何使用Redis事务？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%94%AF%E6%8C%81%E5%8E%9F%E5%AD%90%E6%80%A7%E5%90%97%EF%BC%9F"><span class="toc-number">12.34.</span> <span class="toc-text">Redis支持原子性吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%9F"><span class="toc-number">12.35.</span> <span class="toc-text">如何解决Redis事务的缺陷？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFbigkey%EF%BC%9F"><span class="toc-number">12.36.</span> <span class="toc-text">什么是bigkey？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bigkey%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3%EF%BC%9F"><span class="toc-number">12.37.</span> <span class="toc-text">bigkey有什么危害？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0bigkey%EF%BC%9F"><span class="toc-number">12.38.</span> <span class="toc-text">如何发现bigkey？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E9%87%8Fkey%E9%9B%86%E4%B8%AD%E8%BF%87%E6%9C%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">12.39.</span> <span class="toc-text">大量key集中过期的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F"><span class="toc-number">12.40.</span> <span class="toc-text">什么是缓存穿透？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">12.41.</span> <span class="toc-text">如何解决缓存穿透问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%97%A0%E6%95%88key"><span class="toc-number">12.41.1.</span> <span class="toc-text">缓存无效key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">12.41.2.</span> <span class="toc-text">使用布隆过滤器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9F"><span class="toc-number">12.42.</span> <span class="toc-text">什么是缓存击穿？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">12.43.</span> <span class="toc-text">如何解决缓存击穿问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.44.</span> <span class="toc-text">缓存穿透和缓存击穿有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F"><span class="toc-number">12.45.</span> <span class="toc-text">什么是缓存雪崩？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">12.46.</span> <span class="toc-text">如何解决缓存雪崩问题？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%88%E5%AF%B9Redis%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%8F%AF%E7%94%A8%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">12.46.1.</span> <span class="toc-text">针对Redis服务不可用的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E7%83%AD%E7%82%B9%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">12.46.2.</span> <span class="toc-text">针对热点缓存失效的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%92%8C%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">12.47.</span> <span class="toc-text">缓存雪崩和缓存击穿有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="toc-number">12.48.</span> <span class="toc-text">如何保证缓存和数据库数据的一致性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">12.49.</span> <span class="toc-text">Redis主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">12.49.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">12.49.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE"><span class="toc-number">12.49.3.</span> <span class="toc-text">如何配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%BB%B6%E6%97%B6%E9%97%AE%E9%A2%98"><span class="toc-number">12.49.4.</span> <span class="toc-text">复制延时问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">12.49.5.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%BB%E4%BB%8E%E7%BB%93%E6%9E%84"><span class="toc-number">12.50.</span> <span class="toc-text">常用的三种主从结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%BB%E4%BA%8C%E4%BB%86"><span class="toc-number">12.50.1.</span> <span class="toc-text">一主二仆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0"><span class="toc-number">12.50.2.</span> <span class="toc-text">薪火相传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB"><span class="toc-number">12.50.3.</span> <span class="toc-text">反客为主</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88sentinel%EF%BC%89"><span class="toc-number">12.51.</span> <span class="toc-text">哨兵模式（sentinel）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">12.51.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4"><span class="toc-number">12.51.2.</span> <span class="toc-text">配置步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-number">12.51.3.</span> <span class="toc-text">故障恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFredis%E9%9B%86%E7%BE%A4%EF%BC%9F"><span class="toc-number">12.52.</span> <span class="toc-text">什么是redis集群？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E9%9B%86%E7%BE%A4%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E8%8A%82%E7%82%B9%EF%BC%9F"><span class="toc-number">12.53.</span> <span class="toc-text">redis集群如何分配节点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSlots%EF%BC%9F"><span class="toc-number">12.54.</span> <span class="toc-text">什么是Slots？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E9%9B%86%E7%BE%A4%E7%9A%84%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-number">12.55.</span> <span class="toc-text">redis集群的故障恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E9%9B%86%E7%BE%A4%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">12.56.</span> <span class="toc-text">redis集群的好处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%8D%E8%B6%B3%EF%BC%9F"><span class="toc-number">12.57.</span> <span class="toc-text">redis集群的不足？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cache-Aside-Pattern%EF%BC%88%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">12.58.</span> <span class="toc-text">Cache Aside Pattern（旁路缓存模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99"><span class="toc-number">12.58.1.</span> <span class="toc-text">写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB"><span class="toc-number">12.58.2.</span> <span class="toc-text">读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">12.58.3.</span> <span class="toc-text">常见问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7"><span class="toc-number">12.58.4.</span> <span class="toc-text">缺陷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Read-x2F-Write-Through-Pattern%EF%BC%88%E8%AF%BB%E5%86%99%E7%A9%BF%E9%80%8F%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">12.59.</span> <span class="toc-text">Read&#x2F;Write Through Pattern（读写穿透模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%EF%BC%88Write-Through%EF%BC%89"><span class="toc-number">12.59.1.</span> <span class="toc-text">写（Write Through）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%EF%BC%88Read-Through%EF%BC%89"><span class="toc-number">12.59.2.</span> <span class="toc-text">读（Read Through）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">12.59.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Write-Behind-Pattern%EF%BC%88%E5%BC%82%E6%AD%A5%E7%BC%93%E5%AD%98%E5%86%99%E5%85%A5%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">12.60.</span> <span class="toc-text">Write Behind Pattern（异步缓存写入模式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.61.</span> <span class="toc-text">Redis基本数据结构的底层数据结构是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="toc-number">12.62.</span> <span class="toc-text">String（字符串）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">12.62.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">12.62.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">12.62.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89"><span class="toc-number">12.63.</span> <span class="toc-text">List（列表）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">12.63.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-1"><span class="toc-number">12.63.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">12.63.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%EF%BC%88%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%89"><span class="toc-number">12.64.</span> <span class="toc-text">Hash（哈希表）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">12.64.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-2"><span class="toc-number">12.64.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">12.64.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">12.65.</span> <span class="toc-text">Set（集合）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">12.65.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3"><span class="toc-number">12.65.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-3"><span class="toc-number">12.65.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sorted-Set%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">12.66.</span> <span class="toc-text">Sorted Set（有序集合）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">12.66.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-4"><span class="toc-number">12.66.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-4"><span class="toc-number">12.66.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bitmap"><span class="toc-number">12.67.</span> <span class="toc-text">Bitmap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">12.67.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-5"><span class="toc-number">12.67.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-5"><span class="toc-number">12.67.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">12.68.</span> <span class="toc-text">HyperLogLog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-6"><span class="toc-number">12.68.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-6"><span class="toc-number">12.68.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-6"><span class="toc-number">12.68.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Geospatial-index"><span class="toc-number">12.69.</span> <span class="toc-text">Geospatial index</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-7"><span class="toc-number">12.69.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-7"><span class="toc-number">12.69.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-7"><span class="toc-number">12.69.3.</span> <span class="toc-text">应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">13.</span> <span class="toc-text">消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">13.1.</span> <span class="toc-text">什么是消息队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">13.2.</span> <span class="toc-text">消息队列有什么用？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%EF%BC%88%E5%87%8F%E5%B0%91%E5%93%8D%E5%BA%94%E6%89%80%E9%9C%80%E6%97%B6%E9%97%B4%EF%BC%89"><span class="toc-number">13.2.1.</span> <span class="toc-text">通过异步处理提高系统性能（减少响应所需时间）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8A%E5%B3%B0-x2F-%E9%99%90%E6%B5%81"><span class="toc-number">13.2.2.</span> <span class="toc-text">削峰&#x2F;限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%8D%E4%BD%8E%E7%B3%BB%E7%BB%9F%E8%80%A6%E5%90%88%E5%BA%A6"><span class="toc-number">13.2.3.</span> <span class="toc-text">降低系统耦合度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">13.3.</span> <span class="toc-text">使用消息队列产生的问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMQP%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">13.4.</span> <span class="toc-text">AMQP是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ"><span class="toc-number">14.</span> <span class="toc-text">RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D%E4%BB%8B%E7%BB%8D"><span class="toc-number">14.1.</span> <span class="toc-text">相关名词介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">14.2.</span> <span class="toc-text">RabbitMQ是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">14.3.</span> <span class="toc-text">RabbitMQ的特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMQP%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-1"><span class="toc-number">14.4.</span> <span class="toc-text">AMQP是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AMQP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">14.4.1.</span> <span class="toc-text">AMQP协议的三层结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AMQP%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">14.4.2.</span> <span class="toc-text">AMQP模型的三大组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%94%9F%E4%BA%A7%E8%80%85Producer%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85Consumer%EF%BC%9F"><span class="toc-number">14.5.</span> <span class="toc-text">说说生产者Producer和消费者Consumer？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Broker-%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9%E3%80%81Queue-%E9%98%9F%E5%88%97%E3%80%81Exchange-%E4%BA%A4%E6%8D%A2%E5%99%A8%EF%BC%9F"><span class="toc-number">14.6.</span> <span class="toc-text">说说 Broker 服务节点、Queue 队列、Exchange 交换器？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">14.7.</span> <span class="toc-text">什么是死信队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%BC%E8%87%B4%E7%9A%84%EF%BC%9F"><span class="toc-number">14.8.</span> <span class="toc-text">死信是如何导致的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">14.9.</span> <span class="toc-text">什么是延迟队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">14.10.</span> <span class="toc-text">RabbitMQ怎么实现延迟队列？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">14.10.1.</span> <span class="toc-text">具体实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">14.11.</span> <span class="toc-text">什么是优先级队列？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">14.12.</span> <span class="toc-text">RabbitMQ有哪些工作模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E6%B6%88%E6%81%AF%E6%80%8E%E4%B9%88%E4%BC%A0%E8%BE%93%EF%BC%9F"><span class="toc-number">14.13.</span> <span class="toc-text">RabbitMQ消息怎么传输？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F"><span class="toc-number">14.14.</span> <span class="toc-text">如何保证消息的可靠性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81RabbitMQ%E6%B6%88%E6%81%AF%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7%EF%BC%9F"><span class="toc-number">14.15.</span> <span class="toc-text">如何保证RabbitMQ消息的顺序性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81RabbitMQ%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%EF%BC%9F"><span class="toc-number">14.16.</span> <span class="toc-text">如何保证RabbitMQ的高可用？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%9C%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">14.16.1.</span> <span class="toc-text">单机模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">14.16.2.</span> <span class="toc-text">普通集群模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">14.16.3.</span> <span class="toc-text">镜像集群模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E6%8C%A4%E5%8E%8B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">14.17.</span> <span class="toc-text">如何解决消息挤压问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BB%B6%E6%97%B6%E4%BB%A5%E5%8F%8A%E8%BF%87%E6%9C%9F%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">14.18.</span> <span class="toc-text">如何解决消息队列的延时以及过期失效问题？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/31/%E6%9D%82%E8%B0%88/" title="杂谈"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="杂谈"/></a><div class="content"><a class="title" href="/2023/08/31/%E6%9D%82%E8%B0%88/" title="杂谈">杂谈</a><time datetime="2023-08-31T10:36:51.000Z" title="发表于 2023-08-31 18:36:51">2023-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97%EF%BC%88%E5%8D%B7%E4%BA%8C%EF%BC%89-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/" title="软件工程与计算（卷二）-软件开发的技术基础"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件工程与计算（卷二）-软件开发的技术基础"/></a><div class="content"><a class="title" href="/2023/08/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97%EF%BC%88%E5%8D%B7%E4%BA%8C%EF%BC%89-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/" title="软件工程与计算（卷二）-软件开发的技术基础">软件工程与计算（卷二）-软件开发的技术基础</a><time datetime="2023-08-10T08:06:03.000Z" title="发表于 2023-08-10 16:06:03">2023-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统"/></a><div class="content"><a class="title" href="/2023/08/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统">操作系统</a><time datetime="2023-08-10T07:17:23.000Z" title="发表于 2023-08-10 15:17:23">2023-08-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/%E8%80%83%E7%A0%94%E8%BF%9B%E5%BA%A6/" title="考研进度"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="考研进度"/></a><div class="content"><a class="title" href="/2023/04/17/%E8%80%83%E7%A0%94%E8%BF%9B%E5%BA%A6/" title="考研进度">考研进度</a><time datetime="2023-04-17T10:47:53.000Z" title="发表于 2023-04-17 18:47:53">2023-04-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/17/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/" title="考研英语语法总结"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="考研英语语法总结"/></a><div class="content"><a class="title" href="/2023/04/17/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/" title="考研英语语法总结">考研英语语法总结</a><time datetime="2023-04-17T10:47:40.000Z" title="发表于 2023-04-17 18:47:40">2023-04-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/background.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By Konjacer</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤舟</title>
  <icon>https://www.gravatar.com/avatar/e5611663fc514deb557f849c3a23baeb</icon>
  <subtitle>静静地漂泊在思绪的海洋中</subtitle>
  <link href="https://konjacor.github.io/atom.xml" rel="self"/>
  
  <link href="https://konjacor.github.io/"/>
  <updated>2022-12-20T12:11:43.208Z</updated>
  <id>https://konjacor.github.io/</id>
  
  <author>
    <name>Konjacer</name>
    <email>1175590069@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://konjacor.github.io/2022/12/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E9%87%8D%E7%82%B9(%E6%9A%82%E6%97%B6)/"/>
    <id>https://konjacor.github.io/2022/12/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E9%87%8D%E7%82%B9(%E6%9A%82%E6%97%B6)/</id>
    <published>2022-12-20T12:11:43.208Z</published>
    <updated>2022-12-20T12:11:43.208Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><input disabled="" type="checkbox"> </p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1软件危机介绍"><a href="#1软件危机介绍" class="headerlink" title="1软件危机介绍"></a>1软件危机介绍</h2><p>软件危机是指在计算机软件开发和维护过程中所遇到的一系列的严重问题。</p></li><li><p><input disabled="" type="checkbox"> </p><h2 id="2软件危机的典型表现（简单看一下）"><a href="#2软件危机的典型表现（简单看一下）" class="headerlink" title="2软件危机的典型表现（简单看一下）"></a>2软件危机的典型表现（简单看一下）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="3消除软件危机的途径（4条）（简答题）"><a href="#3消除软件危机的途径（4条）（简答题）" class="headerlink" title="3消除软件危机的途径（4条）（简答题）"></a>3消除软件危机的途径（4条）（简答题）</h2><p>①首先要对计算机软件有着正确的认识。</p><p>②要意识到软件开发不应该是某些个体劳动的神秘技术，而应该是组织良好、管理严密、各类人员协同配合、共同完成的项目工程。</p><p>③要坚持推广和使用在实践过程中总结出来的成功的技术和方法，并不断探索更好更高效的技术和方法。</p><p>④要开发和使用个好的软件工具。</p><p>总之，消除软件危机一方面要有相应的技术措施，也要有相应的组织管理措施。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="4软件工程的基本原理（7条）（简答）"><a href="#4软件工程的基本原理（7条）（简答）" class="headerlink" title="4软件工程的基本原理（7条）（简答）"></a>4软件工程的基本原理（7条）（简答）</h2><p>①使用分阶段的生命周期计划严格管理。</p><p>②要坚持进行阶段性评审。</p><p>③实行严格的产品控制。</p><p>④要使用现代程序设计技术。</p><p>⑤结果应能清楚地审查。</p><p>⑥开发小组的人员应该少而精。</p><p>⑦应该承认改进软件工程实践的重要性。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="5软件工程的方法学三要素（填空）以及目前使用的最广泛地两个软件工程方法学（填空）"><a href="#5软件工程的方法学三要素（填空）以及目前使用的最广泛地两个软件工程方法学（填空）" class="headerlink" title="5软件工程的方法学三要素（填空）以及目前使用的最广泛地两个软件工程方法学（填空）"></a>5软件工程的方法学三要素（填空）以及目前使用的最广泛地两个软件工程方法学（填空）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="6软件生命周期三个时期以及阶段"><a href="#6软件生命周期三个时期以及阶段" class="headerlink" title="6软件生命周期三个时期以及阶段"></a>6软件生命周期三个时期以及阶段</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="7几个软件过程的模型"><a href="#7几个软件过程的模型" class="headerlink" title="7几个软件过程的模型"></a>7几个软件过程的模型</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-研究可行性的三个方面（填空）"><a href="#1-研究可行性的三个方面（填空）" class="headerlink" title="1.研究可行性的三个方面（填空）"></a>1.研究可行性的三个方面（填空）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-数据字典的用途（三条）（简答）"><a href="#2-数据字典的用途（三条）（简答）" class="headerlink" title="2.数据字典的用途（三条）（简答）"></a>2.数据字典的用途（三条）（简答）</h2><p>①数据字典最重要的用途是作为分析阶段的工具。</p><p>②数据字典中每个数据元素的控制信息都是很有价值的。</p><p>③数据字典是开发数据库的第一步，也是很有价值的一步。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="3-成本估计的三个估算技术"><a href="#3-成本估计的三个估算技术" class="headerlink" title="3.成本估计的三个估算技术"></a>3.成本估计的三个估算技术</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-需求分析的三个模型即对应的图"><a href="#1-需求分析的三个模型即对应的图" class="headerlink" title="1.需求分析的三个模型即对应的图"></a>1.需求分析的三个模型即对应的图</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-E-R图的符号"><a href="#2-E-R图的符号" class="headerlink" title="2.E-R图的符号"></a>2.E-R图的符号</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="3-复印机的题"><a href="#3-复印机的题" class="headerlink" title="3.复印机的题"></a>3.复印机的题</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-形式化的三个常用的方法"><a href="#1-形式化的三个常用的方法" class="headerlink" title="1.形式化的三个常用的方法"></a>1.形式化的三个常用的方法</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="2-形式化优点（可能只考小结里的一个）"><a href="#2-形式化优点（可能只考小结里的一个）" class="headerlink" title="2.形式化优点（可能只考小结里的一个）"></a>2.形式化优点（可能只考小结里的一个）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-耦合是啥，划分"><a href="#1-耦合是啥，划分" class="headerlink" title="1.耦合是啥，划分"></a>1.耦合是啥，划分</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-内聚是啥，划分"><a href="#2-内聚是啥，划分" class="headerlink" title="2.内聚是啥，划分"></a>2.内聚是啥，划分</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="3-启发规则（7条）-（简答）"><a href="#3-启发规则（7条）-（简答）" class="headerlink" title="3.启发规则（7条）                 （简答）"></a>3.启发规则（7条）                 （简答）</h2><p>①改变软件结构提高模块的独立性。</p><p>②模块的规模应该适中</p><p>③深度、宽度、扇入和扇出都应该适当。</p><p>④模块的作用域应该在控制域之内。</p><p>⑤应该力争降低模块接口的复杂程度。</p><p>⑥设计单入口和单出口的模块。</p><p>⑦模块的功能应该可以预测。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="4-信息流的类型（填空）"><a href="#4-信息流的类型（填空）" class="headerlink" title="4.信息流的类型（填空）"></a>4.信息流的类型（填空）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-三种基本的控制结构（填空）"><a href="#1-三种基本的控制结构（填空）" class="headerlink" title="1.三种基本的控制结构（填空）"></a>1.三种基本的控制结构（填空）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-系统响应时间的两个重要属性（填空）"><a href="#2-系统响应时间的两个重要属性（填空）" class="headerlink" title="2.系统响应时间的两个重要属性（填空）"></a>2.系统响应时间的两个重要属性（填空）</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="3-过程设计工具"><a href="#3-过程设计工具" class="headerlink" title="3.过程设计工具"></a>3.过程设计工具</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="4-计算环形复杂度（需要三种方法P141P142题）"><a href="#4-计算环形复杂度（需要三种方法P141P142题）" class="headerlink" title="4.计算环形复杂度（需要三种方法P141P142题）"></a>4.计算环形复杂度（需要三种方法P141P142题）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-通常把编码和测试统称为实现（填空）"><a href="#1-通常把编码和测试统称为实现（填空）" class="headerlink" title="1.通常把编码和测试统称为实现（填空）"></a>1.通常把编码和测试统称为实现（填空）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-软件测试的步骤"><a href="#2-软件测试的步骤" class="headerlink" title="2.软件测试的步骤"></a>2.软件测试的步骤</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="3-代码审查分工（组长应该是啥样的（选择））"><a href="#3-代码审查分工（组长应该是啥样的（选择））" class="headerlink" title="3.代码审查分工（组长应该是啥样的（选择））"></a>3.代码审查分工（组长应该是啥样的（选择））</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="4-题P166-P168"><a href="#4-题P166-P168" class="headerlink" title="4.题P166~P168"></a>4.题P166~P168</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="5-黑盒技术的题（P173）"><a href="#5-黑盒技术的题（P173）" class="headerlink" title="5.黑盒技术的题（P173）"></a>5.黑盒技术的题（P173）</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="6-题P187"><a href="#6-题P187" class="headerlink" title="6.题P187"></a>6.题P187</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-四类维护活动（填空）"><a href="#1-四类维护活动（填空）" class="headerlink" title="1.四类维护活动（填空）"></a>1.四类维护活动（填空）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-面向对象的三种模型以及工具"><a href="#1-面向对象的三种模型以及工具" class="headerlink" title="1.面向对象的三种模型以及工具"></a>1.面向对象的三种模型以及工具</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-属性可见性（没有默认的可见性）"><a href="#2-属性可见性（没有默认的可见性）" class="headerlink" title="2.属性可见性（没有默认的可见性）"></a>2.属性可见性（没有默认的可见性）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1></li><li><p><input disabled="" type="checkbox"> </p><h2 id="无"><a href="#无" class="headerlink" title="无"></a>无</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-类构件的重用方式（填空）"><a href="#1-类构件的重用方式（填空）" class="headerlink" title="1.类构件的重用方式（填空）"></a>1.类构件的重用方式（填空）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h1></li><li><p><input disabled="" type="checkbox"> </p><h2 id="无-1"><a href="#无-1" class="headerlink" title="无"></a>无</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-代码行技术的优缺点-（简答）"><a href="#1-代码行技术的优缺点-（简答）" class="headerlink" title="1.代码行技术的优缺点                                   （简答）"></a>1.代码行技术的优缺点                                   （简答）</h2><p>（1）优点</p><p>①代码是所有的软件开发都要有的产品。</p><p>②很容易计算代码行数</p><p>（2）缺点</p><p>①源码知识软件配置的一部分，使用源码的规模来代表整体软件的规模似乎不是很合理。</p><p>②不同的语言实现同一个软件所用到的代码行数不同。</p><p>③代码行技术不适合用于非过程性的语言。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-工作量估算的三种模型（选择，混入一个别的）"><a href="#2-工作量估算的三种模型（选择，混入一个别的）" class="headerlink" title="2.工作量估算的三种模型（选择，混入一个别的）"></a>2.工作量估算的三种模型（选择，混入一个别的）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="3-民主制程序员组的优点（简答）"><a href="#3-民主制程序员组的优点（简答）" class="headerlink" title="3.民主制程序员组的优点（简答）"></a>3.民主制程序员组的优点（简答）</h2><p>①使组员们对发现程序错误抱有积极地态度，这种积极的态度有利于更快的发现程序中的错误，产生高质量的代码。</p><p>②组员们拥有充足民主，组内具有高度凝聚力，小组的学术氛围浓厚，有利于攻克技术难关。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="4-正式的技术复查包括-走查-和-审查（填空）"><a href="#4-正式的技术复查包括-走查-和-审查（填空）" class="headerlink" title="4.正式的技术复查包括  走查   和   审查（填空）"></a>4.正式的技术复查包括  走查   和   审查（填空）</h2></li></ul><p><img src="file:///D:\Softwares\QQ\Recv\2470152347\Image\Group2\7P~3\7P~38J{HQOM8VAVFBOVT1KN.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;/p&gt;
&lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h1&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;in</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://konjacor.github.io/2022/12/20/hello-world/"/>
    <id>https://konjacor.github.io/2022/12/20/hello-world/</id>
    <published>2022-12-20T12:11:43.202Z</published>
    <updated>2022-12-20T12:11:43.202Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>EffectiveJava读后整理</title>
    <link href="https://konjacor.github.io/2022/12/07/EffectiveJava%E8%AF%BB%E5%90%8E%E6%95%B4%E7%90%86/"/>
    <id>https://konjacor.github.io/2022/12/07/EffectiveJava%E8%AF%BB%E5%90%8E%E6%95%B4%E7%90%86/</id>
    <published>2022-12-07T08:23:35.000Z</published>
    <updated>2022-12-20T12:11:43.194Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
</summary>
      
    
    
    
    
    <category term="EffectiveJava" scheme="https://konjacor.github.io/tags/EffectiveJava/"/>
    
    <category term="读后整理" scheme="https://konjacor.github.io/tags/%E8%AF%BB%E5%90%8E%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JUC并发编程</title>
    <link href="https://konjacor.github.io/2022/12/07/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://konjacor.github.io/2022/12/07/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2022-12-07T08:22:54.000Z</published>
    <updated>2022-12-20T12:11:43.195Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
</summary>
      
    
    
    
    
    <category term="JUC工具类" scheme="https://konjacor.github.io/tags/JUC%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    <category term="并发编程" scheme="https://konjacor.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://konjacor.github.io/2022/12/07/JVM/"/>
    <id>https://konjacor.github.io/2022/12/07/JVM/</id>
    <published>2022-12-07T08:22:17.000Z</published>
    <updated>2022-12-20T12:11:43.196Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
</summary>
      
    
    
    
    
    <category term="JVM" scheme="https://konjacor.github.io/tags/JVM/"/>
    
    <category term="Java虚拟机" scheme="https://konjacor.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud</title>
    <link href="https://konjacor.github.io/2022/12/07/SpringCloud/"/>
    <id>https://konjacor.github.io/2022/12/07/SpringCloud/</id>
    <published>2022-12-07T08:15:34.000Z</published>
    <updated>2022-12-20T12:11:43.200Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><ul><li>尚硅谷SpringCloudAlibaba教程，第42章由于缺乏JUC并发编程的知识还没有听。</li><li>JMeter压力测试</li><li>gateway底层采用了webflux和reactor-netty这类异步非阻塞响应式框架，什么是异步非阻塞响应式？</li><li>IDEA中如果不想写太多重复的微服务，可以使用虚拟端口映射来复制一份，但是复制的一份是虚的，最终请求还是打到被复制的微服务上。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;ul&gt;
&lt;li&gt;尚硅谷SpringCloudAlibaba教程，第42章由于缺乏JUC并发编程的知识还没有听。&lt;/li&gt;
&lt;li&gt;JMeter压力测试&lt;/li&gt;
&lt;li&gt;gateway</summary>
      
    
    
    
    
    <category term="SpringCloud" scheme="https://konjacor.github.io/tags/SpringCloud/"/>
    
    <category term="Alibaba" scheme="https://konjacor.github.io/tags/Alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="https://konjacor.github.io/2022/11/01/Maven/"/>
    <id>https://konjacor.github.io/2022/11/01/Maven/</id>
    <published>2022-11-01T12:17:52.000Z</published>
    <updated>2022-12-20T12:11:43.198Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="为什么要学习Maven？"><a href="#为什么要学习Maven？" class="headerlink" title="为什么要学习Maven？"></a>为什么要学习Maven？</h1><h2 id="Maven作为依赖管理工具"><a href="#Maven作为依赖管理工具" class="headerlink" title="Maven作为依赖管理工具"></a>Maven作为依赖管理工具</h2><h3 id="jar包的规模越来越大"><a href="#jar包的规模越来越大" class="headerlink" title="jar包的规模越来越大"></a>jar包的规模越来越大</h3><ul><li><p>随着我们使用越来越多的框架，或者框架封装程度越来越高，<strong>项目中使用的jar包也越来越多</strong>。项目中，一个模块里面用到上百个jar包是非常正常的。</p></li><li><p>比如下面的例子，我们只用到SpringBoot、SpringCloud框架中的三个功能：</p><ol><li>Nacos 服务注册发现</li><li>Web 框架环境</li><li>图模板技术 Thymeleaf</li></ol><p>最终却导入了106个jar包……</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.security:spring-security-rsa:jar:1.0.9.RELEASE:compile</span><br><span class="line">com.netflix.ribbon: ribbon:jar:2.3.0:compile</span><br><span class="line">org.springframework.boot:spring-boot-starter-thymeleaf:jar:2.3.6.RELEASE:compile</span><br><span class="line">commons-configuration:commons-configuration:jar:1.8:compile</span><br><span class="line">org.apache.logging.log4j:log4j-api:jar:2.13.3:compile</span><br><span class="line">org.springframework:spring-beans:jar:5.2.11.RELEASE:compile</span><br><span class="line">org.springframework.cloud:spring-cloud-starter-netflix-ribbon:jar:2.2.6.RELEASE:compile</span><br><span class="line">org.apache.tomcat.embed:tomcat-embed-websocket:jar:9.0.39:compile</span><br><span class="line">com.alibaba.cloud:spring-cloud-alibaba-commons:jar:2.2.6.RELEASE:compile</span><br><span class="line">org.bouncycastle:bcprov-jdk15on:jar:1.64:compile</span><br><span class="line">org.springframework.security:spring-security-crypto:jar:5.3.5.RELEASE:compile</span><br><span class="line">org.apache.httpcomponents:httpasyncclient:jar:4.1.4:compile</span><br><span class="line">com.google.j2objc:j2objc-annotations:jar:1.3:compile</span><br><span class="line">com.fasterxml.jackson.core:jackson-databind:jar:2.11.3:compile</span><br><span class="line">io.reactivex:rxjava:jar:1.3.8:compile</span><br><span class="line">ch.qos.logback:logback-classic:jar:1.2.3:compile</span><br><span class="line">org.springframework:spring-web:jar:5.2.11.RELEASE:compile</span><br><span class="line">io.reactivex:rxnetty-servo:jar:0.4.9:runtime</span><br><span class="line">org.springframework:spring-core:jar:5.2.11.RELEASE:compile</span><br><span class="line">io.github.openfeign.form:feign-form-spring:jar:3.8.0:compile</span><br><span class="line">io.github.openfeign.form:feign-form:jar:3.8.0:compile</span><br><span class="line">com.netflix.ribbon:ribbon-loadbalancer:jar:2.3.0:compile</span><br><span class="line">org.apache.httpcomponents:httpcore:jar:4.4.13:compile</span><br><span class="line">org.thymeleaf.extras:thymeleaf-extras-java8time:jar:3.0.4.RELEASE:compile</span><br><span class="line">org.slf4j:jul-to-slf4j:jar:1.7.30:compile</span><br><span class="line">com.atguigu.demo:demo09-base-entity:jar:1.0-SNAPSHOT:compile</span><br><span class="line">org.yaml:snakeyaml:jar:1.26:compile</span><br><span class="line">org.springframework.boot:spring-boot-starter-logging:jar:2.3.6.RELEASE:compile</span><br><span class="line">io.reactivex:rxnetty-contexts:jar:0.4.9:runtime</span><br><span class="line">org.apache.httpcomponents:httpclient:jar:4.5.13:compile</span><br><span class="line">io.github.openfeign:feign-core:jar:10.10.1:compile</span><br><span class="line">org.springframework.boot:spring-boot-starter-aop:jar:2.3.6.RELEASE:compile</span><br><span class="line">org.hdrhistogram:HdrHistogram:jar:2.1.9:compile</span><br><span class="line">org.springframework:spring-context:jar:5.2.11.RELEASE:compile</span><br><span class="line">commons-lang:commons-lang:jar:2.6:compile</span><br><span class="line">io.prometheus:simpleclient:jar:0.5.0:compile</span><br><span class="line">ch.qos.logback:logback-core:jar:1.2.3:compile</span><br><span class="line">org.springframework:spring-webmvc:jar:5.2.11.RELEASE:compile</span><br><span class="line">com.sun.jersey:jersey-core:jar:1.19.1:runtime</span><br><span class="line">javax.ws.rs:jsr311-api:jar:1.1.1:runtime</span><br><span class="line">javax.inject:javax.inject:jar:1:runtime</span><br><span class="line">org.springframework.cloud:spring-cloud-openfeign-core:jar:2.2.6.RELEASE:compile</span><br><span class="line">com.netflix.ribbon:ribbon-core:jar:2.3.0:compile</span><br><span class="line">com.netflix.hystrix:hystrix-core:jar:1.5.18:compile</span><br><span class="line">com.netflix.ribbon:ribbon-transport:jar:2.3.0:runtime</span><br><span class="line">org.springframework.boot:spring-boot-starter-json:jar:2.3.6.RELEASE:compile</span><br><span class="line">org.springframework.cloud:spring-cloud-starter-openfeign:jar:2.2.6.RELEASE:compile</span><br><span class="line">com.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.11.3:compile</span><br><span class="line">com.sun.jersey.contribs:jersey-apache-client4:jar:1.19.1:runtime</span><br><span class="line">io.github.openfeign:feign-hystrix:jar:10.10.1:compile</span><br><span class="line">io.github.openfeign:feign-slf4j:jar:10.10.1:compile</span><br><span class="line">com.alibaba.nacos:nacos-client:jar:1.4.2:compile</span><br><span class="line">org.apache.httpcomponents:httpcore-nio:jar:4.4.13:compile</span><br><span class="line">com.sun.jersey:jersey-client:jar:1.19.1:runtime</span><br><span class="line">org.springframework.cloud:spring-cloud-context:jar:2.2.6.RELEASE:compile</span><br><span class="line">org.glassfish:jakarta.el:jar:3.0.3:compile</span><br><span class="line">org.apache.logging.log4j:log4j-to-slf4j:jar:2.13.3:compile</span><br><span class="line">com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.11.3:compile</span><br><span class="line">org.springframework.cloud:spring-cloud-commons:jar:2.2.6.RELEASE:compile</span><br><span class="line">org.aspectj:aspectjweaver:jar:1.9.6:compile</span><br><span class="line">com.alibaba.cloud:spring-cloud-starter-alibaba-nacos-discovery:jar:2.2.6.RELEASE:compile</span><br><span class="line">com.google.guava:listenablefuture:jar:9999.0-empty-to-avoid-conflict-with-guava:compile</span><br><span class="line">com.alibaba.spring:spring-context-support:jar:1.0.10:compile</span><br><span class="line">jakarta.annotation:jakarta.annotation-api:jar:1.3.5:compile</span><br><span class="line">org.bouncycastle:bcpkix-jdk15on:jar:1.64:compile</span><br><span class="line">com.netflix.netflix-commons:netflix-commons-util:jar:0.3.0:runtime</span><br><span class="line">com.fasterxml.jackson.core:jackson-annotations:jar:2.11.3:compile</span><br><span class="line">com.google.guava:guava:jar:29.0-jre:compile</span><br><span class="line">com.google.guava:failureaccess:jar:1.0.1:compile</span><br><span class="line">org.springframework.boot:spring-boot:jar:2.3.6.RELEASE:compile</span><br><span class="line">com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.11.3:compile</span><br><span class="line">com.atguigu.demo:demo08-base-api:jar:1.0-SNAPSHOT:compile</span><br><span class="line">org.springframework.cloud:spring-cloud-starter-netflix-archaius:jar:2.2.6.RELEASE:compile</span><br><span class="line">org.springframework.boot:spring-boot-autoconfigure:jar:2.3.6.RELEASE:compile</span><br><span class="line">org.slf4j:slf4j-api:jar:1.7.30:compile</span><br><span class="line">commons-io:commons-io:jar:2.7:compile</span><br><span class="line">org.springframework.cloud:spring-cloud-starter:jar:2.2.6.RELEASE:compile</span><br><span class="line">org.apache.tomcat.embed:tomcat-embed-core:jar:9.0.39:compile</span><br><span class="line">io.reactivex:rxnetty:jar:0.4.9:runtime</span><br><span class="line">com.fasterxml.jackson.core:jackson-core:jar:2.11.3:compile</span><br><span class="line">com.google.code.findbugs:jsr305:jar:3.0.2:compile</span><br><span class="line">com.netflix.archaius:archaius-core:jar:0.7.6:compile</span><br><span class="line">org.springframework.boot:spring-boot-starter-web:jar:2.3.6.RELEASE:compile</span><br><span class="line">commons-codec:commons-codec:jar:1.14:compile</span><br><span class="line">com.netflix.servo:servo-core:jar:0.12.21:runtime</span><br><span class="line">com.google.errorprone:error_prone_annotations:jar:2.3.4:compile</span><br><span class="line">org.attoparser:attoparser:jar:2.0.5.RELEASE:compile</span><br><span class="line">com.atguigu.demo:demo10-base-util:jar:1.0-SNAPSHOT:compile</span><br><span class="line">org.checkerframework:checker-qual:jar:2.11.1:compile</span><br><span class="line">org.thymeleaf:thymeleaf-spring5:jar:3.0.11.RELEASE:compile</span><br><span class="line">commons-fileupload:commons-fileupload:jar:1.4:compile</span><br><span class="line">com.netflix.ribbon:ribbon-httpclient:jar:2.3.0:compile</span><br><span class="line">com.netflix.netflix-commons:netflix-statistics:jar:0.1.1:runtime</span><br><span class="line">org.unbescape:unbescape:jar:1.1.6.RELEASE:compile</span><br><span class="line">org.springframework:spring-jcl:jar:5.2.11.RELEASE:compile</span><br><span class="line">com.alibaba.nacos:nacos-common:jar:1.4.2:compile</span><br><span class="line">commons-collections:commons-collections:jar:3.2.2:runtime</span><br><span class="line">javax.persistence:persistence-api:jar:1.0:compile</span><br><span class="line">com.alibaba.nacos:nacos-api:jar:1.4.2:compile</span><br><span class="line">org.thymeleaf:thymeleaf:jar:3.0.11.RELEASE:compile</span><br><span class="line">org.springframework:spring-aop:jar:5.2.11.RELEASE:compile</span><br><span class="line">org.springframework.boot:spring-boot-starter:jar:2.3.6.RELEASE:compile</span><br><span class="line">org.springframework.boot:spring-boot-starter-tomcat:jar:2.3.6.RELEASE:compile</span><br><span class="line">org.springframework.cloud:spring-cloud-netflix-ribbon:jar:2.2.6.RELEASE:compile</span><br><span class="line">org.springframework:spring-expression:jar:5.2.11.RELEASE:compile</span><br><span class="line">org.springframework.cloud:spring-cloud-netflix-archaius:jar:2.2.6.RELEASE:compile</span><br></pre></td></tr></table></figure></li><li><p>而如果使用Maven来引入这些jar包只需要配置三个<strong>依赖</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- Nacos 服务注册发现启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- web启动器依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 视图模板技术 thymeleaf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>剩下的依赖Maven通过处理依赖结构、利用依赖传递的特性自动帮我们导入了。</p></li></ul><h3 id="jar包的来源良莠不齐"><a href="#jar包的来源良莠不齐" class="headerlink" title="jar包的来源良莠不齐"></a>jar包的来源良莠不齐</h3><ul><li>多数jar包所属技术的官网通常是英文界面，网站的结构又不尽相同，甚至找到下载链接还发现需要通过特殊的工具下载。</li><li>第三方网站提供下载。问题是不规范，在使用过程中会出现各种问题。<ul><li>jar包的名称可能不同</li><li>jar包的版本可能不同</li><li>jar包内的具体细节可能不同</li></ul></li><li>而使用 Maven 后，<strong>依赖对应的 jar 包能够自动下载</strong>，方便、快捷又规范。</li></ul><h3 id="jar包之间的依赖关系难以手动处理"><a href="#jar包之间的依赖关系难以手动处理" class="headerlink" title="jar包之间的依赖关系难以手动处理"></a>jar包之间的依赖关系难以手动处理</h3><ul><li><p>框架中使用的 jar 包，不仅数量庞大，而且<strong>彼此之间存在错综复杂的依赖关系。依赖关系的复杂程度，已经上升到了完全不能靠人力手动解决的程度</strong>。另外，<strong>jar 包之间有可能产生冲突</strong>。进一步增加了我们在 jar 包使用过程中的难度。</p></li><li><p>下面是前面的例子中jar包之间的依赖关系，属于是看都看不过来了……：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221101204923420.png" alt="image-20221101204923420"></p></li><li><p>而实际上<strong>jar 包之间的依赖关系是普遍存在的，如果要由程序员手动梳理无疑会增加极高的学习成本</strong>，而这些工作又对实现业务功能毫无帮助。</p></li><li><p>而<strong>使用 Maven 则几乎不需要管理这些关系，极个别的地方调整一下即可，极大的减轻了我们的工作量</strong>。</p></li></ul><h2 id="Maven作为构建的管理工具"><a href="#Maven作为构建的管理工具" class="headerlink" title="Maven作为构建的管理工具"></a>Maven作为构建的管理工具</h2><h3 id="你没有注意过的构建"><a href="#你没有注意过的构建" class="headerlink" title="你没有注意过的构建"></a>你没有注意过的构建</h3><ul><li>你可以不使用 Maven，但是构建必须要做。当我们使用 IDEA 进行开发时，构建是 IDEA 替我们做的。</li><li><strong>编译源文件、测试、打包、部署等步骤都属于项目的构建</strong></li></ul><h3 id="脱离IDE环境仍需构建"><a href="#脱离IDE环境仍需构建" class="headerlink" title="脱离IDE环境仍需构建"></a>脱离IDE环境仍需构建</h3><ul><li><p>以下是企业开发代码从开发到部署的流程，可以看到代码在推送到服务器上之后仍需要构建，Maven在服务器上对于代码的构建也起到了举足轻重的作用：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221101210513468.png" alt="image-20221101210513468"></p></li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li><strong>管理规模庞大的 jar 包，需要专门工具。</strong></li><li><strong>脱离 IDE 环境执行构建操作，需要专门工具。</strong></li></ul><h1 id="什么是Maven"><a href="#什么是Maven" class="headerlink" title="什么是Maven"></a>什么是Maven</h1><ul><li><p>Maven 是 Apache 软件基金会组织维护的一款专门<strong>为 Java 项目提供构建和依赖管理支持的工具</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221101231358965.png" alt="image-20221101231358965"></p></li></ul><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><ul><li><p>Java项目开发过程中，<strong>构建指的是使用原材料生产产品的过程</strong>。</p><p><strong>原材料</strong>：Java源代码、基于HTML的Thymeleaf文件、图片、配置文件等</p><p><strong>产品</strong>：一个可以在服务器上运行的项目</p></li><li><p>构建过程包含的主要环节：</p><ul><li><strong>清理</strong>：删除上一次构建的结果，为下一次构建做好准备</li><li><strong>编译</strong>：Java 源程序编译成 *.class 字节码文件</li><li><strong>测试</strong>：运行提前准备好的测试程序</li><li><strong>报告</strong>：针对刚才测试的结果生成一个全面的信息</li><li><strong>打包</strong>：<ul><li>Java工程：jar包</li><li>Web工程：war包</li></ul></li><li><strong>安装</strong>：把一个 Maven 工程经过打包操作生成的 jar 包或 war 包存入 Maven 仓库</li><li><strong>部署</strong>：<ul><li>部署 jar 包：把一个 jar 包部署到 Nexus 私服服务器上</li><li>部署 war 包：借助相关 Maven 插件（例如 cargo），将 war 包部署到 Tomcat 服务器上</li></ul></li></ul></li></ul><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li><p>如果 A 工程里面用到了 B 工程的类、接口、配置文件等等这样的资源，那么我们就可以说 A 依赖 B。例如：</p><ul><li>junit-4.12 依赖 hamcrest-core-1.3</li><li>thymeleaf-3.0.12.RELEASE 依赖 ognl-3.1.26<ul><li>ognl-3.1.26 依赖 javassist-3.20.0-GA</li></ul></li><li>thymeleaf-3.0.12.RELEASE 依赖 attoparser-2.0.5.RELEASE</li><li>thymeleaf-3.0.12.RELEASE 依赖 unbescape-1.1.6.RELEASE</li><li>thymeleaf-3.0.12.RELEASE 依赖 slf4j-api-1.7.26</li></ul></li><li><p>依赖管理中要解决的具体问题：</p><ul><li><strong>jar 包的下载</strong>：使用 Maven 之后，jar 包会从规范的远程仓库下载到本地</li><li><strong>jar 包之间的依赖</strong>：通过依赖的传递性自动完成</li><li><strong>jar 包之间的冲突</strong>：通过对依赖的配置进行调整，让某些jar包不会被导入</li></ul></li></ul><h2 id="Maven的工作机制"><a href="#Maven的工作机制" class="headerlink" title="Maven的工作机制"></a>Maven的工作机制</h2><ul><li>下面的图很清晰的说明了Maven的工作机制：<img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221101232114478.png" alt="image-20221101232114478"></li></ul><h1 id="Maven核心程序解压与配置"><a href="#Maven核心程序解压与配置" class="headerlink" title="Maven核心程序解压与配置"></a>Maven核心程序解压与配置</h1><h2 id="Maven官网地址"><a href="#Maven官网地址" class="headerlink" title="Maven官网地址"></a>Maven官网地址</h2><ul><li><p>首页：<a href="https://maven.apache.org/">https://maven.apache.org/</a></p></li><li><p>下载页面：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p></li><li><p>下载链接：<a href="https://dlcdn.apache.org/maven/maven-3/3.8.4/binaries/apache-maven-3.8.4-bin.zip">https://dlcdn.apache.org/maven/maven-3/3.8.4/binaries/apache-maven-3.8.4-bin.zip</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102091030137.png" alt="image-20221102091030137"></p><p>带src的是带源码的版本，扩展名是.tar.gz的是linux的。</p></li></ul><h2 id="解压Maven核心程序"><a href="#解压Maven核心程序" class="headerlink" title="解压Maven核心程序"></a>解压Maven核心程序</h2><ul><li><p>核心程序压缩包：apache-maven-3.8.4-bin.zip，<strong>解压到非中文、没有空格的目录</strong>。例如：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102091153825.png" alt="image-20221102091153825"></p></li><li><p>在解压目录中，我们需要着重关注Maven的核心配置文件：<strong>conf&#x2F;settings.xml</strong></p></li></ul><h2 id="指定本地仓库"><a href="#指定本地仓库" class="headerlink" title="指定本地仓库"></a>指定本地仓库</h2><ul><li><p><strong>本地仓库默认值：用户家目录&#x2F;.m2&#x2F;repository</strong>。由于本地仓库的默认位置是在用户的家目录下，而家目录往往是在 C 盘，也就是系统盘。将来 Maven 仓库中 jar 包越来越多，仓库体积越来越大，可能会拖慢 C 盘运行速度，影响系统性能。所以<strong>建议将 Maven 的本地仓库放在其他盘符下</strong>。配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">| The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">| Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\maven-repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>本地仓库这个目录，我们<strong>手动创建一个空的目录即可</strong>。注意配置不要写到配置文件的注释里面，然后<strong>本地仓库本身也需要使用一个非中文、没有空格的目录</strong>。</p></li></ul><h2 id="配置阿里云提供的镜像仓库"><a href="#配置阿里云提供的镜像仓库" class="headerlink" title="配置阿里云提供的镜像仓库"></a>配置阿里云提供的镜像仓库</h2><ul><li>Maven 下载 jar 包默认访问境外的中央仓库，而国外网站速度很慢。<strong>改成阿里云提供的镜像仓库，访问国内网站，可以让 Maven 下载 jar 包的时候速度更快</strong>。配置的方式是：</li></ul><h3 id="将原有的例子配置注释掉"><a href="#将原有的例子配置注释掉" class="headerlink" title="将原有的例子配置注释掉"></a>将原有的例子配置注释掉</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">  &lt;id&gt;maven-default-http-blocker&lt;/id&gt;</span></span><br><span class="line"><span class="comment">  &lt;mirrorOf&gt;external:http:*&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">  &lt;name&gt;Pseudo repository to mirror external repositories initially using HTTP.&lt;/name&gt;</span></span><br><span class="line"><span class="comment">  &lt;url&gt;http://0.0.0.0/&lt;/url&gt;</span></span><br><span class="line"><span class="comment">  &lt;blocked&gt;true&lt;/blocked&gt;</span></span><br><span class="line"><span class="comment">&lt;/mirror&gt; --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="加入阿里云的镜像配置"><a href="#加入阿里云的镜像配置" class="headerlink" title="加入阿里云的镜像配置"></a>加入阿里云的镜像配置</h3><ul><li><p>将下面的mirror标签整体复制到settings.xml文件的<strong>mirrors标签内部</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="配置Maven工程的基础JDK版本"><a href="#配置Maven工程的基础JDK版本" class="headerlink" title="配置Maven工程的基础JDK版本"></a>配置Maven工程的基础JDK版本</h2><ul><li><p><strong>如果按照默认配置运行，Java 工程使用的默认 JDK 版本是 1.5</strong>，而我们熟悉和常用的是 JDK 1.8 版本。修改配置的方式是：<strong>将自定义的 profile 标签整个复制到 settings.xml 文件的 profiles 标签内</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><ul><li><p>Maven 是一个用 Java 语言开发的程序，它必须基于 JDK 来运行，<strong>需要通过 JAVA_HOME 来找到 JDK 的安装位置</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102092313207.png" alt="image-20221102092313207"></p></li><li><p>可以使用下面的命令验证JDK是否被正确的加入到了环境变量中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;echo %JAVA_HOME%</span><br><span class="line">D:\software\Java</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;java -version</span><br><span class="line">java version &quot;1.8.0_141&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置MAVEN-HOME"><a href="#配置MAVEN-HOME" class="headerlink" title="配置MAVEN_HOME"></a>配置MAVEN_HOME</h2><ul><li><p>新建系统变量：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102092502592.png" alt="image-20221102092502592"></p></li></ul><h2 id="配置Path"><a href="#配置Path" class="headerlink" title="配置Path"></a>配置Path</h2><ul><li>编辑Path，<strong>用两个百分号可以引用刚才配置的系统变量</strong>：</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102092831843.png" alt="image-20221102092831843"></p><ul><li>配置环境变量的规律：<strong>XXX_HOME通常配置的是目标bin目录的上一级目录，Path中配置的是目标bin目录</strong>。</li></ul><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ul><li><p>在非maven的bin目录下输入下方的命令来检测maven的环境变量是否配置正确：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;mvn -v</span><br><span class="line">Apache Maven 3.8.4 (9b656c72d54e5bacbed989b64718c159fe39b537)</span><br><span class="line">Maven home: D:\software\apache-maven-3.8.4</span><br><span class="line">Java version: 1.8.0_141, vendor: Oracle Corporation, runtime: D:\software\Java\jre</span><br><span class="line">Default locale: zh_CN, platform encoding: GBK</span><br><span class="line">OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;windows&quot;</span><br></pre></td></tr></table></figure></li></ul><h1 id="实验一：根据坐标创建Maven工程"><a href="#实验一：根据坐标创建Maven工程" class="headerlink" title="实验一：根据坐标创建Maven工程"></a>实验一：根据坐标创建Maven工程</h1><ul><li>前面的实验先讲maven在命令行页面的使用，之后再讲在IDEA中使用maven。</li></ul><h2 id="Maven核心概念：坐标"><a href="#Maven核心概念：坐标" class="headerlink" title="Maven核心概念：坐标"></a>Maven核心概念：坐标</h2><h3 id="数学中的坐标"><a href="#数学中的坐标" class="headerlink" title="数学中的坐标"></a>数学中的坐标</h3><ul><li>使用x、y、z三个<strong>向量</strong>作为空间的坐标系，可以在<strong>空间</strong>中<strong>唯一地</strong>定位到一个<strong>点</strong>。</li></ul><h3 id="Maven中的坐标"><a href="#Maven中的坐标" class="headerlink" title="Maven中的坐标"></a>Maven中的坐标</h3><h4 id="向量说明"><a href="#向量说明" class="headerlink" title="向量说明"></a>向量说明</h4><ul><li>Maven使用三个<strong>向量</strong>在<strong>Maven的仓库</strong>中<strong>唯一</strong>地定位到一个<strong>jar包</strong>：<ol><li><strong>groupId</strong>：公司或组织的 id</li><li><strong>artifactId</strong>：一个项目或者是项目中的一个模块的 id</li><li><strong>version</strong>：版本号</li></ol></li></ul><h4 id="三个向量的取值方式"><a href="#三个向量的取值方式" class="headerlink" title="三个向量的取值方式"></a>三个向量的取值方式</h4><ul><li><strong>groupId</strong>：公司或组织域名的倒序，通常也会加上项目名称<ul><li>例如：com.atguigu.maven</li></ul></li><li><strong>artifactId</strong>：模块的名称，将来作为 Maven 工程的工程名</li><li><strong>version</strong>：模块的版本号，根据自己的需要设定<ul><li>例如：SNAPSHOT 表示快照版本，正在迭代过程中，不稳定的版本</li><li>例如：RELEASE 表示正式版本</li></ul></li></ul><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><ul><li>groupId：com.atguigu.maven</li><li>artifactId：pro01-atguigu-maven</li><li>version：1.0-SNAPSHOT</li></ul><h3 id="坐标和仓库中jar包的存储路径之间的对应关系"><a href="#坐标和仓库中jar包的存储路径之间的对应关系" class="headerlink" title="坐标和仓库中jar包的存储路径之间的对应关系"></a>坐标和仓库中jar包的存储路径之间的对应关系</h3><ul><li><p>坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>上面坐标对应的jar包在Maven本地仓库中的位置：<strong>Maven本地仓库根目录\javax\servlet\servlet-api\2.5\servlet-api-2.5.jar</strong>，可以看到<strong>每一个坐标对应着一层或多层目录，坐标的值由点分开，每一段都是一层目录，最后找到的jar包名称是artifactId-version.jar的格式</strong>。</p></li><li><p>一定要学会根据坐标到本地仓库中找到对应的jar包。</p></li></ul><h2 id="实验操作"><a href="#实验操作" class="headerlink" title="实验操作"></a>实验操作</h2><h3 id="创建目录作为后面maven操作的工作空间"><a href="#创建目录作为后面maven操作的工作空间" class="headerlink" title="创建目录作为后面maven操作的工作空间"></a>创建目录作为后面maven操作的工作空间</h3><ul><li>例如：D:\maven-workspace\space201026</li><li>此时我们已经有了三个目录，分别是：<ol><li><strong>Maven 核心程序</strong>：中军大帐</li><li><strong>Maven 本地仓库</strong>：兵营</li><li><strong>本地工作空间</strong>：战场</li></ol></li></ul><h3 id="在工作空间目录下打开命令行窗口"><a href="#在工作空间目录下打开命令行窗口" class="headerlink" title="在工作空间目录下打开命令行窗口"></a>在工作空间目录下打开命令行窗口</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102094855936.png" alt="image-20221102094855936"></p><h3 id="使用命令生成Maven工程"><a href="#使用命令生成Maven工程" class="headerlink" title="使用命令生成Maven工程"></a>使用命令生成Maven工程</h3><ul><li><p>maven命令结构：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102095138936.png" alt="image-20221102095138936"></p></li><li><p>运行 <strong>mvn archetype:generate</strong> 命令，下面根据提示进行操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 7:【直接回车，使用默认值】</span><br><span class="line"></span><br><span class="line">Define value for property &#x27;groupId&#x27;: com.atguigu.maven</span><br><span class="line"></span><br><span class="line">Define value for property &#x27;artifactId&#x27;: pro01-maven-java</span><br><span class="line"></span><br><span class="line">Define value for property &#x27;version&#x27; 1.0-SNAPSHOT: :【直接回车，使用默认值】</span><br><span class="line"></span><br><span class="line">Define value for property &#x27;package&#x27; com.atguigu.maven: :【直接回车，使用默认值】</span><br><span class="line"></span><br><span class="line">Confirm properties configuration: groupId: com.atguigu.maven artifactId: pro01-maven-java version: 1.0-SNAPSHOT package: com.atguigu.maven Y: :【直接回车，表示确认。如果前面有输入错误，想要重新输入，则输入 N 再回车。】</span><br></pre></td></tr></table></figure></li></ul><h3 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h3><ul><li><p>Maven 默认生成的工程，对 junit 依赖的是较低的 3.8.1 版本，我们可以改成较适合的 4.12 版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 依赖信息配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- dependencies复数标签：里面包含dependency单数标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- dependency单数标签：配置一个具体的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过坐标来依赖其他jar包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 依赖的范围 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>自动生成的 App.java 和 AppTest.java 可以删除。</p></li></ul><h3 id="自动生成的pom-xml文件解读"><a href="#自动生成的pom-xml文件解读" class="headerlink" title="自动生成的pom.xml文件解读"></a>自动生成的pom.xml文件解读</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当前Maven工程的坐标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 当前Maven工程的打包方式，可选值有下面三种： --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- jar：表示这个工程是一个Java工程  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- war：表示这个工程是一个Web工程 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- pom：表示这个工程是“管理其他工程”的工程 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span><span class="comment">&lt;!--在这里定义的标签后面都可以通过$&#123;标签名&#125;来取到标签的值--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 工程构建过程中读取源码时使用的字符集 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 当前工程所依赖的jar包 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用dependency配置一个具体的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 在dependency标签内使用具体的坐标依赖我们需要的一个jar包 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- scope标签配置依赖的范围 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Maven的核心概念：POM"><a href="#Maven的核心概念：POM" class="headerlink" title="Maven的核心概念：POM"></a>Maven的核心概念：POM</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ul><li>POM：<strong>P</strong>roject <strong>O</strong>bject <strong>M</strong>odel，<strong>项目对象模型</strong>。和 POM 类似的是：DOM（Document Object Model），文档对象模型。它们都是模型化思想的具体体现。</li></ul><h3 id="模型化思想"><a href="#模型化思想" class="headerlink" title="模型化思想"></a>模型化思想</h3><ul><li>POM 表示<strong>将工程抽象为一个模型，再用程序中的对象来描述这个模型</strong>。这样我们就可以用程序来管理项目了。我们在开发过程中，最基本的做法就是<strong>将现实生活中的事物抽象为模型，然后封装模型相关的数据作为一个对象，这样就可以在程序中计算与现实事物相关的数据</strong>。</li></ul><h3 id="对应的配置文件"><a href="#对应的配置文件" class="headerlink" title="对应的配置文件"></a>对应的配置文件</h3><ul><li>POM 理念集中体现在 Maven 工程根目录下 <strong>pom.xml</strong> 这个配置文件中。所以这个 <strong>pom.xml 配置文件就是 Maven 工程的核心配置文件</strong>。其实<strong>学习 Maven 就是学这个文件怎么配置，各个配置有什么用</strong>。</li></ul><h2 id="Maven核心概念：约定的目录结构"><a href="#Maven核心概念：约定的目录结构" class="headerlink" title="Maven核心概念：约定的目录结构"></a>Maven核心概念：约定的目录结构</h2><h3 id="各个目录的作用"><a href="#各个目录的作用" class="headerlink" title="各个目录的作用"></a>各个目录的作用</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102095906918.png" alt="image-20221102095906918"></p><ul><li>除此之外，还有一个<strong>target目录专门存放构建操作输出的结果</strong>。</li></ul><h3 id="约定目录结构的意义"><a href="#约定目录结构的意义" class="headerlink" title="约定目录结构的意义"></a>约定目录结构的意义</h3><ul><li>Maven <strong>为了让构建过程能够尽可能自动化完成，所以必须约定目录结构的作用</strong>。例如：Maven 执行编译操作，必须先去 Java 源程序目录读取 Java 源代码，然后执行编译，最后把编译结果存放在 target 目录。</li></ul><h3 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h3><ul><li><p><strong>Maven 对于目录结构这个问题，没有采用配置的方式，而是基于约定</strong>。这样会让我们在开发过程中非常方便。如果每次创建 Maven 工程后，还需要针对各个目录的位置进行详细的配置，那肯定非常麻烦。</p></li><li><p>目前开发领域的技术发展趋势就是：<strong>约定优于配置，配置优于编码</strong>。先把约定的做好了再做配置然后再开始编码，这其实<strong>是一种开发原则或者说是一种软件设计范式</strong>，我个人理解其指的是<strong>在开发过程中形成的软件结构应该让工作尽可能着重于更优的开发原则&#x2F;软件设计范式提供的任务上</strong>，比如一个工程的结构使得工作着重于编码，那么它就不如工作着重于配置的工程的结构，这些<strong>更优的开发原则、软件设计范式给工程提供了更简单的开发难度、更好的可维护性，同时也让工程不失灵活性</strong>。</p></li></ul><h1 id="实验二：在Maven工程中编写代码"><a href="#实验二：在Maven工程中编写代码" class="headerlink" title="实验二：在Maven工程中编写代码"></a>实验二：在Maven工程中编写代码</h1><h2 id="主体程序"><a href="#主体程序" class="headerlink" title="主体程序"></a>主体程序</h2><ul><li><p>主体程序指的是被测试的程序，同时也是<strong>将来在项目中真正要使用的程序</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102113412498.png" alt="image-20221102113412498"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><ul><li><p>通过测试程序<strong>对主体程序进行测试</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102113529912.png" alt="image-20221102113529912"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.maven.Calculator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态导入的效果是将Assert类中的静态资源导入当前类</span></span><br><span class="line"><span class="comment">// 这样一来，在当前类中就可以直接使用Assert类中的静态资源，不需要写类名</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorTest</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSum</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建Calculator对象</span></span><br><span class="line"><span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调用Calculator对象的方法，获取到程序运行实际的结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">actualResult</span> <span class="operator">=</span> calculator.sum(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.声明一个变量，表示程序运行期待的结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">expectedResult</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.使用断言来判断实际结果和期待结果是否一致</span></span><br><span class="line"><span class="comment">// 如果一致：测试通过，不会抛出异常</span></span><br><span class="line"><span class="comment">// 如果不一致：抛出异常，测试失败</span></span><br><span class="line">assertEquals(expectedResult, actualResult);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="实验三：执行Maven的构建命令"><a href="#实验三：执行Maven的构建命令" class="headerlink" title="实验三：执行Maven的构建命令"></a>实验三：执行Maven的构建命令</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul><li><p><strong>运行 Maven 中和构建操作相关的命令时，必须进入到 pom.xml 所在的目录</strong>。如果没有在 pom.xml 所在的目录运行 Maven 的构建命令，那么会看到下面的错误信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The goal you specified requires a project to execute but there is no POM in this directory</span><br></pre></td></tr></table></figure></li><li><p>mvn -v 命令和构建操作无关，只要正确配置了 PATH，在任何目录下执行都可以。而<strong>与构建相关的命令要在 pom.xml 所在目录下运行——操作哪个工程，就进入这个工程的 pom.xml 目录</strong>。</p></li></ul><h2 id="清理操作"><a href="#清理操作" class="headerlink" title="清理操作"></a>清理操作</h2><ul><li><strong>mvn clean</strong>：删除构建操作生成的target目录。</li></ul><h2 id="编译操作"><a href="#编译操作" class="headerlink" title="编译操作"></a>编译操作</h2><ul><li>主程序编译：<strong>mvn compile</strong></li><li>测试程序编译：<strong>mvn test-compile</strong></li><li>主体程序编译结果存放的目录：<strong>target&#x2F;classes</strong></li><li>测试程序编译结果存放的目录：<strong>target&#x2F;test-classes</strong></li></ul><h2 id="测试操作"><a href="#测试操作" class="headerlink" title="测试操作"></a>测试操作</h2><ul><li><strong>mvn test</strong>：测试的报告存放的目录为<strong>target&#x2F;surefire-reports</strong></li></ul><h2 id="打包操作"><a href="#打包操作" class="headerlink" title="打包操作"></a>打包操作</h2><ul><li><strong>mvn package</strong>：打包的结果在pom.xml中指定过了，存放的目录：<strong>target</strong></li></ul><h2 id="安装操作"><a href="#安装操作" class="headerlink" title="安装操作"></a>安装操作</h2><ul><li><p><strong>mvn install</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Installing D:\maven-workspace\space201026\pro01-maven-java\target\pro01-maven-java-1.0-SNAPSHOT.jar to D:\maven-rep1026\com\atguigu\maven\pro01-maven-java\1.0-SNAPSHOT\pro01-maven-java-1.0-SNAPSHOT.jar</span><br><span class="line">[INFO] Installing D:\maven-workspace\space201026\pro01-maven-java\pom.xml to D:\maven-rep1026\com\atguigu\maven\pro01-maven-java\1.0-SNAPSHOT\pro01-maven-java-1.0-SNAPSHOT.pom</span><br></pre></td></tr></table></figure></li><li><p>安装的效果是<strong>将本地构建过程中生成的 jar 包存入 Maven 本地仓库</strong>。这个 <strong>jar 包在 Maven 仓库中的路径是根据它的坐标生成的</strong>。</p><p>坐标信息如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Maven仓库中生成的路径如下，之前也说过这个路径和坐标的关系了，看也能很容易看出来其实：</p><p><strong>D:\maven-rep1026\com\atguigu\maven\pro01-maven-java\1.0-SNAPSHOT\pro01-maven-java-1.0-SNAPSHOT.jar</strong></p></li><li><p>另外，<strong>安装操作还会将 pom.xml 文件转换为 XXX.pom 文件一起存入本地仓库</strong>。所以我们在 Maven 的本地仓库中想看一个 jar 包原始的 pom.xml 文件时，查看对应 XXX.pom 文件即可，它们是名字发生了改变，本质上是同一个文件。</p></li></ul><h1 id="实验四：创建Maven版的Web工程"><a href="#实验四：创建Maven版的Web工程" class="headerlink" title="实验四：创建Maven版的Web工程"></a>实验四：创建Maven版的Web工程</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li><p>使用 mvn archetype:generate 命令生成 Web 工程时，需要使用一个专门的 archetype。这个专门生成 Web 工程骨架的 archetype 可以参照官网看到它的用法：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102183514646.png" alt="image-20221102183514646"></p></li><li><p>参数 archetypeGroupId、archetypeArtifactId、archetypeVersion 用来指定现在使用的 maven-archetype-webapp 的坐标。</p></li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul><li><p>注意：如果在上一个工程的目录下执行 mvn archetype:generate 命令，那么 Maven 会报错：<strong>不能在一个打包类型非 pom 的工程下再创建其他工程</strong>。所以不要再刚才创建的工程里再创建新的工程，<strong>请回到工作空间根目录来操作</strong>。</p></li><li><p>然后运行生成工程的命令：<strong>mvn archetype:generate -DarchetypeGroupId&#x3D;org.apache.maven.archetypes -DarchetypeArtifactId&#x3D;maven-archetype-webapp -DarchetypeVersion&#x3D;1.4</strong></p></li><li><p>下面的操作按照提示执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Define value for property &#x27;groupId&#x27;: com.atguigu.maven Define value for property &#x27;artifactId&#x27;: pro02-maven-web Define value for property &#x27;version&#x27; 1.0-SNAPSHOT: :【直接回车，使用默认值】</span><br><span class="line"></span><br><span class="line">Define value for property &#x27;package&#x27; com.atguigu.maven: :【直接回车，使用默认值】 Confirm properties configuration: groupId: com.atguigu.maven artifactId: pro02-maven-web version: 1.0-SNAPSHOT package: com.atguigu.maven Y: :【直接回车，表示确认】</span><br></pre></td></tr></table></figure></li></ul><h2 id="生成的pom-xml"><a href="#生成的pom-xml" class="headerlink" title="生成的pom.xml"></a>生成的pom.xml</h2><ul><li><p>确认打包的方式是war包形式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="生成的Web工程的目录结构"><a href="#生成的Web工程的目录结构" class="headerlink" title="生成的Web工程的目录结构"></a>生成的Web工程的目录结构</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103100725735.png" alt="image-20221103100725735"></p><ul><li>webapp目录下有index.jsp</li><li>WEB-INF目录下有web.xml</li></ul><h2 id="创建Servlet"><a href="#创建Servlet" class="headerlink" title="创建Servlet"></a>创建Servlet</h2><h3 id="在main目录下创建java目录"><a href="#在main目录下创建java目录" class="headerlink" title="在main目录下创建java目录"></a>在main目录下创建java目录</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103101207930.png" alt="image-20221103101207930"></p><h3 id="在java目录下创建Servlet类所在的包的目录"><a href="#在java目录下创建Servlet类所在的包的目录" class="headerlink" title="在java目录下创建Servlet类所在的包的目录"></a>在java目录下创建Servlet类所在的包的目录</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103101236668.png" alt="image-20221103101236668"></p><h3 id="在包下创建Servlet类"><a href="#在包下创建Servlet类" class="headerlink" title="在包下创建Servlet类"></a>在包下创建Servlet类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">response.getWriter().write(<span class="string">&quot;hello maven web&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在web-xml中注册Servlet"><a href="#在web-xml中注册Servlet" class="headerlink" title="在web.xml中注册Servlet"></a>在web.xml中注册Servlet</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>helloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.maven.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>helloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/helloServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="在index-jsp页面编写超链接"><a href="#在index-jsp页面编写超链接" class="headerlink" title="在index.jsp页面编写超链接"></a>在index.jsp页面编写超链接</h2><ul><li><p>虽然现在几乎用不到jsp技术了，这里只是为了进行演示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;helloServlet&quot;</span>&gt;</span>Access Servlet<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>JSP全称是 Java Server Page，和 Thymeleaf 一样，是服务器端页面渲染技术。这里我们不必关心 JSP 语法细节，编写一个超链接标签即可。</p></li></ul><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul><li><p>此时直接执行<strong>mvn compile</strong>命令出错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DANGER</span><br><span class="line"></span><br><span class="line">程序包 javax.servlet.http 不存在</span><br><span class="line"></span><br><span class="line">程序包 javax.servlet 不存在</span><br><span class="line"></span><br><span class="line">找不到符号</span><br><span class="line"></span><br><span class="line">符号: 类 HttpServlet</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure></li><li><p>上面的错误信息说明：我们的 Web 工程用到了 HttpServlet 这个类，而 HttpServlet 这个类属于 servlet-api.jar 这个 jar 包。此时我们说，Web 工程需要依赖 servlet-api.jar 包。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103102538266.png" alt="image-20221103102538266"></p></li></ul><h2 id="配置对servlet-api-jar包的依赖"><a href="#配置对servlet-api-jar包的依赖" class="headerlink" title="配置对servlet-api.jar包的依赖"></a>配置对servlet-api.jar包的依赖</h2><ul><li><p>对于不知道详细信息的依赖可以到<a href="https://mvnrepository.com/%E7%BD%91%E7%AB%99%E6%9F%A5%E8%AF%A2%E3%80%82**%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A2**%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E5%88%97%E8%A1%A8%E4%B8%AD%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%82">https://mvnrepository.com/网站查询。**使用关键词搜索**，然后在搜索结果列表中选择适合的使用。</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103102743004.png" alt="image-20221103102743004"></p></li><li><p>比如，我们找到的servlet-api的依赖信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>这样就可以把上面的信息加入pom.xml。重新执行mvn compile命令即可顺利编译。</p></li></ul><h2 id="将Web工程打包为war包"><a href="#将Web工程打包为war包" class="headerlink" title="将Web工程打包为war包"></a>将Web工程打包为war包</h2><ul><li><p>运行<strong>mvn package</strong>命令，生成war包的位置如下图所示：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103103051932.png" alt="image-20221103103051932"></p></li></ul><h2 id="将war包部署到Tomcat上运行"><a href="#将war包部署到Tomcat上运行" class="headerlink" title="将war包部署到Tomcat上运行"></a>将war包部署到Tomcat上运行</h2><ul><li><p>将war包复制到<strong>Tomcat&#x2F;webapps</strong>目录下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103103150452.png" alt="image-20221103103150452"></p></li><li><p>启动Tomcat：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103103219090.png" alt="image-20221103103219090"></p></li><li><p>Tomcat会自动解压war包，反正都要解压之后使用，所以<strong>也可以直接把解压好的war包放到Tomcat中</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103103320669.png" alt="image-20221103103320669"></p></li><li><p>通过浏览器尝试访问：<a href="http://localhost:8080/pro02-maven-web/index.jsp%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%AE%BF%E9%97%AE%E6%88%90%E5%8A%9F%E8%AF%B4%E6%98%8EWeb%E5%B7%A5%E7%A8%8B%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F%E5%B9%B6%E8%83%BD%E9%A1%BA%E5%88%A9%E8%BF%90%E8%A1%8C%E3%80%82">http://localhost:8080/pro02-maven-web/index.jsp，如果访问成功说明Web工程部署成功并能顺利运行。</a></p></li></ul><h1 id="实验五：让Web工程依赖Java工程"><a href="#实验五：让Web工程依赖Java工程" class="headerlink" title="实验五：让Web工程依赖Java工程"></a>实验五：让Web工程依赖Java工程</h1><h2 id="观念"><a href="#观念" class="headerlink" title="观念"></a>观念</h2><ul><li>明确一个意识：<strong>从来只有 Web 工程依赖 Java 工程，没有反过来 Java 工程依赖 Web 工程</strong>。本质上来说，<strong>Web 工程依赖的 Java 工程其实就是 Web 工程里导入的 jar 包</strong>。最终 Java 工程会变成 jar 包，<strong>放在 Web 工程的 WEB-INF&#x2F;lib 目录下</strong>。</li></ul><h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><ul><li><p>在 pro02-maven-web 工程的 pom.xml 中，找到 dependencies 标签，在 dependencies 标签中做如下配置，这样依赖的是我们刚才实验用到的java工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置对Java工程pro01-maven-java的依赖 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体的配置方式：在dependency标签内使用坐标实现依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="在Web工程中，编写测试代码"><a href="#在Web工程中，编写测试代码" class="headerlink" title="在Web工程中，编写测试代码"></a>在Web工程中，编写测试代码</h2><h3 id="补充自动创建的目录"><a href="#补充自动创建的目录" class="headerlink" title="补充自动创建的目录"></a>补充自动创建的目录</h3><ul><li>pro02-maven-web<strong>\src\test\java\com\atguigu\maven</strong>，test目录下的结构尽量和main目录下的结构保持一致。</li></ul><h3 id="确认Web工程依赖了junit"><a href="#确认Web工程依赖了junit" class="headerlink" title="确认Web工程依赖了junit"></a>确认Web工程依赖了junit</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建测试类"><a href="#创建测试类" class="headerlink" title="创建测试类"></a>创建测试类</h3><ul><li>把 Java 工程的 CalculatorTest.java 类复制到 pro02-maven-wb<strong>\src\test\java\com\atguigu\maven</strong> 目录下</li></ul><h2 id="执行Maven命令"><a href="#执行Maven命令" class="headerlink" title="执行Maven命令"></a>执行Maven命令</h2><h3 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h3><ul><li>使用<strong>mvn test</strong>命令</li><li>说明：测试操作中会提前自动执行编译操作，测试成功就说明编译也是成功的，这样的特性是由于<strong>编译和测试操作同属一个生命周期并且在那个生命周期中编译操作在测试操作的前面</strong>。</li></ul><h3 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h3><ul><li><p>使用<strong>mvn package</strong>命令</p></li><li><p><strong>打包后的文件会放到target目录下</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103114152535.png" alt="image-20221103114152535"></p></li><li><p>通过查看war包内的结构，我们看到<strong>被Web工程依赖的Java工程确实是会变成Web工程的WEB-INF&#x2F;lib目录下的jar包</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103114306748.png" alt="image-20221103114306748"></p></li></ul><h3 id="查看当前Web工程所依赖的jar包的列表"><a href="#查看当前Web工程所依赖的jar包的列表" class="headerlink" title="查看当前Web工程所依赖的jar包的列表"></a>查看当前Web工程所依赖的jar包的列表</h3><ul><li><p>使用命令<strong>mvn dependency:list</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[INFO] The following files have been resolved:</span><br><span class="line">[INFO] org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] javax.servlet:javax.servlet-api:jar:3.1.0:provided</span><br><span class="line">[INFO] com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile</span><br><span class="line">[INFO] junit:junit:jar:4.12:test</span><br></pre></td></tr></table></figure></li><li><p>说明：像javax.servlet:javax.servlet-api:jar:3.1.0:provided这样的格式显示的是一个 jar 包的坐标信息。格式是：<strong>groupId:artifactId:打包方式:version:依赖的范围</strong></p></li><li><p>这样的格式虽然和我们 XML 配置文件中坐标的格式不同，但是<strong>本质上还是坐标信息</strong>，我们需要能够认识这样的格式，将来从 Maven 命令的日志或错误信息中看到这样格式的信息，就能够识别出来这是坐标。进而根据坐标到Maven 仓库找到对应的jar包，用这样的方式解决我们遇到的报错的情况。</p></li></ul><h3 id="以树形结构查看当前Web工程的依赖信息"><a href="#以树形结构查看当前Web工程的依赖信息" class="headerlink" title="以树形结构查看当前Web工程的依赖信息"></a>以树形结构查看当前Web工程的依赖信息</h3><ul><li><p>使用命令<strong>mvn dependency:tree</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] | \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided</span><br><span class="line">[INFO] \- com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile</span><br></pre></td></tr></table></figure></li><li><p>我们在 pom.xml 中并没有依赖 hamcrest-core，但是它却被加入了我们依赖的列表。原因是：junit 依赖了hamcrest-core，然后<strong>基于依赖的传递性</strong>，hamcrest-core 被传递到我们的工程了。</p></li></ul><h1 id="实验六：测试依赖的范围"><a href="#实验六：测试依赖的范围" class="headerlink" title="实验六：测试依赖的范围"></a>实验六：测试依赖的范围</h1><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><ul><li>scope标签的位置：dependencies -&gt; dependency -&gt; <strong>scope</strong></li><li>scope标签的可选值：<strong>compile</strong>&#x2F;<strong>test</strong>&#x2F;<strong>provided</strong>&#x2F;system&#x2F;runtime&#x2F;<strong>import</strong></li><li>scope标签的<strong>默认值</strong>：<strong>compile</strong></li></ul><h3 id="compile和test作用的时空对比"><a href="#compile和test作用的时空对比" class="headerlink" title="compile和test作用的时空对比"></a>compile和test作用的时空对比</h3><table><thead><tr><th></th><th>main目录(空间)</th><th>test目录(空间)</th><th>开发过程(时间)</th><th>部署到服务器(时间)</th></tr></thead><tbody><tr><td>compile</td><td>有效</td><td>有效</td><td>有效</td><td>有效</td></tr><tr><td>test</td><td>无效</td><td>有效</td><td>有效</td><td>无效</td></tr></tbody></table><h3 id="compile和provided作用的时空对比"><a href="#compile和provided作用的时空对比" class="headerlink" title="compile和provided作用的时空对比"></a>compile和provided作用的时空对比</h3><table><thead><tr><th></th><th>main目录(空间)</th><th>test目录(空间)</th><th>开发过程(时间)</th><th>部署到服务器(时间)</th></tr></thead><tbody><tr><td>compile</td><td>有效</td><td>有效</td><td>有效</td><td>有效</td></tr><tr><td>provided</td><td>有效</td><td>有效</td><td>有效</td><td>无效</td></tr></tbody></table><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><ul><li><strong>compile</strong>：通常使用的第三方框架的 jar 包这样<strong>在项目实际运行时真正要用到的 jar 包</strong>都是以 compile 范围进行依赖的。比如 SSM 框架所需jar包。</li><li><strong>test</strong>：<strong>测试过程中使用</strong>的 jar 包，以 test 范围依赖进来。比如 junit。</li><li><strong>provided</strong>：在<strong>开发过程中需要用到的“服务器上的 jar 包”</strong>通常以 provided 范围依赖进来，scope为这个值的包说明<strong>其在服务器上已经被提供</strong>。比如 servlet-api、jsp-api。而这个范围的 jar 包之所以<strong>不参与部署、不放进 war 包，就是避免和服务器上已有的同类 jar 包产生冲突，同时减轻服务器的负担</strong>。说白了就是：“<strong>服务器上已经有了，你就别带啦！</strong>”</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>测试方法很简单，向要测试的地方导个要检测的包看一下能不能过编译就行了</li></ul><h3 id="验证compile范围对main目录有效"><a href="#验证compile范围对main目录有效" class="headerlink" title="验证compile范围对main目录有效"></a>验证compile范围对main目录有效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main目录下的类：HelloServlet 使用compile范围导入的依赖：pro01-atguigu-maven</span><br><span class="line"></span><br><span class="line">验证：使用compile范围导入的依赖对main目录下的类来说是有效的</span><br><span class="line"></span><br><span class="line">有效：HelloServlet 能够使用 pro01-atguigu-maven 工程中的 Calculator 类</span><br><span class="line"></span><br><span class="line">验证方式：在 HelloServlet 类中导入 Calculator 类，然后编译就说明有效。</span><br></pre></td></tr></table></figure><h3 id="验证test范围对main目录无效"><a href="#验证test范围对main目录无效" class="headerlink" title="验证test范围对main目录无效"></a>验证test范围对main目录无效</h3><ul><li><p>测试方式：在主体程序中导入org.junit.Test这个注解，然后执行编译。</p></li><li><p>具体操作：在pro01-maven-java\src\main\java\com\atguigu\maven目录下修改Calculator.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行Maven编译命令，发现报错了，说明scope为test的jar包不对main目录有效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] /D:/maven-workspace/space201026/pro01-maven-java/src/main/java/com/atguigu/maven/Calculator.java:[3,17] 程序包org.junit不存在</span><br></pre></td></tr></table></figure></li></ul><h3 id="验证test和provided范围不参与服务器部署"><a href="#验证test和provided范围不参与服务器部署" class="headerlink" title="验证test和provided范围不参与服务器部署"></a>验证test和provided范围不参与服务器部署</h3><ul><li><p>其实就是验证：通过compile范围依赖的jar包会放入war包，通过test范围依赖的jar包不会放入war包。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103232528630.png" alt="image-20221103232528630"></p></li></ul><h3 id="验证provided范围对测试程序有效"><a href="#验证provided范围对测试程序有效" class="headerlink" title="验证provided范围对测试程序有效"></a>验证provided范围对测试程序有效</h3><ul><li><p>测试方式是在pro02-maven-web的测试程序中加入servlet-api.jar包中的类。</p></li><li><p>修改：<strong>pro02-maven-web</strong>\src\<strong>test</strong>\java\com\atguigu\maven\<strong>CalculatorTest.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.maven.Calculator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态导入的效果是将Assert类中的静态资源导入当前类</span></span><br><span class="line"><span class="comment">// 这样一来，在当前类中就可以直接使用Assert类中的静态资源，不需要写类名</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorTest</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSum</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建Calculator对象</span></span><br><span class="line"><span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调用Calculator对象的方法，获取到程序运行实际的结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">actualResult</span> <span class="operator">=</span> calculator.sum(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.声明一个变量，表示程序运行期待的结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">expectedResult</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.使用断言来判断实际结果和期待结果是否一致</span></span><br><span class="line"><span class="comment">// 如果一致：测试通过，不会抛出异常</span></span><br><span class="line"><span class="comment">// 如果不一致：抛出异常，测试失败</span></span><br><span class="line">assertEquals(expectedResult, actualResult);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后运行Maven的编译命令：<strong>mvn compile</strong>，然后看到编译成功。</p></li></ul><h1 id="实验七：测试依赖的传递性"><a href="#实验七：测试依赖的传递性" class="headerlink" title="实验七：测试依赖的传递性"></a>实验七：测试依赖的传递性</h1><h2 id="依赖的传递性"><a href="#依赖的传递性" class="headerlink" title="依赖的传递性"></a>依赖的传递性</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>A 依赖 B，B 依赖 C，那么在 A 没有配置对 C 的依赖的情况下，A 里面能不能直接使用 C？</li></ul><h3 id="传递的原则"><a href="#传递的原则" class="headerlink" title="传递的原则"></a>传递的原则</h3><ul><li>在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围：<ul><li>B 依赖 C 时使用 <strong>compile 范围：可以传递</strong></li><li>B 依赖 C 时使用 <strong>test 或 provided 范围：不能传递</strong>，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。</li></ul></li></ul><h2 id="使用compile范围依赖spring-core"><a href="#使用compile范围依赖spring-core" class="headerlink" title="使用compile范围依赖spring-core"></a>使用compile范围依赖spring-core</h2><ul><li><p>测试方式：让 pro01-maven-java 工程依赖 spring-core</p></li><li><p>具体操作：编辑 pro01-maven-java 工程根目录下 pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用<strong>mvn dependency:tree</strong>命令查看效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[INFO] com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] | \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] \- org.springframework:spring-core:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] \- commons-logging:commons-logging:jar:1.1.1:compile</span><br></pre></td></tr></table></figure></li><li><p>还可以在 Web 工程中，使用 <strong>mvn dependency:tree</strong> 命令查看效果（<strong>需要重新将 pro01-maven-java 安装到仓库</strong>），可以看到spring-core这个依赖被传递过去了，所以证明<strong>scope为compile的依赖可以被传递</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] | \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided</span><br><span class="line">[INFO] \- com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile</span><br><span class="line">[INFO] \- org.springframework:spring-core:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] \- commons-logging:commons-logging:jar:1.1.1:compile</span><br></pre></td></tr></table></figure></li><li><p>注意上面提到改变pro01-maven-java的pom.xml之后，需要重新安装到仓库才能被别的工程引用最新的版本，原因是<strong>pom.xml中的依赖都是从maven仓库中取的，因此如果只在工作空间更新了一个包的内容而没有将其安装到本地仓库中的话，别的工程是无法正确获取最新的包的内容的</strong>。</p></li></ul><h2 id="验证test和provided范围不能传递"><a href="#验证test和provided范围不能传递" class="headerlink" title="验证test和provided范围不能传递"></a>验证test和provided范围不能传递</h2><ul><li><p>从上面的例子已经能够看到，pro01-maven-java 依赖了 junit，但是在 pro02-maven-web 工程中查看依赖树的时候并没有看到 junit。</p></li><li><p>要验证 provided 范围不能传递，可以在 pro01-maven-java 工程中加入 servlet-api 的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>效果还是和之前一样，证明<strong>scope为test和provided的依赖无法被传递</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] | \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided</span><br><span class="line">[INFO] \- com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile</span><br><span class="line">[INFO] \- org.springframework:spring-core:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] \- commons-logging:commons-logging:jar:1.1.1:compile</span><br></pre></td></tr></table></figure></li></ul><h1 id="实验八：测试依赖的排除"><a href="#实验八：测试依赖的排除" class="headerlink" title="实验八：测试依赖的排除"></a>实验八：测试依赖的排除</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li><p>当 A 依赖 B，B 依赖 C 而且 C 可以传递到 A 的时候，A 不想要 C，需要在 A 里面把 C 排除掉。而往往这种情况都是<strong>为了避免 jar 包之间的冲突</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104093931728.png" alt="image-20221104093931728"></p></li><li><p>所以<strong>配置依赖的排除其实就是阻止某些jar包的传递</strong>，因为这样的jar包传递过来会和其他jar包冲突。</p></li></ul><h2 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h2><ul><li><p>需要<strong>在dependency标签中配置exclusions标签和exclusion标签</strong>：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用excludes标签配置依赖的排除--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version，因为没有歧义）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><ul><li><p>测试的方式：在 pro02-maven-web 工程中配置对 commons-logging 的排除：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用excludes标签配置依赖的排除--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行<strong>mvn dependency:tree</strong>命令查看效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] | \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided</span><br><span class="line">[INFO] \- com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile</span><br><span class="line">[INFO] \- org.springframework:spring-core:jar:4.0.0.RELEASE:compile</span><br></pre></td></tr></table></figure></li><li><p>发现在spring-core下面就没有commons-logging了，说明依赖排除生效了。</p></li></ul><h1 id="实验九：继承"><a href="#实验九：继承" class="headerlink" title="实验九：继承"></a>实验九：继承</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><ul><li><p>Maven工程之间，A 工程继承 B 工程</p><ul><li>B 工程：父工程</li><li>A 工程：子工程</li></ul></li><li><p>本质上是 <strong>A 工程的 pom.xml 中的配置继承了 B 工程中 pom.xml 的配置</strong>。</p></li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li><p>在<strong>父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本</strong>。</p></li><li><p>这一特性作用的背景是：</p><ul><li>对一个比较大型的项目进行了模块拆分。</li><li>一个 project 下面，创建了很多个 module。</li><li>每一个 module 都需要配置自己的依赖信息。</li></ul></li><li><p>它背后的需求是：</p><ul><li>在<strong>每一个 module 中各自维护各自的依赖信息很容易发生出入，不易统一管理</strong>。</li><li>使用同一个框架内的不同 jar 包，它们应该是同一个版本，所以<strong>整个项目中使用的框架版本需要统一</strong>。</li><li>使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个<strong>耗费很大精力总结出来的方案不应该在新的项目中重新摸索</strong>。</li></ul></li><li><p>综上所述，我们<strong>需要在父工程中对整个项目的依赖信息进行统一管理</strong>，通过在父工程中为整个项目维护依赖信息的组合既<strong>保证了整个项目使用规范、准确的 jar 包</strong>；又能够<strong>将以往的经验沉淀下来，节约时间和精力</strong>。</p></li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ul><li><p>在一个工程中依赖多个Spring的jar包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[INFO] +- org.springframework:spring-core:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] | \- commons-logging:commons-logging:jar:1.1.1:compile</span><br><span class="line">[INFO] +- org.springframework:spring-beans:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] +- org.springframework:spring-context:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] +- org.springframework:spring-expression:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] +- org.springframework:spring-aop:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] | \- aopalliance:aopalliance:jar:1.0:compile</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Spring 时要求所有 Spring 自己的 jar 包版本必须一致</strong>，比如上面的例子中，就都是4.0.0版本。为了能够对这些 jar 包的版本进行统一管理，我们使用继承这个机制，将所有版本信息统一在父工程中进行管理。</p></li></ul><h2 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h2><h3 id="创建父工程"><a href="#创建父工程" class="headerlink" title="创建父工程"></a>创建父工程</h3><ul><li><p>创建的过程和前面创建 pro01-maven-java 一样。</p></li><li><p>工程名称：pro03-maven-parent</p></li><li><p>工程创建好之后，要修改它的打包方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>只有打包方式为 pom 的 Maven 工程能够管理其他 Maven 工程</strong>。打包方式为 pom 的 Maven 工程中<strong>不写业务代码</strong>，它是<strong>专门管理其他 Maven 工程</strong>的工程。</p></li></ul><h3 id="创建模块工程"><a href="#创建模块工程" class="headerlink" title="创建模块工程"></a>创建模块工程</h3><ul><li><p>模块工程类似于 IDEA 中的 module，所以需要<strong>进入 pro03-maven-parent 工程的根目录</strong>，然后<strong>运行 mvn archetype:generate 命令来创建模块工程</strong>。</p></li><li><p>假设，我们创建三个模块工程：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104102340362.png" alt="image-20221104102340362"></p></li></ul><h3 id="查看被添加新内容的父工程pom-xml"><a href="#查看被添加新内容的父工程pom-xml" class="headerlink" title="查看被添加新内容的父工程pom.xml"></a>查看被添加新内容的父工程pom.xml</h3><ul><li><p>在<strong>创建子工程之后，父工程的pom.xml中更新后会自动生成和子工程建立聚合关系的配置</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro05-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro06-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="解读子工程的pom-xml"><a href="#解读子工程的pom-xml" class="headerlink" title="解读子工程的pom.xml"></a>解读子工程的pom.xml</h3><ul><li><p><strong>子工程中也存在和其父工程相关的配置</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 父工程的坐标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子工程的坐标 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="在父工程中配置依赖的统一管理"><a href="#在父工程中配置依赖的统一管理" class="headerlink" title="在父工程中配置依赖的统一管理"></a>在父工程中配置依赖的统一管理</h3><ul><li><p>使用<strong>dependencyManagement标签</strong>实现管理依赖，<strong>被管理的依赖并没有真正被引入到父工程</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="子工程中引用那些被父工程管理的依赖"><a href="#子工程中引用那些被父工程管理的依赖" class="headerlink" title="子工程中引用那些被父工程管理的依赖"></a>子工程中引用那些被父工程管理的依赖</h3><ul><li><p>关键在于子工程引用的时候，如果依赖被父工程管理，那么在引用的时候<strong>可以省略版本号</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="测试依赖性，在父工程中升级依赖信息的版本"><a href="#测试依赖性，在父工程中升级依赖信息的版本" class="headerlink" title="测试依赖性，在父工程中升级依赖信息的版本"></a>测试依赖性，在父工程中升级依赖信息的版本</h3><ul><li><p>把所有和spring相关的依赖都改个版本：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure></li><li><p>然后在子工程中运行<strong>mvn dependency:list</strong>，效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[INFO] org.springframework:spring-aop:jar:4.1.4.RELEASE:compile</span><br><span class="line">[INFO] org.springframework:spring-core:jar:4.1.4.RELEASE:compile</span><br><span class="line">[INFO] org.springframework:spring-context:jar:4.1.4.RELEASE:compile</span><br><span class="line">[INFO] org.springframework:spring-beans:jar:4.1.4.RELEASE:compile</span><br><span class="line">[INFO] org.springframework:spring-expression:jar:4.1.4.RELEASE:compile</span><br></pre></td></tr></table></figure><p>可以看到子工程中的依赖版本也都发生了改变，所以父工程对于依赖的管理是生效的。</p></li></ul><h3 id="在父工程中声明自定义属性"><a href="#在父工程中声明自定义属性" class="headerlink" title="在父工程中声明自定义属性"></a>在父工程中声明自定义属性</h3><ul><li><p>在<strong>properties标签</strong>中自定义属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 自定义标签，维护Spring版本数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">atguigu.spring.version</span>&gt;</span>4.3.6.RELEASE<span class="tag">&lt;/<span class="name">atguigu.spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在需要的地方使用**${自定义属性名}**的形式来引用自定义的属性名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;atguigu.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>这样真正实现了**”一处修改，处处生效”**。</p></li></ul><h2 id="实际意义"><a href="#实际意义" class="headerlink" title="实际意义"></a>实际意义</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104103614834.png" alt="image-20221104103614834"></p><ul><li>编写一套符合要求、开发各种功能都能正常工作的依赖组合并不容易。如果公司里已经有人总结了成熟的组合方案，那么再开发新项目时，如果不使用原有的积累，而是重新摸索，会浪费大量的时间。为了提高效率，我们可以<strong>使用工程继承的机制，让成熟的依赖组合方案能够保留下来</strong>。</li><li>如上图所示，<strong>公司级的父工程中管理的就是成熟的依赖组合方案，各个新项目、子系统各取所需即可</strong>。</li></ul><h1 id="实验十：聚合"><a href="#实验十：聚合" class="headerlink" title="实验十：聚合"></a>实验十：聚合</h1><h2 id="聚合本身的含义"><a href="#聚合本身的含义" class="headerlink" title="聚合本身的含义"></a>聚合本身的含义</h2><ul><li>部分组成整体，整体和部分之间就是聚合的关系。</li><li>设计模式中<strong>组合是部分和整体之间的关系，部分和整体共存亡</strong>；设计模式中<strong>聚合是比较松散的关系，只是说明整体中包含部分，但是他们的生命周期一般不一致</strong>。</li></ul><h2 id="Maven中的聚合"><a href="#Maven中的聚合" class="headerlink" title="Maven中的聚合"></a>Maven中的聚合</h2><ul><li><p><strong>使用一个“总工程”将各个“模块工程”汇集起来，作为一个整体对应完整的项目</strong>。</p><ul><li>项目：整体</li><li>模块：部分</li></ul></li><li><p>概念的对应关系：</p><ul><li>从继承关系角度来看是：父工程和子工程</li><li>从聚合关系角度来看是：总工程和模块工程</li></ul></li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>一键执行 Maven 命令：<strong>很多构建命令都可以在“总工程”中一键执行</strong>。</li><li>以 mvn install 命令为例：Maven 要求有父工程时先安装父工程；有依赖的工程时，先安装被依赖的工程。我们自己考虑这些规则会很麻烦。但是<strong>工程聚合之后，在总工程执行 mvn install 可以一键完成安装，而且会自动按照正确的顺序执行</strong>。</li><li><strong>配置聚合之后，各个模块工程会在总工程中展示一个列表，让项目中的各个模块一目了然</strong>。</li></ul><h2 id="聚合的配置"><a href="#聚合的配置" class="headerlink" title="聚合的配置"></a>聚合的配置</h2><ul><li><p>在总工程中配置modules即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro05-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro06-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="依赖循环问题"><a href="#依赖循环问题" class="headerlink" title="依赖循环问题"></a>依赖循环问题</h2><ul><li>如果 A 工程依赖 B 工程，B 工程依赖 C 工程，C 工程又反过来依赖 A 工程，那么在执行构建操作时会报下面的错误：**[ERROR] [ERROR] The projects in the reactor contain a cyclic reference:<strong>，这个错误的含义是：</strong>循环引用**</li><li>在工程中不要出现这样的依赖关系。</li></ul><h1 id="在IDEA环境中使用Maven"><a href="#在IDEA环境中使用Maven" class="headerlink" title="在IDEA环境中使用Maven"></a>在IDEA环境中使用Maven</h1><h2 id="创建父工程-1"><a href="#创建父工程-1" class="headerlink" title="创建父工程"></a>创建父工程</h2><h3 id="创建Project"><a href="#创建Project" class="headerlink" title="创建Project"></a>创建Project</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104120215910.png" alt="image-20221104120215910"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104120226562.png" alt="image-20221104120226562"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104120237465.png" alt="image-20221104120237465"></p><h3 id="开启自动导入"><a href="#开启自动导入" class="headerlink" title="开启自动导入"></a>开启自动导入</h3><ul><li><p>创建 Project 后，IDEA 会自动弹出下面提示，我们选择<strong>『Enable Auto-Import』</strong>，意思是启用自动导入：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104120305916.png" alt="image-20221104120305916"></p></li><li><p>这个<strong>自动导入一定要开启</strong>，因为 Project、Module 新创建或 pom.xml <strong>每次修改时都应该让 IDEA 重新加载 Maven 信息</strong>。这对 Maven 目录结构认定、Java 源程序编译、依赖 jar 包的导入都有非常关键的影响。另外<strong>也可以通过 IDEA 的 Settings 设置来开启</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104120403416.png" alt="image-20221104120403416"></p></li></ul><h2 id="配置Maven信息"><a href="#配置Maven信息" class="headerlink" title="配置Maven信息"></a>配置Maven信息</h2><ul><li><p><strong>每次创建 Project 后都需要设置 Maven 家目录位置，否则 IDEA 将使用内置的 Maven 核心程序（不稳定）并使用默认的本地仓库位置</strong>。这样一来，我们在命令行操作过程中已下载好的 jar 包就白下载了，默认的本地仓库通常在 C 盘，还影响系统运行。</p></li><li><p>配置之后，IDEA 会根据我们在这里指定的 Maven 家目录自动识别到我们在 settings.xml 配置文件中指定的本地仓库。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104121608954.png" alt="image-20221104121608954"></p></li><li><p>每次创建新的工程都要重新配置maven，这样做非常不方便，所幸高版本的IDEA提供了这样一个设置：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104121919660.png" alt="image-20221104121919660"></p><p>在这个地方<strong>可以设置每次创建新工程之后应该遵循的setting和structure</strong>，在这个地方设置一下就不用每次都设置了。</p></li></ul><h2 id="创建Java模块工程"><a href="#创建Java模块工程" class="headerlink" title="创建Java模块工程"></a>创建Java模块工程</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104122125032.png" alt="image-20221104122125032"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104122137263.png" alt="image-20221104122137263"></p><h2 id="创建Web模块工程"><a href="#创建Web模块工程" class="headerlink" title="创建Web模块工程"></a>创建Web模块工程</h2><h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h3><ul><li>按照前面的同样操作创建模块，<strong>此时</strong>这个模块其实还是一个<strong>Java模块</strong>。</li></ul><h3 id="修改打包方式"><a href="#修改打包方式" class="headerlink" title="修改打包方式"></a>修改打包方式</h3><ul><li><p>Web 模块将来打包当然应该是 <strong>war</strong> 包。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Web设定"><a href="#Web设定" class="headerlink" title="Web设定"></a>Web设定</h3><ul><li><p>首先打开项目结构菜单：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104122437463.png" alt="image-20221104122437463"></p></li><li><p>然后到 Facets 下查看 IDEA 是否已经帮我们自动生成了 Web 设定。正常来说<strong>只要我们确实设置了打包方式为 war，那么 IDEA 2019 版就会自动生成 Web 设定</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104122508382.png" alt="image-20221104122508382"></p></li><li><p>另外，对于IDEA 2018 诸版本没有自动生成 Web 设定，那么请参照下面两图，我们自己创建，简单地说就是<strong>如果IDEA没有把我们的模块识别成web模块，那么我们就手动告诉IDEA</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104122547971.png" alt="image-20221104122547971"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104122601249.png" alt="image-20221104122601249"></p></li></ul><h3 id="借助IDEA生成web-xml"><a href="#借助IDEA生成web-xml" class="headerlink" title="借助IDEA生成web.xml"></a>借助IDEA生成web.xml</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104123239315.png" alt="image-20221104123239315"></p><ul><li><p>这个上面这个<strong>部署描述符实际上就是指的web.xml文件</strong>，可以点击那个加号按钮来声明一个web.xml的位置：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104123352730.png" alt="image-20221104123352730"></p></li></ul><h3 id="设置Web资源的根目录"><a href="#设置Web资源的根目录" class="headerlink" title="设置Web资源的根目录"></a>设置Web资源的根目录</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104123846594.png" alt="image-20221104123846594"></p><ul><li><p>在上面这个地方指定Web资源的目录，点击加号按钮新增一个Web资源目录。</p></li><li><p>结合 Maven 的目录结构，<strong>Web 资源的根目录需要设置为 src&#x2F;main&#x2F;webapp 目录</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104124016366.png" alt="image-20221104124016366"></p></li></ul><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="在IDEA中执行Maven命令"><a href="#在IDEA中执行Maven命令" class="headerlink" title="在IDEA中执行Maven命令"></a>在IDEA中执行Maven命令</h3><h4 id="直接执行"><a href="#直接执行" class="headerlink" title="直接执行"></a>直接执行</h4><ul><li><p>在IDEA右边的maven界面中双击操作即可执行：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104124226175.png" alt="image-20221104124226175"></p></li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104124144107.png" alt="image-20221104124144107"></p><h4 id="手动输入"><a href="#手动输入" class="headerlink" title="手动输入"></a>手动输入</h4><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104141358112.png" alt="image-20221104141358112"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104141408290.png" alt="image-20221104141408290"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104141417494.png" alt="image-20221104141417494"></p><ul><li><p>如果有需要，还可以给命令后面附加参数：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104141443717.png" alt="image-20221104141443717"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -D 表示后面要附加命令的参数，字母 D 和后面的参数是紧挨着的，中间没有任何其它字符</span></span><br><span class="line"><span class="comment"># maven.test.skip=true 表示在执行命令的过程中跳过测试</span></span><br><span class="line">mvn clean install -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="在IDEA中查看某个模块的依赖信息"><a href="#在IDEA中查看某个模块的依赖信息" class="headerlink" title="在IDEA中查看某个模块的依赖信息"></a>在IDEA中查看某个模块的依赖信息</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104141551740.png" alt="image-20221104141551740"></p><h3 id="工程导入"><a href="#工程导入" class="headerlink" title="工程导入"></a>工程导入</h3><ul><li>Maven工程除了自己创建的，还有很多情况是别人创建的。而为了参与开发或者是参考学习，我们都需要导入到 IDEA 中。下面我们分几种不同情况来说明：</li></ul><h4 id="来自版本控制系统（VCS）"><a href="#来自版本控制系统（VCS）" class="headerlink" title="来自版本控制系统（VCS）"></a>来自版本控制系统（VCS）</h4><ul><li>通常使用git+gitee&#x2F;github来实现版本控制，IDEA中也有对于它们的相关操作方式，这里不再赘述。</li></ul><h4 id="来自工程目录"><a href="#来自工程目录" class="headerlink" title="来自工程目录"></a>来自工程目录</h4><ul><li><p>直接使用IDEA打开工程目录即可。下面举个例子：</p><ol><li><p><strong>获取工程压缩包</strong>：假设别人发给我们一个 Maven 工程的 zip 压缩包：maven-rest-demo.zip。从码云或GitHub上也可以以 ZIP 压缩格式对项目代码打包下载。</p></li><li><p><strong>解压工程压缩包</strong>：如果你的所有 IDEA 工程有一个专门的目录来存放，而不是散落各处，那么首先我们就把 ZIP 包解压到这个指定目录中。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104142023322.png" alt="image-20221104142023322"></p></li><li><p><strong>使用IDEA打开解压好的目录</strong>：只要我们确认在解压目录下可以直接看到 pom.xml，那就能证明这个解压目录就是我们的工程目录。那么接下来让 IDEA 打开这个目录就可以了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104142112084.png" alt="image-20221104142112084"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104142129071.png" alt="image-20221104142129071"></p></li><li><p><strong>设置Maven核心程序的位置</strong>（如果在IDEA中配置了新工程的setting就不用这步了）：打开一个新的 Maven 工程，和新创建一个 Maven 工程是一样的，此时 IDEA 的 settings 配置中关于 Maven 仍然是默认值，所以我们还是需要像新建 Maven 工程那样，指定一下 Maven 核心程序位置：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104142354750.png" alt="image-20221104142354750"></p></li></ol></li></ul><h3 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h3><h4 id="情景重现"><a href="#情景重现" class="headerlink" title="情景重现"></a>情景重现</h4><ul><li><p><strong>在实际开发中，通常会忽略模块（也就是module）所在的项目（也就是project）仅仅导入某一个模块本身</strong>。这么做很可能是类似这样的情况：比如基于 Maven 学习 SSM 的时候，做练习需要导入老师发给我们的代码参考。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104142714234.png" alt="image-20221104142714234"></p></li></ul><h4 id="导入Java类型模块"><a href="#导入Java类型模块" class="headerlink" title="导入Java类型模块"></a>导入Java类型模块</h4><ol><li><p>找到想要导入模块的所在目录：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104142754321.png" alt="image-20221104142754321"></p></li><li><p>复制我们想要导入的模块目录：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104142821800.png" alt="image-20221104142821800"></p></li><li><p>粘贴到我们自己的工程目录下，这个工程（project）是我们事先在IDEA中创建好的：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104143342073.png" alt="image-20221104143342073"></p></li><li><p>在IDEA中执行导入：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104143420462.png" alt="image-20221104143420462"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104143431264.png" alt="image-20221104143431264"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104143449031.png" alt="image-20221104143449031"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104143502738.png" alt="image-20221104143502738"></p></li><li><p>修改pom.xml，刚刚导入的 module 的父工程坐标还是以前的，需要改成我们自己的 project：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104143833323.png" alt="image-20221104143833323"></p></li><li><p>最终效果：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104143858373.png" alt="image-20221104143858373"></p></li></ol><h4 id="导入Web类型模块"><a href="#导入Web类型模块" class="headerlink" title="导入Web类型模块"></a>导入Web类型模块</h4><ul><li><p>其它操作和上面演示的都一样，只是多一步：删除多余的、不正确的 web.xml 设置。如下图所示：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104143952837.png" alt="image-20221104143952837"></p></li></ul><h1 id="其他核心概念"><a href="#其他核心概念" class="headerlink" title="其他核心概念"></a>其他核心概念</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul><li>为了让构建过程自动化完成，Maven 设定了<strong>三个生命周期</strong>，<strong>生命周期中的每一个环节对应构建过程中的一个操作</strong>。</li></ul><h3 id="三个生命周期"><a href="#三个生命周期" class="headerlink" title="三个生命周期"></a>三个生命周期</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104144831599.png" alt="image-20221104144831599"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>前面<strong>三个生命周期彼此是独立的</strong>。</li><li><strong>在任何一个生命周期内部，执行任何一个具体环节的操作，都是从本周期最初的位置开始执行，直到指定的地方</strong>。（本节记住这句话就行了，其他的都不需要记）</li><li>Maven 之所以这么设计其实就是<strong>为了提高构建过程的自动化程度</strong>：让使用者只关心最终要干的即可，过程中的各个环节是自动执行的。</li></ul><h2 id="插件和目标"><a href="#插件和目标" class="headerlink" title="插件和目标"></a>插件和目标</h2><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul><li>Maven 的<strong>核心程序仅仅负责宏观调度，不做具体工作</strong>。<strong>具体工作都是由 Maven 插件完成的</strong>。例如：编译就是由 maven-compiler-plugin-3.1.jar 插件来执行的。</li></ul><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li><strong>一个插件可以对应多个目标，而每一个目标都和生命周期中的某一个环节对应</strong>。</li><li>Default 生命周期中有 compile 和 test-compile 两个和编译相关的环节，这两个环节对应 compile 和 test-compile 两个目标，而这两个目标都是由 maven-compiler-plugin-3.1.jar 插件来执行的。</li></ul><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><ul><li><p><strong>本地仓库</strong>：在当前电脑上，为电脑上所有 Maven 工程服务</p></li><li><p><strong>远程仓库</strong>：需要联网</p><ul><li>局域网：我们自己搭建的 Maven 私服，例如使用 Nexus 技术。</li><li>Internet：<ul><li>中央仓库</li><li>镜像仓库：内容和中央仓库保持一致，但是能够分担中央仓库的负载，同时让用户能够就近访问提高下载速度，例如：Nexus aliyun</li></ul></li></ul></li><li><p>建议：<strong>不要中央仓库和阿里云镜像混用，否则 jar 包来源不纯，彼此冲突</strong>。</p></li><li><p>专门搜索 Maven 依赖信息的网站：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;为什么要学习Maven？&quot;&gt;&lt;a href=&quot;#为什么要学习Maven？&quot; class=&quot;headerlink&quot; title=&quot;为什么要学习Maven？&quot;&gt;&lt;/a&gt;为什么</summary>
      
    
    
    
    
    <category term="Maven" scheme="https://konjacor.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ入门</title>
    <link href="https://konjacor.github.io/2022/10/28/RabbitMQ%E5%85%A5%E9%97%A8/"/>
    <id>https://konjacor.github.io/2022/10/28/RabbitMQ%E5%85%A5%E9%97%A8/</id>
    <published>2022-10-28T01:29:59.000Z</published>
    <updated>2022-12-20T12:11:43.199Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="MQ的相关概念"><a href="#MQ的相关概念" class="headerlink" title="MQ的相关概念"></a>MQ的相关概念</h1><h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h2><ul><li>MQ(message queue)，从字面意思上看，<strong>本质是个队列，FIFO 先入先出</strong>，只不过队列中存放的内容是message 而已，还<strong>是一种跨进程的通信机制，用于上下游传递消息</strong>。在互联网架构中，MQ 是一种非常常见的<strong>上下游“逻辑解耦+物理解耦”的消息通信服务</strong>。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。</li></ul><h2 id="为什么要用MQ"><a href="#为什么要用MQ" class="headerlink" title="为什么要用MQ"></a>为什么要用MQ</h2><h3 id="流量削-消-峰"><a href="#流量削-消-峰" class="headerlink" title="流量削(消)峰"></a>流量削(消)峰</h3><ul><li>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。<strong>使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好</strong>。</li></ul><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><ul><li><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，<strong>如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常</strong>。当<strong>转变成基于消息队列的方式后，系统间调用的问题会减少很多</strong>，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统<strong>要处理的内容被缓存在消息队列中</strong>，用户的下单操作可以正常完成。当物流<strong>系统恢复后，继续处理订单信息</strong>即可，下单用户感受不到物流系统的故障，<strong>提升系统的可用性</strong>。</p></li><li><p>引入消息队列后系统的结构：<img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221028095447013.png" alt="image-20221028095447013"></p></li></ul><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><ul><li><p><strong>有些服务间调用是异步的</strong>，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，<strong>使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务</strong>。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p></li><li><p>加入消息队列后的异步消息处理：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221028100044425.png" alt="image-20221028100044425"></p></li></ul><h2 id="MQ的分类"><a href="#MQ的分类" class="headerlink" title="MQ的分类"></a>MQ的分类</h2><h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><ul><li><strong>优点</strong>：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据。</li><li><strong>缺点</strong>：官方社区现在对 ActiveMQ 5.x <strong>维护越来越少，高吞吐量场景较少使用</strong>。</li></ul><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><ul><li>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款<strong>为大数据而生的消息中间件</strong>，以其<strong>百万级</strong> <strong>TPS</strong> 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</li><li><strong>优点</strong>: 性能卓越，单机写入 TPS 约在百万条&#x2F;秒，最大的优点，就是<strong>吞吐量高</strong>。时效性 ms 级可用性非常高，<strong>kafka 是分布式的</strong>，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;<strong>有优秀的第三方Kafka Web 管理界面 Kafka-Manager</strong>；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能较为简单，主要支持简单的 MQ 功能，<strong>在大数据领域的实时计算以及日志采集被大规模使用</strong>。</li><li><strong>缺点</strong>：Kafka 单机超过 64 个队列&#x2F;分区，Load（负载）会发生明显的飙高现象，<strong>队列越多，load 越高，发送消息响应时间变长</strong>，<strong>使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试</strong>；<strong>支持消息顺序，但是一台代理宕机后，就会产生消息乱序</strong>，<strong>社区更新较慢</strong>；</li></ul><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><ul><li>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。‘</li><li><strong>优点</strong>：<strong>单机吞吐量十万级</strong>,可用性非常高，分布式架构,<strong>消息可以做到</strong> <strong>0</strong> <strong>丢失</strong>,MQ 功能较为完善，还是<strong>分布式的，扩展性好</strong>,<strong>支持</strong> <strong>10</strong> <strong>亿级别的消息堆积</strong>，不会因为堆积导致性能下降,源码是 java 我们可以自己阅读源码，定制自己公司的 MQ。</li><li><strong>缺点</strong>：<strong>支持的客户端语言不多</strong>，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在 MQ核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码。</li></ul><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><ul><li>2007 年发布，是一个<strong>在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统</strong>，是<strong>当前最主流的消息中间件之一</strong>。</li><li><strong>优点</strong>：由于 erlang 语言的<strong>高并发特性</strong>，性能较好；<strong>吞吐量到万级</strong>，MQ 功能比较完备,健壮、稳定、易用、跨平台、<strong>支持多种语言</strong> 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持 AJAX 文档齐全；<strong>开源提供的管理界面非常棒</strong>，用起来很好用,<strong>社区活跃度高</strong>；<strong>更新频率相当高</strong>。</li><li><strong>缺点</strong>：商业版需要收费,学习成本较高。</li></ul><h2 id="MQ的选择"><a href="#MQ的选择" class="headerlink" title="MQ的选择"></a>MQ的选择</h2><h3 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h3><ul><li>Kafka 主要特点是<strong>基于 Pull 的模式来处理消息消费，追求高吞吐量</strong>，一开始的目的就是用于日志收集和传输，<strong>适合产生大量数据的互联网服务的数据收集业务</strong>。<strong>大型公司建议可以选用</strong>，如果<strong>有日志采集功能，肯定是首选 kafka</strong>了。</li></ul><h3 id="RocketMQ-1"><a href="#RocketMQ-1" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><ul><li>天生<strong>为金融互联网领域而生</strong>，对于<strong>可靠性要求很高的场景</strong>，尤其是<strong>电商里面的订单扣款，以及业务削峰</strong>，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</li></ul><h3 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><ul><li>结合 <strong>erlang 语言本身的并发优势</strong>，性能好<strong>时效性微秒级</strong>，<strong>社区活跃度也比较高</strong>，<strong>管理界面用起来十分方便</strong>，如果你的<strong>数据量没有那么大</strong>，中小型公司优先选择功能比较完备的 RabbitMQ。</li></ul><h1 id="RabbitMQ-2"><a href="#RabbitMQ-2" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="RabbitMQ的概念"><a href="#RabbitMQ的概念" class="headerlink" title="RabbitMQ的概念"></a>RabbitMQ的概念</h2><ul><li>RabbitMQ 是一个消息中间件：它<strong>接受并转发消息</strong>。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑<strong>RabbitMQ 是一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据</strong>。</li></ul><h2 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><ul><li>产生数据发送消息的程序是生产者。</li></ul><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><ul><li>交换机是 RabbitMQ 非常重要的一个部件，一方面<strong>它接收来自生产者的消息，另一方面它将消息推送到队列中</strong>。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得由交换机类型决定。</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>队列是 RabbitMQ 内部使用的一种数据结构，<strong>尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中</strong>。队列仅受主机的内存和磁盘限制的约束，<strong>本质上是一个大的消息缓冲区</strong>。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式。</li></ul><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><ul><li>消费与接收具有相似的含义。<strong>消费者大多时候是一个等待接收消息的程序</strong>。请注意<strong>生产者，消费者和消息中间件很多时候并不在同一机器上</strong>。同一个应用程序既可以是生产者又是可以是消费者。</li></ul><h2 id="RabbitMQ核心部分"><a href="#RabbitMQ核心部分" class="headerlink" title="RabbitMQ核心部分"></a>RabbitMQ核心部分</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029093156586.png" alt="image-20221029093156586"></p><ol><li>“Hello World”：消息队列的简单使用</li><li>Work queues：工作队列</li><li>Publish&#x2F;Subscribe：消息的发布订阅</li><li>Routing：不同的路由方式</li><li>Topics：主题路由</li><li>Publisher Confirms：消息的发布确认</li></ol><h2 id="相关名词介绍"><a href="#相关名词介绍" class="headerlink" title="相关名词介绍"></a>相关名词介绍</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029093829448.png" alt="image-20221029093829448"></p><ul><li><strong>Broker（代理）</strong>：<strong>接收和分发消息的应用</strong>，RabbitMQ Server 就是 Message Broker。</li><li><strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP（协议）的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。<strong>当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</strong>。</li><li><strong>Connection</strong>：<strong>publisher／consumer 和 broker 之间的 TCP 连接</strong>。</li><li><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。<strong>Channel 是在 connection 内部建立的逻辑连接</strong>，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的Connection极大减少了操作系统建立TCP connection的开销</strong>。</li><li><strong>Exchange</strong>：message 到达 broker 的第一站，<strong>根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去</strong>。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</li><li><strong>Queue</strong>：<strong>消息最终被送到这里等待 consumer 取走</strong>。</li><li><strong>Binding</strong>：<strong>exchange 和 queue 之间的虚拟连接</strong>，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h3><ul><li><a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a></li></ul><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><ul><li><p>下载到&#x2F;usr&#x2F;local&#x2F;software 目录下(如果没有 software 需要自己创建)</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029100246651.png" alt="image-20221029100246651"></p></li></ul><h3 id="安装文件-分别按照以下顺序安装"><a href="#安装文件-分别按照以下顺序安装" class="headerlink" title="安装文件(分别按照以下顺序安装)"></a>安装文件(分别按照以下顺序安装)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh erlang-21.3-1.el7.x86_64.rpm</span><br><span class="line">yum install socat -y</span><br><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><h3 id="常用命令（按照以下顺序执行）"><a href="#常用命令（按照以下顺序执行）" class="headerlink" title="常用命令（按照以下顺序执行）"></a>常用命令（按照以下顺序执行）</h3><ul><li><p>添加开机启动RabbitMQ服务：<strong>chkconfig rabbitmq-server on</strong></p></li><li><p>启动服务：**&#x2F;sbin&#x2F;service rabbitmq-server start**</p></li><li><p>查看服务状态：**&#x2F;sbin&#x2F;service rabbitmq-server status**</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029100508454.png" alt="image-20221029100508454"></p></li><li><p>停止服务（选择执行）：**&#x2F;sbin&#x2F;service rabbitmq-server stop**</p></li><li><p>开启web管理插件：<strong>rabbitmq-plugins enable rabbitmq_management</strong></p></li><li><p>用默认账号密码(guest)访问地址<a href="http://47.115.185.244:15672/%E5%87%BA%E7%8E%B0%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%EF%BC%9A">http://47.115.185.244:15672/出现权限问题：</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029100645974.png" alt="image-20221029100645974"></p></li></ul><h3 id="添加一个新的用户"><a href="#添加一个新的用户" class="headerlink" title="添加一个新的用户"></a>添加一个新的用户</h3><ul><li><p>创建帐号：<strong>rabbitmqctl add_user admin 123</strong></p></li><li><p>设置用户角色：<strong>rabbitmqctl set_user_tags admin administrator</strong></p></li><li><p>设置用户权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span><br><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">用户 user_admin 具有/vhost1 这个 virtual host 中所有资源的配置、写、读权限当前用户和角色</span><br><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure></li></ul><h3 id="再次利用admin用户登录"><a href="#再次利用admin用户登录" class="headerlink" title="再次利用admin用户登录"></a>再次利用admin用户登录</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029100915001.png" alt="image-20221029100915001"></p><h3 id="重置命令"><a href="#重置命令" class="headerlink" title="重置命令"></a>重置命令</h3><ul><li>关闭应用的命令为：<strong>rabbitmqctl stop_app</strong></li><li>清除的命令为：<strong>rabbitmqctl reset</strong></li><li>重新启动命令为：<strong>rabbitmqctl start_app</strong></li></ul><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><ul><li><p>在这一部分中，我们将用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者。我们将介绍 Java API 中的一些细节。</p></li><li><p>在下图中，“P”是我们的生产者，“C”是我们的消费者。中间的框是一个队列-RabbitMQ代表使用者保留的消息缓冲区。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221030093742819.png" alt="image-20221030093742819"></p></li></ul><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定 jdk 编译版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--rabbitmq 依赖客户端--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--操作文件流的一个依赖--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//创建一个连接工厂</span></span><br><span class="line"> <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"> factory.setHost(<span class="string">&quot;182.92.234.71&quot;</span>);</span><br><span class="line"> factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"> factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"> <span class="comment">//channel 实现了自动 close 接口 自动关闭 不需要显示关闭</span></span><br><span class="line"> <span class="keyword">try</span>(<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;<span class="comment">//从factory中获得connection，再从connection中获得channel</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 生成一个队列</span></span><br><span class="line"><span class="comment">  * 1.队列名称</span></span><br><span class="line"><span class="comment">  * 2.队列里面的消息是否持久化 默认消息存储在内存中</span></span><br><span class="line"><span class="comment">  * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费</span></span><br><span class="line"><span class="comment">  * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除</span></span><br><span class="line"><span class="comment">  * 5.其他参数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);<span class="comment">//声明队列</span></span><br><span class="line"> String message=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 发送一个消息</span></span><br><span class="line"><span class="comment">  * 1.发送到那个交换机</span></span><br><span class="line"><span class="comment">  * 2.路由的 key 是哪个</span></span><br><span class="line"><span class="comment">  * 3.其他的参数信息</span></span><br><span class="line"><span class="comment">  * 4.发送消息的消息体</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());<span class="comment">//由于没有设置交换机，所以消息发布到队列中</span></span><br><span class="line">System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"> factory.setHost(<span class="string">&quot;182.92.234.71&quot;</span>);</span><br><span class="line"> factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"> factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"> System.out.println(<span class="string">&quot;等待接收消息....&quot;</span>);</span><br><span class="line"> <span class="comment">//推送的消息如何进行消费的接口回调</span></span><br><span class="line"> DeliverCallback deliverCallback=(consumerTag,delivery)-&gt;&#123;</span><br><span class="line"> String message= <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line"> System.out.println(message);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span></span><br><span class="line"> CancelCallback cancelCallback=(consumerTag)-&gt;&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 消费者消费消息</span></span><br><span class="line"><span class="comment">  * 1.消费哪个队列</span></span><br><span class="line"><span class="comment">  * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答</span></span><br><span class="line"><span class="comment">  * 3.消费者未成功消费的回调</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);<span class="comment">//从队列中消费消息</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h1><ul><li><p>工作队列(又称任务队列)的主要思想是<strong>避免立即执行资源密集型任务</strong>，而不得不等待它完成。</p><p>相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进</p><p>程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p></li></ul><h2 id="轮询分发消息"><a href="#轮询分发消息" class="headerlink" title="轮询分发消息"></a>轮询分发消息</h2><ul><li><p>在这个案例中我们会启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程</p><p>是如何工作的。</p></li></ul><h3 id="抽取工具类"><a href="#抽取工具类" class="headerlink" title="抽取工具类"></a>抽取工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqUtils</span> &#123;</span><br><span class="line"> <span class="comment">//得到一个连接的 channel</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"> <span class="comment">//创建一个连接工厂</span></span><br><span class="line"> <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"> factory.setHost(<span class="string">&quot;182.92.234.71&quot;</span>);</span><br><span class="line"> factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"> factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"> <span class="keyword">return</span> channel;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动两个工作线程"><a href="#启动两个工作线程" class="headerlink" title="启动两个工作线程"></a>启动两个工作线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker01</span> &#123;<span class="comment">//改个文本再开第二个线程比较有辨识度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">DeliverCallback deliverCallback=(consumerTag,delivery)-&gt;&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">System.out.println(<span class="string">&quot;接收到消息:&quot;</span>+receivedMessage);</span><br><span class="line">&#125;;</span><br><span class="line">CancelCallback cancelCallback=(consumerTag)-&gt;&#123;</span><br><span class="line">System.out.println(consumerTag+<span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;C2 消费者启动等待消费......&quot;</span>);</span><br><span class="line">channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221030230515903.png" alt="image-20221030230515903"></p><h3 id="启动一个发送线程"><a href="#启动一个发送线程" class="headerlink" title="启动一个发送线程"></a>启动一个发送线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task01</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="keyword">try</span>(Channel channel=RabbitMqUtils.getChannel();) &#123;</span><br><span class="line"> channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"> <span class="comment">//从控制台当中接受信息</span></span><br><span class="line"> <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"> <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line"> channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line"> System.out.println(<span class="string">&quot;发送消息完成:&quot;</span>+message);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><ul><li><p>通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221030230922398.png" alt="image-20221030230922398"></p></li></ul><h2 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。<strong>默认情况下RabbitMQ一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息，以及后续发送给该消费者的消息</strong>，因为它无法接收到。</li><li>为了保证消息在发送过程中不丢失，rabbitmq引入<strong>消息应答机制</strong>，消息应答就是：<strong>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong></li></ul><h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><ul><li><strong>消息发送后立即被认为已经传送成功</strong>，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面<strong>这种模式消费者那边可以传递过载的消息（因为传过去就马上确认，就可以马上传下一个了），没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压</strong>，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以<strong>这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用</strong>。</li></ul><h3 id="手动消息应答的方法"><a href="#手动消息应答的方法" class="headerlink" title="手动消息应答的方法"></a>手动消息应答的方法</h3><ul><li>**Channel.basicAck(args)**：用于肯定确认，RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了。</li><li>**Channel.basicNack()**：用于否定确认。</li><li>**Channel.basicReject()**：用于否定确认，与 Channel.basicNack 相比少一个参数，不处理该消息了直接拒绝，可以将其丢弃了</li></ul><h3 id="手动应答方法参数Multiple的解释"><a href="#手动应答方法参数Multiple的解释" class="headerlink" title="手动应答方法参数Multiple的解释"></a>手动应答方法参数Multiple的解释</h3><ul><li><p>手动应答的好处是<strong>可以批量应答并且减少网络拥堵</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031090701521.png" alt="image-20221031090701521"></p></li><li><p>multiple的true和false代表不同的意思：</p><ul><li><p>true代表<strong>批量应答channel上未应答的消息</strong>。比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031091013530.png" alt="image-20221031091013530"></p></li><li><p>false同上面相比，只会应答tag&#x3D;8的消息，5，6，7这三个消息依然不会被确认收到消息应答</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031091025972.png" alt="image-20221031091025972"></p></li></ul></li></ul><h3 id="消息自动重新入队"><a href="#消息自动重新入队" class="headerlink" title="消息自动重新入队"></a>消息自动重新入队</h3><ul><li><p>如果消费者由于某些原因失去连接（其通道已关闭，连接已关闭或TCP连接丢失），导致<strong>消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将对其重新排队</strong>。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031091402285.png" alt="image-20221031091402285"></p></li></ul><h3 id="消息手动应答代码"><a href="#消息手动应答代码" class="headerlink" title="消息手动应答代码"></a>消息手动应答代码</h3><ul><li><p>默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答，消费者在上面代码的基础上增加下面画红色部分代码。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031091631480.png" alt="image-20221031091631480"></p></li><li><p>消息生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task02</span> &#123;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line"> channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"> <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"> System.out.println(<span class="string">&quot;请输入信息&quot;</span>);</span><br><span class="line"> <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"> channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"> System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者01：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work03</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACK_QUEUE_NAME=<span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"> System.out.println(<span class="string">&quot;C1 等待接收消息处理时间较短&quot;</span>);</span><br><span class="line"><span class="comment">//消息消费的时候如何处理消息</span></span><br><span class="line"> DeliverCallback deliverCallback=(consumerTag,delivery)-&gt;&#123;</span><br><span class="line"> String message= <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line"> SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;接收到消息:&quot;</span>+message);</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 1.消息标记 tag</span></span><br><span class="line"><span class="comment">  * 2.是否批量应答未应答消息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">//采用手动应答</span></span><br><span class="line"> <span class="type">boolean</span> autoAck=<span class="literal">false</span>;</span><br><span class="line"> channel.basicConsume(ACK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag)-&gt;&#123;</span><br><span class="line"> System.out.println(consumerTag+<span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者02：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work04</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACK_QUEUE_NAME=<span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"> System.out.println(<span class="string">&quot;C2 等待接收消息处理时间较长&quot;</span>);</span><br><span class="line"> <span class="comment">//消息消费的时候如何处理消息</span></span><br><span class="line"> DeliverCallback deliverCallback=(consumerTag,delivery)-&gt;&#123;</span><br><span class="line"> String message= <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line"> SleepUtils.sleep(<span class="number">30</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;接收到消息:&quot;</span>+message);</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 1.消息标记 tag</span></span><br><span class="line"><span class="comment">  * 2.是否批量应答未应答消息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">//采用手动应答</span></span><br><span class="line"> <span class="type">boolean</span> autoAck=<span class="literal">false</span>;</span><br><span class="line"> channel.basicConsume(ACK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag)-&gt;&#123;</span><br><span class="line"> System.out.println(consumerTag+<span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="手动应答效果演示"><a href="#手动应答效果演示" class="headerlink" title="手动应答效果演示"></a>手动应答效果演示</h3><ul><li><p>正常情况下消息发送方发送两个消息，C1和C2分别接收到消息并进行处理：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031092726539.png" alt="image-20221031092726539"></p></li><li><p>在发送者发送消息 dd，发出消息之后把 C2 消费者停掉，按理说该 C2 来处理该消息，但是由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了，此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031092917687.png" alt="image-20221031092917687"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031092931800.png" alt="image-20221031092931800"></p></li></ul><h2 id="RabbitMQ持久化"><a href="#RabbitMQ持久化" class="headerlink" title="RabbitMQ持久化"></a>RabbitMQ持久化</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>刚刚我们已经看到了如何处理任务不丢失的情况，但是如何保障当 RabbitMQ 服务停掉以后消息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化</strong>。</li></ul><h3 id="队列如何实现持久化"><a href="#队列如何实现持久化" class="headerlink" title="队列如何实现持久化"></a>队列如何实现持久化</h3><ul><li><p>之前我们创建的队列都是非持久化的，rabbitmq 如果重启的话，该队列就会被删除掉，如果要队列实现持久化 需要<strong>在声明队列的时候把durable参数设置为true</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031093551216.png" alt="image-20221031093551216"></p></li><li><p>但是需要注意的就是<strong>如果之前声明的队列不是持久化的，需要把原先的队列先删除，或者重新创建一个持久化的队列，不然就会出现错误</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031093753906.png" alt="image-20221031093753906"></p></li><li><p>以下为控制台中持久化与非持久化队列的UI显示区：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031093845725.png" alt="image-20221031093845725"></p></li><li><p>将队列设置为持久化后，即使重启rabbitmq队列也依然存在。</p></li></ul><h3 id="消息实现持久化"><a href="#消息实现持久化" class="headerlink" title="消息实现持久化"></a>消息实现持久化</h3><ul><li><p>要想让消息实现持久化需要<strong>在消息生产者修改代码，添加MessageProperties.PERSISTENT_TEXT_PLAIN这个属性</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031094022385.png" alt="image-20221031094022385"></p></li><li><p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里<strong>依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点，此时并没有真正写入磁盘。持久性保证并不强</strong>，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果需要更强有力的持久化策略，参考后边课件发布确认章节。</p></li></ul><h3 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h3><ul><li><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮询分发，但是在某种场景下这种策略并不是很好，<strong>比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者2处理速度却很慢，这个时候我们还是采用轮询分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好</strong>，但是RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p></li><li><p>为了避免这种情况，我们可以<strong>设置参数channel.basicQos(1);</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031094452126.png" alt="image-20221031094452126"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031094517497.png" alt="image-20221031094517497"></p></li><li><p>意思就是<strong>如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我</strong>，我目前只能处理一个任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。</p></li></ul><h3 id="预取值"><a href="#预取值" class="headerlink" title="预取值"></a>预取值</h3><ul><li><p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以<strong>通过使用basic.qos 方法设置“预取计数”值</strong>来完成的。<strong>该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认</strong>，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的RAM消耗</strong>(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。<strong>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031095001072.png" alt="image-20221031095001072"></p></li></ul><h1 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h1><h2 id="发布确认原理"><a href="#发布确认原理" class="headerlink" title="发布确认原理"></a>发布确认原理</h2><ul><li>生产者将信道设置成 confirm 模式，<strong>一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出</strong>，broker 回传给生产者的确认消息中 <strong>delivery-tag 域包含了确认消息的序列号</strong>，此外broker 也可以<strong>设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理</strong>。</li><li>confirm 模式最大的好处在于<strong>他是异步的</strong>，一旦发布一条消息，<strong>生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息</strong>，如果<strong>RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息</strong>。</li></ul><h2 id="发布确认的策略"><a href="#发布确认的策略" class="headerlink" title="发布确认的策略"></a>发布确认的策略</h2><h3 id="开启发布确认的方法"><a href="#开启发布确认的方法" class="headerlink" title="开启发布确认的方法"></a>开启发布确认的方法</h3><ul><li><p>发布确认默认是没有开启的，如果<strong>要开启需要调用方法 confirmSelect</strong>，每当你要想使用发布确认，都需要在 channel 上调用该方法：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105092853970.png" alt="image-20221105092853970"></p></li></ul><h3 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h3><ul><li><p>这是一种简单的确认方式，它是一种<strong>同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布</strong>,<strong>waitForConfirmsOrDie(long)这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常</strong>。</p></li><li><p>这种确认方式有一个最大的缺点就是:<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageIndividually</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line"><span class="comment">//服务端返回 false 或超时时间内未返回，生产者可以消息重发</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个单独确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h3><ul><li><p>上面那种方式非常慢，与单个等待确认消息相比，<strong>先发布一批消息然后一起确认可以极大地提高吞吐量</strong>，当然这种方式的<strong>缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息</strong>。当然<strong>这种方案仍然是同步的，也一样阻塞消息的发布</strong>。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">//批量确认消息大小</span></span><br><span class="line"><span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">//未确认消息个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">outstandingMessageCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">outstandingMessageCount++;</span><br><span class="line"><span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class="line">channel.waitForConfirms();</span><br><span class="line">outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为了确保还有剩余没有确认消息 再次确认</span></span><br><span class="line"><span class="keyword">if</span> (outstandingMessageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">channel.waitForConfirms();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个批量确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h3><ul><li><p>异步确认虽然编程逻辑比上两个要复杂，但是<strong>性价比最高，无论是可靠性还是效率都没得说</strong>，他是<strong>利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功</strong>，下面就让我们来详细讲解异步确认是怎么实现的。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105094400729.png" alt="image-20221105094400729"></p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程安全有序的一个哈希表，适用于高并发的情况</span></span><br><span class="line"><span class="comment"> * 1.轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment"> * 2.轻松批量删除条目 只要给到序列号</span></span><br><span class="line"><span class="comment"> * 3.支持并发访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确认收到消息的一个回调</span></span><br><span class="line"><span class="comment"> * 1.消息序列号</span></span><br><span class="line"><span class="comment"> * 2.true 可以确认小于等于当前序列号的消息</span></span><br><span class="line"><span class="comment"> *  false 确认当前序列号消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (multiple) &#123;</span><br><span class="line"><span class="comment">//返回的是小于等于当前序列号的未确认消息 是一个 map</span></span><br><span class="line">ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outstandingConfirms.headMap(sequenceNumber, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//清除该部分未确认消息</span></span><br><span class="line">confirmed.clear();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//只清除当前序列号的消息</span></span><br><span class="line">outstandingConfirms.remove(sequenceNumber);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> outstandingConfirms.get(sequenceNumber);</span><br><span class="line">System.out.println(<span class="string">&quot;发布的消息&quot;</span>+message+<span class="string">&quot;未被确认，序列号&quot;</span>+sequenceNumber);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加一个异步确认的监听器</span></span><br><span class="line"><span class="comment"> * 1.确认收到消息的回调</span></span><br><span class="line"><span class="comment"> * 2.未收到消息的回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">channel.addConfirmListener(ackCallback, <span class="literal">null</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;消息&quot;</span> + i;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * channel.getNextPublishSeqNo() 获取下一个消息的序列号</span></span><br><span class="line"><span class="comment"> * 通过序列号与消息体进行一个关联</span></span><br><span class="line"><span class="comment"> * 全部都是未确认的消息体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个异步确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="如何处理异步未确认消息"><a href="#如何处理异步未确认消息" class="headerlink" title="如何处理异步未确认消息"></a>如何处理异步未确认消息</h3><ul><li>最好的解决的解决方案就是<strong>把未确认的消息放到一个基于内存的能被发布线程访问的队列</strong>，比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。</li></ul><h3 id="以上3种发布确认速度对比"><a href="#以上3种发布确认速度对比" class="headerlink" title="以上3种发布确认速度对比"></a>以上3种发布确认速度对比</h3><ul><li><p><strong>单独发布消息</strong>：同步等待确认，简单，但吞吐量非常有限。</p></li><li><p><strong>批量发布消息</strong>：批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。</p></li><li><p><strong>异步处理</strong>：最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些。</p></li><li><p>三种方式的确认速度对比：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105095710510.png" alt="image-20221105095710510"></p></li></ul><h1 id="交换机-1"><a href="#交换机-1" class="headerlink" title="交换机"></a>交换机</h1><ul><li>在上一节中，我们创建了一个工作队列。我们<strong>假设的是工作队列背后，每个任务都恰好交付给一个消费者(工作进程)<strong>。在这一部分中，我们将做一些完全不同的事情-我们</strong>将消息传达给多个消费者。这种模式称为 ”发布&#x2F;订阅”</strong>。</li><li>为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者</li></ul><h2 id="Exchange简介"><a href="#Exchange简介" class="headerlink" title="Exchange简介"></a>Exchange简介</h2><h3 id="Exchanges概念"><a href="#Exchanges概念" class="headerlink" title="Exchanges概念"></a>Exchanges概念</h3><ul><li><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中</strong>。</p></li><li><p>相反，<strong>生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列</strong>。<strong>交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116093140914.png" alt="image-20221116093140914"></p></li></ul><h3 id="Exchanges的类型"><a href="#Exchanges的类型" class="headerlink" title="Exchanges的类型"></a>Exchanges的类型</h3><ul><li>目前总共有以下类型：**直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)**。</li></ul><h3 id="无名exchange"><a href="#无名exchange" class="headerlink" title="无名exchange"></a>无名exchange</h3><ul><li><p>在前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="literal">null</span>,message.getBytes());</span><br></pre></td></tr></table></figure></li><li><p>第一个参数是交换机的名称。<strong>空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey)绑定 key 指定的</strong>，如果它存在的话.</p></li></ul><h2 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h2><ul><li><p>之前的部分我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。<strong>队列的名称我们来说至关重要-我们需要指定我们的消费者去消费哪个队列的消息</strong>。</p></li><li><p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们<strong>可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了</strong>。其次<strong>一旦我们断开了消费者的连接，临时队列将被自动删除</strong>。</p></li><li><p>创建临时队列的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure></li><li><p>创建出来之后长这样儿：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116093814696.png" alt="image-20221116093814696"></p></li></ul><h2 id="绑定（bindings）"><a href="#绑定（bindings）" class="headerlink" title="绑定（bindings）"></a>绑定（bindings）</h2><ul><li><p>什么是 bingding 呢，<strong>binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系</strong>。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116093917802.png" alt="image-20221116093917802"></p></li></ul><h2 id="Fanout-Exchange-扇出交换机"><a href="#Fanout-Exchange-扇出交换机" class="headerlink" title="Fanout Exchange(扇出交换机)"></a>Fanout Exchange(扇出交换机)</h2><h3 id="Fanout介绍"><a href="#Fanout介绍" class="headerlink" title="Fanout介绍"></a>Fanout介绍</h3><ul><li><p>Fanout这种类型非常简单。正如从名称中猜到的那样，<strong>它是将接收到的所有消息广播到它知道的所有队列中</strong>。系统中某些exchange的默认类型：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116094214448.png" alt="image-20221116094214448"></p></li></ul><h3 id="Fanout实战"><a href="#Fanout实战" class="headerlink" title="Fanout实战"></a>Fanout实战</h3><ul><li><p>准备实现以下结构：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116094408254.png" alt="image-20221116094408254"></p></li><li><p>Logs和临时队列的绑定关系如下图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116094434664.png" alt="image-20221116094434664"></p></li><li><p>ReceiveLogs01 将接收到的消息打印在控制台：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs01</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成一个临时的队列 队列的名称是随机的</span></span><br><span class="line"><span class="comment"> * 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串</span></span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收消息,把接收到的消息打印在屏幕.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;控制台打印接收到的消息&quot;</span>+message);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ReceiveLogs02 将接收到的消息存储在磁盘：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs02</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成一个临时的队列 队列的名称是随机的</span></span><br><span class="line"><span class="comment"> * 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//把该临时队列绑定我们的 exchange其中 routingkey(也称之为 binding key)为空字符串</span></span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收消息,把接收到的消息写到文件.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\work\\rabbitmq_info.txt&quot;</span>);</span><br><span class="line">FileUtils.writeStringToFile(file,message,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;数据写入文件成功&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>EmitLog 发送消息给两个消费者接收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLog</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel()) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明一个 exchange</span></span><br><span class="line"><span class="comment"> * 1.exchange 的名称</span></span><br><span class="line"><span class="comment"> * 2.exchange 的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入信息&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Direct-Exchange-直接交换机"><a href="#Direct-Exchange-直接交换机" class="headerlink" title="Direct Exchange(直接交换机)"></a>Direct Exchange(直接交换机)</h2><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><ul><li>在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能-比方说<strong>我们只让某个消费者订阅发布的部分消息</strong>。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。</li><li>我们再次来回顾一下什么是 bindings，<strong>绑定是交换机和队列之间的桥梁关系</strong>。也可以这么理解：<strong>队列只对它绑定的交换机的消息感兴趣</strong>。</li><li>绑定用参数：routingKey 来表示也可称该参数为 binding key，<strong>创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);<strong>，</strong>绑定之后的意义由其交换类型决定，交换类型由交换机决定</strong>。</li></ul><h3 id="Direct-Exchange介绍"><a href="#Direct-Exchange介绍" class="headerlink" title="Direct Exchange介绍"></a>Direct Exchange介绍</h3><ul><li><p>上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志消息避免浪费磁盘空间。<strong>Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的广播</strong>，在这里我们将<strong>使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的routingKey 队列中去</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116095810639.png" alt="image-20221116095810639"></p></li><li><p>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列 Q1 绑定键为 orange，队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green。</p></li><li><p>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p></li></ul><h3 id="多重绑定"><a href="#多重绑定" class="headerlink" title="多重绑定"></a>多重绑定</h3><ul><li><p><strong>同一个routingKey可以和多个队列进行绑定</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116100026526.png" alt="image-20221116100026526"></p></li><li><p>当然如果 exchange 的绑定类型是 direct，但是它绑定的多个队列的 key 如果都相同，在这种情况下虽然绑定类型是 direct 但是它表现的就和 fanout 有点类似了，就跟广播差不多，如上图所示。</p></li></ul><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><ul><li><p>准备实现以下结构，通过不同的routingKey给日志区分级别并由不同的消费者进行处理（或没有消费者处理，直接丢弃）。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116100257537.png" alt="image-20221116100257537"></p></li><li><p>交换机的绑定关系如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116100330363.png" alt="image-20221116100330363"></p></li><li><p>消费者1接收错误日志并将其存储到磁盘中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect01</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;disk&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">message=<span class="string">&quot;接收绑定键:&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="string">&quot;,消息:&quot;</span>+message;</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\work\\rabbitmq_info.txt&quot;</span>);</span><br><span class="line">FileUtils.writeStringToFile(file,message,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;错误日志已经接收&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者2接收info和warning级别的日志并输出到终端上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect02</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;console&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot; 接 收 绑 定 键 :&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="string">&quot;, 消息:&quot;</span>+message);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生产者发送消息到直接交换机中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLogDirect</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel()) &#123;</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="comment">//创建多个 bindingKey</span></span><br><span class="line">Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;info&quot;</span>,<span class="string">&quot;普通 info 信息&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;warning&quot;</span>,<span class="string">&quot;警告 warning 信息&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;error&quot;</span>,<span class="string">&quot;错误 error 信息&quot;</span>);</span><br><span class="line"><span class="comment">//debug 没有消费这接收这个消息 所有就丢失了</span></span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;debug&quot;</span>,<span class="string">&quot;调试 debug 信息&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry: bindingKeyMap.entrySet())&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">bindingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME,bindingKey, <span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;生产者发出消息:&quot;</span> + message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Topic-Exchange-主题交换机"><a href="#Topic-Exchange-主题交换机" class="headerlink" title="Topic Exchange(主题交换机)"></a>Topic Exchange(主题交换机)</h2><h3 id="之前类型的交换机存在的问题"><a href="#之前类型的交换机存在的问题" class="headerlink" title="之前类型的交换机存在的问题"></a>之前类型的交换机存在的问题</h3><ul><li>在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。</li><li>尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候 direct 就办不到了。这个时候就只能使用 topic 类型。</li></ul><h3 id="Topic-Exchange的要求"><a href="#Topic-Exchange的要求" class="headerlink" title="Topic Exchange的要求"></a>Topic Exchange的要求</h3><ul><li>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它<strong>必须是一个单词列表，以点号分隔开</strong>。这些单词可以是任意单词，比如说：”stock.usd.nyse”, “nyse.vmw”,”quick.orange.rabbit”.这种类型的。当然<strong>这个单词列表最多不能超过 255 个字节</strong>。</li><li>在这个规则列表中，其中有两个替换符是大家需要注意的：<ol><li>***(星号)可以代替一个单词**</li><li><strong>#(井号)可以替代零个或多个单词</strong></li></ol></li><li>之后<strong>主题交换机就通过结合了单词列表和替换符的routingKey进行路由</strong>。</li></ul><h3 id="Topic-Exchange匹配案例"><a href="#Topic-Exchange匹配案例" class="headerlink" title="Topic Exchange匹配案例"></a>Topic Exchange匹配案例</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116103116297.png" alt="image-20221116103116297"></p><ul><li>上图的绑定关系如下：<ul><li>Q1–&gt;绑定的是中间带 orange 带 3 个单词的字符串(*.orange.*)</li><li>Q2–&gt;绑定的是最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)和第一个单词是 lazy 的多个单词(lazy.#)</li></ul></li><li>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的：<ul><li>quick.orange.rabbit 被队列 Q1Q2 接收到</li><li>lazy.orange.elephant 被队列 Q1Q2 接收到</li><li>quick.orange.fox 被队列 Q1 接收到</li><li>lazy.brown.fox 被队列 Q2 接收到</li><li>lazy.pink.rabbit 虽然满足两个绑定但只被队列 Q2 接收一次</li><li>quick.brown.fox 不匹配任何绑定不会被任何队列接收到会被丢弃</li><li>quick.orange.male.rabbit 是四个单词不匹配任何绑定会被丢弃</li><li>lazy.orange.male.rabbit 是四个单词但匹配 Q2</li></ul></li><li>当队列绑定关系是下列这种情况时需要引起注意：<ul><li><strong>当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像 fanout 了</strong></li><li><strong>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了</strong></li></ul></li></ul><h3 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h3><ul><li><p>交换机的绑定关系如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116103417491.png" alt="image-20221116103417491"></p></li><li><p>生产者发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLogTopic</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel()) &#123;</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Q1--&gt;绑定的是中间带 orange带3个单词的字符串(*.orange.*)</span></span><br><span class="line"><span class="comment"> * Q2--&gt;绑定的是最后一个单词是 rabbit的 3个单词(*.*.rabbit)和第一个单词是 lazy的多个单词(lazy.#)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;quick.orange.rabbit&quot;</span>,<span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;lazy.orange.elephant&quot;</span>,<span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;quick.orange.fox&quot;</span>,<span class="string">&quot;被队列 Q1 接收到&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;lazy.brown.fox&quot;</span>,<span class="string">&quot;被队列 Q2 接收到&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;lazy.pink.rabbit&quot;</span>,<span class="string">&quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;quick.brown.fox&quot;</span>,<span class="string">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;quick.orange.male.rabbit&quot;</span>,<span class="string">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;lazy.orange.male.rabbit&quot;</span>,<span class="string">&quot;是四个单词但匹配 Q2&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry: bindingKeyMap.entrySet())&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">bindingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME,bindingKey, <span class="literal">null</span>,</span><br><span class="line">message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic01</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"><span class="comment">//声明 Q1队列与绑定关系</span></span><br><span class="line">String queueName=<span class="string">&quot;Q1&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot; 接 收 队 列 :&quot;</span>+queueName+<span class="string">&quot; 绑 定键:&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="string">&quot;,消息:&quot;</span>+message);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic02</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"><span class="comment">//声明 Q2队列与绑定关系</span></span><br><span class="line">String queueName=<span class="string">&quot;Q2&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot; 接 收 队 列 :&quot;</span>+queueName+<span class="string">&quot; 绑 定键:&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="string">&quot;,消息:&quot;</span>+message);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Header-Exchange-标题-x2F-首部交换机"><a href="#Header-Exchange-标题-x2F-首部交换机" class="headerlink" title="Header Exchange(标题&#x2F;首部交换机)"></a>Header Exchange(标题&#x2F;首部交换机)</h2><ul><li><strong>首部交换机是忽略<code>routing_key</code>的一种路由方式</strong>。路由器和交换机<strong>路由的规则是通过<code>Headers</code>信息来交换的</strong>，这个有点像<code>HTTP</code>的<code>Headers</code>。<strong>将一个交换机声明成首部交换机，绑定一个队列的时候，定义一个<code>Hash</code>的数据结构，消息发送的时候，会携带一组hash数据结构的信息，当<code>Hash</code>的内容匹配上的时候，消息就会被写入队列</strong>。</li><li>绑定交换机和队列的时候，Hash结构中要求携带一个键<strong>“x-match”</strong>，这个键的<code>Value</code>可以是<code>any</code>或者<code>all</code>，这代表消息携带的<code>Hash</code>是需要<strong>全部匹配</strong>(all)，还是<strong>仅匹配一个键</strong>(any)就可以了。**相比直连交换机，首部交换机的优势是匹配的规则不被限定为字符串(string)**。</li></ul><h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><h2 id="死信的概念"><a href="#死信的概念" class="headerlink" title="死信的概念"></a>死信的概念</h2><ul><li>先从概念解释上搞清楚这个定义，<strong>死信，顾名思义就是无法被消费的消息，字面意思可以这样理解</strong>，一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息进行消费，但<strong>某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列</strong>。</li><li>应用场景:<strong>为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中</strong>.还有比如说: <strong>用户在商城下单成功并点击去支付后在指定时间未支付时自动失效</strong>。</li></ul><h2 id="死信的来源"><a href="#死信的来源" class="headerlink" title="死信的来源"></a>死信的来源</h2><ol><li><strong>消息 TTL 过期</strong></li><li><strong>队列达到最大长度</strong>(队列满了，无法再添加数据到 mq 中)</li><li><strong>消息被拒绝(basic.reject 或 basic.nack)并且 requeue&#x3D;false</strong>.</li></ol><h2 id="死信实战"><a href="#死信实战" class="headerlink" title="死信实战"></a>死信实战</h2><h3 id="代码架构图"><a href="#代码架构图" class="headerlink" title="代码架构图"></a>代码架构图</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117110145349.png" alt="image-20221117110145349"></p><p>需要手动给队列配置它的死信队列。</p><h3 id="消息TTL过期造成的死信"><a href="#消息TTL过期造成的死信" class="headerlink" title="消息TTL过期造成的死信"></a>消息TTL过期造成的死信</h3><ul><li><p>主要是<strong>发送消息的时候给消息设置TTL时间，然后发送到队列中，将对应的消费者关闭以模拟消费者无法消费队列中的消息的场景，然后TTL到期后，相关消息就会被送到和当前队列绑定的死信队列中，被死信队列的消费者消费掉</strong>。</p></li><li><p>生产者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">channel.exchangeDeclare(NORMAL_EXCHANGE,BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="comment">//设置消息的 TTL时间</span></span><br><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">AMQP</span>.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line"><span class="comment">//该信息是用作演示队列个数限制</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">11</span> ; i++) &#123;</span><br><span class="line">String message=<span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, properties,message.getBytes());</span><br><span class="line">System.out.println(<span class="string">&quot;生产者发送消息:&quot;</span>+message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者C1代码（启动之后关闭该消费者，模拟其接收不到消息的情况）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line"><span class="comment">//普通交换机名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"><span class="comment">//死信交换机名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line"><span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="comment">//声明死信队列</span></span><br><span class="line"><span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//死信队列绑定死信交换机与 routingkey</span></span><br><span class="line">channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"><span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//正常队列设置死信交换机 参数 key是固定值</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line"><span class="comment">//正常队列设置死信 routing-key参数 key是固定值</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">normalQueue</span> <span class="operator">=</span> <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">channel.queueDeclare(normalQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span>+message);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(normalQueue, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117110757546.png" alt="image-20221117110757546"></p></li><li><p>消费者C2代码（以上步骤完成后，启动C2消费者，它消费死信队列里面的信息）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer02</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收死信队列消息.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Consumer02 接收死信队列的消息&quot;</span> + message);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(deadQueue, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117111130151.png" alt="image-20221117111130151"></p></li></ul><h3 id="队列达到最大长度造成死信"><a href="#队列达到最大长度造成死信" class="headerlink" title="队列达到最大长度造成死信"></a>队列达到最大长度造成死信</h3><ul><li><p>也是<strong>通过关闭消费者来模拟消费者无法消费队列中的消息，然后队列中的消息越来越多，最后达到队列所能存储消息的上限，多余的消息就会被送到死信队列中</strong>。</p></li><li><p>上面消息生产者的代码去掉设置消息的TTL这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">             <span class="comment">//该信息是用作演示队列个数限制</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">11</span> ; i++) &#123;</span><br><span class="line">String message=<span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">channel.basicPublish(NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>,<span class="literal">null</span>, message.getBytes());</span><br><span class="line">System.out.println(<span class="string">&quot;生产者发送消息:&quot;</span>+message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C1 消费者修改以下代码(启动之后关闭该消费者 模拟其接收不到消息)：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117112737502.png" alt="image-20221117112737502"></p><p>需要手动删除之前的队列以更新队列的配置。</p></li><li><p>C2 消费者代码不变(启动 C2 消费者)：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117112840830.png" alt="image-20221117112840830"></p></li></ul><h3 id="消息被拒造成的死信"><a href="#消息被拒造成的死信" class="headerlink" title="消息被拒造成的死信"></a>消息被拒造成的死信</h3><ul><li><p>通过<strong>手动让消费者拒绝消息来模拟消息在消费的时候被拒绝的情景，被拒绝的消息会进入死信队列中</strong>。</p></li><li><p>消息生产者代码同上生产者一致</p></li><li><p>C1 消费者代码(手动拒绝消息 模拟其拒绝消息)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line"><span class="comment">//普通交换机名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"><span class="comment">//死信交换机名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line"><span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="comment">//声明死信队列</span></span><br><span class="line"><span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//死信队列绑定死信交换机与 routingkey</span></span><br><span class="line">channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"><span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//正常队列设置死信交换机 参数 key是固定值</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line"><span class="comment">//正常队列设置死信 routing-key参数 key是固定值</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">normalQueue</span> <span class="operator">=</span> <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">channel.queueDeclare(normalQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(message.equals(<span class="string">&quot;info5&quot;</span>))&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message + <span class="string">&quot;并拒绝签收该消息&quot;</span>);</span><br><span class="line"><span class="comment">//requeue设置为 false代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中</span></span><br><span class="line">channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span>+message);</span><br><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">channel.basicConsume(normalQueue, autoAck, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117113216967.png" alt="image-20221117113216967"></p></li><li><p>C2消费者代码不变。启动消费者1然后再启动消费者2：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117113300286.png" alt="image-20221117113300286"></p></li></ul><h1 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1><h2 id="延迟队列概念"><a href="#延迟队列概念" class="headerlink" title="延迟队列概念"></a>延迟队列概念</h2><ul><li>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</li></ul><h2 id="延迟队列使用场景"><a href="#延迟队列使用场景" class="headerlink" title="延迟队列使用场景"></a>延迟队列使用场景</h2><ol><li>订单在十分钟之内未支付则自动取消</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒。</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li></ol><ul><li><p>这些场景都有一个特点，<strong>需要在某个事件发生之后或者之前的指定时间点完成某一项任务</strong>，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求，如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118093518414.png" alt="image-20221118093518414"></p></li></ul><h2 id="RabbitMQ中的TTL"><a href="#RabbitMQ中的TTL" class="headerlink" title="RabbitMQ中的TTL"></a>RabbitMQ中的TTL</h2><ul><li>TTL 是什么呢？<strong>TTL就是Time To Live生存时间</strong>，TTL 是 RabbitMQ 中一个消息或者队列的属性，<strong>表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒</strong>。换句话说，<strong>如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为”死信”<strong>。如果</strong>同时配置了队列的 TTL 和消息的TTL，那么较小的那个值将会被使用</strong>，有两种方式设置 TTL。</li></ul><h3 id="队列设置TTL"><a href="#队列设置TTL" class="headerlink" title="队列设置TTL"></a>队列设置TTL</h3><ul><li><p>第一种是在创建队列的时候设置队列的“x-message-ttl”属性：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118093824706.png" alt="image-20221118093824706"></p></li></ul><h3 id="消息设置TTL"><a href="#消息设置TTL" class="headerlink" title="消息设置TTL"></a>消息设置TTL</h3><ul><li><p>另一种方式便是针对每条消息设置 TTL：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118093848655.png" alt="image-20221118093848655"></p></li></ul><h3 id="两种设置TTL方式的区别"><a href="#两种设置TTL方式的区别" class="headerlink" title="两种设置TTL方式的区别"></a>两种设置TTL方式的区别</h3><ul><li><strong>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)<strong>，而</strong>如果设置消息的TTL，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的（也就是说如果设置了消息的TTL，只有该消息将要被消费者消费的时候会检查一遍TTL，别的时间不检查TTL），如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间（因为消息始终没有将被消费者消费，所以它们的TTL一直得不到检查）</strong>；另外，还需要注意的一点是，<strong>如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃</strong>。</li><li>前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，<strong>TTL 则刚好能让消息在延迟多久之后成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息</strong>。</li></ul><h2 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118095817073.png" alt="image-20221118095817073"></p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--RabbitMQ依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--RabbitMQ测试依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">182.92.234.71</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure><h3 id="添加Swagger配置类"><a href="#添加Swagger配置类" class="headerlink" title="添加Swagger配置类"></a>添加Swagger配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">webApiConfig</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">.groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">.apiInfo(webApiInfo())</span><br><span class="line">.select()</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ApiInfo <span class="title function_">webApiInfo</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">.title(<span class="string">&quot;rabbitmq 接口文档&quot;</span>)</span><br><span class="line">.description(<span class="string">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)</span><br><span class="line">.version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">.contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;enjoy6288&quot;</span>, <span class="string">&quot;http://atguigu.com&quot;</span>,<span class="string">&quot;1551388580@qq.com&quot;</span>))</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过设置队列的TTL实现延迟队列"><a href="#通过设置队列的TTL实现延迟队列" class="headerlink" title="通过设置队列的TTL实现延迟队列"></a>通过设置队列的TTL实现延迟队列</h2><h3 id="代码架构图-1"><a href="#代码架构图-1" class="headerlink" title="代码架构图"></a>代码架构图</h3><ul><li><p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118100311986.png" alt="image-20221118100311986"></p></li></ul><h3 id="配置文件类代码"><a href="#配置文件类代码" class="headerlink" title="配置文件类代码"></a>配置文件类代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlQueueConfig</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">X_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_A</span> <span class="operator">=</span> <span class="string">&quot;QA&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_B</span> <span class="operator">=</span> <span class="string">&quot;QB&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;QD&quot;</span>;</span><br><span class="line"><span class="comment">//声明 xExchange</span></span><br><span class="line"><span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">xExchange</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(X_EXCHANGE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明 xExchange</span></span><br><span class="line"><span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">yExchange</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明队列 A ttl 为 10s 并绑定到对应的死信交换机</span></span><br><span class="line"><span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line"><span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line"><span class="comment">//声明队列的 TTL</span></span><br><span class="line">args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明队列 A 绑定 X 交换机</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">queueaBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明队列 B ttl为 40s并绑定到对应的死信交换机</span></span><br><span class="line"><span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line"><span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line"><span class="comment">//声明队列的 TTL</span></span><br><span class="line">args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">40000</span>);</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(args).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明队列 B 绑定 X 交换机</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">queuebBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queue1B,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queue1B).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明死信队列 QD</span></span><br><span class="line"><span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queueD</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DEAD_LETTER_QUEUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明死信队列 QD 绑定关系</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">deadLetterBindingQAD</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,<span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息生产者代码"><a href="#消息生产者代码" class="headerlink" title="消息生产者代码"></a>消息生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ttl&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMsgController</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="meta">@GetMapping(&quot;sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条信息给两个 TTL 队列:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), message);</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot;消息来自 ttl 为 10S 的队列: &quot;</span>+message);</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;消息来自 ttl 为 40S 的队列: &quot;</span>+message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息消费者代码"><a href="#消息消费者代码" class="headerlink" title="消息消费者代码"></a>消息消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterQueueConsumer</span> &#123;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到死信队列信息&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li><p>发起一个请求 <a href="http://localhost:8080/ttl/sendMsg/%E5%98%BB%E5%98%BB%E5%98%BB%EF%BC%9A">http://localhost:8080/ttl/sendMsg/嘻嘻嘻：</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118101038315.png" alt="image-20221118101038315"></p></li><li><p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息，然后被消费掉，这样一个延时队列就打造完成了。</p></li><li><p>不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p></li><li><p>问题在于<strong>无法很方便地添加处理新的延时长度的解决方案</strong>。</p></li></ul><h2 id="通过设置消息的TTL实现延迟队列"><a href="#通过设置消息的TTL实现延迟队列" class="headerlink" title="通过设置消息的TTL实现延迟队列"></a>通过设置消息的TTL实现延迟队列</h2><h3 id="代码架构图-2"><a href="#代码架构图-2" class="headerlink" title="代码架构图"></a>代码架构图</h3><ul><li><p>在这里新增了一个队列QC，绑定关系如下，该队列不设置TTL时间：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118101405136.png" alt="image-20221118101405136"></p></li></ul><h3 id="配置文件类代码-1"><a href="#配置文件类代码-1" class="headerlink" title="配置文件类代码"></a>配置文件类代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgTtlQueueConfig</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_C</span> <span class="operator">=</span> <span class="string">&quot;QC&quot;</span>;</span><br><span class="line"><span class="comment">//声明队列 C 死信交换机</span></span><br><span class="line"><span class="meta">@Bean(&quot;queueC&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line"><span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line"><span class="comment">//没有声明 TTL属性</span></span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(args).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明队列 B 绑定 X 交换机</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">queuecBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息生产者代码-1"><a href="#消息生产者代码-1" class="headerlink" title="消息生产者代码"></a>消息生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message,<span class="meta">@PathVariable</span> String ttlTime)</span> &#123;</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, message, correlationData -&gt;&#123;</span><br><span class="line">correlationData.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line"><span class="keyword">return</span> correlationData;</span><br><span class="line">&#125;);</span><br><span class="line">log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒 TTL 信息给队列 C:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(),ttlTime, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><ul><li><p>发起请求<br><a href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendExpirationMsg/你好</a> 1&#x2F;20000<br><a href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendExpirationMsg/你好</a> 2&#x2F;2000</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118101718111.png" alt="image-20221118101718111"></p></li><li><p>看起来似乎没什么问题，但是在最开始的时候，就介绍过<strong>如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“，因为 RabbitMQ 只会检查第一个消息是否过期</strong>，如果过期则丢到死信队列，如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。</p></li><li><p>问题在于<strong>无法保证检查各消息TTL的并行性，也就是无法保证各消息按时死亡</strong>。</p></li></ul><h2 id="Rabbitmq插件实现延迟队列解决上述问题"><a href="#Rabbitmq插件实现延迟队列解决上述问题" class="headerlink" title="Rabbitmq插件实现延迟队列解决上述问题"></a>Rabbitmq插件实现延迟队列解决上述问题</h2><ul><li>上文中两种实现方式提到的问题，确实是我们需要去解决的，<strong>如果不能实现在消息粒度上的 TTL，并使其在设置的 TTL 时间及时死亡，就无法设计成一个通用的延时队列</strong>。那如何解决呢，接下来我们就去解决该问题。</li></ul><h3 id="安装延时队列插件"><a href="#安装延时队列插件" class="headerlink" title="安装延时队列插件"></a>安装延时队列插件</h3><ul><li><p>在官网上下载 <a href="https://www.rabbitmq.com/community-plugins.html%EF%BC%8C%E4%B8%8B%E8%BD%BD">https://www.rabbitmq.com/community-plugins.html，下载</a><br><strong>rabbitmq_delayed_message_exchange</strong>插件，然后解压放置到 RabbitMQ 的plugins目录。</p></li><li><p>进入 RabbitMQ 的安装目录下的 <strong>plgins 目录</strong>，<strong>执行下面命令让该插件生效</strong>，然后<strong>重启RabbitMQ</strong>：<strong>rabbitmq-plugins enable rabbitmq_delayed_message_exchange</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118103039084.png" alt="image-20221118103039084"></p></li><li><p>在RabbitMQ的图形化界面中查看插件的安装情况：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118103116179.png" alt="image-20221118103116179"></p></li></ul><h3 id="代码架构图-3"><a href="#代码架构图-3" class="headerlink" title="代码架构图"></a>代码架构图</h3><ul><li><p>在这里新增了一个队列 delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118103144304.png" alt="image-20221118103144304"></p></li><li><p>确实比之前的方案简洁了不少。</p></li></ul><h3 id="配置文件类代码-2"><a href="#配置文件类代码-2" class="headerlink" title="配置文件类代码"></a>配置文件类代码</h3><ul><li><p>主要是<strong>通过设置交换机的类型为我们新安装的那个插件的类型来让交换机实现延时投递消息的功能</strong>。</p></li><li><p>在我们自定义的交换机中，这是一种新的交换类型，<strong>该类型消息支持延迟投递机制 消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayedQueueConfig</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DELAYED_QUEUE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义交换机 我们在这里定义的是一个延迟交换机</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CustomExchange <span class="title function_">delayedExchange</span><span class="params">()</span> &#123;</span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//自定义交换机的类型</span></span><br><span class="line">args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bindingDelayedQueue</span><span class="params">(<span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue queue,<span class="meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="消息生产者代码-2"><a href="#消息生产者代码-2" class="headerlink" title="消息生产者代码"></a>消息生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line"><span class="meta">@GetMapping(&quot;sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message,<span class="meta">@PathVariable</span> Integer delayTime)</span> &#123;</span><br><span class="line">rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message,correlationData -&gt;&#123;</span><br><span class="line">    correlationData.getMessageProperties().setDelay(delayTime);</span><br><span class="line"><span class="keyword">return</span> correlationData;</span><br><span class="line">&#125;);</span><br><span class="line">log.info(<span class="string">&quot; 当 前 时 间 ： &#123;&#125;, 发 送 一 条 延 迟 &#123;&#125; 毫 秒 的 信 息 给 队 列 delayed.queue:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(),delayTime, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息消费者代码-1"><a href="#消息消费者代码-1" class="headerlink" title="消息消费者代码"></a>消息消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line"><span class="meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDelayedQueue</span><span class="params">(Message message)</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到延时队列的消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><ul><li><p>发起请求：</p><p><a href="http://localhost:8080/ttl/sendDelayMsg/come">http://localhost:8080/ttl/sendDelayMsg/come</a> on baby1&#x2F;20000<br><a href="http://localhost:8080/ttl/sendDelayMsg/come">http://localhost:8080/ttl/sendDelayMsg/come</a> on baby2&#x2F;2000</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118105503523.png" alt="image-20221118105503523"></p></li><li><p>第二个消息被先消费掉了，符合预期</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>延时队列在需要延时处理的场景下非常有用，<strong>使用 RabbitMQ 来实现延时队列可以很好的利用RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃</strong>。另外，<strong>通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失</strong>。</li><li>当然，延时队列还有很多其它选择，比如利用<strong>Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮</strong>，这些方式各有特点,看需要适用的场景</li></ul><h1 id="发布确认高级"><a href="#发布确认高级" class="headerlink" title="发布确认高级"></a>发布确认高级</h1><ul><li><p>在生产环境中<strong>由于一些不明原因，导致 rabbitmq 重启，在RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复</strong>。于是，我们开始思考，<strong>如何才能进行 RabbitMQ 的消息可靠投递呢</strong>？特别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">应 用 [xxx] 在 [08-1516:36:04] 发 生 [ 错 误 日 志 异 常 ] ， alertId=[xxx] 。 </span><br><span class="line">由[org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:620] 触 发 。</span><br><span class="line">应用 xxx 可能原因如下</span><br><span class="line">服 务 名 为 ：</span><br><span class="line">异 常 为 ： org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:620,</span><br><span class="line">产 生 原 因 如 下 :1.org.springframework.amqp.rabbit.listener.QueuesNotAvailableException:</span><br><span class="line">Cannot prepare queue for listener. Either the queue doesn&#x27;t exist or the broker will not</span><br><span class="line">allow us to use it.||Consumer received fatal=false exception on startup:</span><br></pre></td></tr></table></figure></li></ul><h2 id="发布确认的SpringBoot版本"><a href="#发布确认的SpringBoot版本" class="headerlink" title="发布确认的SpringBoot版本"></a>发布确认的SpringBoot版本</h2><ul><li>针对上面的问题我们通常<strong>采用消息的发布确认模式，并且设置缓存，可以尽可能保证消息的可靠传递</strong>。</li></ul><h3 id="确认机制方案"><a href="#确认机制方案" class="headerlink" title="确认机制方案"></a>确认机制方案</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121165323942.png" alt="image-20221121165323942"></p><h3 id="代码架构图-4"><a href="#代码架构图-4" class="headerlink" title="代码架构图"></a>代码架构图</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121165344609.png" alt="image-20221121165344609"></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li><p>在配置文件当中需要添加<strong>spring.rabbitmq.publisher-confirm-type&#x3D;correlated</strong></p><p>后面的值可以换不同的，有不同的效果：</p><p><strong>none</strong>：禁用发布确认模式，是默认值</p><p><strong>correlated</strong>：发布消息成功到交换机后会出发回调方法</p><p><strong>simple</strong>：经测试有两种效果，其一效果和correlated值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法<br>等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是<br>waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">182.92.234.71</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>=<span class="string">123</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="添加配置类"><a href="#添加配置类" class="headerlink" title="添加配置类"></a>添加配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line"><span class="comment">//声明业务 Exchange</span></span><br><span class="line"><span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明确认队列</span></span><br><span class="line"><span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明确认队列绑定关系</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">queueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息生产者-1"><a href="#消息生产者-1" class="headerlink" title="消息生产者"></a>消息生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyCallBack myCallBack;</span><br><span class="line"><span class="comment">//依赖注入 rabbitTemplate 之后再设置它的回调对象</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">rabbitTemplate.setConfirmCallback(myCallBack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;sendMessage/&#123;message&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line"><span class="comment">//指定消息 id为 1</span></span><br><span class="line">CorrelationData correlationData1=<span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">String routingKey=<span class="string">&quot;key1&quot;</span>;</span><br><span class="line">rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME,routingKey,message+routingKey,correlationData1);</span><br><span class="line">CorrelationData correlationData2=<span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">routingKey=<span class="string">&quot;key2&quot;</span>;</span><br><span class="line">rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME,routingKey,message+routingKey,correlationData2);</span><br><span class="line">log.info(<span class="string">&quot;发送消息内容:&#123;&#125;&quot;</span>,message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回调接口"><a href="#回调接口" class="headerlink" title="回调接口"></a>回调接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换机不管是否收到消息的一个回调方法</span></span><br><span class="line"><span class="comment"> * CorrelationData 消息相关数据</span></span><br><span class="line"><span class="comment"> * ack 交换机是否收到消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">String id=correlationData!=<span class="literal">null</span>?correlationData.getId():<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(ack)&#123;</span><br><span class="line">log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>,id);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>,id,cause);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息消费者-1"><a href="#消息消费者-1" class="headerlink" title="消息消费者"></a>消息消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConsumer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line"><span class="meta">@RabbitListener(queues =CONFIRM_QUEUE_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">String msg=<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">log.info(<span class="string">&quot;接受到队列 confirm.queue 消息:&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121185348719.png" alt="image-20221121185348719"></p><ul><li>可以看到，发送了两条消息，第一条消息的 RoutingKey 为 “key1”，第二条消息的 RoutingKey 为”key2”，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。</li></ul><h2 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h2><h3 id="Mandatory参数"><a href="#Mandatory参数" class="headerlink" title="Mandatory参数"></a>Mandatory参数</h3><ul><li>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</li></ul><h3 id="消息生产者代码-3"><a href="#消息生产者代码-3" class="headerlink" title="消息生产者代码"></a>消息生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageProducer</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback ,</span><br><span class="line">RabbitTemplate.ReturnCallback &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="comment">//rabbitTemplate 注入之后就设置该值</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * true：交换机无法将消息进行路由时，会将该消息返回给生产者</span></span><br><span class="line"><span class="comment"> * false：如果发现消息无法进行路由，则直接丢弃</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">rabbitTemplate.setMandatory(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//设置回退消息交给谁处理</span></span><br><span class="line">rabbitTemplate.setReturnCallback(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;sendMessage&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span>&#123;</span><br><span class="line"><span class="comment">//让消息绑定一个 id值</span></span><br><span class="line"><span class="type">CorrelationData</span> <span class="variable">correlationData1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;confirm.exchange&quot;</span>,<span class="string">&quot;key1&quot;</span>,message+<span class="string">&quot;key1&quot;</span>,correlationData1);</span><br><span class="line">log.info(<span class="string">&quot;发送消息 id 为:&#123;&#125;内容为&#123;&#125;&quot;</span>,correlationData1.getId(),message+<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"><span class="type">CorrelationData</span> <span class="variable">correlationData2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;confirm.exchange&quot;</span>,<span class="string">&quot;key2&quot;</span>,message+<span class="string">&quot;key2&quot;</span>,correlationData2);</span><br><span class="line">log.info(<span class="string">&quot;发送消息 id 为:&#123;&#125;内容为&#123;&#125;&quot;</span>,correlationData2.getId(),message+<span class="string">&quot;key2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (ack) &#123;</span><br><span class="line">log.info(<span class="string">&quot;交换机收到消息确认成功, id:&#123;&#125;&quot;</span>, id);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.error(<span class="string">&quot;消息 id:&#123;&#125;未成功投递到交换机,原因是:&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class="line">log.info(<span class="string">&quot;消息:&#123;&#125;被服务器退回，退回原因:&#123;&#125;, 交换机是:&#123;&#125;, 路由 key:&#123;&#125;&quot;</span>,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()),replyText, exchange, routingKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回调接口-1"><a href="#回调接口-1" class="headerlink" title="回调接口"></a>回调接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span></span><br><span class="line"><span class="title class_">RabbitTemplate</span>.ConfirmCallback,RabbitTemplate.ReturnCallback &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换机不管是否收到消息的一个回调方法</span></span><br><span class="line"><span class="comment"> * CorrelationData 消息相关数据</span></span><br><span class="line"><span class="comment">  * ack 交换机是否收到消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">String id=correlationData!=<span class="literal">null</span>?correlationData.getId():<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(ack)&#123;</span><br><span class="line">log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>,id);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>,id,cause);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当消息无法路由的时候的回调方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class="line">log.error(<span class="string">&quot; 消 息 &#123;&#125;, 被 交 换 机 &#123;&#125; 退 回 ， 退 回 原 因 :&#123;&#125;, 路 由 key:&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()),exchange,replyText,routingKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121192233476.png" alt="image-20221121192233476"></p><h2 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h2><ul><li><strong>有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息无法被投递时发现并处理</strong>。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。什么是备份交换机呢？<strong>备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理</strong>，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进入这个队列了。当然，我们<strong>还可以建立一个报警队列，用独立的消费者来进行监测和报警</strong>。</li></ul><h3 id="代码架构图-5"><a href="#代码架构图-5" class="headerlink" title="代码架构图"></a>代码架构图</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121192654594.png" alt="image-20221121192654594"></p><h3 id="修改配置类"><a href="#修改配置类" class="headerlink" title="修改配置类"></a>修改配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;backup.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;backup.queue&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WARNING_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;warning.queue&quot;</span>;</span><br><span class="line"><span class="comment">//声明确认队列</span></span><br><span class="line"><span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明确认队列绑定关系</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">queueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明备份 Exchange</span></span><br><span class="line"><span class="meta">@Bean(&quot;backupExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> FanoutExchange <span class="title function_">backupExchange</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(BACKUP_EXCHANGE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明确认 Exchange 交换机的备份交换机</span></span><br><span class="line"><span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ExchangeBuilder</span> <span class="variable">exchangeBuilder</span> <span class="operator">=</span> </span><br><span class="line">           ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME).durable(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">//设置该交换机的备份交换机</span></span><br><span class="line">.withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME);</span><br><span class="line"><span class="keyword">return</span> (DirectExchange)exchangeBuilder.build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明警告队列</span></span><br><span class="line"><span class="meta">@Bean(&quot;warningQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">warningQueue</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明报警队列绑定关系</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">warningBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明备份队列</span></span><br><span class="line"><span class="meta">@Bean(&quot;backQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">backQueue</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明备份队列绑定关系</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">backupBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;backQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="报警消费者"><a href="#报警消费者" class="headerlink" title="报警消费者"></a>报警消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarningConsumer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WARNING_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;warning.queue&quot;</span>;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = WARNING_QUEUE_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveWarningMsg</span><span class="params">(Message message)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">log.error(<span class="string">&quot;报警发现不可路由消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试注意事项"><a href="#测试注意事项" class="headerlink" title="测试注意事项"></a>测试注意事项</h3><ul><li><p><strong>重新启动项目的时候需要把原来的 confirm.exchange 删除因为我们修改了其绑定属性</strong>，不然报以下错:</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121193524288.png" alt="image-20221121193524288"></p></li></ul><h3 id="结果分析-2"><a href="#结果分析-2" class="headerlink" title="结果分析"></a>结果分析</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121193542021.png" alt="image-20221121193542021"></p><ul><li>mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是<strong>备份交换机优先级高</strong>。</li></ul><h1 id="RabbitMQ其他知识点"><a href="#RabbitMQ其他知识点" class="headerlink" title="RabbitMQ其他知识点"></a>RabbitMQ其他知识点</h1><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul><li><strong>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用</strong>。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等。</li></ul><h3 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h3><ul><li>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断，故 <strong>MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息</strong>。</li></ul><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><ul><li>MQ 消费者的幂等性的解决<strong>一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过</strong>。</li></ul><h3 id="消费端的幂等性保障"><a href="#消费端的幂等性保障" class="headerlink" title="消费端的幂等性保障"></a>消费端的幂等性保障</h3><ul><li>在海量订单生成的业务高峰期，<strong>生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性，这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息</strong>。业界主流的幂等性有两种操作:a.<strong>唯一 ID+指纹码机制,利用数据库主键去重</strong>, b.<strong>利用 redis 的原子性去实现</strong></li></ul><h3 id="唯一ID-指纹码机制"><a href="#唯一ID-指纹码机制" class="headerlink" title="唯一ID+指纹码机制"></a>唯一ID+指纹码机制</h3><ul><li><strong>指纹码:我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性</strong>，然后就<strong>利用查询语句进行判断这个 id 是否存在数据库中</strong>,<strong>优势就是实现简单就一个拼接，然后查询判断是否重复</strong>；<strong>劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能</strong>，但也不是我们最推荐的方式。</li></ul><h3 id="Redis原子性"><a href="#Redis原子性" class="headerlink" title="Redis原子性"></a>Redis原子性</h3><ul><li><strong>利用redis执行setnx命令，天然具有幂等性</strong>，从而实现不重复消费。</li></ul><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>在我们系统中有一个<strong>订单催付的场景</strong>，我们的客户在天猫下的订单,淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以<strong>订单量大了后采用 RabbitMQ 进行改造和优化,如果发现是大客户的订单就给一个相对比较高的优先级，否则就给默认优先级</strong>。</li></ul><h3 id="如何添加优先级"><a href="#如何添加优先级" class="headerlink" title="如何添加优先级"></a>如何添加优先级</h3><ul><li><p>可以<strong>在控制台页面给队列添加最大优先级属性</strong>，从而使队列变成优先级队列：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122121113089.png" alt="image-20221122121113089"></p></li><li><p>也可以在<strong>声明队列的代码中添加最大优先级属性</strong>从而让队列变成优先级队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122121153693.png" alt="image-20221122121153693"></p></li><li><p><strong>在生成消息的代码中添加优先级</strong>表示当前消息的优先级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br></pre></td></tr></table></figure></li><li><p>注意事项：要让队列实现优先级需要做的事情有如下事情：<strong>队列需要设置为优先级队列，消息需要设置消息的优先级，消费者需要等待消息已经发送到队列中才去消费</strong>，因为这样才有机会对消息进行排序</p></li></ul><h3 id="实战-2"><a href="#实战-2" class="headerlink" title="实战"></a>实战</h3><ul><li><p>消息生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();) &#123;</span><br><span class="line"><span class="comment">//给消息赋予一个 priority属性来表示当前消息的优先级</span></span><br><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">11</span>; i++) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>+i;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;发送消息完成:&quot;</span> + message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消息消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU</span></span><br><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">System.out.println(<span class="string">&quot;消费者启动等待消费......&quot;</span>);</span><br><span class="line">DeliverCallback deliverCallback=(consumerTag, delivery)-&gt;&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">System.out.println(<span class="string">&quot;接收到消息:&quot;</span>+receivedMessage);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,(consumerTag)-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;消费者无法消费消息时调用，如队列被删除&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。<strong>惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储</strong>。当消费者<strong>由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了</strong>。</li><li><strong>默认情况（不使用惰性队列）下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者</strong>。即使是<strong>持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息</strong>。虽然 RabbitMQ 的开发者们一直在升级相关的算法，但是效果始终不太理想，尤其是在消息量特别大的时候。</li></ul><h3 id="队列的两种模式"><a href="#队列的两种模式" class="headerlink" title="队列的两种模式"></a>队列的两种模式</h3><ul><li><p><strong>队列具备两种模式：default 和 lazy</strong>。默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。<strong>lazy模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级</strong>。如果<strong>要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的</strong>。</p></li><li><p>在队列声明的时候<strong>可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”</strong>。下面示例中演示了一个惰性队列的声明细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br></pre></td></tr></table></figure></li></ul><h3 id="内存开销对比"><a href="#内存开销对比" class="headerlink" title="内存开销对比"></a>内存开销对比</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122122542824.png" alt="image-20221122122542824"></p><ul><li>在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅占用 1.5MB，毕竟大部分数据全存到磁盘中了。</li></ul><h1 id="RabbitMQ集群"><a href="#RabbitMQ集群" class="headerlink" title="RabbitMQ集群"></a>RabbitMQ集群</h1><h2 id="clustering-使用集群"><a href="#clustering-使用集群" class="headerlink" title="clustering(使用集群)"></a>clustering(使用集群)</h2><h3 id="使用集群的原因"><a href="#使用集群的原因" class="headerlink" title="使用集群的原因"></a>使用集群的原因</h3><ul><li>最开始我们介绍了如何安装及运行 RabbitMQ 服务，不过这些是单机版的，无法满足目前真实应用的要求。如果 RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？单台 RabbitMQ服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要RabbitMQ 服务满足每秒 10 万条消息的吞吐量呢？<strong>购买昂贵的服务器来增强单机RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是解决实际问题的关键</strong>。</li></ul><h3 id="搭建步骤（三台机器）"><a href="#搭建步骤（三台机器）" class="headerlink" title="搭建步骤（三台机器）"></a>搭建步骤（三台机器）</h3><ol><li><p>使用命令<strong>vim &#x2F;etc&#x2F;hostname</strong>修改3台机器的主机名称，最好使用比较规范的命名方式，方便识别，这里将3台机器分别命名为node1、node2、node3。</p></li><li><p>使用命令<strong>vim &#x2F;etc&#x2F;hosts</strong>配置各个节点的hosts文件，让各个节点都能互相识别对方，<strong>把所有机器对应的ip和其对应机器的机器名组成的映射写到所有机器的hosts文件中</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122163145480.png" alt="image-20221122163145480"></p></li><li><p>在node1上执行远程操作命令：</p><p><strong>scp &#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie root@node2:&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie</strong></p><p><strong>scp &#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie root@node3:&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie</strong></p><p>以确保各个节点的cookie文件使用的是同一个值</p></li><li><p>启动RabbitMQ 服务,顺带启动 Erlang 虚拟机和 RbbitMQ 应用服务(在三台节点上分别执行以下命令)：<strong>rabbitmq-server -detached</strong></p></li><li><p>在节点2执行：</p><p><strong>rabbitmqctl stop_app</strong>（rabbitmqctl stop 会将Erlang 虚拟机和RabbitMQ服务一起关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务）</p><p><strong>rabbitmqctl reset</strong></p><p><strong>rabbitmqctl join_cluster rabbit@node1</strong></p><p><strong>rabbitmqctl start_app</strong>（只启动应用服务）</p></li><li><p>在节点3执行：</p><p><strong>rabbitmqctl stop_app</strong><br><strong>rabbitmqctl reset</strong><br><strong>rabbitmqctl join_cluster rabbit@node2</strong><br><strong>rabbitmqctl start_app</strong></p></li><li><p>查询集群状态：<strong>rabbitmqctl cluster_status</strong></p></li><li><p>需要重新设置集群的用户：</p><p>创建帐号：<strong>rabbitmqctl add_user admin 123</strong></p><p>设置用户角色：<strong>rabbitmqctl set_user_tags admin administrator</strong></p><p>设置用户权限：<strong>rabbitmqctl set_permissions -p “&#x2F;“ admin “.*“ “.*“ “.*“</strong></p></li><li><p>解除集群节点（node2和node3机器分别执行）：</p><p><strong>rabbitmqctl stop_app</strong><br><strong>rabbitmqctl reset</strong><br><strong>rabbitmqctl start_app</strong><br><strong>rabbitmqctl cluster_status</strong></p><p>在node1机器上执行：</p><p><strong>rabbitmqctl forget_cluster_node rabbit@node2</strong></p></li><li><p>总结一下就是：<strong>创建集群的时候需要重启从机并设置其归属主机；解除集群的时候需要重启从机以让从机忘掉主机，再在主机上执行对应的命令以让主机忘记从机</strong>。（集群中应该没有不对等的主从关系，这里使用主机从机只是为了表述归属关系）</p></li></ol><h2 id="镜像队列-Mirror-Queue"><a href="#镜像队列-Mirror-Queue" class="headerlink" title="镜像队列(Mirror Queue)"></a>镜像队列(Mirror Queue)</h2><h3 id="使用镜像队列的原因"><a href="#使用镜像队列的原因" class="headerlink" title="使用镜像队列的原因"></a>使用镜像队列的原因</h3><ul><li><strong>如果 RabbitMQ 集群中只有一个 Broker 节点，那么该节点的失效将导致整体服务的临时性不可用，并且也可能会导致消息的丢失</strong>。可以将所有消息都设置为持久化，并且对应队列的 durable 属性也设置为 true，但是这样仍然无法避免由于缓存导致的问题：因为<strong>消息在发送之后和被写入磁盘井执行刷盘动作之间存在一个短暂却会产生问题的时间窗</strong>。通过 publisher-confirm 机制能够确保客户端知道哪些消息己经存入磁盘，尽管如此，<strong>一般不希望遇到因单点故障导致的服务不可用</strong>。</li><li>引入镜像队列(Mirror Queue)的机制，<strong>可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性</strong>。</li></ul><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol><li><p>启动三台集群节点</p></li><li><p>随便找一个节点添加policy，这个数字参数是配置在集群中队列镜像的个数：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122165327443.png" alt="image-20221122165327443"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122165539951.png" alt="image-20221122165539951"></p></li><li><p>在 node1 上创建一个队列发送一条消息，在node3中存在该队列的镜像队列：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122165658467.png" alt="image-20221122165658467"></p></li><li><p>停掉node1之后发现使用的队列变成了node3里的那个镜像队列，而node2中出现了另外一个镜像队列，说明无论何时，只要机器数量足够，那么一个队列总会有一个镜像队列：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122170014398.png" alt="image-20221122170014398"></p></li><li><p>就算整个集群只剩下一台机器了 依然能消费队列里面的消息，说明队列里面的消息被镜像队列传递到相应机器里面了</p></li></ol><h2 id="Haproxy-Keepalive实现高可用负载均衡"><a href="#Haproxy-Keepalive实现高可用负载均衡" class="headerlink" title="Haproxy+Keepalive实现高可用负载均衡"></a>Haproxy+Keepalive实现高可用负载均衡</h2><ul><li>用nginx好像也可以，都是用来做反向代理服务器的。</li></ul><h3 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122170143227.png" alt="image-20221122170143227"></p><h3 id="Haproxy实现负载均衡"><a href="#Haproxy实现负载均衡" class="headerlink" title="Haproxy实现负载均衡"></a>Haproxy实现负载均衡</h3><ul><li><strong>HAProxy 提供高可用性、负载均衡及基于 TCP-HTTP 应用的代理</strong>，支持虚拟主机，它是免费、快速并且可靠的一种解决方案，包括 Twitter,Reddit,StackOverflow,GitHub 在内的多家知名互联网公司在使用。<strong>HAProxy 实现了一种事件驱动、单一进程模型，此模型支持非常大的井发连接数</strong>。</li><li>扩展 nginx,lvs,haproxy 之间的区别: <a href="http://www.ha97.com/5646.html">http://www.ha97.com/5646.html</a></li></ul><h3 id="搭建步骤-1"><a href="#搭建步骤-1" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol><li><p>下载 haproxy(在 node1 和 node2)：<strong>yum -y install haproxy</strong></p></li><li><p>修改 node1 和 node2 的 haproxy.cfg：<strong>vim &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg</strong></p><p>需要修改红色部分的IP为当前机器的IP：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122170545602.png" alt="image-20221122170545602"></p></li><li><p>在两台机器上启动haproxy：</p><p><strong>haproxy -f &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg</strong></p><p><strong>ps -ef | grep haproxy</strong></p></li><li><p>访问地址：<strong><a href="http://10.211.55.71:8888/stats">http://10.211.55.71:8888/stats</a></strong></p></li></ol><h2 id="Keepalived实现双机-主备-热备-热备份"><a href="#Keepalived实现双机-主备-热备-热备份" class="headerlink" title="Keepalived实现双机(主备)热备(热备份)"></a>Keepalived实现双机(主备)热备(热备份)</h2><ul><li>试想如果前面配置的 HAProxy 主机突然宕机或者网卡失效，那么虽然 RbbitMQ 集群没有任何故障但是对于外界的客户端来说所有的连接都会被断开结果将是灾难性的，<strong>确保负载均衡服务的可靠性同样显得十分重要</strong>，这里就要引入<strong>Keepalived，它能够通过自身健康检查、资源接管功能做高可用(双机热备)，实现故障转移</strong>。</li></ul><h3 id="搭建步骤-2"><a href="#搭建步骤-2" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol><li>下载keepalived：<strong>yum -y install keepalived</strong></li><li>修改节点node1的配置文件：<strong>vim &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf</strong>，把资料里面的keepalived.conf修改之后替换</li><li>节点node2配置文件，需要修改global_defs的router_id，如nodeB；其次要修改 vrrp_instance_VI 中 state 为”BACKUP”；最后要将 priority 设置为小于 100 的值。</li><li>添加haproxy_chk.sh(为了<strong>防止 HAProxy 服务挂掉之后 Keepalived 还在正常工作而没有切换到 Backup 上，所以这里需要编写一个脚本来检测 HAProxy 务的状态,当 HAProxy 服务挂掉之后该脚本会自动重启HAProxy 的服务，如果不成功则关闭 Keepalived 服务，这样便可以切换到 Backup 继续工作</strong>)：<strong>vim &#x2F;etc&#x2F;keepalived&#x2F;haproxy_chk.sh(可以直接上传文件)<strong>，修改权限</strong>chmod 777 &#x2F;etc&#x2F;keepalived&#x2F;haproxy_chk.sh</strong></li><li>启动keepalive命令（node1和node2启动）：<strong>systemctl start keepalived</strong></li><li>观察 Keepalived 的日志：<strong>tail -f &#x2F;var&#x2F;log&#x2F;messages -n 200</strong></li><li>观察最新添加的vip：<strong>ip add show</strong></li><li>node1 模拟 keepalived 关闭状态：<strong>systemctl stop keepalived</strong></li><li>使用 vip 地址来访问 rabbitmq 集群</li></ol><h2 id="Federation-Exchange（联邦交换机）"><a href="#Federation-Exchange（联邦交换机）" class="headerlink" title="Federation Exchange（联邦交换机）"></a>Federation Exchange（联邦交换机）</h2><h3 id="使用它的原因"><a href="#使用它的原因" class="headerlink" title="使用它的原因"></a>使用它的原因</h3><ul><li><p><strong>(broker 北京)，(broker 深圳)彼此之间相距甚远，网络延迟是一个不得不面对的问题</strong>。有一个在北京的业务(Client 北京) 需要连接(broker 北京)，向其中的交换器 exchangeA 发送消息，此时的网络延迟很小，(Client 北京)可以迅速将消息发送至 exchangeA 中，就算在开启了 publisher-confirm 机制或者事务机制的情况下，也可以迅速收到确认信息。此时又有个在深圳的业务(Client 深圳)需要向 exchangeA 发送消息，那么**(Client 深圳) (broker 北京)之间有很大的网络延迟，(Client 深圳) 将发送消息至 exchangeA 会经历一定的延迟，尤其是在开启了 publisher-confirm 机制或者事务机制的情况下，(Client 深圳) 会等待很长的延迟时间来接收(broker 北京)的确认信息，进而必然造成这条发送线程的性能降低，甚至造成一定程度上的阻塞**。</p></li><li><p>将业务(Client 深圳)部署到北京的机房可以解决这个问题，但是如果(Client 深圳)调用的另些服务都部署在深圳，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么容灾又何以实现？这里<strong>使用 Federation 插件就可以很好地解决这个问题</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122181644954.png" alt="image-20221122181644954"></p></li></ul><h3 id="搭建步骤-3"><a href="#搭建步骤-3" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol><li><p>需要保证每台节点单独运行</p></li><li><p>在每台机器上开启federation相关插件：</p><p><strong>rabbitmq-plugins enable rabbitmq_federation</strong></p><p><strong>rabbitmq-plugins enable rabbitmq_federation_management</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122202128016.png" alt="image-20221122202128016"></p></li><li><p>原理图（先运行consumer在node2创建fed_exchange）：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122202308766.png" alt="image-20221122202308766"></p></li><li><p>在downstream（node2）配置upstream（node1）：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122202343393.png" alt="image-20221122202343393"></p></li><li><p>添加policy：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122202405537.png" alt="image-20221122202405537"></p></li><li><p>成功的前提是联邦交换机的state是running：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122202450382.png" alt="image-20221122202450382"></p></li></ol><h2 id="Federation-Queue（联邦队列）"><a href="#Federation-Queue（联邦队列）" class="headerlink" title="Federation Queue（联邦队列）"></a>Federation Queue（联邦队列）</h2><h3 id="使用它的原因-1"><a href="#使用它的原因-1" class="headerlink" title="使用它的原因"></a>使用它的原因</h3><ul><li><strong>联邦队列可以在多个 Broker 节点(或者集群)之间为单个队列提供均衡负载的功能</strong>。<strong>一个联邦队列可以连接一个或者多个上游队列(upstream queue)，并从这些上游队列中获取消息以满足本地消费者消费消息的需求</strong>。</li></ul><h3 id="搭建步骤-4"><a href="#搭建步骤-4" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol><li><p>原理图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122201858251.png" alt="image-20221122201858251"></p></li><li><p>添加upstream（同上）</p></li><li><p>添加policy：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122201931786.png" alt="image-20221122201931786"></p></li></ol><h2 id="Shovel"><a href="#Shovel" class="headerlink" title="Shovel"></a>Shovel</h2><h3 id="使用它的原因-2"><a href="#使用它的原因-2" class="headerlink" title="使用它的原因"></a>使用它的原因</h3><ul><li>Federation 具备的数据转发功能类似，<strong>Shovel 能够可靠、持续地从一个 Broker 中的队列(作为源端，即source)拉取数据并转发至另一个 Broker 中的交换器(作为目的端，即 destination)。作为源端的队列和作为目的端的交换器可以同时位于同一个 Broker，也可以位于不同的 Broker 上</strong>。Shovel 可以翻译为”铲子”，是一种比较形象的比喻，这个”铲子”可以将消息从一方”铲子”另一方。<strong>Shovel的行为就像优秀的客户端应用程序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理</strong>。</li></ul><h3 id="搭建步骤-5"><a href="#搭建步骤-5" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol><li><p>开启插件（需要的机器都开启）：</p><p><strong>rabbitmq-plugins enable rabbitmq_shovel</strong></p><p><strong>rabbitmq-plugins enable rabbitmq_shovel_management</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122201615713.png" alt="image-20221122201615713"></p></li><li><p>原理图（在源头发送的消息直接会进入到目的地队列）：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122201702271.png" alt="image-20221122201702271"></p></li><li><p>添加shovel源和目的地：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122201727815.png" alt="image-20221122201727815"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;MQ的相关概念&quot;&gt;&lt;a href=&quot;#MQ的相关概念&quot; class=&quot;headerlink&quot; title=&quot;MQ的相关概念&quot;&gt;&lt;/a&gt;MQ的相关概念&lt;/h1&gt;&lt;h2 id</summary>
      
    
    
    
    
    <category term="消息队列" scheme="https://konjacor.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="RabbitMQ" scheme="https://konjacor.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://konjacor.github.io/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://konjacor.github.io/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2022-10-17T01:38:45.000Z</published>
    <updated>2022-12-20T12:11:43.207Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="什么是计算机网络？"><a href="#什么是计算机网络？" class="headerlink" title="什么是计算机网络？"></a>什么是计算机网络？</h1><h2 id="计算机网络-x3D-通信技术-计算机技术"><a href="#计算机网络-x3D-通信技术-计算机技术" class="headerlink" title="计算机网络&#x3D;通信技术+计算机技术"></a>计算机网络&#x3D;通信技术+计算机技术</h2><ul><li><p>计算机网络是<strong>通信技术</strong>与<strong>计算机技术</strong>紧密结合的产物。</p></li><li><p>通信系统模型：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221110205335510.png" alt="image-20221110205335510"></p></li><li><p>计算机网络实际上<strong>就是一种通信网络</strong></p></li></ul><h2 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h2><ul><li><p>定义：计算机网络就是<strong>互连的、自治的计算机集合</strong>。</p><ul><li><strong>自治</strong>：无主从关系</li><li><strong>互连</strong>：互联互通</li></ul></li><li><p>通信链路举例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221110205557996.png" alt="image-20221110205557996"></p></li></ul><h2 id="主机之间距离远、数量大如何保证互连？"><a href="#主机之间距离远、数量大如何保证互连？" class="headerlink" title="主机之间距离远、数量大如何保证互连？"></a>主机之间距离远、数量大如何保证互连？</h2><ul><li><p>可以<strong>通过交换网络</strong>互连主机：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221110210012748.png" alt="image-20221110210012748"></p></li></ul><h2 id="什么是Internet？"><a href="#什么是Internet？" class="headerlink" title="什么是Internet？"></a>什么是Internet？</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>Internet就是因特网，是<strong>全球最大的互联网络</strong>，我们现在使用的网络其实就是Internet，如果<strong>用java的概念来理解的话，互联网就是一个接口，而Internet是互联网这个接口的实现</strong>。</li></ul><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><ul><li><p>Internet服务由<strong>因特网服务提供商（Internet server provider 简称 ISP）</strong>提供，而Internet实际上就是ISP提供的网络之间互相连接的网络，也就是<strong>网络之网络</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221110211710548.png" alt="image-20221110211710548"></p></li></ul><h3 id="从组成细节看"><a href="#从组成细节看" class="headerlink" title="从组成细节看"></a>从组成细节看</h3><ul><li>Internet<strong>是数以百万计的互连的计算设备集合</strong>：<ul><li><strong>主机</strong>（hosts） &#x3D; <strong>端系统</strong>（end systems）</li><li>在主机或者端系统上<strong>可以运行各种网络应用</strong></li></ul></li><li>Internet内的<strong>通信链路多种多样</strong>，可以是光纤、铜缆、无线电、卫星等</li><li>Internet内部采取<strong>分组交换的形式来传递信息</strong>，也就是<strong>通过路由器（routers）和交换机（switches）来对数据包进行分组转发</strong>。</li></ul><h3 id="从服务角度看"><a href="#从服务角度看" class="headerlink" title="从服务角度看"></a>从服务角度看</h3><ul><li>Internet<strong>为网络应用提供通信服务的通信基础设施</strong>：<ul><li>网络应用比如Web，VoIP，email，网络游戏，电子商务，社交网络，…</li></ul></li><li>为网络应用<strong>提供应用编程接口（API）</strong>：<ul><li>支持应用程序<strong>”连接“Internet，发送&#x2F;接收数据</strong>。</li><li>提供类似于邮政系统的<strong>数据传输服务</strong>。</li></ul></li></ul><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul><li>仅有硬件（主机、链路、路由器……）连接，Internet能否顺畅运行？能保证应用数据有序交付吗？</li><li>答：很明显不能，还<strong>需要一些约束和规则才能让数据有序、完整、快速地交付</strong>，而这个约束和规则实际上就是<strong>网络协议</strong>，详细的之后会讲。</li></ul><h1 id="什么是网络协议？"><a href="#什么是网络协议？" class="headerlink" title="什么是网络协议？"></a>什么是网络协议？</h1><h2 id="协议是计算机网络有序运行的重要保证"><a href="#协议是计算机网络有序运行的重要保证" class="headerlink" title="协议是计算机网络有序运行的重要保证"></a>协议是计算机网络有序运行的重要保证</h2><ul><li>硬件（主机、路由器、通信链路等）是计算机网络的基础</li><li><strong>计算机网络中的数据交换必须遵守事先约定好的规则</strong>，就像是交通规则一样，每个交通工具就像是一组数据，而马路就是数据通信的线路，要想让交通流畅，就要制定一系列的交通规则来作为道路的通行规范，在这种规则的限定下，交通就会比较流畅，一旦出现交通事故，我们又需要遵循另外的规则来对交通事故进行处理以防止对之后的交通产生影响，就像数据传输出问题后我们需要采取一系列的措施来弥补产生的损失，这些行为都是被规定在相应协议中的。</li></ul><h2 id="任何通信或信息交换过程都需要规则"><a href="#任何通信或信息交换过程都需要规则" class="headerlink" title="任何通信或信息交换过程都需要规则"></a>任何通信或信息交换过程都需要规则</h2><h3 id="人类交谈"><a href="#人类交谈" class="headerlink" title="人类交谈"></a>人类交谈</h3><ul><li><p>我们在互相交谈的时候都是遵循一定的规则的，这样才能产生有效的交流，比如我问一个人今天天气怎么样，那个人回复我现在是11点50分，这样的交流实际上就是无效的，但是如果那个人遵循我询问的规则回答今天下小雨，那么这样的交流就是有效的，我可以从中获益。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221123122047986.png" alt="image-20221123122047986"></p></li></ul><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><ul><li><strong>在网络通信中，通信主体是“机器”而不是“人”在交换“电子化”或者“数字化”的消息</strong>，人在长时间的社会生活中，自然会懂得一些交流的规则，但是<strong>机器没有经过长时间的学习，因此我们不能指望机器可以不依靠任何东西就懂得交换数据的规则</strong>。</li><li>既然无法指望机器自己懂得交换数据的规则，那么就<strong>由我们人类给它们定义一些规则，并通过一系列的方式让机器遵守这些规则</strong>，这样在我们的帮助下，机器也就懂得如何进行数据交换了。</li><li><strong>计算机网络的通信过程必须遵守的某种&#x2F;些规则就是协议</strong></li><li><strong>不同的通信过程使用不同的协议，在计算机网络中，通信类型是多样的，所以通信协议也是多样的</strong>，我们<strong>应该根据具体的情况去选择最合适的协议来作为这种情况下数据交换的规则</strong>。</li></ul><h2 id="网络协议的定义"><a href="#网络协议的定义" class="headerlink" title="网络协议的定义"></a>网络协议的定义</h2><ul><li>网络协议(network protocol)，简称为协议，<strong>是为进行网络中的数据交换而建立的规则、标准或约定</strong>。</li><li><strong>协议规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到信息或发生的事件所采取的“动作”（actions）</strong>。</li></ul><h2 id="协议的三要素"><a href="#协议的三要素" class="headerlink" title="协议的三要素"></a>协议的三要素</h2><ol><li><strong>语法（Syntax）</strong>：规定了数据与控制信息的结构或格式以及信号电平等。</li><li><strong>语义（Semantics）</strong>：规定了需要发出何种控制信息、完成何种动作以及做出何种响应、如何进行差错控制等。</li><li><strong>时序（Timing）</strong>：规定了事件顺序、速度匹配等。</li></ol><h2 id="协议是计算机网络的重要内容"><a href="#协议是计算机网络的重要内容" class="headerlink" title="协议是计算机网络的重要内容"></a>协议是计算机网络的重要内容</h2><ul><li><p>协议规范了网络中所有信息发送和接收的过程。e.g., TCP, IP, HTTP, Skype, 802.11</p></li><li><p>协议是学习网络的重要内容之一</p></li><li><p>协议是网络创新的表现形式之一</p></li><li><p>Internet协议标准被IETF（互联网工程任务组 Internet Engineering Task </p><p>Force）规定在RFC（Request for Comments）文件中。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;什么是计算机网络？&quot;&gt;&lt;a href=&quot;#什么是计算机网络？&quot; class=&quot;headerlink&quot; title=&quot;什么是计算机网络？&quot;&gt;&lt;/a&gt;什么是计算机网络？&lt;/h</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="https://konjacor.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>五子棋网络游戏项目</title>
    <link href="https://konjacor.github.io/2022/10/16/%E4%BA%94%E5%AD%90%E6%A3%8B%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE/"/>
    <id>https://konjacor.github.io/2022/10/16/%E4%BA%94%E5%AD%90%E6%A3%8B%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-10-16T12:17:39.000Z</published>
    <updated>2022-12-20T12:11:43.203Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>突然想试试不用框架来写一个几乎是纯java的C&#x2F;S架构软件了，也是想应用一下自己学的设计模式和计网相关的知识吧。</li><li>选了个比较好写的五子棋项目，准备写个客户端，写个服务端。</li></ul><h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><h2 id="搭建项目基本结构"><a href="#搭建项目基本结构" class="headerlink" title="搭建项目基本结构"></a>搭建项目基本结构</h2><ul><li>采用了一种比较规范的项目结构。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221017201229777.png" alt="image-20221017201229777"></p><h2 id="编写棋子实体"><a href="#编写棋子实体" class="headerlink" title="编写棋子实体"></a>编写棋子实体</h2><ul><li><p>先写抽象父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.five.entity.pawn.abs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 10:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pawn</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> type;<span class="comment">//棋子类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Pawn</span><span class="params">(<span class="type">int</span> type)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getType</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再写子类，子类有黑棋子、白棋子还有一种用来表示没有棋子的空棋子，其中<strong>棋子均采用基于静态内部类实现的单例模式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************黑棋子*************************/</span></span><br><span class="line"><span class="keyword">package</span> com.konjacer.five.entity.pawn.sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.abs.Pawn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 10:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlackPawn</span> <span class="keyword">extends</span> <span class="title class_">Pawn</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private static volatile WhitePawn instance;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BlackPawn</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;<span class="comment">//利用静态内部类的加载特性实现线程安全和懒加载的单例模式</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BlackPawn</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlackPawn</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> BlackPawn <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BlackPawn.SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************白棋子*************************/</span></span><br><span class="line"><span class="keyword">package</span> com.konjacer.five.entity.pawn.sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.abs.Pawn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 10:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhitePawn</span> <span class="keyword">extends</span> <span class="title class_">Pawn</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private static volatile WhitePawn instance;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">WhitePawn</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;<span class="comment">//利用静态内部类的加载特性实现线程安全和懒加载的单例模式</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">WhitePawn</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WhitePawn</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> WhitePawn <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************空棋子*************************/</span></span><br><span class="line"><span class="keyword">package</span> com.konjacer.five.entity.pawn.sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.abs.Pawn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 11:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NullPawn</span> <span class="keyword">extends</span> <span class="title class_">Pawn</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private static volatile WhitePawn instance;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NullPawn</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;<span class="comment">//利用静态内部类的加载特性实现线程安全和懒加载的单例模式</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">NullPawn</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullPawn</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> NullPawn <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> NullPawn.SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编写棋子工厂"><a href="#编写棋子工厂" class="headerlink" title="编写棋子工厂"></a>编写棋子工厂</h2><ul><li><p>棋子工厂用来返回棋子实例，同样先需要一个抽象工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.five.factory.abs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.abs.Pawn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 11:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbsPawnFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    Pawn <span class="title function_">getGoods</span><span class="params">(<span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后就是一个<strong>基于静态内部类实现单例模式的返回棋子实例的工厂</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.five.factory.sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.abs.Pawn;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.sub.BlackPawn;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.sub.NullPawn;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.sub.WhitePawn;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.factory.abs.AbsPawnFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 11:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PawnFactory</span> <span class="keyword">implements</span> <span class="title class_">AbsPawnFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">PawnFactory</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pawn <span class="title function_">getGoods</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> NullPawn.getInstance();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> BlackPawn.getInstance();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> WhitePawn.getInstance();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PawnFactory</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PawnFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> PawnFactory <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PawnFactory.SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编写胜利监视器"><a href="#编写胜利监视器" class="headerlink" title="编写胜利监视器"></a>编写胜利监视器</h2><ul><li><p>需要一个监视器来监视棋局是否胜利，<strong>监视器和棋盘是双分派关联的关系</strong>，监视器内有方法判定当前棋局是否胜利，每当棋盘中的棋发生了变化，都会通知监视器来判断当前棋局是否满足胜利条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.five.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.chessboard.abs.ChessBoard;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.abs.Pawn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-16 20:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckVictory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChessBoard chessBoard;<span class="comment">//组合棋盘</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//private PawnFactory pawnFactory;//组合棋子工厂</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CheckVictory</span><span class="params">(ChessBoard chessBoard)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.chessBoard = chessBoard;</span><br><span class="line">        <span class="comment">//pawnFactory = PawnFactory.getInstance();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;<span class="comment">//判断刚下完的一步棋是否满足胜利条件</span></span><br><span class="line">        <span class="keyword">if</span>(((Pawn)(chessBoard.getElement(i,j))).getType()!=<span class="number">0</span>)&#123;<span class="comment">//如果当前位置不是空棋子，那就开始检查当前位置是否满足获胜条件</span></span><br><span class="line">            <span class="keyword">if</span>(checkRow(i,j) || checkColumn(i,j) || checkLeftDiagonal(i,j) || checkRightDiagonal(i,j))&#123;<span class="comment">//如果任何一个方向满足获胜条件，那就返回当前的棋子表示当前棋子类型胜利</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkRow</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> ((Pawn)(chessBoard.getElement(i,j))).getType();<span class="comment">//获取当前棋子类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//当前获胜路线上当前棋子类型的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> j-<span class="number">1</span>;<span class="comment">//通过cur遍历当前获胜路线上的棋子</span></span><br><span class="line">        <span class="keyword">while</span> (cur&gt;=<span class="number">0</span> &amp;&amp; ((Pawn)(chessBoard.getElement(i,cur))).getType()==type)&#123;<span class="comment">//向左检查</span></span><br><span class="line">            sum++;</span><br><span class="line">            cur--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否胜利</span></span><br><span class="line">        cur = j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur&lt;chessBoard.getColumn() &amp;&amp; ((Pawn)(chessBoard.getElement(i,cur))).getType()==type)&#123;<span class="comment">//向右检查</span></span><br><span class="line">            sum++;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否胜利</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkColumn</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> ((Pawn)(chessBoard.getElement(i,j))).getType();<span class="comment">//获取当前棋子类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//当前获胜路线上当前棋子类型的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> i-<span class="number">1</span>;<span class="comment">//通过cur遍历当前获胜路线上的棋子</span></span><br><span class="line">        <span class="keyword">while</span> (cur&gt;=<span class="number">0</span> &amp;&amp; ((Pawn)(chessBoard.getElement(cur,j))).getType()==type)&#123;<span class="comment">//向上检查</span></span><br><span class="line">            sum++;</span><br><span class="line">            cur--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否胜利</span></span><br><span class="line">        cur = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur&lt;chessBoard.getRow() &amp;&amp; ((Pawn)(chessBoard.getElement(cur,j))).getType()==type)&#123;<span class="comment">//向下检查</span></span><br><span class="line">            sum++;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否胜利</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkLeftDiagonal</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> ((Pawn)(chessBoard.getElement(i,j))).getType();<span class="comment">//获取当前棋子类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//当前获胜路线上当前棋子类型的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curi</span> <span class="operator">=</span> i-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curj</span> <span class="operator">=</span> j-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (curi&gt;=<span class="number">0</span> &amp;&amp; curj&gt;=<span class="number">0</span> &amp;&amp; ((Pawn)(chessBoard.getElement(curi,curj))).getType()==type)&#123;<span class="comment">//向左上检查</span></span><br><span class="line">            sum++;</span><br><span class="line">            curi--;</span><br><span class="line">            curj--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否胜利</span></span><br><span class="line">        curi = i+<span class="number">1</span>;</span><br><span class="line">        curj = j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (curi&lt;chessBoard.getRow() &amp;&amp; curj&lt;chessBoard.getColumn() &amp;&amp; ((Pawn)(chessBoard.getElement(curi,curj))).getType()==type)&#123;<span class="comment">//向右下检查</span></span><br><span class="line">            sum++;</span><br><span class="line">            curi++;</span><br><span class="line">            curj++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否胜利</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkRightDiagonal</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> ((Pawn)(chessBoard.getElement(i,j))).getType();<span class="comment">//获取当前棋子类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//当前获胜路线上当前棋子类型的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curi</span> <span class="operator">=</span> i-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curj</span> <span class="operator">=</span> j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (curi&gt;=<span class="number">0</span> &amp;&amp; curj&lt;chessBoard.getColumn() &amp;&amp; ((Pawn)(chessBoard.getElement(curi,curj))).getType()==type)&#123;<span class="comment">//向右上检查</span></span><br><span class="line">            sum++;</span><br><span class="line">            curi--;</span><br><span class="line">            curj++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否胜利</span></span><br><span class="line">        curi = i+<span class="number">1</span>;</span><br><span class="line">        curj = j-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (curi&lt;chessBoard.getRow() &amp;&amp; curj&gt;=<span class="number">0</span> &amp;&amp; ((Pawn)(chessBoard.getElement(curi,curj))).getType()==type)&#123;<span class="comment">//向左下检查</span></span><br><span class="line">            sum++;</span><br><span class="line">            curi++;</span><br><span class="line">            curj--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否胜利</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编写棋盘实体"><a href="#编写棋盘实体" class="headerlink" title="编写棋盘实体"></a>编写棋盘实体</h2><ul><li><p>五子棋是15x15的棋盘，所以用15x15的Object数组代表棋盘，和棋子一样，首先需要一个抽象父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.five.entity.chessboard.abs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-16 21:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ChessBoard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object[][] board;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ChessBoard</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        board = <span class="keyword">new</span> <span class="title class_">Object</span>[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span>&#123;<span class="comment">//重置棋盘，这里给出了默认实现，子类有需要可以重写该方法，虽然不符合里氏替换原则，但是使用起来更加灵活</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;board.length;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;board[i].length;++j)&#123;</span><br><span class="line">                board[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getElement</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;<span class="comment">//返回指定位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> board[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRow</span><span class="params">()</span>&#123;<span class="comment">//返回行数</span></span><br><span class="line">        <span class="keyword">return</span> board.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getColumn</span><span class="params">()</span>&#123;<span class="comment">//返回列数</span></span><br><span class="line">        <span class="keyword">return</span> board[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后再写五子棋棋盘，它和胜利监视器是双分派的关联关系，和棋子工厂是组合的关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.five.entity.chessboard.sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.algorithm.CheckVictory;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.chessboard.abs.ChessBoard;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.factory.abs.AbsPawnFactory;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.factory.sub.PawnFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 10:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FiveChessBoard</span> <span class="keyword">extends</span> <span class="title class_">ChessBoard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AbsPawnFactory</span> <span class="variable">pawnFactory</span> <span class="operator">=</span> PawnFactory.getInstance();<span class="comment">//棋子工厂</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CheckVictory checkVictory;<span class="comment">//组合胜利监听器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">curType</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//当前应该轮到谁下了，1是黑子，2是白子</span></span><br><span class="line"></span><br><span class="line">    FiveChessBoard()&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">15</span>,<span class="number">15</span>);</span><br><span class="line">        checkVictory = <span class="keyword">new</span> <span class="title class_">CheckVictory</span>(<span class="built_in">this</span>);<span class="comment">//双分派</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;board.length;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;board[i].length;++i)&#123;</span><br><span class="line">                board[i][j] = pawnFactory.getGoods(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">putBlack</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;<span class="comment">//放黑子，放完检查是否胜利</span></span><br><span class="line">        board[i][j] = pawnFactory.getGoods(<span class="number">1</span>);</span><br><span class="line">        curType = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> checkVictory.check(i,j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">putWhite</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;<span class="comment">//放白子，放完检查是否胜利</span></span><br><span class="line">        board[i][j] = pawnFactory.getGoods(<span class="number">2</span>);</span><br><span class="line">        curType = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> checkVictory.check(i,j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编写玩家实体"><a href="#编写玩家实体" class="headerlink" title="编写玩家实体"></a>编写玩家实体</h2><ul><li><p>编写抽象玩家类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.five.entity.player.abs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 19:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写五子棋玩家类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.five.entity.player.sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.player.abs.Player;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 19:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FivePlayer</span> <span class="keyword">extends</span> <span class="title class_">Player</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> roleType;<span class="comment">//角色执子，1为黑子，2为白子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FivePlayer</span><span class="params">(<span class="type">int</span> roleType)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.roleType = roleType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;突然想试试不用框架来写一个几乎是纯</summary>
      
    
    
    
    
    <category term="项目" scheme="https://konjacor.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="java" scheme="https://konjacor.github.io/tags/java/"/>
    
    <category term="网络编程" scheme="https://konjacor.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="游戏" scheme="https://konjacor.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis入门</title>
    <link href="https://konjacor.github.io/2022/10/05/Redis%E5%85%A5%E9%97%A8/"/>
    <id>https://konjacor.github.io/2022/10/05/Redis%E5%85%A5%E9%97%A8/</id>
    <published>2022-10-05T03:17:52.000Z</published>
    <updated>2022-12-20T12:11:43.200Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="NoSQL数据库简介"><a href="#NoSQL数据库简介" class="headerlink" title="NoSQL数据库简介"></a>NoSQL数据库简介</h1><h2 id="技术的发展以及用户增多带来的压力使得NoSQL数据库成为需求"><a href="#技术的发展以及用户增多带来的压力使得NoSQL数据库成为需求" class="headerlink" title="技术的发展以及用户增多带来的压力使得NoSQL数据库成为需求"></a>技术的发展以及用户增多带来的压力使得NoSQL数据库成为需求</h2><h3 id="技术发展"><a href="#技术发展" class="headerlink" title="技术发展"></a>技术发展</h3><ul><li>技术的分类：<ol><li>解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</li><li>解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis</li><li>解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</li></ol></li></ul><h3 id="Web1-0时代"><a href="#Web1-0时代" class="headerlink" title="Web1.0时代"></a>Web1.0时代</h3><ul><li><p>Web1.0的时代，数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005112404492.png" alt="image-20221005112404492"></p></li></ul><h3 id="Web2-0时代"><a href="#Web2-0时代" class="headerlink" title="Web2.0时代"></a>Web2.0时代</h3><ul><li><p>随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005112518190.png" alt="image-20221005112518190"></p></li></ul><h3 id="缓解CPU及内存压力"><a href="#缓解CPU及内存压力" class="headerlink" title="缓解CPU及内存压力"></a>缓解CPU及内存压力</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005112604896.png" alt="image-20221005112604896"></p><h3 id="缓解IO压力"><a href="#缓解IO压力" class="headerlink" title="缓解IO压力"></a>缓解IO压力</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005112629768.png" alt="image-20221005112629768"></p><h2 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h2><h3 id="NoSQL数据库概述"><a href="#NoSQL数据库概述" class="headerlink" title="NoSQL数据库概述"></a>NoSQL数据库概述</h3><ul><li><p>NoSQL(NoSQL &#x3D; <strong>Not Only SQL</strong> )，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。 NoSQL <strong>不依赖业务逻辑方式存储，而以简单的key-value模式存储</strong>。因此大大的增加了数据库的扩展能力。</p></li><li><p>NoSQL数据库不遵循SQL标准</p></li><li><p>NoSQL数据库不支持ACID</p></li><li><p>NoSQL数据库有着远超于SQL的性能</p></li></ul><h3 id="NoSQL数据库的适用场景"><a href="#NoSQL数据库的适用场景" class="headerlink" title="NoSQL数据库的适用场景"></a>NoSQL数据库的适用场景</h3><ul><li>对数据高并发的读写的场景</li><li>海量数据的读写的场景</li><li>对数据有高可扩展性的要求的场景</li><li>用不着sql和用了sql也不行的情况，可以考虑使用NoSQL</li></ul><h3 id="NoSQL数据库不适用的场景"><a href="#NoSQL数据库不适用的场景" class="headerlink" title="NoSQL数据库不适用的场景"></a>NoSQL数据库不适用的场景</h3><ul><li>需要事务支持的场景</li><li>基于sql的结构化查询存储，处理复杂的关系，需要<strong>即席查询</strong>的场景。</li></ul><h2 id="常见的NoSQL数据库"><a href="#常见的NoSQL数据库" class="headerlink" title="常见的NoSQL数据库"></a>常见的NoSQL数据库</h2><h3 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005113605921.png" alt="image-20221005113605921"></p><ul><li><strong>很早出现</strong>的NoSQL数据库</li><li>数据都在内存中，一般<strong>不持久化</strong></li><li>支持简单的key-value模式，<strong>支持类型单一</strong></li><li>一般是作为<strong>缓存数据库</strong>辅助持久化的数据库</li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005113855265.png" alt="image-20221005113855265"></p><ul><li>几乎覆盖了Memcached的绝大部分功能</li><li>数据都在内存中，<strong>支持持久化</strong>，主要用作备份恢复</li><li>除了支持简单的key-value模式，还<strong>支持多种数据结构的存储</strong>，比如 list、set、hash、zset等。</li><li>一般是作为<strong>缓存数据库</strong>辅助持久化的数据库</li></ul><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005114004041.png" alt="image-20221005114004041"></p><ul><li>高性能、开源、模式自由(schema  free)的<strong>文档型数据库</strong></li><li>数据都在内存中， 如果内存不足，<strong>把不常用的数据保存到硬盘</strong></li><li>虽然是key-value模式，但是<strong>对value（尤其是json）提供了丰富的查询功能</strong></li><li><strong>支持二进制数据及大型对象</strong></li><li>可以根据数据的特点<strong>替代RDBMS</strong>，成为独立的数据库。或者<strong>配合RDBMS</strong>，存储特定的数据。</li></ul><h3 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005114922236.png" alt="image-20221005114922236"></p><ul><li>HBase是<strong>Hadoop项目中的数据库</strong>。它<strong>用于需要对大量的数据进行随机、实时的读写操作的场景中</strong>。</li><li>HBase的目标就是<strong>处理数据量非常庞大的表</strong>，可以用普通的计算机处理超过<strong>10亿行数据</strong>，还可处理有<strong>数百万列元素</strong>的数据表。</li></ul><h3 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005115202672.png" alt="image-20221005115202672"></p><ul><li>Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于<strong>管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到PB级别)<strong>。在众多显著特性当中，Cassandra</strong>最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程</strong>。</li><li>计算机存储单位 计算机存储单位一般用bit，B，KB，MB，GB，TB，EB，ZB，YB，BB来表示，它们之间的关系是：除了1B&#x3D;8bit，其它的都是1024进制。（注：“兆”是百万级数量单位）</li></ul><h2 id="大数据时代使得行式存储数据库成为需求"><a href="#大数据时代使得行式存储数据库成为需求" class="headerlink" title="大数据时代使得行式存储数据库成为需求"></a>大数据时代使得行式存储数据库成为需求</h2><h3 id="行式数据库"><a href="#行式数据库" class="headerlink" title="行式数据库"></a>行式数据库</h3><ul><li>按行存储，这样的结构使得查询特定信息时速度很快，但是在求很多记录的某属性的数据特征的时候速度就有点不尽人意了。<img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005114528568.png" alt="image-20221005114528568"></li></ul><h3 id="列式数据库"><a href="#列式数据库" class="headerlink" title="列式数据库"></a>列式数据库</h3><ul><li><p>按列存储，这样的结构使得求多记录的某属性的数据特征的时候速度很快， 但是在查询特定信息时速度有点不尽人意。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005114816603.png" alt="image-20221005114816603"></p></li></ul><h2 id="图关系型数据库"><a href="#图关系型数据库" class="headerlink" title="图关系型数据库"></a>图关系型数据库</h2><h3 id="Noe4j"><a href="#Noe4j" class="headerlink" title="Noe4j"></a>Noe4j</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005115736182.png" alt="image-20221005115736182"></p><ul><li><p>主要应用：社会关系、公共交通网络、地图及网络拓扑(n*(n-1)&#x2F;2)</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005115903720.png" alt="image-20221005115903720"></p></li></ul><h2 id="DB-Engines数据库排名"><a href="#DB-Engines数据库排名" class="headerlink" title="DB-Engines数据库排名"></a>DB-Engines数据库排名</h2><ul><li><p><a href="http://db-engines.com/en/ranking">http://db-engines.com/en/ranking</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005120026236.png" alt="image-20221005120026236"></p></li></ul><h1 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h1><ul><li>Redis是一个<strong>开源的key-value存储系统</strong>。</li><li>和Memcached类似，它<strong>支持存储的value类型相对更多</strong>，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。</li><li>这些数据类型都<strong>支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作</strong>，而且<strong>这些操作都是原子性的</strong>。</li><li>在此基础上，<strong>Redis支持各种不同方式的排序</strong>。</li><li>与memcached一样，<strong>为了保证效率，数据都是缓存在内存中</strong>。区别的是<strong>Redis会按照要求周期性地把更新的数据写入磁盘或者把修改操作写入追加的记录文件</strong>。</li><li>并且在此基础上<strong>实现了master-slave(主从)同步</strong>。</li></ul><h1 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h1><h3 id="配合关系型数据库做高速缓存"><a href="#配合关系型数据库做高速缓存" class="headerlink" title="配合关系型数据库做高速缓存"></a>配合关系型数据库做高速缓存</h3><ul><li><p>缓存<strong>高频次、热门访问</strong>的数据，从而<strong>降低数据库的IO压力</strong></p></li><li><p>利用分布式的架构，做<strong>session共享</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005121420678.png" alt="image-20221005121420678"></p></li></ul><h3 id="用多样的数据结构存储持久化数据"><a href="#用多样的数据结构存储持久化数据" class="headerlink" title="用多样的数据结构存储持久化数据"></a>用多样的数据结构存储持久化数据</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005121553991.png" alt="image-20221005121553991"></p><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><table><thead><tr><th>Redis官方网站</th><th>Redis中文官方网站</th></tr></thead><tbody><tr><td><a href="http://redis.io/">http://redis.io</a></td><td><a href="http://redis.cn/">http://redis.cn/</a></td></tr></tbody></table><h2 id="安装版本"><a href="#安装版本" class="headerlink" title="安装版本"></a>安装版本</h2><ul><li>Linux无脑装最新版就行了，不用考虑在windows环境下对Redis的支持，因为Redis官方根本就没出windows的客户端，要想在windows运行Redis，要去github下载一个微软做了适配的Redis版本，不过那个版本就很低了。</li><li>下面的安装步骤是针对Linux操作系统的。</li></ul><h2 id="安装步骤（Linux）"><a href="#安装步骤（Linux）" class="headerlink" title="安装步骤（Linux）"></a>安装步骤（Linux）</h2><h3 id="准备工作：下载安装最新版的gcc编译器"><a href="#准备工作：下载安装最新版的gcc编译器" class="headerlink" title="准备工作：下载安装最新版的gcc编译器"></a>准备工作：下载安装最新版的gcc编译器</h3><ul><li><p>安装C语言的编译环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br><span class="line">yum install -y devtoolset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash #这个只是暂时修改了gcc的版本为8，当会话结束时gcc的版本会恢复默认</span><br></pre></td></tr></table></figure></li><li><p>测试gcc版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221006093350737.png" alt="image-20221006093350737"></p></li></ul><h3 id="从官网下载redis-6-2-1-tar-gz放到自己想放的目录"><a href="#从官网下载redis-6-2-1-tar-gz放到自己想放的目录" class="headerlink" title="从官网下载redis-6.2.1.tar.gz放到自己想放的目录"></a>从官网下载redis-6.2.1.tar.gz放到自己想放的目录</h3><ul><li>下载支持linux的最新版就行了，linux压缩文件的后缀是**.tar.gz**</li></ul><h3 id="解压压缩文件"><a href="#解压压缩文件" class="headerlink" title="解压压缩文件"></a>解压压缩文件</h3><ul><li>先移动到刚才压缩包所在的目录下，用解压命令：<strong>tar -zxvf redis-6.2.1.tar.gz</strong>进行解压</li></ul><h3 id="进入解压完成后的目录"><a href="#进入解压完成后的目录" class="headerlink" title="进入解压完成后的目录"></a>进入解压完成后的目录</h3><ul><li>用cd命令</li></ul><h3 id="编译文件"><a href="#编译文件" class="headerlink" title="编译文件"></a>编译文件</h3><ul><li>在解压完成后的目录下执行<strong>make</strong>命令将文件编译好。</li><li>如果没有准备好C语言的编译环境，make会报错：Jemalloc&#x2F;jemalloc.h：没有那个文件，解决方案：运行<strong>make distclean</strong>，然后再次执行<strong>make</strong>命令</li></ul><h3 id="安装文件"><a href="#安装文件" class="headerlink" title="安装文件"></a>安装文件</h3><ul><li>继续在当前目录下执行<strong>make install</strong>命令</li><li>安装目录：**&#x2F;usr&#x2F;local&#x2F;bin**</li></ul><h2 id="在默认安装目录查看安装结果"><a href="#在默认安装目录查看安装结果" class="headerlink" title="在默认安装目录查看安装结果"></a>在默认安装目录查看安装结果</h2><ul><li>以下是常用文件：<ol><li>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</li><li>redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲</li><li>redis-check-dump：修复有问题的dump.rdb文件</li><li>redis-sentinel：Redis集群使用</li><li>redis-server：Redis服务器启动命令</li><li>redis-cli：客户端，操作入口</li></ol></li></ul><h2 id="前台启动（不推荐）"><a href="#前台启动（不推荐）" class="headerlink" title="前台启动（不推荐）"></a>前台启动（不推荐）</h2><ul><li><p>如果使用前台启动，那么命令行窗口不能关闭，否则服务器停止。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221006095121261.png" alt="image-20221006095121261"></p></li></ul><h2 id="后台启动（推荐）"><a href="#后台启动（推荐）" class="headerlink" title="后台启动（推荐）"></a>后台启动（推荐）</h2><h3 id="备份redis-conf"><a href="#备份redis-conf" class="headerlink" title="备份redis.conf"></a>备份redis.conf</h3><ul><li>拷贝一份redis.conf到其他目录：<strong>cp 文件目录 想要复制到的目录</strong></li></ul><h3 id="在redis-conf中将后台启动设置daemonize-no改成yes"><a href="#在redis-conf中将后台启动设置daemonize-no改成yes" class="headerlink" title="在redis.conf中将后台启动设置daemonize no改成yes"></a>在redis.conf中将后台启动设置daemonize no改成yes</h3><ul><li>修改redis.conf(128行左右)文件将里面的daemonize no 改成 yes，允许服务默认在后台启动</li></ul><h3 id="选择配置文件启动Redis"><a href="#选择配置文件启动Redis" class="headerlink" title="选择配置文件启动Redis"></a>选择配置文件启动Redis</h3><ul><li>使用命令：<strong>redis-server 配置文件相对路径</strong>，由于配置了后台启动，所以这次启动是后台启动，可以用<strong>ps -ef | grep redis</strong>命令来查询信息中含有redis的进程来查看启动结果。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221006095817088.png" alt="image-20221006095817088"></p><h3 id="用客户端访问"><a href="#用客户端访问" class="headerlink" title="用客户端访问"></a>用客户端访问</h3><ul><li><p>在安装目录下运行<strong>redis-cli</strong>，就可以以默认端口号访问到redis服务</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221006100350168.png" alt="image-20221006100350168"></p></li><li><p>如果想要以特定端口号访问redis服务可以这样写：<strong>redis-cli -p端口号</strong></p></li></ul><h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><ul><li><p>使用ping命令，如果回复是PONG说明连通了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221006100419596.png" alt="image-20221006100419596"></p></li></ul><h3 id="关闭Redis"><a href="#关闭Redis" class="headerlink" title="关闭Redis"></a>关闭Redis</h3><ul><li><p>单实例关闭：<strong>redis-cli shutdown</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221006100454106.png" alt="image-20221006100454106"></p></li><li><p>也可以进入redis的客户端后再使用<strong>shutdown</strong>命令关闭</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221006100547655.png" alt="image-20221006100547655"></p></li><li><p>多实例关闭、指定端口关闭：<strong>redis-cli -p 端口号 shutdown</strong></p></li></ul><h1 id="Redis相关知识"><a href="#Redis相关知识" class="headerlink" title="Redis相关知识"></a>Redis相关知识</h1><ul><li><p>Redis的默认端口6379有来头，可以上网搜搜</p></li><li><p>Redis默认有16个数据库，类似数组下标从0开始，初始<strong>默认使用0号库</strong></p></li><li><p>使用命令**select &lt;dbid&gt;**来切换数据库，如：select 8</p></li><li><p>统一密码管理，<strong>所有库都是同样的密码</strong></p></li><li><p>用<strong>dbsize</strong>命令查看当前数据库的key的数量</p></li><li><p>用<strong>flushdb</strong>清空当前库</p></li><li><p>用<strong>flushall</strong>通杀全部库</p></li><li><p>Redis是<strong>单线程+多路IO复用技术</strong>，多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）</p></li><li><p>串行  vs  多线程+锁（memcached） vs  单线程+多路IO复用(Redis) ，他们三个各有什么优劣？</p></li><li><p>与Memcache的三点不同：redis支持多数据类型，redis支持持久化，redis采用单线程+多路IO复用的形式</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221006104716983.png" alt="image-20221006104716983"></p></li></ul><h1 id="常用五大数据类型"><a href="#常用五大数据类型" class="headerlink" title="常用五大数据类型"></a>常用五大数据类型</h1><ul><li>获得redis常见数据类型操作命令：<a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></li></ul><h2 id="Redis键（key）"><a href="#Redis键（key）" class="headerlink" title="Redis键（key）"></a>Redis键（key）</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>keys *：查看当前库所有key   (匹配：keys *1)</li><li>exists key：判断某个key是否存在</li><li>type key：查看你的key是什么类型</li><li>del key： 删除指定的key数据</li><li>unlink key：  根据value选择非阻塞删除，仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</li><li>expire key 10：为给定的key设置过期时间为10秒钟</li><li>ttl key： 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li><li>select：命令切换数据库</li><li>dbsize：查看当前数据库的key的数量</li><li>flushdb：清空当前库</li><li>flushall：通杀全部库</li></ul><h2 id="Redis字符串（String）"><a href="#Redis字符串（String）" class="headerlink" title="Redis字符串（String）"></a>Redis字符串（String）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，<strong>一个key对应一个value</strong>。</li><li>String类型<strong>是二进制安全的</strong>。意味着Redis的string<strong>可以包含任何数据</strong>。比如jpg图片或者序列化的对象。</li><li>String类型是Redis最基本的数据类型，一个Redis中字符串value<strong>最多可以是512M</strong></li></ul><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221007103952053.png" alt="image-20221007103952053"></p><ul><li>所谓原子操作是指不会被线程调度机制打断的操作，<strong>这种操作一旦开始，就一直运行到结束</strong>，中间不会有任何context switch（切换到另外一个线程）。原子操作原本指不可再分的操作，但是对于可再分的操作我们可以通过一些手段让他表现出不可再分的特性，所以对于这种操作我们也称其为原子操作。</li><li><strong>在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间</strong>。</li><li><strong>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作</strong>。</li><li>Redis单命令的原子性主要得益于Redis的单线程。</li></ul><h3 id="原子性的案例"><a href="#原子性的案例" class="headerlink" title="原子性的案例"></a>原子性的案例</h3><ul><li><p>问：java中的i++是否是原子操作？</p></li><li><p>答：不是原子操作，尽管从代码上来看，i++似乎是一个不可分割的操作，但是底层在执行这个操作的时候实际上是分了好几步的：</p><ol><li>从内存中读i到寄存器</li><li>在寄存器中让i自增</li><li>将寄存器中的i写回内存</li></ol><p>java是一个支持多线程的语言，<strong>若不实行一些同步措施那么在i++执行上面的任意一个步骤的时候别的线程也有可能同时在操作i自变量</strong>，所以最后的结果可能不是预期的结果。</p></li><li><p>问：java中令i&#x3D;0，两个线程分别对i进行++100次，值是多少？</p></li><li><p>答：2-200都有可能，因为根据上个问题的答案，任何一次++操作的第三步操作之后都有可能被别的线程的++操作的第三步操作覆盖。（答案是对，但是解析不确定，之后懂了再回来改吧）</p></li></ul><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><p>set  &lt;key&gt; &lt;value&gt;：添加键值对</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221007103011842.png" alt="image-20221007103011842"></p><ul><li>NX：当数据库中key不存在时，可以将key-value添加到数据库</li><li>XX：当数据库中key存在时，可以将key-value添加到数据库，与NX参数互斥</li><li>EX：key的超时秒数</li><li>PX：key的超时毫秒数，与EX互斥</li></ul></li><li><p>get  &lt;key&gt;：查询对应键值</p></li><li><p>append  &lt;key&gt; &lt;value&gt;：将给定的&lt;value&gt; 追加到原值的末尾</p></li><li><p>strlen  &lt;key&gt;：获得值的长度</p></li><li><p>setnx  &lt;key&gt; &lt;value&gt;：只有在 key 不存在时   设置 key 的值 </p></li><li><p>incr  &lt;key&gt;：将 key 中储存的数字值增1，只能对数字值操作，如果为空，新增值为1</p></li><li><p>decr  &lt;key&gt;：将 key 中储存的数字值减1，只能对数字值操作，如果为空，新增值为-1</p></li><li><p>incrby &#x2F; decrby  &lt;key&gt; &lt;步长&gt;：将 key 中储存的数字值增减。自定义步长。</p></li><li><p>mset  &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt;  ….. ：同时设置一个或多个 key-value对  </p></li><li><p>mget  &lt;key1&gt; &lt;key2&gt; &lt;key3&gt; …..：同时获取一个或多个 value  </p></li><li><p>msetnx &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt;  ….. ：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。原子性，有一个失败则都失败</p></li><li><p>getrange  &lt;key&gt; &lt;起始位置&gt; &lt;结束位置&gt;：获得值的范围，类似java中的substring，前包，后包</p></li><li><p>setrange  &lt;key&gt; &lt;起始位置&gt; &lt;value&gt;：用 &lt;value&gt;  覆写&lt;key&gt;所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。</p></li><li><p>setex  &lt;key&gt; &lt;过期时间&gt; &lt;value&gt;：设置键值的同时，设置过期时间，单位秒。</p></li><li><p>getset &lt;key&gt; &lt;value&gt;：以新换旧，设置了新值同时获得旧值。</p></li></ul><h3 id="String数据结构"><a href="#String数据结构" class="headerlink" title="String数据结构"></a>String数据结构</h3><ul><li><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，<strong>采用预分配冗余空间的方式来减少内存的频繁分配</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221007110816409.png" alt="image-20221007110816409"></p></li><li><p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。<strong>当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M</strong>。</p></li></ul><h2 id="Redis列表（List）"><a href="#Redis列表（List）" class="headerlink" title="Redis列表（List）"></a>Redis列表（List）</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>List列表是采用<strong>单键多值</strong>的方式进行存储的，是简单的字符串列表，元素按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</li><li>它的底层实际是个双向链表，对两端的操作性能很高，但通过索引下标的操作中间的节点性能会较差。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221008101337715.png" alt="image-20221008101337715"></p><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>lpush&#x2F;rpush  &lt;key&gt; &lt;value1&gt; &lt;value2&gt; &lt;value3&gt; …. ：从左边&#x2F;右边插入一个或多个值。</li><li>lpop&#x2F;rpop  &lt;key&gt;：从左边&#x2F;右边吐出一个值。值在键在，值光键亡。</li><li>rpoplpush  &lt;key1&gt; &lt;key2&gt;：从&lt;key1&gt;列表右边吐出一个值，插到&lt;key2&gt;列表左边。</li><li>lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;：按照索引下标获得元素(从左到右)</li><li>lrange mylist 0 -1：  0左边第一个，-1右边第一个，（0-1表示获取所有）</li><li>lindex &lt;key&gt; &lt;index&gt;：按照索引下标获得元素(从左到右)</li><li>llen &lt;key&gt;：获得列表长度 </li><li>linsert &lt;key&gt;  before &lt;value&gt; &lt;newvalue&gt;：在&lt;value&gt;的后面插入&lt;newvalue&gt;插入值</li><li>lrem &lt;key&gt; &lt;n&gt; &lt;value&gt;：从左边删除n个value(从左到右)</li><li>lset &lt;key&gt; &lt;index&gt; &lt;value&gt;：将列表key下标为index的值替换成value</li></ul><h3 id="List数据结构"><a href="#List数据结构" class="headerlink" title="List数据结构"></a>List数据结构</h3><ul><li><p>List的数据结构为<strong>快速链表quickList</strong>。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是<strong>ziplist</strong>，也即是<strong>压缩列表</strong>。它将所有的元素紧挨着一起存储，<strong>分配的是一块连续的内存</strong>。当<strong>数据量比较多的时候才会改成quicklist</strong>。</p></li><li><p>因为<strong>普通的链表需要的附加指针空间太大，会比较浪费空间</strong>。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221008101933655.png" alt="image-20221008101933655"></p><p>Redis将链表和ziplist结合起来组成了quicklist。也就是<strong>将多个ziplist使用双向指针串起来使用</strong>。这样<strong>既满足了快速的插入删除性能，又不会出现太大的空间冗余</strong>。</p></li></ul><h2 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul><li>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且<strong>set提供了判断某个成员是否在一个set集合内的重要接口</strong>，这个也是list所不能提供的。</li><li>Redis的<strong>Set是string类型的无序集合</strong>。它<strong>底层其实是一个value为null的hash表</strong>，所以添加，删除，查找的**复杂度都是O(1)**。</li><li>一个算法，随着数据的增加，执行时间的长短也可能会有变化，但复杂度如果是O(1)，数据增加，查找数据的时间不变。</li></ul><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>sadd &lt;key&gt; &lt;value1&gt; &lt;value2&gt; ….. ：将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</li><li>smembers &lt;key&gt;：取出该集合的所有值。</li><li>sismember &lt;key&gt; &lt;value&gt;：判断集合&lt;key&gt;是否为含有该&lt;value&gt;值，有1，没有0</li><li>scard &lt;key&gt;：返回该集合的元素个数。</li><li>srem &lt;key&gt; &lt;value1&gt; &lt;value2&gt; …. ：删除集合中的某个元素。</li><li>spop &lt;key&gt;：<strong>随机从该集合中吐出一个值。</strong></li><li>srandmember &lt;key&gt; &lt;n&gt;：随机从该集合中取出n个值。不会从集合中删除 。</li><li>smove &lt;source&gt; &lt;destination&gt;：value把集合中一个值从一个集合移动到另一个集合</li><li>sinter &lt;key1&gt; &lt;key2&gt;：返回两个集合的交集元素。</li><li>sunion &lt;key1&gt; &lt;key2&gt;：返回两个集合的并集元素。</li><li>sdiff &lt;key1&gt; &lt;key2&gt;：返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)</li></ul><h3 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h3><ul><li>Set数据结构是<strong>dict字典</strong>，字典<strong>是用哈希表实现</strong>的。</li><li>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，<strong>它的内部也使用hash结构，所有的value都指向同一个内部值</strong>。</li></ul><h2 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><ul><li><p>Redis hash 是一个<strong>键值对集合</strong>。</p></li><li><p>Redis hash是一个<strong>string类型的field和value的映射表</strong>，hash特别<strong>适合用于存储对象</strong>。<strong>类似Java里面的Map&lt;String,Object&gt;</strong></p></li><li><p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key&#x2F;value结构来存储，主要有以下两种存储方式：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221008105151907.png" alt="image-20221008105151907"></p><p>使用Redis hash来存储，解决了上述两种方式的问题：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221008105233869.png" alt="image-20221008105233869"></p></li></ul><h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>hset &lt;key&gt; &lt;field&gt; &lt;value&gt;：给&lt;key&gt;集合中的&lt;field&gt;键赋值&lt;value&gt;</li><li>hget &lt;key1&gt; &lt;field&gt;：从&lt;key1&gt;集合&lt;field&gt;取出 value </li><li>hmset &lt;key1&gt; &lt;field1&gt; &lt;value1&gt; &lt;field2&gt; &lt;value2&gt;… ：批量设置hash的值</li><li>hexists &lt;key1&gt; &lt;field&gt;：查看哈希表 key 中，给定域 field 是否存在。 </li><li>hkeys &lt;key&gt;：列出该hash集合的所有field</li><li>hvals &lt;key&gt;：列出该hash集合的所有value</li><li>hincrby &lt;key&gt; &lt;field&gt; &lt;increment&gt;：为哈希表 key 中的域 field 的值加上增量 1  -1</li><li>hsetnx &lt;key&gt; &lt;field&gt; &lt;value&gt;：将哈希表 key 中的域 field 的值设置为 value ，当且仅当域field 不存在</li></ul><h3 id="Hash数据结构"><a href="#Hash数据结构" class="headerlink" title="Hash数据结构"></a>Hash数据结构</h3><ul><li>Hash类型对应的数据结构是两种：<strong>ziplist（压缩列表），hashtable（哈希表）</strong>。<strong>当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable</strong>。</li></ul><h2 id="Redis有序集合Zset-sorted-set"><a href="#Redis有序集合Zset-sorted-set" class="headerlink" title="Redis有序集合Zset(sorted set)"></a>Redis有序集合Zset(sorted set)</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><ul><li>Redis有序集合zset与普通集合set非常相似，是一个<strong>没有重复元素的字符串集合</strong>。</li><li>不同之处是有序集合的<strong>每个成员都关联了一个评分（score）</strong>,这个评分（score）被<strong>用来按照从最低分到最高分的方式排序集合中的成员</strong>。<strong>集合的成员是唯一的</strong>，但是<strong>评分可以是重复</strong>的 。</li><li>因为元素是有序的, 所以你也<strong>可以很快的根据评分（score）或者次序（position）来获取一个范围的元素</strong>。</li><li><strong>访问有序集合的中间元素也是非常快</strong>的,因此你<strong>能够使用有序集合作为一个没有重复成员的智能列表</strong>。</li></ul><h3 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a>常用命令</h3><h3 id="Zset数据结构"><a href="#Zset数据结构" class="headerlink" title="Zset数据结构"></a>Zset数据结构</h3><ul><li>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，<strong>不能有重复的key，并且可以给每一个元素value赋予一个权重score</strong>，另一方面它又类似于TreeSet，<strong>内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表</strong>。</li><li>zset底层使用了两个数据结构：<ol><li>hash，<strong>hash的作用就是关联元素value和权重score，保障元素value的唯一性</strong>，可以通过元素value找到相应的score值。</li><li>跳跃表，<strong>跳跃表的目的在于给元素value排序，根据score的范围获取元素列表</strong>。</li></ol></li></ul><h3 id="跳跃表（跳表）"><a href="#跳跃表（跳表）" class="headerlink" title="跳跃表（跳表）"></a>跳跃表（跳表）</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><ul><li>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。<strong>跳跃表效率堪比红黑树，实现远比红黑树简单</strong>。</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul><li><p>对比有序链表和跳跃表，从链表中查询出51</p></li><li><p>有序链表：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221008111754655.png" alt="image-20221008111754655"></p><p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p></li><li><p>跳跃表：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221008111823462.png" alt="image-20221008111823462"></p><p>从第2层开始，1节点比51节点小，向后比较。</p><p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</p><p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</p><p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p></li><li><p>从此可以看出<strong>跳跃表比有序链表效率要高</strong></p></li></ul><h1 id="Redis配置文件介绍"><a href="#Redis配置文件介绍" class="headerlink" title="Redis配置文件介绍"></a>Redis配置文件介绍</h1><ul><li>配置文件名称：redis.conf</li></ul><h2 id="Units-单位"><a href="#Units-单位" class="headerlink" title="Units 单位"></a>Units 单位</h2><ul><li><p>配置大小单位,开头定义了一些基本的度量单位，<strong>只支持bytes，不支持bit</strong>，<strong>大小写不敏感</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009104414297.png" alt="image-20221009104414297"></p></li></ul><h2 id="INCLUDES-包含"><a href="#INCLUDES-包含" class="headerlink" title="INCLUDES 包含"></a>INCLUDES 包含</h2><ul><li><p>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来，之后可以通过直接include那个配置文件来引入那个配置文件的相关配置。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009104601357.png" alt="image-20221009104601357"></p></li></ul><h2 id="网络相关配置"><a href="#网络相关配置" class="headerlink" title="网络相关配置"></a>网络相关配置</h2><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><ul><li><p>默认情况bind&#x3D;127.0.0.1只能接受本机的访问请求，不写的情况下，无限制接受任何ip地址的访问。</p></li><li><p>生产环境肯定要写你应用服务器的地址；<strong>服务器是需要远程访问的，所以需要将其注释掉</strong></p></li><li><p><strong>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009105041816.png" alt="image-20221009105041816"></p></li><li><p>注：修改完配置之后需要<strong>保存配置、停止服务、重新启动服务</strong>才能生效。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009105239588.png" alt="image-20221009105239588"></p></li></ul><h3 id="protected-mode"><a href="#protected-mode" class="headerlink" title="protected-mode"></a>protected-mode</h3><ul><li><p>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应。</p></li><li><p>在开发阶段建议先把这个选项设置为no</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009110217704.png" alt="image-20221009110217704"></p></li></ul><h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><ul><li><p>设置redis服务的端口号，默认为6379。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009110033805.png" alt="image-20221009110033805"></p></li></ul><h3 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp-backlog"></a>tcp-backlog</h3><ul><li><p>设置tcp的backlog，backlog其实是一个连接队列，<strong>backlog队列总和&#x3D;未完成三次握手队列 + 已经完成三次握手队列</strong>。</p></li><li><p>在<strong>高并发环境下你需要一个高backlog值来避免慢客户端连接问题</strong>。</p></li><li><p>注意Linux内核会将这个值减小到&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn的值（128），所以<strong>需要确认增大&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn和&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog（128）两个值来达到想要的效果</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009110702327.png" alt="image-20221009110702327"></p></li></ul><h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><ul><li><p>设置<strong>一个空闲的客户端维持多少秒会关闭</strong>，0表示关闭该功能。即永不关闭。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009110740091.png" alt="image-20221009110740091"></p></li></ul><h3 id="tcp-keepalive"><a href="#tcp-keepalive" class="headerlink" title="tcp-keepalive"></a>tcp-keepalive</h3><ul><li><p>对访问客户端的一种心跳检测，每个n秒检测一次，<strong>如果没有心跳即没有请求了，那么就关闭tcp通道</strong>。</p></li><li><p>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009110922733.png" alt="image-20221009110922733"></p></li></ul><h2 id="GENERAL-通用"><a href="#GENERAL-通用" class="headerlink" title="GENERAL 通用"></a>GENERAL 通用</h2><h3 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a>daemonize</h3><ul><li><p>启动时是否是后台启动，设置为yes后，启动redis服务端的时候就会在后台启动。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009111238488.png" alt="image-20221009111238488"></p></li></ul><h3 id="pidfile"><a href="#pidfile" class="headerlink" title="pidfile"></a>pidfile</h3><ul><li><p>存放pid文件的位置，<strong>每个redis进程实例会产生一个不同的pid文件</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009111407502.png" alt="image-20221009111407502"></p></li></ul><h3 id="loglevel"><a href="#loglevel" class="headerlink" title="loglevel"></a>loglevel</h3><ul><li><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，<strong>默认为notice</strong>，越往左输出的内容越详细。</p></li><li><p>四个级别根据使用阶段来选择，生产环境选择notice 或者warning</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009111548869.png" alt="image-20221009111548869"></p></li></ul><h3 id="logfile"><a href="#logfile" class="headerlink" title="logfile"></a>logfile</h3><ul><li><p>日志文件名称</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009111619547.png" alt="image-20221009111619547"></p></li></ul><h3 id="databases-16"><a href="#databases-16" class="headerlink" title="databases 16"></a>databases 16</h3><ul><li><p><strong>设定库的数量</strong>默认16，默认数据库为0，<strong>可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009111723684.png" alt="image-20221009111723684"></p></li></ul><h2 id="SECURITY-安全"><a href="#SECURITY-安全" class="headerlink" title="SECURITY 安全"></a>SECURITY 安全</h2><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><ul><li><p>可以在配置文件的<strong>requirepass后面设置访问密码</strong>，也可以使用命令设置密码，但是使用命令设置的密码只是临时的，如果重启redis服务器，密码会被还原，<strong>如果需要永久设置密码，需要在配置文件中进行设置</strong>。</p></li><li><p>在配置文件中设置密码：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009113843381.png" alt="image-20221009113843381"></p></li><li><p>使用命令查看访问密码、修改访问密码、登录：<br><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009113913607.png" alt="image-20221009113913607"></p></li></ul><h2 id="LIMITS-限制"><a href="#LIMITS-限制" class="headerlink" title="LIMITS 限制"></a>LIMITS 限制</h2><h3 id="maxclients"><a href="#maxclients" class="headerlink" title="maxclients"></a>maxclients</h3><ul><li><p><strong>设置redis同时可以与多少个客户端进行连接</strong>。</p></li><li><p>默认情况下为10000个客户端。</p></li><li><p>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009112836144.png" alt="image-20221009112836144"></p></li></ul><h3 id="maxmemory"><a href="#maxmemory" class="headerlink" title="maxmemory"></a>maxmemory</h3><ul><li><p>设置<strong>redis可以使用的内存量</strong>。一旦到达内存使用上限，redis将会试图移除内部数据，<strong>移除规则可以通过maxmemory-policy来指定</strong>。</p></li><li><p>建议<strong>必须设置</strong>，否则将内存占满可能会造成服务器宕机。</p></li><li><p>如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</p></li><li><p>但是对于无内存申请的指令，仍然会正常响应，比如GET等。<strong>如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009114449510.png" alt="image-20221009114449510"></p></li></ul><h3 id="maxmemory-policy"><a href="#maxmemory-policy" class="headerlink" title="maxmemory-policy"></a>maxmemory-policy</h3><ul><li><p>设置<strong>redis到达内存使用上限后的行为规则</strong>。</p></li><li><p>volatile-lru：使用LRU（最近最少使用）算法移除key，<strong>只针对设置了过期时间的键</strong>。</p></li><li><p>allkeys-lru：在<strong>所有集合key</strong>中，使用LRU（最近最少使用）算法移除key。</p></li><li><p>volatile-random：在过期集合中移除随机的key，<strong>只针对设置了过期时间的键</strong>。</p></li><li><p>allkeys-random：在<strong>所有集合key</strong>中，移除随机的key。</p></li><li><p>volatile-ttl：移除那些TTL值最小的key，即那些<strong>最近要过期的key</strong>，<strong>只针对设置了过期时间的键</strong>。</p></li><li><p>noeviction：<strong>不进行移除</strong>。针对写操作，只是<strong>返回错误信息</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009115003839.png" alt="image-20221009115003839"></p></li></ul><h3 id="maxmemory-samples"><a href="#maxmemory-samples" class="headerlink" title="maxmemory-samples"></a>maxmemory-samples</h3><ul><li><p><strong>设置LRU算法和最小TTL算法执行时检查的样本规模</strong>，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。</p></li><li><p><strong>一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009115057158.png" alt="image-20221009115057158"></p></li></ul><h1 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h1><h2 id="什么是发布和订阅"><a href="#什么是发布和订阅" class="headerlink" title="什么是发布和订阅"></a>什么是发布和订阅</h2><ul><li>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：<strong>发送者 (pub) 发送消息，订阅者 (sub) 接收消息</strong>。</li><li>Redis客户端可以订阅任意数量的频道。</li></ul><h2 id="Redis的发布和订阅-1"><a href="#Redis的发布和订阅-1" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h2><ul><li><p>客户端可以订阅频道，如下图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010101505044.png" alt="image-20221010101505044"></p></li><li><p>当另一个客户端给这个频道发布消息后，消息就会发送给订阅的客户端：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010101548295.png" alt="image-20221010101548295"></p></li></ul><h2 id="发布订阅的命令行实现"><a href="#发布订阅的命令行实现" class="headerlink" title="发布订阅的命令行实现"></a>发布订阅的命令行实现</h2><ol><li><p>打开一个客户端订阅channel1：<strong>SUBSCRIBE channel1</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010101704069.png" alt="image-20221010101704069"></p></li><li><p>打开另一个客户端，给channel1发布消息hello：<strong>publish channel1 hello</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010101934952.png" alt="image-20221010101934952"></p><p>返回的1是订阅者的数量。</p></li><li><p>打开第一个客户端可以看到发送的消息：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010102101292.png" alt="image-20221010102101292"></p><p>注：发布的消息没有持久化。</p></li></ol><h1 id="Redis新数据类型"><a href="#Redis新数据类型" class="headerlink" title="Redis新数据类型"></a>Redis新数据类型</h1><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><ul><li><p>现代计算机用二进制（位） 作为信息的基础单位， <strong>1个字节等于8位</strong>， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010102548868.png" alt="image-20221010102548868"></p><p><strong>合理地使用操作位能够有效地提高内存使用率和开发效率</strong>。</p></li><li><p>Redis提供了<strong>Bitmaps</strong>这个“数据类型”可以<strong>实现对位的操作</strong>：</p><ol><li>Bitmaps本身不是一种数据类型， <strong>实际上它就是Map&lt;key,String&gt;<strong>， 但是</strong>它可以对字符串的位进行操作</strong>。</li><li>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以<strong>把Bitmaps想象成一个以位为单位的数组</strong>， <strong>数组的每个单元只能存储0和1</strong>， <strong>数组的下标在Bitmaps中叫做偏移量</strong>。</li></ol><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010102819858.png" alt="image-20221010102819858"></p></li></ul><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul><li><p>setbit：</p><ol><li><p>格式：</p><p><strong>setbit &lt;key&gt; &lt;offset&gt; &lt;value&gt;<strong>：</strong>设置Bitmaps中某个value的偏移量的值（0或1）</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010103405710.png" alt="image-20221010103405710"></p><p>offset：偏移量从0开始</p></li><li><p>实例：</p><p><strong>每个独立用户是否访问过网站存放在Bitmaps中</strong>， 将访问的用户记做1， 没有访问的用户记做0， <strong>用偏移量作为用户的id</strong>。</p><p>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid&#x3D;1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010103548835.png" alt="image-20221010103548835"></p><p>unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010103743958.png" alt="image-20221010103743958"></p><p>注：很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是<strong>每次做setbit操作时将用户id减去这个指定数字</strong>。<strong>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞</strong>。</p></li></ol></li><li><p>getbit：</p><ol><li><p>格式：</p><p><strong>getbit &lt;key&gt; &lt;offset&gt;<strong>：</strong>获取Bitmaps中某个value的偏移量的值</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010104454677.png" alt="image-20221010104454677"></p><p>获取键对应值的第offset位的值（从0开始算）</p></li><li><p>实例：</p><p>获取id&#x3D;8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010104554699.png" alt="image-20221010104554699"></p><p>注：因为100根本不存在，所以也是返回0。</p></li></ol></li><li><p>bitcount：<strong>统计字符串被设置为1的bit数</strong>。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。</p><ol><li><p>格式：</p><p><strong>bitcount &lt;key&gt; [start end]<strong>：统计字符串从start</strong>字节</strong>到end<strong>字节</strong>（左右都是闭）比特值为1的数量</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010104852283.png" alt="image-20221010104852283"></p></li><li><p>实例：</p><p>计算2022-11-06这天的独立访问用户数量</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010104922486.png" alt="image-20221010104922486"></p><p><strong>start和end代表起始和结束字节数</strong>， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。</p></li><li><p>举例：K1 【01000001 01000000  00000000 00100001】，对应【0，1，2，3】字节bitcount K1 0 -2  ： 统计下标0到下标倒数第2，字节组中bit&#x3D;1的个数，即01000001  01000000  00000000中bit&#x3D;1的个数，结果是3</p></li></ol><p>注意：<strong>redis的setbit设置或清除是以bit为单位，而bitcount计算是以byte区间为单位</strong>。</p></li><li><p>bitop：</p><ol><li><p>格式：</p><p>**bitop and(or&#x2F;not&#x2F;xor) &lt;destkey&gt; [key…]**：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010112055534.png" alt="image-20221010112055534"></p><p>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集）&#x2F; or（并集） &#x2F;not（非）&#x2F;xor（异或） 操作并将结果保存在destkey中。</p></li><li><p>实例：</p><p>计算出两天都访问过网站的用户数量：<strong>bitop and unique:users:and:20201104_03 unique:users:20201103 unique:users:20201104</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010112529496.png" alt="image-20221010112529496"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010112605365.png" alt="image-20221010112605365"></p><p>计算出任意一天访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集：<strong>bitop or unique:users:or:20201104_03 unique:users:20201103 unique:users:20201104</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010112834145.png" alt="image-20221010112834145"></p></li></ol></li></ul><h3 id="Bitmaps与set对比"><a href="#Bitmaps与set对比" class="headerlink" title="Bitmaps与set对比"></a>Bitmaps与set对比</h3><ul><li><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010112959645.png" alt="image-20221010112959645"></p></li><li><p>很明显，<strong>假如该网站每天的独立访问用户很多</strong>， <strong>这种情况下使用Bitmaps能节省很多的内存空间</strong>， 尤其是随着时间推移节省的内存还是非常可观的：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010113056084.png" alt="image-20221010113056084"></p></li><li><p>但Bitmaps并不是万金油， <strong>假如该网站每天的独立访问用户很少</strong>， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， <strong>这时候使用Bitmaps就不太合适了</strong>， 因为基本上大部分位都是0：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010113311567.png" alt="image-20221010113311567"></p></li></ul><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><ul><li><p>在工作当中，我们经常会遇到<strong>与统计相关的功能需求</strong>，比如统计网站PV（PageView页面访问量）,<strong>可以使用Redis的incr、incrby轻松实现</strong>。</p></li><li><p>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种<strong>求集合中不重复元素个数的问题称为基数问题</strong>。</p></li><li><p>解决基数问题有很多种方案：</p><ol><li>数据存储在MySQL表中，使用distinct count计算不重复个数</li><li>使用Redis提供的hash、set、bitmaps等数据结构来处理</li></ol><p>以上的方案结果精确，但<strong>随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的</strong>。能否能够<strong>降低一定的精度来平衡存储空间</strong>？针对这个问题Redis推出了HyperLogLog。</p></li><li><p>Redis HyperLogLog 是<strong>用来做基数统计的算法</strong>，HyperLogLog 的优点是，<strong>在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的</strong>。</p></li><li><p>在 Redis 里面，<strong>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数</strong>。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p></li><li><p>什么是基数？其实就是<strong>一个数据集中不重复元素的个数</strong>，比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p></li></ul><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><ul><li><p>pfadd：</p><ol><li><p>格式：</p><p>**pfadd &lt;key&gt; &lt; element&gt; [element …]**：添加指定元素到HyperLogLog中</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011093114682.png" alt="image-20221011093114682"></p></li><li><p>实例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011093200199.png" alt="image-20221011093200199"></p><p>将所有元素添加到指定HyperLogLog数据结构中。<strong>如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0</strong>。</p></li></ol></li><li><p>pfcount：</p><ol><li><p>格式：</p><p><strong>pfcount &lt;key&gt; [key …]<strong>：计算HLL的近似基数，</strong>可以计算多个HLL并集的基数</strong>，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011093442399.png" alt="image-20221011093442399"></p></li><li><p>实例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011093504462.png" alt="image-20221011093504462"></p></li></ol></li><li><p>pfmerge：</p><ol><li><p>格式：</p><p><strong>pfmerge &lt;destkey&gt; &lt;sourcekey&gt; [sourcekey …]<strong>：</strong>将一个或多个HLL合并后的结果存储在另一个HLL中</strong>，比如每月活跃用户可以使用每天的活跃用户来合并计算可得。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011093653921.png" alt="image-20221011093653921"></p></li><li><p>实例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011093717593.png" alt="image-20221011093717593"></p></li></ol></li></ul><h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h2><h3 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h3><ul><li>Redis 3.2 中<strong>增加了对GEO类型的支持</strong>。GEO，Geographic，地理信息的缩写。<strong>该类型，就是元素的2维坐标，在地图上就是经纬度</strong>。redis基于该类型，<strong>提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作</strong>。</li></ul><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><ul><li><p>geoadd：</p><ol><li><p>格式：</p><p>**geoadd &lt;key&gt; &lt; longitude&gt; &lt;latitude&gt; &lt;member&gt; [longitude latitude member…]**：添加地理位置（经度，纬度，名称）</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011095713245.png" alt="image-20221011095713245"></p></li><li><p>实例：</p><p>geoadd china:city 121.47 31.23 shanghai</p><p>geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011095900818.png" alt="image-20221011095900818"></p><p><strong>两极地区无法直接添加</strong>，一般会下载城市数据，直接通过 Java 程序一次性导入。</p><p><strong>有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度</strong>。</p><p><strong>当坐标位置超出指定范围时，该命令将会返回一个错误</strong>。</p><p><strong>已经添加的数据，是无法再次往里面添加的</strong>。</p></li></ol></li><li><p>geopos：</p><ol><li><p>格式：</p><p>**geopos  &lt;key&gt; &lt;member&gt; [member…]**：获得指定地区的坐标值</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011100158382.png" alt="image-20221011100158382"></p></li><li><p>实例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011100217221.png" alt="image-20221011100217221"></p></li></ol></li><li><p>geodist：</p><ol><li><p>格式：</p><p>geodist &lt;key&gt; &lt;member1&gt; &lt;member2&gt;  [m|km|ft|mi ]：获取两个位置之间的直线距离</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011100306916.png" alt="image-20221011100306916"></p></li><li><p>实例：</p><p>获取两个位置之间的直线距离</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011100332658.png" alt="image-20221011100332658"></p><p>单位：</p><p>m 表示单位为米[默认值]。</p><p>km 表示单位为千米。</p><p>mi 表示单位为英里。</p><p>ft 表示单位为英尺。</p><p><strong>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</strong>。</p></li></ol></li><li><p>georadius：</p><ol><li><p>格式：</p><p>georadius &lt;key&gt; &lt; longitude&gt; &lt;latitude&gt; &lt;radius&gt; m|km|ft|mi  以给定的经纬度为中心，找出某一半径内的元素</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011120642761.png" alt="image-20221011120642761"></p></li><li><p>实例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011120719951.png" alt="image-20221011120719951"></p></li></ol></li></ul><h1 id="Java操作Redis（使用Jedis）测试"><a href="#Java操作Redis（使用Jedis）测试" class="headerlink" title="Java操作Redis（使用Jedis）测试"></a>Java操作Redis（使用Jedis）测试</h1><h2 id="Jedis所需要的jar包"><a href="#Jedis所需要的jar包" class="headerlink" title="Jedis所需要的jar包"></a>Jedis所需要的jar包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="连接Redis注意事项"><a href="#连接Redis注意事项" class="headerlink" title="连接Redis注意事项"></a>连接Redis注意事项</h2><ul><li>禁用Linux的防火墙：Linux(CentOS7)里执行命令<strong>systemctl stop&#x2F;disable firewalld.service</strong></li><li>redis.conf中<strong>注释掉bind 127.0.0.1</strong>,然后<strong>protected-mode no</strong></li></ul><h2 id="Jedis常用操作"><a href="#Jedis常用操作" class="headerlink" title="Jedis常用操作"></a>Jedis常用操作</h2><h3 id="创建动态的工程"><a href="#创建动态的工程" class="headerlink" title="创建动态的工程"></a>创建动态的工程</h3><h3 id="创建测试程序"><a href="#创建测试程序" class="headerlink" title="创建测试程序"></a>创建测试程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.137.3&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">pong</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">System.out.println(<span class="string">&quot;连接成功：&quot;</span>+pong);</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试相关数据类型"><a href="#测试相关数据类型" class="headerlink" title="测试相关数据类型"></a>测试相关数据类型</h2><h3 id="Jedis-API：key"><a href="#Jedis-API：key" class="headerlink" title="Jedis-API：key"></a>Jedis-API：key</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jedis.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);<span class="comment">//向redis中存入数据</span></span><br><span class="line">jedis.set(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line">Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);<span class="comment">//获取所有key？</span></span><br><span class="line">System.out.println(keys.size());</span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(jedis.exists(<span class="string">&quot;k1&quot;</span>));<span class="comment">//redis中是否存在指定key</span></span><br><span class="line">System.out.println(jedis.ttl(<span class="string">&quot;k1&quot;</span>));<span class="comment">//常看指定key的过期时间</span></span><br><span class="line">System.out.println(jedis.get(<span class="string">&quot;k1&quot;</span>));<span class="comment">//获取指定key对应的值</span></span><br></pre></td></tr></table></figure><h3 id="Jedis-API：String"><a href="#Jedis-API：String" class="headerlink" title="Jedis-API：String"></a>Jedis-API：String</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jedis.mset(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;v2&quot;</span>,<span class="string">&quot;str3&quot;</span>,<span class="string">&quot;v3&quot;</span>);<span class="comment">//批量添加数据</span></span><br><span class="line">System.out.println(jedis.mget(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;str3&quot;</span>));<span class="comment">//批量获取数据</span></span><br></pre></td></tr></table></figure><h3 id="Jedis-API：List"><a href="#Jedis-API：List" class="headerlink" title="Jedis-API：List"></a>Jedis-API：List</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = jedis.lrange(<span class="string">&quot;mylist&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);<span class="comment">//取出List指定范围内的数据</span></span><br><span class="line"><span class="keyword">for</span> (String element : list) &#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jedis-API：set"><a href="#Jedis-API：set" class="headerlink" title="Jedis-API：set"></a>Jedis-API：set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order01&quot;</span>);<span class="comment">//向对应的set中添加数据</span></span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order02&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order03&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order04&quot;</span>);</span><br><span class="line">Set&lt;String&gt; smembers = jedis.smembers(<span class="string">&quot;orders&quot;</span>);<span class="comment">//获取指定set中的所有数据</span></span><br><span class="line"><span class="keyword">for</span> (String order : smembers) &#123;</span><br><span class="line">System.out.println(order);</span><br><span class="line">&#125;</span><br><span class="line">jedis.srem(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order02&quot;</span>);<span class="comment">//删除指定set中的指定元素</span></span><br></pre></td></tr></table></figure><h3 id="Jedis-API：hash"><a href="#Jedis-API：hash" class="headerlink" title="Jedis-API：hash"></a>Jedis-API：hash</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jedis.hset(<span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;lisi&quot;</span>);<span class="comment">//向指定的hash中添加键值对</span></span><br><span class="line">System.out.println(jedis.hget(<span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;userName&quot;</span>));<span class="comment">//获取指定hash中的指定key的值</span></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;13810169999&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;abc@163.com&quot;</span>);</span><br><span class="line">jedis.hmset(<span class="string">&quot;hash2&quot;</span>,map);<span class="comment">//批量向指定的hash中添加键值对</span></span><br><span class="line">List&lt;String&gt; result = jedis.hmget(<span class="string">&quot;hash2&quot;</span>, <span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;email&quot;</span>);<span class="comment">//批量获取指定的hash中的指定key的值</span></span><br><span class="line"><span class="keyword">for</span> (String element : result) &#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jedis-API：zset"><a href="#Jedis-API：zset" class="headerlink" title="Jedis-API：zset"></a>Jedis-API：zset</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">100d</span>, <span class="string">&quot;z3&quot;</span>);<span class="comment">//向有序集合中添加数据并设置评分</span></span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">90d</span>, <span class="string">&quot;l4&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">80d</span>, <span class="string">&quot;w5&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">70d</span>, <span class="string">&quot;z6&quot;</span>);</span><br><span class="line"> </span><br><span class="line">Set&lt;String&gt; zrange = jedis.zrange(<span class="string">&quot;zset01&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);<span class="comment">//获取指定有序集合中指定范围的数据</span></span><br><span class="line"><span class="keyword">for</span> (String e : zrange) &#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Jedis实例"><a href="#Jedis实例" class="headerlink" title="Jedis实例"></a>Jedis实例</h1><h2 id="完成一个手机验证码功能"><a href="#完成一个手机验证码功能" class="headerlink" title="完成一个手机验证码功能"></a>完成一个手机验证码功能</h2><ul><li>要求：<ol><li>输入手机号，点击发送后随机生成6位数字码，2分钟有效</li><li>输入验证码，点击验证，返回成功或失败</li><li>每个手机号每天只能输入3次</li></ol></li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221012180940414.png" alt="image-20221012180940414"></p><h1 id="Redis与Spring-Boot整合"><a href="#Redis与Spring-Boot整合" class="headerlink" title="Redis与Spring Boot整合"></a>Redis与Spring Boot整合</h1><ul><li>Spring Boot整合Redis非常简单，只需要按照如下步骤进行整合即可。</li></ul><h2 id="整合步骤"><a href="#整合步骤" class="headerlink" title="整合步骤"></a>整合步骤</h2><ol><li><p>在pom.xml文件中引入redis相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring2.X集成redis所需common-pool2，这东西是个redis的连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在application.properties中配置redis的配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">192.168.140.136</span></span><br><span class="line"><span class="comment">#Redis服务器连接端口</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="attr">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line"><span class="attr">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure></li><li><p>添加redis配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"><span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line"><span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"><span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"><span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"><span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行测试，创建RedisTestController并向其中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置值到redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        <span class="comment">//从redis获取值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String)redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><h2 id="Redis的事务定义"><a href="#Redis的事务定义" class="headerlink" title="Redis的事务定义"></a>Redis的事务定义</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221012181544824.png" alt="image-20221012181544824"></p><ul><li>Redis事务<strong>是一个单独的隔离操作</strong>：事务中的所有命令都会<strong>序列化、按顺序地执行</strong>。<strong>事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</strong>。</li><li>Redis事务的<strong>主要作用就是串联多个命令防止别的命令插队</strong>。</li></ul><h2 id="Multi、Exec、discard"><a href="#Multi、Exec、discard" class="headerlink" title="Multi、Exec、discard"></a>Multi、Exec、discard</h2><ul><li><p>从输入<strong>Multi</strong>命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入<strong>Exec</strong>后，Redis会将之前的命令队列中的命令依次执行。</p></li><li><p>组队的过程中可以通过<strong>discard</strong>来放弃组队，放弃组队后之前组的队也无了。</p></li><li><p>案例：</p><p>组队成功，提交成功：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221012182056645.png" alt="image-20221012182056645"></p><p>组队阶段报错，会提交失败：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221012182212710.png" alt="image-20221012182212710"></p><p>组队成功，提交时有失败的不会影响到成功的：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221012182343240.png" alt="image-20221012182343240"></p></li></ul><h2 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h2><ul><li><p><strong>组队中</strong>某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221012182611402.png" alt="image-20221012182611402"></p></li><li><p>如果<strong>执行阶段</strong>某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221012182757980.png" alt="image-20221012182757980"></p></li></ul><h2 id="为什么要做成事务"><a href="#为什么要做成事务" class="headerlink" title="为什么要做成事务"></a>为什么要做成事务</h2><ul><li>如果没有了事务带来的隔离性，那么在高并发的场景下就会造成事务之间的冲突（同步问题）。</li></ul><h2 id="事务冲突的问题"><a href="#事务冲突的问题" class="headerlink" title="事务冲突的问题"></a>事务冲突的问题</h2><ul><li>就是类似于线程之间的同步问题。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li><p>账户里有10000块钱，一个请求想给金额减8000，一个请求想给金额减5000，一个请求想给金额减1000。按理说如果要是账户里的金额不够的话要拒绝减金额的操作，但是如果事务之间没有隔离性，那么在判断阶段，<strong>这三个操作可能同时被判断为可以减掉指定的数额</strong>，所以会导致最后的数据出现异常，这就是事务冲突。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221013092935421.png" alt="image-20221013092935421"></p></li></ul><h2 id="Redis事务三特性"><a href="#Redis事务三特性" class="headerlink" title="Redis事务三特性"></a>Redis事务三特性</h2><ol><li><strong>单独的隔离操作</strong>：事务中的所有命令都会<strong>序列化、按顺序地执行</strong>。<strong>事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</strong>。</li><li><strong>没有隔离级别的概念</strong>：队列中的命令没有提交之前都不会实际被执行，因为<strong>事务提交前任何指令都不会被实际执行</strong>。</li><li><strong>不保证原子性</strong>：事务中<strong>如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</strong>。</li></ol><h1 id="Redis锁"><a href="#Redis锁" class="headerlink" title="Redis锁"></a>Redis锁</h1><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><ul><li><p><strong>悲观锁(Pessimistic Lock)</strong>, 顾名思义，就是<strong>很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁</strong>。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221013093157920.png" alt="image-20221013093157920"></p></li></ul><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><ul><li><p><strong>乐观锁(Optimistic Lock)</strong>,顾名思义，就是<strong>很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制</strong>。乐观锁<strong>适用于多读的应用类型</strong>，这样<strong>可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221013093512211.png" alt="image-20221013093512211"></p></li></ul><h1 id="Redis运用事务的秒杀案例"><a href="#Redis运用事务的秒杀案例" class="headerlink" title="Redis运用事务的秒杀案例"></a>Redis运用事务的秒杀案例</h1><ul><li>就是各大电商平台搞活动的时候搞得那种限时抢多少个特价商品的那种情况。</li></ul><h2 id="解决计数器和人员记录的事务操作"><a href="#解决计数器和人员记录的事务操作" class="headerlink" title="解决计数器和人员记录的事务操作"></a>解决计数器和人员记录的事务操作</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014084815738.png" alt="image-20221014084815738"></p><h2 id="秒杀并发模拟"><a href="#秒杀并发模拟" class="headerlink" title="秒杀并发模拟"></a>秒杀并发模拟</h2><ul><li>使用工具ab模拟测试</li><li>CentOS6默认安装，CentOS7需要手动安装</li></ul><h3 id="联网安装ab"><a href="#联网安装ab" class="headerlink" title="联网安装ab"></a>联网安装ab</h3><ul><li>使用命令：<strong>yum install httpd-tools</strong></li></ul><h3 id="无网络安装ab"><a href="#无网络安装ab" class="headerlink" title="无网络安装ab"></a>无网络安装ab</h3><ul><li>进入cd  &#x2F;run&#x2F;media&#x2F;root&#x2F;CentOS 7 x86_64&#x2F;Packages（路径跟centos6不同）</li><li>顺序安装：<ol><li>apr-1.4.8-3.el7.x86_64.rpm</li><li>apr-util-1.5.2-6.el7.x86_64.rpm</li><li>httpd-tools-2.4.6-67.el7.centos.x86_64.rpm</li></ol></li></ul><h3 id="通过ab测试"><a href="#通过ab测试" class="headerlink" title="通过ab测试"></a>通过ab测试</h3><ul><li>在自定义的目录下，通过<strong>vim postfile</strong>新建文件填写模拟表单提交的参数，以&amp;符号结尾，文件会存放到当前目录中。样例内容：prodid&#x3D;0101&amp;</li><li>然后通过ab提供的命令进行测试：<strong>ab -n 请求数 -c 并发线程数 -k -p 参数文件 -T 请求报文数据类型 请求地址</strong></li><li>命令示例：ab -n 2000 -c 200 -k -p ~&#x2F;postfile -T application&#x2F;x-www-form-urlencoded <a href="http://192.168.2.115:8081/Seckill/doseckill">http://192.168.2.115:8081/Seckill/doseckill</a></li></ul><h3 id="经过ab的测试，发现了超卖的异常情况"><a href="#经过ab的测试，发现了超卖的异常情况" class="headerlink" title="经过ab的测试，发现了超卖的异常情况"></a>经过ab的测试，发现了超卖的异常情况</h3><ul><li><p>到最后商品剩余数量变为-1，很明显这是一个异常的数据。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014090958746.png" alt="image-20221014090958746"></p></li></ul><h2 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h2><ul><li><p>就是线程同步的问题，高并发的情况下如果不采取一定的线程同步措施，那么<strong>线程之间由于缺少隔离性又没有同步措施会互相产生干扰</strong>，影响最后的结果。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014091557208.png" alt="image-20221014091557208"></p></li></ul><h2 id="利用乐观锁淘汰用户，解决超卖问题"><a href="#利用乐观锁淘汰用户，解决超卖问题" class="headerlink" title="利用乐观锁淘汰用户，解决超卖问题"></a>利用乐观锁淘汰用户，解决超卖问题</h2><ul><li><p>让用户每次修改完数据之后改变数据的版本号，这样如果之前有取到同一版本号的数据的另一个线程后来到达之后就不会再修改数据了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014091854452.png" alt="image-20221014091854452"></p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加乐观锁</span></span><br><span class="line">jedis.watch(qtkey);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//3.判断库存</span></span><br><span class="line"><span class="type">String</span> <span class="variable">qtkeystr</span> <span class="operator">=</span> jedis.get(qtkey);</span><br><span class="line"><span class="keyword">if</span>(qtkeystr==<span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(qtkeystr.trim())) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;未初始化库存&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="variable">qt</span> <span class="operator">=</span> Integer.parseInt(qtkeystr);</span><br><span class="line"><span class="keyword">if</span>(qt&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">System.err.println(<span class="string">&quot;已经秒光&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//增加事务</span></span><br><span class="line"><span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//4.减少库存</span></span><br><span class="line"><span class="comment">//jedis.decr(qtkey);</span></span><br><span class="line">multi.decr(qtkey);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//5.加人</span></span><br><span class="line"><span class="comment">//jedis.sadd(usrkey, uid);</span></span><br><span class="line">multi.sadd(usrkey, uid);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//执行事务</span></span><br><span class="line">List&lt;Object&gt; list = multi.exec();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断事务提交是否失败</span></span><br><span class="line"><span class="keyword">if</span>(list==<span class="literal">null</span> || list.size()==<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;秒杀失败&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.err.println(<span class="string">&quot;秒杀成功&quot;</span>);</span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure></li><li><p>在使用乐观锁后，超卖问题被解决了：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014092118630.png" alt="image-20221014092118630"></p></li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014092146669.png" alt="image-20221014092146669"></p><h2 id="继续增加并发测试"><a href="#继续增加并发测试" class="headerlink" title="继续增加并发测试"></a>继续增加并发测试</h2><h3 id="连接有限制"><a href="#连接有限制" class="headerlink" title="连接有限制"></a>连接有限制</h3><ul><li><p>在使用ab命令进行并发测试的时候报连接被拒绝的错误：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014092802618.png" alt="image-20221014092802618"></p></li><li><p>通过在请求中增加-r参数解决，**-r，Don’t exit on socket receive errors**。</p></li><li><p>命令示例：ab -n 2000 -c 100 -r -p postfile -T ‘application&#x2F;x-www-form-urlencoded’ <a href="http://192.168.140.1:8080/seckill/doseckill">http://192.168.140.1:8080/seckill/doseckill</a></p></li></ul><h3 id="已经秒光，可是还有库存（库存遗留问题）"><a href="#已经秒光，可是还有库存（库存遗留问题）" class="headerlink" title="已经秒光，可是还有库存（库存遗留问题）"></a>已经秒光，可是还有库存（库存遗留问题）</h3><ul><li><p>ab -n 2000 -c 100 -p postfile -T ‘application&#x2F;x-www-form-urlencoded’ <a href="http://192.168.137.1:8080/seckill/doseckill">http://192.168.137.1:8080/seckill/doseckill</a></p></li><li><p>已经秒光，可是还有库存。原因就是<strong>乐观锁导致很多请求都失败</strong>，而请求一共就那么多。先点的没秒到，后点的可能秒到了。</p></li><li><p>解决思路可以从请求发现数据的版本号不对后重新请求或者赋予请求原子性出发。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014093459750.png" alt="image-20221014093459750"></p></li></ul><h3 id="连接超时，通过连接池解决"><a href="#连接超时，通过连接池解决" class="headerlink" title="连接超时，通过连接池解决"></a>连接超时，通过连接池解决</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014093634038.png" alt="image-20221014093634038"></p><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><ul><li>通过参数管理连接的行为，节省每次连接redis服务带来的消耗，把连接好的实例反复利用。</li><li>链接池参数：<ul><li><strong>MaxTotal</strong>：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。</li><li><strong>maxIdle</strong>：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；</li><li><strong>MaxWaitMillis</strong>：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException；</li><li><strong>testOnBorrow</strong>：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的；</li></ul></li></ul><h2 id="解决库存遗留问题"><a href="#解决库存遗留问题" class="headerlink" title="解决库存遗留问题"></a>解决库存遗留问题</h2><h3 id="LUA脚本"><a href="#LUA脚本" class="headerlink" title="LUA脚本"></a>LUA脚本</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014111425136.png" alt="image-20221014111425136"></p><ul><li>Lua 是一个小巧的<a href="http://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a>，Lua脚本可以很容易的被C&#x2F;C++ 代码调用，也可以反过来调用C&#x2F;C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以Lua不适合作为开发独立应用程序的语言，而是<strong>作为嵌入式脚本语言</strong>。</li><li>很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现<strong>可配置性、可扩展性</strong>。</li><li>这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。</li><li><a href="https://www.w3cschool.cn/lua/">教程链接</a></li></ul><h3 id="LUA脚本在Redis中的优势"><a href="#LUA脚本在Redis中的优势" class="headerlink" title="LUA脚本在Redis中的优势"></a>LUA脚本在Redis中的优势</h3><ul><li><p><strong>将复杂的或者多步的redis操作，写为一个脚本</strong>，一次提交给redis执行，减少反复连接redis的次数。提升性能。</p></li><li><p>LUA脚本是类似redis事务，<strong>有一定的原子性，不会被其他命令插队</strong>，可以完成一些redis事务性的操作。</p></li><li><p>但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。</p></li><li><p>可以利用lua脚本淘汰用户，解决超卖问题</p></li><li><p>redis 2.6版本以后，通过lua脚本解决<strong>争抢问题</strong>，实际上是<strong>redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014112011027.png" alt="image-20221014112011027"></p></li></ul><h2 id="秒杀案例代码"><a href="#秒杀案例代码" class="headerlink" title="秒杀案例代码"></a>秒杀案例代码</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014112057581.png" alt="image-20221014112057581"></p><h3 id="第一版：简单版"><a href="#第一版：简单版" class="headerlink" title="第一版：简单版"></a>第一版：简单版</h3><ul><li>使用ab模拟并发测试，会出现超卖情况，查看库存会出现负数。</li></ul><h3 id="第二版：加事务-x2F-乐观锁（解决超卖问题），但会出现遗留库存和连接超时的问题"><a href="#第二版：加事务-x2F-乐观锁（解决超卖问题），但会出现遗留库存和连接超时的问题" class="headerlink" title="第二版：加事务&#x2F;乐观锁（解决超卖问题），但会出现遗留库存和连接超时的问题"></a>第二版：加事务&#x2F;乐观锁（解决超卖问题），但会出现遗留库存和连接超时的问题</h3><h3 id="第三版：用连接池解决超时问题"><a href="#第三版：用连接池解决超时问题" class="headerlink" title="第三版：用连接池解决超时问题"></a>第三版：用连接池解决超时问题</h3><h3 id="第四版：用LUA脚本解决库存依赖问题（实现方式是不是有点像悲观锁？）"><a href="#第四版：用LUA脚本解决库存依赖问题（实现方式是不是有点像悲观锁？）" class="headerlink" title="第四版：用LUA脚本解决库存依赖问题（实现方式是不是有点像悲观锁？）"></a>第四版：用LUA脚本解决库存依赖问题（实现方式是不是有点像悲观锁？）</h3><ul><li><p>lua脚本示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">local userid=KEYS[<span class="number">1</span>]; </span><br><span class="line">local prodid=KEYS[<span class="number">2</span>];</span><br><span class="line">local qtkey=<span class="string">&quot;sk:&quot;</span>..prodid..<span class="string">&quot;:qt&quot;</span>;</span><br><span class="line">local usersKey=<span class="string">&quot;sk:&quot;</span>..prodid.<span class="string">&quot;:usr&#x27;; </span></span><br><span class="line"><span class="string">local userExists=redis.call(&quot;</span>sismember<span class="string">&quot;,usersKey,userid);</span></span><br><span class="line"><span class="string">if tonumber(userExists)==1 then </span></span><br><span class="line"><span class="string">  return 2;</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">local num= redis.call(&quot;</span>get<span class="string">&quot; ,qtkey);</span></span><br><span class="line"><span class="string">if tonumber(num)&lt;=0 then </span></span><br><span class="line"><span class="string">  return 0; </span></span><br><span class="line"><span class="string">else </span></span><br><span class="line"><span class="string">  redis.call(&quot;</span>decr<span class="string">&quot;,qtkey);</span></span><br><span class="line"><span class="string">  redis.call(&quot;</span>sadd<span class="string">&quot;,usersKey,userid);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">return 1;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><ul><li><p>官网介绍：<strong><a href="http://www.redis.io/">http://www.redis.io</a></strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014112951511.png" alt="image-20221014112951511"></p></li><li><p>由官网信息得知，Redis提供了两个不同形式的持久化方式：</p><ol><li><strong>RDB（Redis DataBase）</strong></li><li><strong>AOF（Append Of File）</strong></li></ol></li></ul><h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><h3 id="官网介绍"><a href="#官网介绍" class="headerlink" title="官网介绍"></a>官网介绍</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014113334621.png" alt="image-20221014113334621"></p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul><li><strong>在指定的时间间隔内将内存中的数据集快照写入磁盘</strong>， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</li></ul><h3 id="备份是如何执行的"><a href="#备份是如何执行的" class="headerlink" title="备份是如何执行的"></a>备份是如何执行的</h3><ul><li>Redis会<strong>单独创建（fork）一个子进程来进行持久化</strong>，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 <strong>整个过程中，主进程是不进行任何IO操作的</strong>，这就确保了极高的性能，<strong>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效</strong>。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。</li></ul><h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><ul><li>Fork的作用是<strong>复制一个与当前进程一样的进程</strong>。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并<strong>作为原进程的子进程</strong>。</li><li>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>”</li><li><strong>写时复制技术：一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</strong>。</li></ul><h3 id="RDB持久化流程"><a href="#RDB持久化流程" class="headerlink" title="RDB持久化流程"></a>RDB持久化流程</h3><ul><li>注意子进程在进行生成RDB文件时是<strong>先将数据写到一个临时文件中，写完之后将临时文件和之前的RDB文件进行替换</strong>，这个图里对这一点体现的不明显。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014114220988.png" alt="image-20221014114220988"></p><h3 id="配置rdb文件生成的名称"><a href="#配置rdb文件生成的名称" class="headerlink" title="配置rdb文件生成的名称"></a>配置rdb文件生成的名称</h3><ul><li><p>rdb文件就是每次进行RDB持久化后生成的数据文件</p></li><li><p>我们可以在redis.conf中配置文件名称，默认为dump.rdb</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014114650591.png" alt="image-20221014114650591"></p></li></ul><h3 id="配置rdb文件生成的位置"><a href="#配置rdb文件生成的位置" class="headerlink" title="配置rdb文件生成的位置"></a>配置rdb文件生成的位置</h3><ul><li><p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014114806183.png" alt="image-20221014114806183"></p></li></ul><h3 id="如何触发RDB快照（快照策略）"><a href="#如何触发RDB快照（快照策略）" class="headerlink" title="如何触发RDB快照（快照策略）"></a>如何触发RDB快照（快照策略）</h3><h4 id="配置文件中默认的快照配置"><a href="#配置文件中默认的快照配置" class="headerlink" title="配置文件中默认的快照配置"></a>配置文件中默认的快照配置</h4><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014115049725.png" alt="image-20221014115049725"></p><h4 id="命令-save-vs-bgsave"><a href="#命令-save-vs-bgsave" class="headerlink" title="命令 save vs bgsave"></a>命令 save vs bgsave</h4><ul><li>save ：save时只管保存，其它不管，全部阻塞。手动保存。<strong>不建议</strong>。</li><li><strong>bgsave：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。</strong></li><li>可以通过lastsave 命令<strong>获取最后一次成功执行快照的时间</strong></li></ul><h4 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h4><ul><li>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</li></ul><h3 id="SNAPSHOTTING快照配置"><a href="#SNAPSHOTTING快照配置" class="headerlink" title="SNAPSHOTTING快照配置"></a>SNAPSHOTTING快照配置</h3><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><ul><li>格式：<strong>save 秒数 写操作次数</strong>，指<strong>在规定秒数内写操作次数达到指定的操作次数就会触发快照</strong>，RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，默认是1分钟内改了1万次，或者五分钟内改了10次，或者15分钟内改了1次。</li><li>禁用：不设置save指令，或者给save传入空字符串</li></ul><h4 id="stop-writes-on-bgsave-error"><a href="#stop-writes-on-bgsave-error" class="headerlink" title="stop-writes-on-bgsave-error"></a>stop-writes-on-bgsave-error</h4><ul><li><strong>当Redis无法写入磁盘的话，直接关掉Redis的写操作</strong>，<strong>推荐设置为yes</strong>。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014143705419.png" alt="image-20221014143705419"></p><h4 id="rdbcompression压缩文件"><a href="#rdbcompression压缩文件" class="headerlink" title="rdbcompression压缩文件"></a>rdbcompression压缩文件</h4><ul><li><p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。<strong>如果是的话，redis会采用LZF算法进行压缩</strong>。</p></li><li><p>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。<strong>推荐yes</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014143931470.png" alt="image-20221014143931470"></p></li></ul><h4 id="rdbchecksum检查完整性"><a href="#rdbchecksum检查完整性" class="headerlink" title="rdbchecksum检查完整性"></a>rdbchecksum检查完整性</h4><ul><li><p><strong>在存储快照后，还可以让redis使用CRC64算法来进行数据校验</strong>，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能，<strong>推荐yes</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014144104665.png" alt="image-20221014144104665"></p></li></ul><h3 id="rdb的备份"><a href="#rdb的备份" class="headerlink" title="rdb的备份"></a>rdb的备份</h3><ul><li>先通过<strong>config get dir</strong>查询rdb文件的目录，将*.rdb的文件拷贝到别的地方</li><li>rdb的恢复：<ol><li>关闭Redis</li><li>先把备份的文件拷贝到工作目录下，注意名称要和配置文件中配置的一致。</li><li>启动Redis, 备份数据会直接加载</li></ol></li></ul><h3 id="RDB的优势"><a href="#RDB的优势" class="headerlink" title="RDB的优势"></a>RDB的优势</h3><ul><li><p>适合大规模的数据恢复</p></li><li><p>对数据完整性和一致性要求不高更适合使用</p></li><li><p>节省磁盘空间</p></li><li><p>恢复速度快</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014144428846.png" alt="image-20221014144428846"></p></li></ul><h3 id="RDB的劣势"><a href="#RDB的劣势" class="headerlink" title="RDB的劣势"></a>RDB的劣势</h3><ul><li>Fork的时候，内存中的数据被克隆了一份，大致<strong>2倍的膨胀性需要考虑</strong>。</li><li>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>,但是<strong>如果数据庞大时还是比较消耗性能</strong>。</li><li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就<strong>可能会丢失最后一次快照后的所有修改</strong>。</li></ul><h3 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h3><ul><li>动态停止RDB：<strong>redis-cli config set save “”</strong>  #save后给空值，表示禁用保存策略</li><li>静态停止RDB：关闭Redis，<strong>在Redis的配置文件中注释掉save或者给save空值</strong>，然后重启Redis即可。</li></ul><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014144846557.png" alt="image-20221014144846557"></p><h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ul><li>以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，<strong>redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</strong>。</li></ul><h3 id="AOF持久化流程"><a href="#AOF持久化流程" class="headerlink" title="AOF持久化流程"></a>AOF持久化流程</h3><ol><li><p>客户端的<strong>请求写命令会被append追加到AOF缓冲区内</strong>；</p></li><li><p>AOF缓冲区<strong>根据AOF持久化策略 [ always, everysec, no ] 将操作sync同步到磁盘的AOF文件中</strong>；</p></li><li><p><strong>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写</strong>，压缩AOF文件容量；</p></li><li><p>Redis服务重启时，会<strong>重新load加载AOF文件中的写操作达到数据恢复的目的</strong>；</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014150136936.png" alt="image-20221014150136936"></p></li></ol><h3 id="AOF默认是不开启的"><a href="#AOF默认是不开启的" class="headerlink" title="AOF默认是不开启的"></a>AOF默认是不开启的</h3><ul><li><p>需要在配置文件中配置AOF的开启，<strong>修改默认的appendonly no，改为yes</strong>。</p></li><li><p>可以在redis.conf中配置文件名称，默认为 appendonly.aof。</p></li><li><p>AOF文件设置保存路径，同RDB设置路径一致。</p></li></ul><h3 id="AOF和RDB同时开启，redis听谁的？"><a href="#AOF和RDB同时开启，redis听谁的？" class="headerlink" title="AOF和RDB同时开启，redis听谁的？"></a>AOF和RDB同时开启，redis听谁的？</h3><ul><li>AOF和RDB同时开启，<strong>系统默认取AOF的数据（数据不会存在丢失）</strong>。</li></ul><h3 id="AOF的启动-x2F-修复-x2F-恢复"><a href="#AOF的启动-x2F-修复-x2F-恢复" class="headerlink" title="AOF的启动&#x2F;修复&#x2F;恢复"></a>AOF的启动&#x2F;修复&#x2F;恢复</h3><ul><li><p>AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p></li><li><p>正常恢复：</p><ol><li>修改默认的appendonly no，改为yes</li><li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</li><li>恢复：重启redis然后重新加载</li></ol></li><li><p>异常恢复：</p><ol><li>修改默认的appendonly no，改为yes</li><li>如遇到<strong>AOF文件损坏</strong>，通过在&#x2F;usr&#x2F;local&#x2F;bin&#x2F;使用命令<strong>redis-check-aof–fix appendonly.aof</strong>进行恢复</li><li>备份被写坏的AOF文件</li><li>恢复：重启redis，然后重新加载</li></ol></li></ul><h3 id="AOF同步频率设置"><a href="#AOF同步频率设置" class="headerlink" title="AOF同步频率设置"></a>AOF同步频率设置</h3><ul><li><strong>appendfsync always</strong>：<strong>始终同步</strong>，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好。</li><li><strong>appendfsync everysec</strong>：<strong>每秒同步</strong>，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</li><li><strong>appendfsync no</strong>：<strong>redis不主动进行同步，把同步时机交给操作系统</strong>。</li></ul><h3 id="Rewrite（重写）压缩"><a href="#Rewrite（重写）压缩" class="headerlink" title="Rewrite（重写）压缩"></a>Rewrite（重写）压缩</h3><h4 id="这是什么"><a href="#这是什么" class="headerlink" title="这是什么"></a>这是什么</h4><ul><li>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， <strong>只保留可以恢复数据的最小指令集</strong>。可以<strong>使用命令bgrewriteaof手动触发内容压缩（重写）操作</strong>。</li></ul><h4 id="重写原理，如何实现重写"><a href="#重写原理，如何实现重写" class="headerlink" title="重写原理，如何实现重写"></a>重写原理，如何实现重写</h4><ul><li><p>AOF文件持续增长而过大时，会<strong>fork出一条新进程来将文件重写(也是先写临时文件最后再rename)<strong>，</strong>redis4.0版本后的重写，实际上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作，在这个操作的基础上再压缩剩下的命令</strong>。</p></li><li><p><strong>no-appendfsync-on-rewrite</strong>：如果no-appendfsync-on-rewrite&#x3D;yes，不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）；如果 no-appendfsync-on-rewrite&#x3D;no,  还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p></li><li><p>触发机制，何时重写：Redis会记录上次重写时的AOF大小，<strong>默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</strong>，重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写：</p><ul><li><strong>auto-aof-rewrite-percentage</strong>：<strong>当目前aof文件大小超过上一次重写的aof文件大小的百分之多少后进行重写</strong>，默认是100%。</li><li><strong>auto-aof-rewrite-min-size</strong>：<strong>设置允许重写的最小aof 文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</strong>，默认是64MB。</li></ul></li><li><p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</p></li><li><p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size，<strong>如果Redis的AOF当前大小&gt;&#x3D; base_size +base_size*100% (默认)且当前大小&gt;&#x3D;64mb(默认)的情况下，Redis会对AOF进行重写</strong>。</p></li></ul><h4 id="重写流程"><a href="#重写流程" class="headerlink" title="重写流程"></a>重写流程</h4><ol><li><p>bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</p></li><li><p>主进程fork出子进程执行重写操作，保证主进程不会阻塞。</p></li><li><p>子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</p></li><li><p>1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</p></li><li><p>使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014161849951.png" alt="image-20221014161849951"></p></li></ol><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>备份机制更稳健，<strong>丢失数据概率更低</strong>。</li><li>可读的日志文本，<strong>通过操作AOF文件，可以处理误操作</strong>。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014161927407.png" alt="image-20221014161927407"></p><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li>比起RDB<strong>占用更多的磁盘空间</strong>。</li><li><strong>恢复备份速度要慢</strong>。</li><li><strong>每次读写都同步的话，有一定的性能压力</strong>。</li><li><strong>存在个别Bug</strong>，造成恢复不能。</li></ul><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014162114242.png" alt="image-20221014162114242"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="用哪个好"><a href="#用哪个好" class="headerlink" title="用哪个好"></a>用哪个好</h3><ul><li>官方<strong>推荐两个都启用</strong>。</li><li>如果<strong>对数据不敏感，可以选单独用RDB</strong>。</li><li><strong>不建议单独用 AOF</strong>，因为可能会出现Bug。</li><li>如果<strong>只是做纯内存缓存，可以都不用</strong>。</li></ul><h3 id="官网建议"><a href="#官网建议" class="headerlink" title="官网建议"></a>官网建议</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014162204415.png" alt="image-20221014162204415"></p><ul><li><strong>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</strong></li><li><strong>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据</strong>,AOF命令以redis协议追加保存每次写的操作到文件末尾.，Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</li><li>只做缓存：<strong>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式</strong>.</li><li><strong>如非只做缓存，那么推荐同时开启两种持久化方式，</strong>在这种情况下,当redis重启的时候<strong>会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整</strong>.</li><li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ 建议不要，<strong>因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段</strong>。</li><li>性能建议：<ul><li>因为<strong>RDB文件只用作后备用途</strong>，<strong>建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则</strong>。</li><li>如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。</li><li>只要硬盘许可，应该<strong>尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上</strong>。</li><li><strong>可以把默认超过原大小百分之多少时重写这一配置改到适当的数值</strong>。</li></ul></li></ul><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>主机数据更新后根据配置和策略， 自动同步到备机的<strong>master&#x2F;slaver机制</strong>，<strong>Master以写为主，Slave以读为主</strong>。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li><p><strong>读写分离，性能扩展</strong></p></li><li><p><strong>容灾快速恢复</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015094548694.png" alt="image-20221015094548694"></p></li></ul><h2 id="如何实现主从复制"><a href="#如何实现主从复制" class="headerlink" title="如何实现主从复制"></a>如何实现主从复制</h2><h3 id="新建redis6379-conf"><a href="#新建redis6379-conf" class="headerlink" title="新建redis6379.conf"></a>新建redis6379.conf</h3><ul><li><p>填写以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.conf //引入已有配置文件中的配置</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">port 6379</span><br><span class="line">dbfilename dump6379.rdb</span><br></pre></td></tr></table></figure></li></ul><h3 id="新建redis6380-conf"><a href="#新建redis6380-conf" class="headerlink" title="新建redis6380.conf"></a>新建redis6380.conf</h3><ul><li><p>填写以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.conf //引入已有配置文件中的配置</span><br><span class="line">pidfile /var/run/redis_6380.pid</span><br><span class="line">port 6380</span><br><span class="line">dbfilename dump6380.rdb</span><br></pre></td></tr></table></figure></li></ul><h3 id="新建redis6381-conf"><a href="#新建redis6381-conf" class="headerlink" title="新建redis6381.conf"></a>新建redis6381.conf</h3><ul><li><p>填写以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.conf //引入已有配置文件中的配置</span><br><span class="line">pidfile /var/run/redis_6381.pid</span><br><span class="line">port 6381</span><br><span class="line">dbfilename dump6381.rdb</span><br></pre></td></tr></table></figure></li></ul><h3 id="设置从机的优先级"><a href="#设置从机的优先级" class="headerlink" title="设置从机的优先级"></a>设置从机的优先级</h3><ul><li>slave-priority 10：设置从机的优先级，值越小，优先级越高，<strong>用于选举主机时使用</strong>。默认100。</li></ul><h3 id="启动三台redis服务器"><a href="#启动三台redis服务器" class="headerlink" title="启动三台redis服务器"></a>启动三台redis服务器</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015095228553.png" alt="image-20221015095228553"></p><h3 id="查看系统进程，看看三台服务器是否都正常启动"><a href="#查看系统进程，看看三台服务器是否都正常启动" class="headerlink" title="查看系统进程，看看三台服务器是否都正常启动"></a>查看系统进程，看看三台服务器是否都正常启动</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015095312770.png" alt="image-20221015095312770"></p><h3 id="查看三台主机的主从情况"><a href="#查看三台主机的主从情况" class="headerlink" title="查看三台主机的主从情况"></a>查看三台主机的主从情况</h3><ul><li><p>使用客户端命令：<strong>info replication</strong>来打印主从复制的相关信息。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015095427167.png" alt="image-20221015095427167"></p></li></ul><h3 id="配置从机不配置主机"><a href="#配置从机不配置主机" class="headerlink" title="配置从机不配置主机"></a>配置从机不配置主机</h3><ul><li><p>从上面查看三台主机的主从情况可以看出，每个服务端的role字段都是master，这说明<strong>默认所有的服务端都是主机</strong>，因此如果要是想要配置从机，就应该在想要用作从机的上面进行配置，而主机不用进行配置。</p></li><li><p>使用客户端命令**slaveof  &lt;ip&gt; &lt;port&gt;**来让当前服务端成为某个服务端的从服务端，或者将这个配置加入到配置文件中永久生效。</p></li><li><p>配置示例：在6380和6381上执行: slaveof 127.0.0.1 6379</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015100217990.png" alt="image-20221015100217990"></p></li><li><p>在主机上可以写数据，在从机上可以读取数据，<strong>在从机上写数据会报错</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015100258091.png" alt="image-20221015100258091"></p></li><li><p>如果主机挂掉了，主机重启即可，主机不用做额外的操作。但是从机会变成主机，所以**从机需要重新设置slaveof  &lt;ip&gt; &lt;port&gt;**，可以将配置增加到配置文件中永久生效。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015100522674.png" alt="image-20221015100522674"></p></li><li><p><strong>从机下面也能配置从机</strong>。</p></li><li><p>用<strong>slaveof  no one</strong>将从机变为主机。</p></li></ul><h2 id="常用的三种主从结构"><a href="#常用的三种主从结构" class="headerlink" title="常用的三种主从结构"></a>常用的三种主从结构</h2><h3 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h3><ul><li><p>切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制？</p><p>从机是否可以写？set可否？ </p><p>主机shutdown后情况如何？从机是上位还是原地待命？</p><p>主机又回来了后，主机新增记录，从机还能否顺利复制？ </p><p>其中一台从机down后情况如何？依照原有它能跟上大部队吗？</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015100717323.png" alt="image-20221015100717323"></p></li></ul><h3 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h3><ul><li><p>上一个Slave可以是下一个slave的Master，<strong>Slave同样可以接收其他slaves的连接和同步请求</strong>，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</p></li><li><p>用 slaveof  &lt;ip&gt; &lt;port&gt;进行配置</p><p>中途变更转向:会清除之前的数据，重新建立拷贝最新的</p><p>风险是一旦某个slave宕机，后面的slave都没法备份</p><p>主机挂了，从机还是从机，无法写数据了</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101147373.png" alt="image-20221015101147373"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101153056.png" alt="image-20221015101153056"></p></li></ul><h3 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h3><ul><li><strong>当一个master宕机后，后面的slave可以立刻升为master</strong>，其后面的slave不用做任何修改。</li><li>用<strong>slaveof  no one</strong>将从机变为主机。</li></ul><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><ul><li><p><strong>Slave启动成功连接到master后会发送一个sync命令</strong>。</p></li><li><p>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，<strong>master将传送整个数据文件到slave,以完成一次完全同步</strong>。</p></li><li><p><strong>全量复制</strong>：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p></li><li><p><strong>增量复制</strong>：Master继续将新的所有收集到的修改命令依次传给slave,完成同步。</p></li><li><p>但是<strong>只要是重新连接master,一次完全同步（全量复制)将被自动执行</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101757180.png" alt="image-20221015101757180"></p></li></ul><h2 id="哨兵模式（sentinel）"><a href="#哨兵模式（sentinel）" class="headerlink" title="哨兵模式（sentinel）"></a>哨兵模式（sentinel）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li><p>这是<strong>反客为主的自动版</strong>，能够<strong>后台监控主机是否故障</strong>，如果故障了<strong>根据投票数自动将从库转换为主库</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101935319.png" alt="image-20221015101935319"></p></li></ul><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><ol><li><p>调整为一主二仆模式，6379带着6380、6381</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015102041213.png" alt="image-20221015102041213"></p></li><li><p>自定义的&#x2F;myredis目录下<strong>新建sentinel.conf文件</strong>，名字绝不能错</p></li><li><p>配置哨兵，在sentinel.conf中填写内容：<strong>sentinel monitor mymaster 127.0.0.1 6379 1</strong>，其中<strong>mymaster为监控对象起的服务器名称</strong>， <strong>1为至少有多少个哨兵同意迁移的数量</strong>。</p></li><li><p>启动哨兵：在&#x2F;usr&#x2F;local&#x2F;bin(安装目录)下执行<strong>redis-sentinel  &#x2F;myredis&#x2F;sentinel.conf</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015102700028.png" alt="image-20221015102700028"></p></li><li><p>redis<strong>做压力测试可以用自带的redis-benchmark工具</strong></p></li></ol><h3 id="当主机挂掉，哨兵会在从机中选出新的主机"><a href="#当主机挂掉，哨兵会在从机中选出新的主机" class="headerlink" title="当主机挂掉，哨兵会在从机中选出新的主机"></a>当主机挂掉，哨兵会在从机中选出新的主机</h3><ul><li><p>大概10秒左右可以看到哨兵窗口日志，切换了新的主机</p></li><li><p>哪个从机会被选举为主机呢？<strong>根据优先级别：slave-priority ，值越小优先级越高</strong>，<strong>原主机重启后会变为从机</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015103019042.png" alt="image-20221015103019042"></p></li></ul><h3 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h3><ul><li>由于<strong>所有的写操作都是先在Master上操作，然后同步更新到Slave上</strong>，所以<strong>从Master同步到Slave机器有一定的延迟</strong>，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</li></ul><h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><ul><li>优先级在redis.conf中默认：slave-priority 100，<strong>值越小优先级越高</strong></li><li><strong>偏移量是指获得原主机数据最全的</strong></li><li>每个redis实例启动后都会<strong>随机生成一个40位的runid</strong></li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015103154028.png" alt="image-20221015103154028"></p><h3 id="java代码实现"><a href="#java代码实现" class="headerlink" title="java代码实现"></a>java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisSentinelPool jedisSentinelPool=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  Jedis <span class="title function_">getJedisFromSentinel</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(jedisSentinelPool==<span class="literal">null</span>)&#123;</span><br><span class="line">        Set&lt;String&gt; sentinelSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        sentinelSet.add(<span class="string">&quot;192.168.11.103:26379&quot;</span>);</span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">10</span>); <span class="comment">//最大可用连接数</span></span><br><span class="line">jedisPoolConfig.setMaxIdle(<span class="number">5</span>); <span class="comment">//最大闲置连接数</span></span><br><span class="line">jedisPoolConfig.setMinIdle(<span class="number">5</span>); <span class="comment">//最小闲置连接数</span></span><br><span class="line">jedisPoolConfig.setBlockWhenExhausted(<span class="literal">true</span>); <span class="comment">//连接耗尽是否等待</span></span><br><span class="line">jedisPoolConfig.setMaxWaitMillis(<span class="number">2000</span>); <span class="comment">//等待时间</span></span><br><span class="line">jedisPoolConfig.setTestOnBorrow(<span class="literal">true</span>); <span class="comment">//取连接的时候进行一下测试 ping pong</span></span><br><span class="line">jedisSentinelPool=<span class="keyword">new</span> <span class="title class_">JedisSentinelPool</span>(<span class="string">&quot;mymaster&quot;</span>,sentinelSet,jedisPoolConfig);</span><br><span class="line">        <span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>容量不够，redis如何进行扩容？</li><li>并发写操作， redis如何分摊？</li><li>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是<strong>无中心化集群配置</strong>。</li></ul><h2 id="什么是集群"><a href="#什么是集群" class="headerlink" title="什么是集群"></a>什么是集群</h2><ul><li>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，<strong>将整个数据库分布存储在这N个节点中，每个节点存储总数据的1&#x2F;N</strong>。</li><li>Redis 集群<strong>通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求</strong>。</li></ul><h2 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h2><h3 id="删除持久化数据"><a href="#删除持久化数据" class="headerlink" title="删除持久化数据"></a>删除持久化数据</h3><ul><li>将rdb、aof文件都删除</li></ul><h3 id="制作6个redis实例，6379，6380，6381，6389，6390，6391"><a href="#制作6个redis实例，6379，6380，6381，6389，6390，6391" class="headerlink" title="制作6个redis实例，6379，6380，6381，6389，6390，6391"></a>制作6个redis实例，6379，6380，6381，6389，6390，6391</h3><h3 id="配置所有实例的基本信息"><a href="#配置所有实例的基本信息" class="headerlink" title="配置所有实例的基本信息"></a>配置所有实例的基本信息</h3><ul><li>include基本配置</li><li>开启daemonize yes</li><li>Pid文件名字</li><li>指定端口</li><li>Log文件名字</li><li>Dump.rdb名字</li><li>Appendonly 关掉或者换名字</li></ul><h3 id="redis-cluster（集群）配置修改"><a href="#redis-cluster（集群）配置修改" class="headerlink" title="redis cluster（集群）配置修改"></a>redis cluster（集群）配置修改</h3><ul><li><p><strong>cluster-enabled yes</strong>  打开集群模式</p></li><li><p><strong>cluster-config-file nodes-6379.conf</strong> 设定节点配置文件名</p></li><li><p><strong>cluster-node-timeout 15000</strong>  设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</p></li><li><p>配置示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">include /home/bigdata/redis.conf</span><br><span class="line">port 6379</span><br><span class="line">pidfile &quot;/var/run/redis_6379.pid&quot;</span><br><span class="line">dbfilename &quot;dump6379.rdb&quot;</span><br><span class="line">dir &quot;/home/bigdata/redis_cluster&quot;</span><br><span class="line">logfile &quot;/home/bigdata/redis_cluster/redis_err_6379.log&quot;</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure></li></ul><h3 id="修改好redis6379-conf文件，拷贝多个redis-conf文件"><a href="#修改好redis6379-conf文件，拷贝多个redis-conf文件" class="headerlink" title="修改好redis6379.conf文件，拷贝多个redis.conf文件"></a>修改好redis6379.conf文件，拷贝多个redis.conf文件</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015113959317.png" alt="image-20221015113959317"></p><h3 id="使用查找替换修改另外5个文件的内容"><a href="#使用查找替换修改另外5个文件的内容" class="headerlink" title="使用查找替换修改另外5个文件的内容"></a>使用查找替换修改另外5个文件的内容</h3><ul><li>例如：%s&#x2F;6379&#x2F;6380</li></ul><h3 id="启动6个redis服务"><a href="#启动6个redis服务" class="headerlink" title="启动6个redis服务"></a>启动6个redis服务</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015114051147.png" alt="image-20221015114051147"></p><h3 id="将6个节点合成一个集群"><a href="#将6个节点合成一个集群" class="headerlink" title="将6个节点合成一个集群"></a>将6个节点合成一个集群</h3><ul><li><p>组合之前，<strong>请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015114158540.png" alt="image-20221015114158540"></p></li><li><p>合体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391</span><br></pre></td></tr></table></figure><p>此处不要用127.0.0.1，请用真实的IP地址</p><p><strong>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机</strong>，正好三组。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015114356061.png" alt="image-20221015114356061"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015114418734.png" alt="image-20221015114418734"></p></li><li><p>登录：不要使用普通方式登录集群，因为用普通方式登录可能会直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，<strong>应该以集群方式登录</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015114551455.png" alt="image-20221015114551455"></p></li></ul><h2 id="以集群方式登录集群"><a href="#以集群方式登录集群" class="headerlink" title="以集群方式登录集群"></a>以集群方式登录集群</h2><ul><li><p><strong>登录时添加-c参数表示采用集群策略连接，写数据会自动切换到相应的写主机</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015114727624.png" alt="image-20221015114727624"></p></li></ul><h2 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h2><ul><li><p>通过<strong>cluster nodes 命令查看集群信息</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015114809189.png" alt="image-20221015114809189"></p></li></ul><h2 id="redis-cluster（集群）如何分配节点？"><a href="#redis-cluster（集群）如何分配节点？" class="headerlink" title="redis cluster（集群）如何分配节点？"></a>redis cluster（集群）如何分配节点？</h2><ul><li><strong>一个集群至少要有三个主节点</strong>。</li><li>选项 <strong>–cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点</strong>。</li><li>分配原则<strong>尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上</strong>。</li></ul><h2 id="什么是slots"><a href="#什么是slots" class="headerlink" title="什么是slots"></a>什么是slots</h2><ul><li><p>在配置完redis集群之后会弹出这样的信息：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015114418734.png" alt="image-20221015114418734"></p><p>其中的slots代表什么呢？</p></li><li><p>一个 Redis 集群包含 16384 个插槽（hash slot）， <strong>数据库中的每个键都属于这 16384 个插槽的其中一个</strong>，<strong>一个插槽中可以有多个键，但一个键只对应一个插槽</strong>。</p></li><li><p><strong>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽</strong>， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p></li><li><p><strong>集群中的每个节点负责处理一部分插槽</strong>。 举个例子， 如果一个集群可以有主节点， 其中：</p><p>节点 A 负责处理 0 号至 5460 号插槽。</p><p>节点 B 负责处理 5461 号至 10922 号插槽。</p><p>节点 C 负责处理 10923 号至 16383 号插槽。</p></li></ul><h2 id="在集群中录入值"><a href="#在集群中录入值" class="headerlink" title="在集群中录入值"></a>在集群中录入值</h2><ul><li><p><strong>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽</strong>，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。</p></li><li><p>redis-cli客户端提供了<strong>–c 参数登录实现自动重定向</strong>。如redis-cli  -c –p 6379 登入后，再录入、查询键值对可以自动重定向。</p></li><li><p><strong>不在一个slot下的键值，是不能使用mget,mset等多键操作</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015120213529.png" alt="image-20221015120213529"></p></li><li><p>可以<strong>通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015120259156.png" alt="image-20221015120259156"></p></li></ul><h2 id="查询集群中的值"><a href="#查询集群中的值" class="headerlink" title="查询集群中的值"></a>查询集群中的值</h2><ul><li>**cluster keyslot &lt;key&#x2F;组名&gt;**：返回指定key所在的slot的编号</li><li>**cluster countkeysinslot  &lt;slot&gt;**：返回指定slot所拥有的key的数量</li><li>**cluster getkeysinslot &lt;slot&gt; &lt;count&gt;**：返回 count 个 slot 槽中的键。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015120349902.png" alt="image-20221015120349902"></p><h2 id="故障恢复-1"><a href="#故障恢复-1" class="headerlink" title="故障恢复"></a>故障恢复</h2><ul><li><p>如果主节点下线？从节点能否自动升为主节点？答：能，注意：<strong>15秒超时</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015121830226.png" alt="image-20221015121830226"></p></li><li><p>主节点恢复后，主从关系会如何？答：主节点回来会变成从机。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015121849156.png" alt="image-20221015121849156"></p></li><li><p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p><p><strong>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉。</strong></p><p><strong>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</strong></p><p>redis.conf中的参数  cluster-require-full-coverage</p></li></ul><h2 id="集群的Jedis开发"><a href="#集群的Jedis开发" class="headerlink" title="集群的Jedis开发"></a>集群的Jedis开发</h2><ul><li><p>即使连接的不是主机，<strong>集群会自动切换主机存储。主机写，从机读</strong>。</p></li><li><p><strong>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据</strong>。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisClusterTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">     Set&lt;HostAndPort&gt;set =<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;HostAndPort&gt;();</span><br><span class="line">     set.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.31.211&quot;</span>,<span class="number">6379</span>));</span><br><span class="line">     JedisCluster jedisCluster=<span class="keyword">new</span> <span class="title class_">JedisCluster</span>(set);</span><br><span class="line">     jedisCluster.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">     System.out.println(jedisCluster.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Redis集群提供了以下好处"><a href="#Redis集群提供了以下好处" class="headerlink" title="Redis集群提供了以下好处"></a>Redis集群提供了以下好处</h2><ul><li><strong>实现扩容</strong></li><li><strong>分摊压力</strong></li><li><strong>无中心配置相对简单</strong></li></ul><h2 id="Redis集群的不足"><a href="#Redis集群的不足" class="headerlink" title="Redis集群的不足"></a>Redis集群的不足</h2><ul><li><strong>多键操作是不被支持的</strong>，因为多个键所在的slot可能不同。</li><li><strong>多键的Redis事务是不被支持的，lua脚本不被支持</strong>。</li><li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而<strong>代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大</strong>。</li></ul><h1 id="Redis应用问题解决"><a href="#Redis应用问题解决" class="headerlink" title="Redis应用问题解决"></a>Redis应用问题解决</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li><p><strong>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源</strong>。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015154904013.png" alt="image-20221015154904013"></p></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>一个一定不存在缓存即查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p></li><li><p>解决方案：</p><ol><li><p><strong>对空值缓存</strong>：如果一个查询返回的数据为空（不管是数据是否不存在），我们<strong>仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</strong>。</p></li><li><p><strong>设置可访问的名单（白名单）</strong>：使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，<strong>如果访问id不在bitmaps里面，进行拦截，不允许访问</strong>。</p></li><li><p><strong>采用布隆过滤器</strong>：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)</p><p><strong>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力</strong>。</p></li><li><p><strong>进行实时监控</strong>：当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，<strong>和运维人员配合，可以设置黑名单限制服务</strong>。</p></li></ol></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015155516731.png" alt="image-20221015155516731"></p></li></ul><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p></li><li><p>解决问题：</p><ol><li><p><strong>预先设置热门数据</strong>：在redis高峰访问之前，把一些热门数据提前存入到redis里面，<strong>加大这些热门数据key的时长</strong>。</p></li><li><p><strong>实时调整</strong>：现场监控哪些数据热门，<strong>实时调整key的过期时长</strong>。</p></li><li><p><strong>使用锁</strong>：就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key。当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015155826935.png" alt="image-20221015155826935"></p></li></ol></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。<strong>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key正常访问</strong>。</p></li><li><p>正常访问：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015160127583.png" alt="image-20221015160127583"></p></li><li><p>缓存失效瞬间：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015160147037.png" alt="image-20221015160147037"></p></li></ul><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>缓存失效时的雪崩效应对底层系统的冲击非常可怕！</li><li>解决方案：<ol><li><strong>构建多级缓存架构</strong>：nginx缓存 + redis缓存 +其他缓存（ehcache等）</li><li><strong>使用锁或队列</strong>：<strong>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写</strong>，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况。</li><li><strong>设置过期标志更新缓存</strong>：记录缓存数据是否过期（设置提前量），如果<strong>过期会触发通知另外的线程在后台去更新实际key的缓存</strong>。</li><li><strong>将缓存失效时间分散开</strong>：比如我们<strong>可以在原有的失效时间基础上增加一个随机值</strong>，比如1-5分钟随机，<strong>这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件</strong>。</li></ol></li></ul><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使<strong>原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问</strong>，这就是分布式锁要解决的问题！</p></li><li><p>分布式锁主流的实现方案：</p><ol><li>基于数据库实现分布式锁</li><li>基于缓存（Redis等）</li><li>基于Zookeeper</li></ol></li><li><p>每一种分布式锁解决方案都有各自的优缺点：</p><ol><li>性能：redis最高</li><li>可靠性：zookeeper最高</li></ol></li><li><p>这里，我们就基于redis实现分布式锁</p></li></ul><h3 id="解决方案：使用redis实现分布式锁"><a href="#解决方案：使用redis实现分布式锁" class="headerlink" title="解决方案：使用redis实现分布式锁"></a>解决方案：使用redis实现分布式锁</h3><ul><li><p>redis命令：<strong>set sku:1:info “OK” NX PX 10000</strong></p><p>**EX second **：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</p><p><strong>PX millisecond</strong> ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</p><p><strong>NX</strong> ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</p><p><strong>XX</strong> ：只在键已经存在时，才对键进行设置操作。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015165627020.png" alt="image-20221015165627020"></p><ol><li>多个客户端同时获取锁（setnx）</li><li>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</li><li>其他客户端等待重试</li></ol></li></ul><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><ul><li><p>redis中先set num 0</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1获取锁，setne</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">//2获取锁成功、查询num的值</span></span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="comment">//2.1判断num为空return</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2有值就转成成int</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(value+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//2.3把redis的num加1</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, ++num);</span><br><span class="line">        <span class="comment">//2.4释放锁，del</span></span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//3获取锁失败、每隔0.1秒再获取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重启服务器集群，通过网关进行压力测试：<strong>ab -n 1000 -c 100 <a href="http://192.168.140.1:8080/test/testLock">http://192.168.140.1:8080/test/testLock</a></strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015170050806.png" alt="image-20221015170050806"></p></li><li><p>查看redis中num的值：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015170111047.png" alt="image-20221015170111047"></p><p>可以发现符合预期结果，说明效果基本实现。</p></li><li><p>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放。</p><p>解决：设置过期时间，到规定的时间后自动释放锁。</p></li></ul><h3 id="优化之设置锁的过期时间"><a href="#优化之设置锁的过期时间" class="headerlink" title="优化之设置锁的过期时间"></a>优化之设置锁的过期时间</h3><ul><li><p>设置过期时间有两种方式：</p><ol><li>首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</li><li><strong>在set时指定过期时间（推荐）</strong></li></ol><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015170316729.png" alt="image-20221015170316729"></p></li><li><p>设置过期时间：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015170336763.png" alt="image-20221015170336763"></p><p>压力测试肯定也没有问题，自行进行测试。</p></li><li><p>问题：可能会释放其他服务器的锁</p></li><li><p>场景：如果业务逻辑的执行时间是7s。执行流程如下：</p><ol><li>index1业务逻辑没执行完，3秒后锁被自动释放。</li><li>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</li><li>index3获取到锁，执行业务逻辑</li><li>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。</li></ol><p>最终等于没锁的情况</p></li><li><p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p></li></ul><h3 id="优化之UUID防误删"><a href="#优化之UUID防误删" class="headerlink" title="优化之UUID防误删"></a>优化之UUID防误删</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015170615036.png" alt="image-20221015170615036"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015170624482.png" alt="image-20221015170624482"></p><ul><li><p>问题：删除操作缺乏原子性</p></li><li><p>场景：</p><ol><li><p>index1执行删除时，查询到的lock值确实和uuid相等</p><p>uuid&#x3D;v1</p><p>set(lock,uuid)；</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015171522206.png" alt="image-20221015171522206"> </p></li><li><p>index1执行删除前，lock刚好过期时间已到，被redis自动释放</p><p>在redis中没有了lock，没有了锁。</p></li></ol><p>​    <img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015172129853.png" alt="image-20221015172129853"></p><ol start="3"><li><p>index2获取了lock</p><p>index2线程获取到了cpu的资源，开始执行方法</p><p>uuid&#x3D;v2</p><p>set(lock,uuid)；</p></li><li><p>index1执行删除，此时会把index2的lock删除</p><p>index1 因为已经在方法中了，所以不需要重新上锁。index1有执行的权限。index1已经比较完成了，这个时候，开始执行</p><p> <img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015172147236.png" alt="image-20221015172147236"></p><p>删除的index2的锁！</p></li></ol></li></ul><h3 id="优化之LUA脚本保证删除的原子性"><a href="#优化之LUA脚本保证删除的原子性" class="headerlink" title="优化之LUA脚本保证删除的原子性"></a>优化之LUA脚本保证删除的原子性</h3><ul><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLockLua&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLockLua</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">//2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">skuId</span> <span class="operator">=</span> <span class="string">&quot;25&quot;</span>; <span class="comment">// 访问skuId 为25号的商品 100008348542</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">locKey</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span> + skuId; <span class="comment">// 锁住的是每个商品的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(locKey, uuid, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种： lock 与过期时间中间不写任何的代码。</span></span><br><span class="line">    <span class="comment">// redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);//设置过期时间</span></span><br><span class="line">    <span class="comment">// 如果true</span></span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 执行的业务逻辑开始</span></span><br><span class="line">        <span class="comment">// 获取缓存中的num 数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果是空直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(value + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 使num 每次+1 放入缓存</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, String.valueOf(++num));</span><br><span class="line">        <span class="comment">/*使用lua脚本来锁*/</span></span><br><span class="line">        <span class="comment">// 定义lua 脚本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="comment">// 使用redis执行lua执行</span></span><br><span class="line">        DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        redisScript.setScriptText(script);</span><br><span class="line">        <span class="comment">// 设置一下返回值类型 为Long</span></span><br><span class="line">        <span class="comment">// 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，</span></span><br><span class="line">        <span class="comment">// 那么返回字符串与0 会有发生错误。</span></span><br><span class="line">        redisScript.setResultType(Long.class);</span><br><span class="line">        <span class="comment">// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。</span></span><br><span class="line">        redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他线程等待</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 睡眠</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">// 睡醒了之后，调用方法。</span></span><br><span class="line">            testLockLua();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Lua脚本详解：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015170739599.png" alt="image-20221015170739599"></p></li><li><p>项目中正确使用：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015170812863.png" alt="image-20221015170812863"></p></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li><p>加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 从redis中获取锁,set k1 v1 px 20000 nx</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.redisTemplate.opsForValue()</span><br><span class="line">      .setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></li><li><p>使用lua释放锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 释放锁 del</span></span><br><span class="line"><span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line"><span class="comment">// 设置lua脚本返回的数据类型</span></span><br><span class="line">DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 设置lua脚本返回类型为Long</span></span><br><span class="line">redisScript.setResultType(Long.class);</span><br><span class="line">redisScript.setScriptText(script);</span><br><span class="line">redisTemplate.execute(redisScript, Arrays.asList(<span class="string">&quot;lock&quot;</span>),uuid);</span><br></pre></td></tr></table></figure></li><li><p>重试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">testLock();</span><br></pre></td></tr></table></figure></li><li><p>为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p><ul><li>互斥性。<strong>在任意时刻，只有一个客户端能持有锁</strong>。</li><li><strong>不会发生死锁</strong>。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>解铃还须系铃人。<strong>加锁和解锁必须是同一个客户端</strong>，客户端自己不能把别人加的锁给解了。</li><li><strong>加锁和解锁必须具有原子性</strong>。</li></ul></li></ol><h1 id="Redis6-0新功能"><a href="#Redis6-0新功能" class="headerlink" title="Redis6.0新功能"></a>Redis6.0新功能</h1><h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><h3 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h3><ul><li><p>Redis ACL是Access Control List（访问控制列表）的缩写，<strong>该功能允许根据可以执行的命令和可以访问的键来限制某些连接，说白了就是可以进行基于用户的权限管理</strong>。</p></li><li><p>在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。<strong>Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制</strong> ：</p><ol><li>接入权限:用户名和密码 </li><li>可以执行的命令 </li><li>可以操作的 KEY</li></ol></li><li><p>参考官网：<a href="https://redis.io/topics/acl">https://redis.io/topics/acl</a></p></li></ul><h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><ol><li><p>使用<strong>acl list</strong>命令<strong>展现用户权限列表</strong>，数据说明：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015161827095.png" alt="image-20221015161827095"></p></li><li><p>使用<strong>acl cat</strong>命令<strong>查看添加权限指令类别</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015161936151.png" alt="image-20221015161936151"></p><p><strong>加参数类型名可以查看类型下具体命令</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015162016482.png" alt="image-20221015162016482"></p></li><li><p>使用<strong>acl whoami</strong>命令查看当前用户：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015162046674.png" alt="image-20221015162046674"></p></li><li><p>使用<strong>acl setuser</strong>命令<strong>创建和编辑用户的ACL</strong></p><ul><li><p>ACL规则：下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015162430565.png" alt="image-20221015162430565"></p></li><li><p>通过命令创建新用户默认权限：<strong>acl setuser user1</strong>，在这个示例中，我根本没有指定任何规则。如果用户不存在，这将<strong>使用just created的默认属性来创建用户</strong>。如果用户已经存在，则上面的命令将不执行任何操作。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015162749523.png" alt="image-20221015162749523"></p></li><li><p>设置有用户名、密码、ACL权限并启用的用户：<em><em>acl setuser user2 on &gt;password ~cached:</em> +get</em>*</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015162858006.png" alt="image-20221015162858006"></p></li><li><p>使用<strong>auth username password</strong>切换用户，验证权限：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015162942902.png" alt="image-20221015162942902"></p></li></ul></li></ol><h2 id="IO多线程"><a href="#IO多线程" class="headerlink" title="IO多线程"></a>IO多线程</h2><h3 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h3><ul><li><p>Redis6终于支撑多线程了，告别单线程了吗？IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非执行命令多线程。<strong>Redis6执行命令依然是单线程</strong>。</p></li><li><p>另外，多线程IO默认也是不开启的，需要在配置文件中配置：</p><p><strong>io-threads-do-reads  yes</strong> &#x2F;&#x2F;开启多线程IO</p><p><strong>io-threads 4</strong> &#x2F;&#x2F;最大线程数？</p></li></ul><h3 id="原理架构"><a href="#原理架构" class="headerlink" title="原理架构"></a>原理架构</h3><ul><li><p>Redis 6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。<strong>Redis 的多线程部分只是用来处理网络数据的读写和协议解析</strong>，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH&#x2F;LPOP 等等的并发问题。整体的设计大体如下:</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015164018542.png" alt="image-20221015164018542"></p></li></ul><h2 id="工具支持Cluster"><a href="#工具支持Cluster" class="headerlink" title="工具支持Cluster"></a>工具支持Cluster</h2><ul><li><p>之前老版Redis想要搭集群需要单独安装ruby环境，<strong>Redis 5 将 redis-trib.rb 的功能集成到 redis-cli</strong>。另外<strong>官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015164928416.png" alt="image-20221015164928416"></p></li></ul><h2 id="Redis新功能持续关注"><a href="#Redis新功能持续关注" class="headerlink" title="Redis新功能持续关注"></a>Redis新功能持续关注</h2><ul><li>Redis6新功能还有：<ol><li><strong>RESP3新的 Redis 通信协议</strong>：优化服务端与客户端之间通信</li><li><strong>Client side caching客户端缓存</strong>：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。</li><li><strong>Proxy集群代理模式</strong>：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。</li><li><strong>Modules API</strong>：Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。</li></ol></li></ul><h1 id="Redis实战：黑马点评项目"><a href="#Redis实战：黑马点评项目" class="headerlink" title="Redis实战：黑马点评项目"></a>Redis实战：黑马点评项目</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;NoSQL数据库简介&quot;&gt;&lt;a href=&quot;#NoSQL数据库简介&quot; class=&quot;headerlink&quot; title=&quot;NoSQL数据库简介&quot;&gt;&lt;/a&gt;NoSQL数据库简</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://konjacor.github.io/tags/Redis/"/>
    
    <category term="非关系型数据库" scheme="https://konjacor.github.io/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="中间件" scheme="https://konjacor.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="https://konjacor.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>https://konjacor.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2022-09-25T11:54:24.000Z</published>
    <updated>2022-12-20T12:11:43.206Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="常用排序算法的总结和对比"><a href="#常用排序算法的总结和对比" class="headerlink" title="常用排序算法的总结和对比"></a>常用排序算法的总结和对比</h2><h3 id="一张排序算法的比较图"><a href="#一张排序算法的比较图" class="headerlink" title="一张排序算法的比较图"></a>一张排序算法的比较图</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106091748277.png" alt="image-20221106091748277"></p><h3 id="相关术语解释"><a href="#相关术语解释" class="headerlink" title="相关术语解释"></a>相关术语解释</h3><ol><li>稳定：如果 a 原本在 b 前面，而 a&#x3D;b，排序之后 a 仍然在 b 的前面；</li><li>不稳定：如果 a 原本在 b 的前面，而 a&#x3D;b，排序之后 a 可能会出现在 b 的后面；</li><li>内部排序：所有排序操作都在内存中完成；</li><li>外部排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度： 一个算法执行所耗费的时间。</li><li>空间复杂度：运行完一个程序所需内存的大小。</li><li>n: 数据规模</li><li>k: “桶”的个数</li><li>In-place: 不占用额外内存</li><li>Out-place: 占用额外内存</li></ol><h2 id="新人入坑冒泡排序"><a href="#新人入坑冒泡排序" class="headerlink" title="新人入坑冒泡排序"></a>新人入坑冒泡排序</h2><ul><li>这个是典中典了，任何学过算法的人估计都学过这个吧，它简单的算法思想也让他成为了入坑排序算法的最佳选择。</li></ul><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,<strong>依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部</strong>，就象水底下的气泡一样逐渐向上冒。</li><li>需要两层循环，<strong>每次外层循环都会使得无序区域最大的一个数字到达正确的位置</strong>，对于长度为n的序列，我们只需要将外层循环做n-1次即可使整个序列有序，<strong>内层循环遍历整个序列的无序部分，目的是让目标元素和相邻元素做比较从而将目标元素放到它该在的地方</strong>。</li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>由于需要两层循环来实现该算法，并且每层循环都和序列长度n有关，所以它的<strong>时间复杂度是：O(n^2)</strong></li></ul><h3 id="冒泡过程图解"><a href="#冒泡过程图解" class="headerlink" title="冒泡过程图解"></a>冒泡过程图解</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105225817170.png" alt="image-20221105225817170"></p><h3 id="对于冒泡排序的优化"><a href="#对于冒泡排序的优化" class="headerlink" title="对于冒泡排序的优化"></a>对于冒泡排序的优化</h3><ul><li>因为排序的过程中，各元素不断接近自己的位置，<strong>如果一趟比较下来没有进行过交换，就说明序列已经有序，就不用做后续的比较操作了</strong>，因此要<strong>在排序过程中设置一个标志 flag 判断元素是否进行过交换，从而减少不必要的比较</strong>。</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-07 20:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//归位n-1个数字即可使数组有序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n-i;++j)&#123;<span class="comment">//每次内层循环需要的次数由于上次数字归位而递减</span></span><br><span class="line">                <span class="keyword">if</span>(num[j]&gt;num[j+<span class="number">1</span>])&#123;<span class="comment">//交换两数的原地算法,但是这样写在数据很大的情况下有数值溢出风险</span></span><br><span class="line">                    num[j] += num[j+<span class="number">1</span>];</span><br><span class="line">                    num[j+<span class="number">1</span>] = num[j] - num[j+<span class="number">1</span>];</span><br><span class="line">                    num[j] -= num[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(num[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="先挑后换选择排序"><a href="#先挑后换选择排序" class="headerlink" title="先挑后换选择排序"></a>先挑后换选择排序</h2><ul><li>总是和插入排序混掉，这个选择排序是从后面的序列中按一定规则挑出元素来换到前面，而插入排序是从后面的序列中取第一个数然后按一定规则插入到前面，<strong>它们的区别在于选择排序的比较规则体现在后面的序列中，插入排序的比较规则体现在前面的序列中</strong>。</li></ul><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>选择式排序也属于内部排序法，是<strong>从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的</strong>。</li></ul><h3 id="选择排序思想"><a href="#选择排序思想" class="headerlink" title="选择排序思想"></a>选择排序思想</h3><ul><li>选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：<strong>第一次从 arr[0]<del>arr[n-1]中选取最小值，与 arr[0]交换，第二次从 arr[1]</del>arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]<del>arr[n-1]中选取最小值，与 arr[2]交换，…，第 i 次从 arr[i-1]</del>arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值，与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列</strong>。</li><li>和冒泡排序相似，也是两层循环，<strong>外层循环跑一次都会让一个元素归位，内层循环遍历后面的无序序列，挑出其中最小的和无序队列的头部元素进行交换</strong>。对于长度为n的序列，外层循环只需要跑n-1次即可使序列有序。</li></ul><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>由于是两层循环，还都和序列的长度有关，所以<strong>时间复杂度是O(n^2)的</strong></li></ul><h3 id="选择排序过程图解"><a href="#选择排序过程图解" class="headerlink" title="选择排序过程图解"></a>选择排序过程图解</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105230143186.png" alt="image-20221105230143186"></p><ul><li><p>对一个数组的选择排序再进行图解：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105230338223.png" alt="image-20221105230338223"></p></li></ul><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-07 20:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;++i)&#123;<span class="comment">//归位n-1个数字即可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> num[i];<span class="comment">//让无序区第一个元素先当min，之后动态更新</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> i;<span class="comment">//最小值对应的坐标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;<span class="comment">//从后面的无序区域找最小的换到无序区的最前面，外面每循环一次，无序区域就减少一个单位，由于之前默认让无序区的第一元素作为最小值并知晓其坐标，所以就没必要遍历第一个元素了</span></span><br><span class="line">                <span class="keyword">if</span>(min&gt;num[j])&#123;</span><br><span class="line">                    min = num[j];</span><br><span class="line">                    pos = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos!=i) &#123;<span class="comment">//如果最小值不是无序区的头元素就原地算法交换两数，如果忘了判断最小值是不是无序区的头元素，利用原地交换算法就会出错，但是还是那个问题，如果数据过大会数值溢出</span></span><br><span class="line">                num[i] += num[pos];</span><br><span class="line">                num[pos] = num[i] - num[pos];</span><br><span class="line">                num[i] -= num[pos];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(num[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="先取后插插入排序"><a href="#先取后插插入排序" class="headerlink" title="先取后插插入排序"></a>先取后插插入排序</h2><ul><li>总是和选择排序混掉，选择排序是从后面的序列中按一定规则挑出元素来换到前面，而插入排序是从后面的序列中取第一个数然后按一定规则插入到前面，<strong>它们的区别在于选择排序的比较规则体现在后面的序列中，插入排序的比较规则体现在前面的序列中</strong>。</li></ul><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。</li></ul><h3 id="插入排序思想"><a href="#插入排序思想" class="headerlink" title="插入排序思想"></a>插入排序思想</h3><ul><li>插入排序（Insertion Sorting）的基本思想是：<strong>把 n 个待排序的元素看成为一个有序表和一个无序表</strong>，开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，<strong>排序过程中每次从无序表中取出第一个元素，把它的排序码依次与前面有序表元素的排序码进行比较，如果满足给定的条件就进行交换，如果中间某一次没有交换，说明该元素已经归位，这样做能将它插入到有序表中的适当位置，使之成为有序表的一部分</strong>。</li><li>也是需要两层循环，<strong>外层循环每循环一次都会将一个无序区的元素归位，内层循环主要是让选中的元素和前面的有序部分进行逐个比较好确定选中的元素应该插入的位置</strong>。</li></ul><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>由于还是两层循环，并且每层循环都和序列长度有关，所以<strong>时间复杂度还是O(n^2)的</strong>。</li></ul><h3 id="插入排序过程图解"><a href="#插入排序过程图解" class="headerlink" title="插入排序过程图解"></a>插入排序过程图解</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105232220474.png" alt="image-20221105232220474"></p><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-07 23:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//第一个元素可以看作已经归位，也就是说刚开始有序区是1，接下来把剩下的n-1个元素插入到有序区即可</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=<span class="number">0</span>;--j)&#123;<span class="comment">//让无序区的头元素向前（也就是有序区）基于比较来进行移动，中间某一次没移动就说明归位了，退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(num[j]&lt;num[j-<span class="number">1</span>])&#123;<span class="comment">//交换两数的原地算法，还是那个问题，如果数据过大会数值溢出</span></span><br><span class="line">                    num[j] += num[j-<span class="number">1</span>];</span><br><span class="line">                    num[j-<span class="number">1</span>] = num[j] - num[j-<span class="number">1</span>];</span><br><span class="line">                    num[j] -= num[j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(num[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插排优化希尔排序"><a href="#插排优化希尔排序" class="headerlink" title="插排优化希尔排序"></a>插排优化希尔排序</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。<strong>希尔排序也是一种插入排序</strong>，它<strong>是简单插入排序经过改进之后的一个更高效的版本</strong>，也称为<strong>缩小增量排序</strong>。</li></ul><h3 id="希尔排序思想"><a href="#希尔排序思想" class="headerlink" title="希尔排序思想"></a>希尔排序思想</h3><ul><li><p>在简单插入排序中存在这样一个问题，说极端点就是如果最后一个无序元素非常小，那么它在插入到前面有序序列时的消耗是很大的，我们自然不希望看到这样的情况频繁发生，所以<strong>希尔排序的思想就是以这一点为切入点，通过增量分组的方式，每次分组排序后都尽量让整个序列均匀，也就是每次分组排序后让整个序列尽可能有序，防止出现某个元素消耗过多的时间去比较，从而优化时间复杂度</strong>。</p></li><li><p>希尔排序是<strong>把记录按下标的一定增量分组，对每组使用直接插入排序算法排序</strong>；随着增量逐渐减少，每组包含的关键词越来越多，<strong>当增量减至 1 时，整个文件恰被分成一组，算法便终止</strong>。</p></li><li><p>需要三层循环，<strong>外层循环负责控制分组步长大小，步长大小从序列的长度开始，之后的每次步长都是上次步长的一半，直到步长大小变成0，退出循环</strong>。<strong>中层循环每次从下标为分组步长的元素开始（这个下标对应着所有分组的最前面的无序元素）负责遍历每个分组无序区的元素（步长为1挪到最后就相当于遍历了所有分组的无序元素）</strong>。<strong>内层循环负责对遍历到的无序元素在它们组内（体现在每次比较跨越的步长为外层循环的值，这样可以保证相互比较的值都是同一组）进行插入排序（基于比较往前挪，直到中间某一次没挪，说明归位了）</strong>。</p></li><li><p>写完代码说一句：不愧是历史上时间复杂度首次突破O(n^2)的算法，这三层循环真是挺巧妙的。</p></li></ul><h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>查前面那个表。</li></ul><h3 id="希尔排序流程图解"><a href="#希尔排序流程图解" class="headerlink" title="希尔排序流程图解"></a>希尔排序流程图解</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106092745473.png" alt="image-20221106092745473"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106092757251.png" alt="image-20221106092757251"></p><h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-08 9:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=num.length/<span class="number">2</span>;k&gt;<span class="number">0</span>;k/=<span class="number">2</span>)&#123;<span class="comment">//控制分组步长，从数组长度除2开始，每次迭代都除2，直到小于等于0，说明已经排好序了</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;num.length;++i)&#123;<span class="comment">//为了进行插入排序，我们首先要定位到每一组无序区的头元素，而每轮的k正好是所有分组的第一组的无序区的头元素（因为第一组的有序区元素下标为0，这个下标加上步长k正好是无序区的头元素，而第一组的无序区头元素又是所有分组中最靠前的，可以保证在它之后的所有元素都是无序区的元素，在它前面的元素都是有序区的元素），之后每次i++的时候就相当于遍历到了别的分组的无序区的头元素，遍历完一轮分组之后，所有无序区的头元素归位，继续i++就是遍历所有分组的新无序区的头元素，直到最后，i可以遍历完所有分组的无序区</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i-k;j&gt;=<span class="number">0</span>;j-=k)&#123;<span class="comment">//把上一层循环选中的元素移动到它所在分组的有序区的正确位置，基于比较移动</span></span><br><span class="line">                    <span class="keyword">if</span>(j!=j+k&amp;&amp;num[j]&gt;num[j+k])&#123;<span class="comment">//原地交换，还是那些问题，数据过大会导致数值溢出并且两边下标相同时会出现问题，总的说就是交换两个元素的时候最少需要两个单位的空间（两个元素已经占用了两个单位的空间）</span></span><br><span class="line">                        num[j] += num[j+k];</span><br><span class="line">                        num[j+k] = num[j] - num[j+k];</span><br><span class="line">                        num[j] -= num[j+k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(num[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="期待已久的堆排序"><a href="#期待已久的堆排序" class="headerlink" title="期待已久的堆排序"></a>期待已久的堆排序</h2><ul><li>堆排序这个东西，在上大一的时候就有所耳闻，然而当时写题都用c++自带的快速排序的函数，所以对这种神奇的排序方法也没有深究，这一眨眼上大三了，学校里也开了算法的课程，正好学到了这个堆排序，我听了听确实巧妙，回来之后根据自己的理解进行了实现，下面细说。</li></ul><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><ul><li><p><strong>同时满足以下两个条件</strong>的数据结构被称为堆：</p><ol><li>堆是一颗<strong>完全二叉树</strong></li><li>堆的<strong>每一个节点的值都大于等于或都小于等于其子节点的值</strong></li></ol></li><li><p>每个节点的值都大于等于其子节点的值的堆被称为<strong>最大堆（或者是大根堆）</strong>，剩下的那种情况被称为<strong>最小堆（或者是小根堆）</strong>。</p></li></ul><h3 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h3><ul><li>由于二叉树特殊的访问性质，所以我们一般都<strong>通过数组来存储堆</strong>，可以通过二叉树的性质来对一个节点的父节点或是子节点进行访问，比如说<strong>下标为i的节点的父节点的下标为floor((i-1)&#x2F;2)</strong>,<strong>其子节点的下标为(i*2+1)和(i*2+2)</strong></li></ul><h3 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h3><h4 id="节点上移（ShiftUp）"><a href="#节点上移（ShiftUp）" class="headerlink" title="节点上移（ShiftUp）"></a>节点上移（ShiftUp）</h4><ul><li><p>这个操作可以<strong>让某个节点上移直到合适的位置</strong>，由于其父节点只可能有一个，因此只需要进行一次判断并且只有一种上移路径，其中应该格外注意在进行节点上移的时候不要发生数组越界。</p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">shiftUp</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (index&gt;<span class="number">0</span> &amp;&amp; num[index]&gt;num[(index-<span class="number">1</span>)/<span class="number">2</span>])&#123;<span class="comment">//没越界，并且当前节点位置异常</span></span><br><span class="line">        <span class="comment">//System.out.println(1);</span></span><br><span class="line">   <span class="comment">//下面三行是交换操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num[index];</span><br><span class="line">        num[index] = num[(index-<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">        num[(index-<span class="number">1</span>)/<span class="number">2</span>] = temp;</span><br><span class="line">        <span class="comment">//坐标重定向为交换过去的位置</span></span><br><span class="line">        index = (index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="节点下移（ShiftDown）"><a href="#节点下移（ShiftDown）" class="headerlink" title="节点下移（ShiftDown）"></a>节点下移（ShiftDown）</h4><ul><li><p>这个操作可以<strong>让某个节点下移直到合适的位置</strong>，其子节点可能有多个，因此需要进行两次判断，由于有两种下移路径，我们应该<strong>选用最合适的路径进行下移</strong>，其中应该格外注意在进行节点下移的时候不要发生数组越界。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">shiftDown</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((index*<span class="number">2</span>+<span class="number">1</span>)&lt;len &amp;&amp; (index*<span class="number">2</span>+<span class="number">2</span>)&lt;len)&#123;<span class="comment">//有俩孩子的情况</span></span><br><span class="line">        <span class="comment">//System.out.println(1);</span></span><br><span class="line">        <span class="keyword">if</span>(!(num[index]&gt;=num[index*<span class="number">2</span>+<span class="number">1</span>]&amp;&amp;num[index]&gt;=num[index*<span class="number">2</span>+<span class="number">2</span>]))&#123;<span class="comment">//当前节点位置异常，选最合适的一条路径进行下移</span></span><br><span class="line">            <span class="keyword">if</span>(num[index*<span class="number">2</span>+<span class="number">1</span>]&gt;num[index*<span class="number">2</span>+<span class="number">2</span>])&#123;<span class="comment">//第一种情况</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num[index];</span><br><span class="line">                num[index] = num[index*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">                num[index*<span class="number">2</span>+<span class="number">1</span>] = temp;</span><br><span class="line">                index = index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//第二种情况</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num[index];</span><br><span class="line">                num[index] = num[index*<span class="number">2</span>+<span class="number">2</span>];</span><br><span class="line">                num[index*<span class="number">2</span>+<span class="number">2</span>] = temp;</span><br><span class="line">                index = index*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">//注意这个地方少了会死循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((index*<span class="number">2</span>+<span class="number">1</span>)&lt;len)&#123;<span class="comment">//只有一个孩子的情况，顶多再下移一次了，既能保证一开始就是这样的情况，又能保证上面的代码执行完毕后剩下的是这种情况，一举两得。</span></span><br><span class="line">        <span class="keyword">if</span>(num[index]&lt;num[index*<span class="number">2</span>+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num[index];</span><br><span class="line">            num[index] = num[index*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">            num[index*<span class="number">2</span>+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="插入元素（Insert）"><a href="#插入元素（Insert）" class="headerlink" title="插入元素（Insert）"></a>插入元素（Insert）</h4><ul><li>将<strong>新元素加到堆的最后</strong>，将<strong>堆的规模加1</strong>，然后<strong>使用ShiftUp操作将新元素移动到合适的位置</strong>上</li><li>代码示例：</li></ul><h4 id="删除元素（Delete）"><a href="#删除元素（Delete）" class="headerlink" title="删除元素（Delete）"></a>删除元素（Delete）</h4><ul><li>将待删除的元素与最后一个元素进行交换，将堆的大小减1（也就是<strong>保证被删除的元素不参与元素上移或者下移的判断</strong>），然后<strong>再用ShiftDown操作或者ShiftUp操作来调整换上来的那个元素</strong>以维持堆的性质。</li><li>代码示例：</li></ul><h4 id="删除最大值（DeleteMax）"><a href="#删除最大值（DeleteMax）" class="headerlink" title="删除最大值（DeleteMax）"></a>删除最大值（DeleteMax）</h4><ul><li><strong>对栈顶元素进行删除元素操作</strong>即可。</li><li>代码示例：</li></ul><h4 id="创建堆（MakeHeap）"><a href="#创建堆（MakeHeap）" class="headerlink" title="创建堆（MakeHeap）"></a>创建堆（MakeHeap）</h4><ul><li><p>目的是<strong>将一个随机排列的数组变成一个符合堆定义的数组</strong></p></li><li><p>叶节点只有他本身，没有子树，所以它本身是符合堆的定义的，那么我们就需要<strong>从倒数第一个非叶节点开始进行操作</strong>，因为非叶节点有子树，并不能保证它们是符合堆的性质的，因此需要<strong>通过节点下移进行调整</strong>，调整完毕后当前子树符合堆的性质了，再往上走<strong>遇到节点时总能保证它的子树是符合堆定义的，但是顶点的位置不一定正常，因此只需要让顶点进行下移操作即可将其本身也调整为一个堆</strong>，调整完所有非叶节点后，所有子树包括它本身就都符合堆的定义了，这样一个堆就建好了。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shift</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(len-<span class="number">2</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i)&#123;<span class="comment">//从最后一个非叶节点开始</span></span><br><span class="line">        shiftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="堆排序（HeapSort）"><a href="#堆排序（HeapSort）" class="headerlink" title="堆排序（HeapSort）"></a>堆排序（HeapSort）</h4><ul><li><p>首先要<strong>保证这个数组符合堆的定义才能进行堆排序</strong>。</p></li><li><p>每次都<strong>让顶点元素和最后一个元素换位置</strong>，然后将<strong>堆的逻辑长度减1</strong>（也就是<strong>不让换到最后的元素参与下移的运算</strong>），此时除了顶点外别的部分都符合堆的定义，因此需要<strong>对顶点进行下移操作以保证堆的性质</strong>，这个操作完毕后第一轮就结束了，在<strong>堆最后的有序区增加了一个元素</strong>，一共执行这个操作n（数组长度）次，堆排序就做好了。</p></li><li><p>不难分析出**堆排序的时间复杂度是O(NlogN)**的，换位置的操作复杂度是O(N)，节点下移操作的复杂度是O(logN)，每次换位置的操作后都会有个下移操作，所以整体时间复杂度是O(NlogN)。</p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num.length;++i)&#123;<span class="comment">//做n次</span></span><br><span class="line">        <span class="comment">//换位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num[<span class="number">0</span>];</span><br><span class="line">        num[<span class="number">0</span>] = num[len-<span class="number">1</span>];</span><br><span class="line">        num[len-<span class="number">1</span>] = temp;</span><br><span class="line">        <span class="comment">//堆的逻辑长度--，为的是不让有序区参与下移运算，只让剩下的无序部分参与下移操作</span></span><br><span class="line">        len--;</span><br><span class="line">        <span class="comment">//使用下移操作对堆顶点进行调整</span></span><br><span class="line">        shiftDown(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul><li>很明显，在堆上做的节点上移和节点下移操作时间复杂度都是O(logN)的，而每次得到最大值的操作都有节点下移操作，得到所有元素的时间复杂度是O(N)的，所以时间复杂度应该是O(NlogN)的。</li></ul><h2 id="分而治之归并排序"><a href="#分而治之归并排序" class="headerlink" title="分而治之归并排序"></a>分而治之归并排序</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>这种排序方式主要突出一个分而治之，<strong>将大问题分解成小问题，等小问题解决了之后再合并成为大问题的解</strong>，这种形式的问题就很适合用递归进行解决，每次递归都是一次解决小问题的过程，有些小问题暂时还没法解决怎么办，没事，继续往下递归，到最后层层返回后的答案就是合并后的答案。</li></ul><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li>主要思路就是：<strong>每次递归将数组对半分，分别对左右两半的数组进行递归保证左右两边的数组都是有序的之后，再调用双路归并的算法来对两半数组进行合并</strong>，每次递归都执行上述操作，最后得到的答案就是排序后的数组。</li></ul><h3 id="双路归并算法"><a href="#双路归并算法" class="headerlink" title="双路归并算法"></a>双路归并算法</h3><ul><li>该算法是归并排序中合并两个有序集合的操作，具体实现是：<strong>三个指针i，j，k分别表示左集合的头元素，右集合的头元素，结果集合的头元素，每次比较i，j指向的元素，将比较小的那个元素放到结果集合中并移动指针</strong>，以此类推最后得到的就是合并了两个有序集合的有序集合。</li></ul><h3 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul><li>二分的时间复杂度是O(logN)的，二路归并的时间复杂度是O(N)的，每次二分之后都会有一个二路归并，所以总体的<strong>时间复杂度是O(NlogN)的</strong>，但是递归所造成的空间消耗是巨大的。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-06 23:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入数据规模：&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        random.setSeed(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            arr[i] = random.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">dateBefore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        arr = sort(arr);</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        System.out.println(<span class="string">&quot;一共用时：&quot;</span>+((<span class="keyword">new</span> <span class="title class_">Date</span>().getTime()-dateBefore.getTime())/<span class="number">60000.0</span>)+<span class="string">&quot;分钟&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length==<span class="number">1</span>)&#123;<span class="comment">//如果只有一个元素，那这个集合本身就是有序的，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> arr.length/<span class="number">2</span>;<span class="comment">//二分</span></span><br><span class="line">        <span class="keyword">return</span> merge(sort(Arrays.copyOfRange(arr,<span class="number">0</span>,mid)),sort(Arrays.copyOfRange(arr,mid,arr.length)));<span class="comment">//保证两边的集合都有序后再合并</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] merge(<span class="type">int</span>[] a,<span class="type">int</span>[] b)&#123;<span class="comment">//二路归并操作</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[a.length+b.length];<span class="comment">//结果数组的长度应该是两个数组的长度之和</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;<span class="comment">//分别是两个数组的头指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;ans.length;++k)&#123;<span class="comment">//对结果数组中的每个元素进行赋值</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;a.length&amp;&amp;j&lt;b.length) &#123;<span class="comment">//两个数组都没到头的时候</span></span><br><span class="line">                ans[k] = a[i] &lt; b[j] ? a[i++] : b[j++];<span class="comment">//赋值为较小的那个并移动指针</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//其中至少有一个数组遍历到头了，就把剩下的元素都塞到后面即可</span></span><br><span class="line">                <span class="keyword">for</span>(;i&lt;a.length;++i)&#123;</span><br><span class="line">                    ans[k++] = a[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(;j&lt;b.length;++j)&#123;</span><br><span class="line">                    ans[k++] = b[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用得最多快速排序"><a href="#用得最多快速排序" class="headerlink" title="用得最多快速排序"></a>用得最多快速排序</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</li><li>效率很高，**平均时间复杂度可以达到O(NlogN)**，但是通常情况下都要比这个快。</li></ul><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li>也是有一个分治的思想在里面，不过每次调整序列的时候是用了效率比较高的方式，其思想是<strong>选中序列中的一个数作为基准数</strong>，我们要调整当前序列为：<strong>所有在基准数左边的数都比基准数要小，所有在基准数右边的数都比基准数要大</strong>。<strong>调整完毕后，再递归地对其左右边的序列继续上面的步骤</strong>，最后递归层层返回后得到的结果就是排序好的序列。</li><li>怎么调整序列呢？基本思路是：<strong>设置i，j两个指针分别指向序列的头和尾，选取尾部元素作为基准数，提前记录下来，然后i开始向后扫描，扫描到比基准数小的就过，扫描到比基准数大的就把i当前的值赋值给j位置的值，并让j–，由于j位置的值就是基准数，而基准数被提前记录了，所以在这个操作中没有数据的损失；做完上述步骤之后，换为j向前扫描，扫描到比基准数大的就过，扫描到比基准数小的就把j当前的值赋值给i位置的值，并让i++，由于i位置的值在上一步中已经被记录到之前j所在的位置，所以在这个操作中也没有数据的损失，之后就是一直重复上面的步骤直至i和j汇合，此时的位置就是基准数应该在的位置，将基准数赋值给这个位置，调整完毕</strong>。</li><li>为什么上述方式可以保证调整成功呢？是因为最后i和j汇合的地方是基准数的位置，所以在汇合之前，i和j所在的区域都应该是满足调整成功的序列的条件的，所以<strong>无论是谁在扫描序列，在碰上不符合这个区域的条件的元素时，我们就要拜托远在另一个区域的“兄弟”把当前这个不符合条件的数字处理掉，由于处理掉之后产生了空位（至少从逻辑上是这样的，因为当前位置留下的那个数字冗余了），所以当前空位上的指针还要处理一下这个空位，于是它就一直等待它远在另外一个区域的“兄弟”帮它找到一个符合条件的元素来给它处理一下这个空位，而此时另外那个兄弟因为解决了空位问题所以继续扫描，周而复始就能解决所有空位，并能使两边的区域中的元素都符合条件，最后一个空位兄弟俩一起解决，将最开始的那个元素填入，至此调整完毕</strong>。</li></ul><h3 id="时间复杂度分析-2"><a href="#时间复杂度分析-2" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul><li>最坏情况下每次比较都需要交换位置，所以最坏情况下的时间复杂度是O(N^2)的。</li><li>最好情况下和平均情况下的时间复杂度都是O(NlogN)的</li><li>正是因为有如此优秀的平均时间复杂度和较小的空间开销，才使得快速排序立于不败之地。</li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-07 12:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入数据规模：&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        random.setSeed(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            arr[i] = random.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">dateBefore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        sort(<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        System.out.println(<span class="string">&quot;一共用时：&quot;</span>+((<span class="keyword">new</span> <span class="title class_">Date</span>().getTime()-dateBefore.getTime())/<span class="number">60000.0</span>)+<span class="string">&quot;分钟&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;<span class="comment">//begin是处理的当前区间的左界，end是处理的当前区间的右界</span></span><br><span class="line">        <span class="comment">//System.out.println(begin+&quot; &quot;+end);</span></span><br><span class="line">        <span class="keyword">if</span>(begin&gt;=end) <span class="keyword">return</span>;<span class="comment">//如果出现只有一个元素或者没有元素的情况在逻辑上就是有序的，直接返回即可</span></span><br><span class="line">        <span class="type">int</span> i=begin,j=end,p=arr[end];<span class="comment">//设置左右哨兵，记录最后一个值为基准数，准备扫描</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">shift</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//为true时i往后扫描，为false时j往前扫描</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;<span class="comment">//没有碰头时说明基准数的位置还没定下来</span></span><br><span class="line">            <span class="keyword">if</span>(shift)&#123;<span class="comment">//i往后扫描</span></span><br><span class="line">                <span class="keyword">if</span>(arr[i]&gt;p)&#123;<span class="comment">//找到了异端，拜托j处理掉它，i在此等待填坑</span></span><br><span class="line">                    arr[j] = arr[i];<span class="comment">//处理异端</span></span><br><span class="line">                    j--;<span class="comment">//j的坑填完了可以继续扫描了</span></span><br><span class="line">                    shift = <span class="literal">false</span>;<span class="comment">//让j扫描</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> i++;<span class="comment">//如果没找到异端就继续扫描</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//j往前扫描</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;p)&#123;<span class="comment">//找到了异端，拜托i处理掉它，j在此等待填坑</span></span><br><span class="line">                    arr[i] = arr[j];<span class="comment">//处理异端</span></span><br><span class="line">                    i++;<span class="comment">//i的坑填完了可以继续扫描了</span></span><br><span class="line">                    shift = <span class="literal">true</span>;<span class="comment">//让i扫描</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> j--;<span class="comment">//如果没找到异端就继续扫描</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(i+&quot; &quot;+j);</span></span><br><span class="line">        arr[i] = p;<span class="comment">//将基准数归位</span></span><br><span class="line">        <span class="comment">//System.out.println(p);</span></span><br><span class="line">        sort(begin,i-<span class="number">1</span>);<span class="comment">//处理左半截，开头是begin不是0，因为这次递归处理的是其中一个区间</span></span><br><span class="line">        sort(i+<span class="number">1</span>,end);<span class="comment">//处理右半截，结尾是end不是arr.length-1，因为这次递归处理的是其中一个区间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="速度很快的桶排序"><a href="#速度很快的桶排序" class="headerlink" title="速度很快的桶排序"></a>速度很快的桶排序</h2><h3 id="桶排序思路"><a href="#桶排序思路" class="headerlink" title="桶排序思路"></a>桶排序思路</h3><ul><li>将待排序元素划分到不同的桶。先扫描一遍序列求出最大值 maxV 和最小值 minV ，设桶的个数为 k ，则把区间 [minV, maxV] 均匀划分成 k 个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。</li><li>对每个桶内的元素进行排序。可以选择任意一种排序算法。</li><li>将各个桶中的元素合并成一个大的有序序列。</li><li>假设数据是均匀分布的，则每个桶的元素平均个数为 n&#x2F;k 。假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为 O(n&#x2F;klog(n&#x2F;k)) 。总的时间复杂度为O(n)+O(k)O(n&#x2F;klog(n&#x2F;k)) &#x3D; O(n+nlog(n&#x2F;k)) &#x3D; O(n+nlogn-nlogk) 。当 k 接近于 n 时，桶排序的时间复杂度就可以金斯认为是 O(n) 的。即桶越多，时间效率就越高，而桶越多，空间就越大。</li></ul><h3 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="桶数最多计数排序"><a href="#桶数最多计数排序" class="headerlink" title="桶数最多计数排序"></a>桶数最多计数排序</h2><h3 id="计数排序思想"><a href="#计数排序思想" class="headerlink" title="计数排序思想"></a>计数排序思想</h3><ul><li><p>是一种<strong>时间复杂度为O(n)的排序算法</strong>，其思路是开一个长度为 maxValue-minValue+1 的数组，然后</p><ol><li><p><strong>分配</strong>：扫描一遍原始数组，以当前值 - minValue 作为下标，将该下标的计数器增1。</p></li><li><p><strong>收集</strong>：扫描一遍计数器数组，按顺序把值收集起来。</p></li></ol></li><li><p>举个例子， nums&#x3D;[2, 1, 3, 1, 5] , 首先扫描一遍获取最小值和最大值， maxValue&#x3D;5 , minValue&#x3D;1 ，于是开一个长度为5的计数器数组 counter ，</p><ol><li><p>分配。统计每个元素出现的频率，得到 counter&#x3D;[2, 1, 1, 0, 1] ，例如 counter[0] 表示值 0+minValue&#x3D;1 出现了2次。</p></li><li><p>收集。 counter[0]&#x3D;2 表示 1 出现了两次，那就向原始数组写入两个1， counter[1]&#x3D;1 表示 2 出现了1次，那就向原始数组写入一个2，依次类推，最终原始数组变为 [1,1,2,3,5] ，排序好了。</p></li></ol></li><li><p>计数排序本质上<strong>是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序</strong>。</p></li></ul><h3 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-09 10:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> INF;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//存储数据并找出数据中的最大值和最小值</span></span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(min&gt;num[i]) min = num[i];</span><br><span class="line">            <span class="keyword">if</span>(max&lt;num[i]) max = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[max-min+<span class="number">1</span>];<span class="comment">//把桶子创建出来，创建max-min+1个而不是max个实际上是优化空间，但相应要在下面的步骤中多做一点操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//对桶子对应的元素进行计数，计数为几说明存在几个当前桶子对应的元素，不过记得元素减min之后再给对应桶子计数，最后遍历的时候也要将桶子对应的元素加上min，这样才能得到原数据</span></span><br><span class="line">            bucket[num[i]-min]++;<span class="comment">//将元素给个偏移量后放进对应的桶子中，后面输出的时候应该让桶子对应的元素把偏移量加回去</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max-min+<span class="number">1</span>;++i)&#123;<span class="comment">//遍历桶子</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;bucket[i];++j)&#123;<span class="comment">//根据当前桶子的计数来决定输出当前桶子对应的元素的数量，桶子大于1的计数在原数据中体现为重复的元素</span></span><br><span class="line">                System.out.print((i+min)+<span class="string">&quot; &quot;</span>);<span class="comment">//记得输出的时候把偏移量加回去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数位做桶基数排序"><a href="#数位做桶基数排序" class="headerlink" title="数位做桶基数排序"></a>数位做桶基数排序</h2><h3 id="基数排序介绍"><a href="#基数排序介绍" class="headerlink" title="基数排序介绍"></a>基数排序介绍</h3><ul><li>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾名思义，<strong>它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</strong>。</li><li>基数排序法是属于稳定性的排序，基数排序法的是<strong>效率高的稳定性排序法</strong>。</li><li><strong>基数排序(Radix Sort)是桶排序的扩展</strong>。</li><li>基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：<strong>将整数按位数切割成不同的数字，然后按每个位数分别比较</strong>。</li></ul><h3 id="基数排序基本思想"><a href="#基数排序基本思想" class="headerlink" title="基数排序基本思想"></a>基数排序基本思想</h3><ul><li><strong>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零</strong>。然后，<strong>从最低位开始，依次进行一次排序</strong>。这样<strong>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</strong>。</li><li>实际上的原理就是<strong>每次循环过后使得下一次循环放入同一个桶中的元素从当前数位开始到最后组成的数字有序了，而不同的桶本身就自带顺序属性，在两方有序的加持下，整体的表现就是有序</strong>，比如123和221，经过一次循环之后221排到123前面了；那么在下一次循环中，221和123放到了同一个桶中，由于上一次循环把它们的个位数排序了，所以在这次循环中，它们从十位数开始之后的数位组成的数字是有序的，然后221又排到了123前面；再下一次循环，123和221不在一个桶中了，123又排到了221的前面，更高位数的数以此类推。实际上这么多次循环<strong>是在解决由于放入桶中的条件减少导致的桶内元素无序的情况，每次循环都致力于让最后的桶内部的元素是有序的</strong>。（我在说些什么。。。）</li><li>很明显，<strong>外层循环次数由序列中元素的最大数位长度（十进制）决定</strong>，<strong>由于某个数位的大小是0-9，所以桶的数量固定为10</strong>。</li><li>需要两层循环，<strong>外层循环控制本次是用哪个数位进行桶排序，内层循环做桶排序</strong>。</li></ul><h3 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>虽然用到了两层循环，但是<strong>外层循环是和最大数位长度（十进制）k有关，内层循环做桶排序和序列长度n有关</strong>，所以<strong>时间复杂度是O(nk)的</strong>。</li></ul><h3 id="基数排序流程图解"><a href="#基数排序流程图解" class="headerlink" title="基数排序流程图解"></a>基数排序流程图解</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106105500208.png" alt="image-20221106105500208"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106105512310.png" alt="image-20221106105512310"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106105526703.png" alt="image-20221106105526703"></p><h3 id="代码示例-6"><a href="#代码示例-6" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-09 10:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDigit</span> <span class="operator">=</span> -INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//存储数据，顺便找到所有数字中最大的数位长度作为桶排序的次数</span></span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> getDigit(num[i]);<span class="comment">//获取对应数字的数位长度</span></span><br><span class="line">            maxDigit = maxDigit&lt;digit?digit:maxDigit;<span class="comment">//找最大的数位长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;LinkedList&lt;Integer&gt;&gt; bucket = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//创建桶子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;<span class="comment">//因为每个数位的大小只能是0-9，而我们要对某个数位进行桶排序，所以只需要十个桶即可。</span></span><br><span class="line">            bucket.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//bucket = bucket.stream().map((v) -&gt; new LinkedList&lt;Integer&gt;()).collect(Collectors.toList());//流式操作初始化容器（好吧这样好像不太行）</span></span><br><span class="line">        <span class="comment">//System.out.println(bucket.size());</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxDigit;++i)&#123;<span class="comment">//对每个数位进行桶排序，从0开始方便后面做相关计算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">divisor</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">10</span>,i);<span class="comment">//用于获取对应的数位，数字除以这个数，然后再mod10就是对应的数位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;<span class="comment">//遍历数据，根据当前循环到数位往桶子里放</span></span><br><span class="line">                bucket.get((num[j]/divisor)%<span class="number">10</span>).add(num[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//更新num用的下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;++j)&#123;<span class="comment">//遍历桶</span></span><br><span class="line">                <span class="keyword">while</span> (!bucket.get(j).isEmpty())&#123;<span class="comment">//如果桶子里面有元素，取出元素更新num</span></span><br><span class="line">                    num[index++] = bucket.get(j).poll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(num[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDigit</span><span class="params">(<span class="type">int</span> num)</span>&#123;<span class="comment">//获取一个数字的数位长度，就是一个数字十进制下有几位数，比如123的数位长度是3，12的数位长度是2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何创建一棵二叉树"><a href="#如何创建一棵二叉树" class="headerlink" title="如何创建一棵二叉树"></a>如何创建一棵二叉树</h1><ul><li><p><strong>首先将所有节点按照层序遍历的顺序放入一个线性结构</strong>，然后<strong>再遍历这个线性结构，用访问二叉树子节点的方式(左节点下标为i*2+1，右节点下标为i*2+2)访问当前节点的左右节点并将这些节点建立起联系</strong>。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-10 14:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入树的节点(包括空节点)的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;树为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入树的层序结构（空节点用&#x27;#&#x27;表示，元素之间用空格分割）：&quot;</span>);</span><br><span class="line">        List&lt;TreeNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//用线性结构先把树的节点存储起来，之后再建立节点之间的关系</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//输入节点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.next();<span class="comment">//这个读取String的方法可以被空格阻断</span></span><br><span class="line">            <span class="keyword">if</span>(input.charAt(<span class="number">0</span>)==<span class="string">&#x27;#&#x27;</span>)&#123;<span class="comment">//处理空节点</span></span><br><span class="line">                nodes.add(<span class="literal">null</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//处理非空节点</span></span><br><span class="line">                nodes.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(input)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//建立节点之间的联系</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> nodes.get(i);<span class="comment">//取出当前节点，准备给其左右节点赋值</span></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="literal">null</span>) <span class="keyword">continue</span>;<span class="comment">//如果当前节点是个空节点，就continue，不过从面向对象的角度来说，空节点也应该是一个对象，不过有点麻烦所以就没弄</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//左节点下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i*<span class="number">2</span>+<span class="number">2</span>;<span class="comment">//右节点下标</span></span><br><span class="line">            <span class="keyword">if</span>(left&lt;n)&#123;<span class="comment">//检测左节点下标是否越界，如果越界了不用处理，默认反正就是null</span></span><br><span class="line">                temp.setLeft(nodes.get(left));<span class="comment">//设置左节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right&lt;n)&#123;<span class="comment">//检测右节点下标是否越界，如果越界了不用处理，默认反正就是null</span></span><br><span class="line">                temp.setRight(nodes.get(right));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);<span class="comment">//联系建立完毕后，线性结构中的第一个节点就是树的根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;<span class="comment">//二叉树节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;<span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode left;<span class="comment">//左节点</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode right;<span class="comment">//右节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(TreeNode left)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(TreeNode right)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="二叉树遍历算法"><a href="#二叉树遍历算法" class="headerlink" title="二叉树遍历算法"></a>二叉树遍历算法</h1><h2 id="二叉树的纵序遍历"><a href="#二叉树的纵序遍历" class="headerlink" title="二叉树的纵序遍历"></a>二叉树的纵序遍历</h2><h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><ul><li><strong>以下均以先遍历左子树再遍历右子树为前提</strong>。</li></ul><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul><li>该算法巧妙地利用到了一个二叉树中叶节点的空指针，从而使空间复杂度降到了O(1)，原理是<strong>构建了一颗线索二叉树，使得每次访问到每个子树的最后一个节点后都能找到应该回到哪里继续进行遍历</strong>，这一线索在之前学过的遍历方法中由递归、栈提供，但在Morris遍历中利用叶节点的空指针来提供。</li><li>morris遍历是二叉树遍历算法的超强进阶算法，morris遍历可以将非递归遍历中的空间复杂度降为O(1)。从而实现时间复杂度为O(N)，而空间复杂度为O(1)的精妙算法。<strong>morris遍历利用的是树的叶节点左右孩子为空（树的大量空闲指针），实现空间开销的极限缩减</strong>。</li></ul><h4 id="实现原则"><a href="#实现原则" class="headerlink" title="实现原则"></a>实现原则</h4><ul><li>记当前节点为cur：<ol><li>如果cur无左孩子，cur向右移动（cur&#x3D;cur.right）</li><li>如果cur有左孩子，找到cur左子树上最右的节点，记为mostright：如果mostright的right指针指向空，让其指向cur，cur向左移动（cur&#x3D;cur.left）；如果mostright的right指针指向cur，让其指向空，cur向右移动（cur&#x3D;cur.right）。</li></ol></li></ul><h4 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h4><ul><li>建立一种机制，对于没有左子树的节点只到达一次，对于有左子树的节点会到达两次。</li><li>实际上就是<strong>构建了一棵线索二叉树，让每个子树的最后遍历到的元素的右指针指向这颗子树的顶点，这样遍历完这颗子树后，就可以返回到顶点处（返回后要取消线索，意味着左子树已经遍历完毕）进行下一步的遍历操作了</strong>。</li></ul><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-10 14:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Morris</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入树的节点(包括空节点)的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;树为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入树的层序结构（空节点用&#x27;#&#x27;表示，元素之间用空格分割）：&quot;</span>);</span><br><span class="line">        List&lt;TreeNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//用线性结构先把树的节点存储起来，之后再建立节点之间的关系</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//输入节点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.next();<span class="comment">//这个读取String的方法可以被空格阻断</span></span><br><span class="line">            <span class="keyword">if</span>(input.charAt(<span class="number">0</span>)==<span class="string">&#x27;#&#x27;</span>)&#123;<span class="comment">//处理空节点</span></span><br><span class="line">                nodes.add(<span class="literal">null</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//处理非空节点</span></span><br><span class="line">                nodes.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(input)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//建立节点之间的联系</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> nodes.get(i);<span class="comment">//取出当前节点，准备给其左右节点赋值</span></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="literal">null</span>) <span class="keyword">continue</span>;<span class="comment">//如果当前节点是个空节点，就continue，不过从面向对象的角度来说，空节点也应该是一个对象，不过有点麻烦所以就没弄</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//左节点下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i*<span class="number">2</span>+<span class="number">2</span>;<span class="comment">//右节点下标</span></span><br><span class="line">            <span class="keyword">if</span>(left&lt;n)&#123;<span class="comment">//检测左节点下标是否越界，如果越界了不用处理，默认反正就是null</span></span><br><span class="line">                temp.setLeft(nodes.get(left));<span class="comment">//设置左节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right&lt;n)&#123;<span class="comment">//检测右节点下标是否越界，如果越界了不用处理，默认反正就是null</span></span><br><span class="line">                temp.setRight(nodes.get(right));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);<span class="comment">//联系建立完毕后，线性结构中的第一个节点就是树的根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pointer</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">if</span>(pointer==<span class="literal">null</span>) System.out.println(<span class="string">&quot;树为空&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;指定树的前序Morris遍历的结果为&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(pointer!=<span class="literal">null</span>)&#123;<span class="comment">//Morris遍历，这里写个前序</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">mostRight</span> <span class="operator">=</span> pointer.left;<span class="comment">//mostRight用来找左子树的最右边的节点，把当前节点的左树赋给mostRight可以在后面顺便检测左树是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(mostRight!=<span class="literal">null</span>)&#123;<span class="comment">//如果左树存在</span></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="literal">null</span> &amp;&amp; mostRight.right!=pointer)&#123;<span class="comment">//找左子树最靠右的节点，最靠右的节点的右节点一定是null或者当前节点</span></span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(mostRight.right == <span class="literal">null</span>)&#123;<span class="comment">//如果最右节点的右节点是null，说明这个左子树还没有被遍历过，就做好线索之后向左遍历，这个线索指向当前节点，为的是遍历完左子树回到当前节点并且还是作为左子树已经遍历过的标志</span></span><br><span class="line">                    System.out.print(pointer.val+<span class="string">&quot; &quot;</span>);<span class="comment">//前序遍历，在向左遍历之前输出</span></span><br><span class="line">                    mostRight.right = pointer;<span class="comment">//建立线索</span></span><br><span class="line">                    pointer = pointer.left;<span class="comment">//向左遍历</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果最右节点的右节点是当前节点，说明这个左子树已经被遍历过了，恢复右指针为null并向右遍历即可</span></span><br><span class="line">                    <span class="comment">//这里没有输出语句，是因为这个条件中是左子树已经被遍历过了，由于是前序遍历，所以当前节点应该已经被输出过一遍了，不用再输出一遍了。</span></span><br><span class="line">                    mostRight.right = <span class="literal">null</span>;<span class="comment">//消除线索</span></span><br><span class="line">                    pointer = pointer.right;<span class="comment">//向右遍历</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果左树不存在</span></span><br><span class="line">                System.out.print(pointer.val+<span class="string">&quot; &quot;</span>);<span class="comment">//前序遍历，没有左子树的时候，输出再向右遍历</span></span><br><span class="line">                pointer = pointer.right;<span class="comment">//向右遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;<span class="comment">//二叉树节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;<span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode left;<span class="comment">//左节点</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode right;<span class="comment">//右节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(TreeNode left)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(TreeNode right)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码里还有个<strong>创建一棵树</strong>的知识点。</p><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><h3 id="利用队列实现"><a href="#利用队列实现" class="headerlink" title="利用队列实现"></a>利用队列实现</h3><ul><li><p>总体思想就是BFS的思想，先初始化队列（往队列里面放第一个值），每次从队列中poll一个元素，然后把和这个元素相邻的下一层元素再放到队列中，一直重复操作直到队列为空，不过其中有几个比较难想的点。</p></li><li><p>如何获取每一层的元素数量？<strong>每一层的元素数量就是外层循环刚开始时的队列的长度，内层循环根据这个长度来poll元素即可保证poll出来的元素是同一层的</strong>，不过内层for循环中<strong>不要把queue.size()当作循环结束条件</strong>，而要在for循环之前记录队列在循环刚开始时的值，因为在内层循环中队列的长度是不断变化的，不能当作循环结束的条件。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;TreeNode&gt; qu = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; mid;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        qu.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!qu.isEmpty())&#123;</span><br><span class="line">            mid = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> qu.size();<span class="comment">//本层的节点数量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;++i) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> qu.poll();</span><br><span class="line">                mid.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>)</span><br><span class="line">                    qu.add(temp.left);</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>)</span><br><span class="line">                    qu.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h1 id="分支限界算法"><a href="#分支限界算法" class="headerlink" title="分支限界算法"></a>分支限界算法</h1><h2 id="状态空间树（解空间树）"><a href="#状态空间树（解空间树）" class="headerlink" title="状态空间树（解空间树）"></a>状态空间树（解空间树）</h2><ul><li>状态空间树就是问题的解空间树，分为<strong>子集树</strong>和<strong>排列树</strong>。</li><li>状态空间树<strong>通常是一个虚拟的树，并不需要我们实际将其构建出来，它的存在只是为了让我们能进一步理解解决问题需要计算的规模和问题的可能存在的解等，起到的是辅助的作用</strong>。</li><li><strong>对于明显不可能找到答案的分支我们可以选择不予遍历来提高效率，这样就是对状态空间树剪枝，剪枝的难点在于设计剪枝条件</strong>。</li></ul><h3 id="子集树"><a href="#子集树" class="headerlink" title="子集树"></a>子集树</h3><ul><li><p>当所给的问题是<strong>从n个元素组成的集合set中找到满足某一条件的一个子集时，相应的解空间树称为子集树</strong>。要注意，这个<strong>解空间树是一个虚拟的树，并不是需要实际构建出来的</strong>。</p></li><li><p><strong>0-1背包问题的解空间树实际上就是一个很典型的子集树，因为我们实际上是想要找到所有物品这个集合中的一个子集，使得子集中的物品能全部装到背包中并且价值最大</strong>，所以我们可以使用子集树来描述0-1背包问题的解空间。</p></li><li><p>对于<strong>0-1背包问题</strong>的子集树，我们通常<strong>将每个节点描述为目前装载的物品，向左遍历可以再装下一个物品，向右遍历不装下一个物品</strong>，以此类推，将所有的物品全部都决定完装或者不装之后，当前的节点也就是叶节点就可能是答案，要尝试更新答案，当将状态空间树的所有节点全部遍历一遍之后，答案也就被找出来了。</p></li><li><p>子集树示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121145007229.png" alt="image-20221121145007229"></p></li></ul><h3 id="排列树"><a href="#排列树" class="headerlink" title="排列树"></a>排列树</h3><ul><li><p>当所给的问题是<strong>求n个元素的全排列的时候，相应的解空间树称为排列树</strong>。要注意，这个<strong>解空间树是一个虚拟的树，并不是需要实际构建出来的</strong>。</p></li><li><p><strong>TSP问题（也就是旅行商问题，求从一个节点开始走过所有其它节点一遍后返回起始节点所需的最短路径）的解空间树实际上就是一个很典型的排列树，因为我们无论如何都要走过所有其它的节点一遍，只是顺序有先后，因此我们需要遍历其所有的顺序，从中找出答案</strong>。</p></li><li><p>对于<strong>TSP问题</strong>，我们通常<strong>将每个节点描述为目前经过的图上节点，每一层的遍历都是尝试将所有没经过的图上节点加入到经过的图上节点中，所以一个父节点有几个孩子不一定</strong>。最后所有图上节点都经过一遍之后，当前节点就是叶节点就可能是答案，要尝试更新答案，当将状态空间树的所有节点全部遍历一遍之后，答案也就被找出来了。</p></li><li><p>排列树示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121151314120.png" alt="image-20221121151314120"></p></li></ul><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><ul><li>如果说回溯法是使用深度优先搜索的方式遍历一个问题的状态空间树来寻找可能的答案，那么<strong>分支限界法实际上就是使用广度优先搜索的方式遍历一个问题的状态空间树来寻找可能的答案</strong>。</li><li><strong>相比于回溯法的用递归解决问题，分支限界法常常具有更好的效率和更小的空间开销，每次都能决定状态空间树一整层节点的特性也让依赖于同层节点状态的剪枝变得相对容易一些</strong>。</li><li>在优化方面可以根据具体情况进行<strong>剪枝</strong>；也可以看情况用<strong>优先队列</strong>代替做广度优先搜索用到的队列，让最有可能找出答案的节点尽量早些被遍历到。</li><li>对于分支限界算法来说，<strong>如何设计状态空间树的节点是很重要的</strong>，<strong>状态空间树的节点中包含的属性应该可以准确描述当前状态并能为顺利构建下一个状态提供帮助，最好是还带有一些特定数据从而能更方便地实现剪枝操作</strong>。</li></ul><h2 id="0-1背包问题的分支限界法解决"><a href="#0-1背包问题的分支限界法解决" class="headerlink" title="0-1背包问题的分支限界法解决"></a>0-1背包问题的分支限界法解决</h2><ul><li><p><strong>难点在于设计状态空间树的节点、剪枝以及使用优先队列进行优化</strong>。</p></li><li><p><strong>将所有物品按照性价比进行降序排序，然后从前往后尝试进行选择，向左遍历是选择当前物品，向右遍历时不选择当前物品</strong>。</p></li><li><p>对于节点的设计，需要一个<strong>index来指示下一个应该尝试选择的物品是第几个（在针对性价比排列过的序列中），这个属性对于顺利构建出下一个节点也有很重要的作用</strong>；需要一个<strong>valueNow来表示当前节点代表的状态装了价值为多少的东西</strong>；需要一个<strong>weightNow来表示当前节点代表的状态装了重量为多少的东西</strong>；还需要一个<strong>upperBound来表示当前节点表示的状态中背包的剩余空间全部利用上（装不下的可以装一部分，总之让剩余空间要全部装满）最多还能装多少价值的东西，这个属性是用来剪枝用的，如果要是valueNow+upperBound小于等于目前更新到的可能的答案，那么就可以剪枝了，因为沿着这条路走下去不可能会遍历到一个节点使得valueNow大于当前更新到的可能的答案，也就是说答案不可能在这条路上得到更新，直接剪掉就好了</strong>。</p></li><li><p>还可以<strong>用优先队列代替队列进行广度优先搜索，将最有可能得到答案的节点提前遍历，提高提前找到答案的可能性</strong>。</p></li><li><p>代码示例，没有做剪枝和优先队列优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-20 9:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BranchAndBound01Backpack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入背包的容量：&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">w</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入物品的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">double</span>[] value = <span class="keyword">new</span> <span class="title class_">double</span>[n];<span class="comment">//存物品价值</span></span><br><span class="line">        <span class="type">double</span>[] weight = <span class="keyword">new</span> <span class="title class_">double</span>[n];<span class="comment">//存物品重量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+i+<span class="string">&quot;个物品的价值和重量：&quot;</span>);</span><br><span class="line">            value[i-<span class="number">1</span>] = scanner.nextDouble();</span><br><span class="line">            weight[i-<span class="number">1</span>] = scanner.nextDouble();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//冒泡排序将物品按照性价比排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n-i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(value[j]/weight[j]&lt;value[j+<span class="number">1</span>]/weight[j+<span class="number">1</span>])&#123;<span class="comment">//计算相邻两个物品的性价比，如果顺序不对就交换两个物品的位置（体现在交换两个数组的元素位置上）</span></span><br><span class="line">                    <span class="type">double</span> <span class="variable">temp</span> <span class="operator">=</span> value[j];</span><br><span class="line">                    value[j] = value[j+<span class="number">1</span>];</span><br><span class="line">                    value[j+<span class="number">1</span>] = temp;</span><br><span class="line">                    temp = weight[j];</span><br><span class="line">                    weight[j] = weight[j+<span class="number">1</span>];</span><br><span class="line">                    weight[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//队列</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,getUpperBound(value,weight,<span class="number">0</span>,w)));<span class="comment">//加入初始节点</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;<span class="comment">//广度优先遍历状态空间树</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(temp.index&gt;=n)&#123;<span class="comment">//如果下标越界，说明当前可能是答案，所以对答案尝试更新</span></span><br><span class="line">                <span class="keyword">if</span>(temp.valueNow&gt;ans) ans = temp.valueNow;<span class="comment">//尝试更新答案</span></span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//由于下标越界，所以后面不可能有别的节点了，它是叶节点，所以不用扩展它的子节点，直接continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将空间状态树的两个子节点加入队列中</span></span><br><span class="line">            <span class="keyword">if</span>(temp.weightNow+weight[temp.index]&lt;=w)&#123;<span class="comment">//这是要装下一个物品的节点，如果能装下下一个物品就装，如果不能装下的话就不装，体现在程序上就是是否能计算得到下一个有效的状态节点并将其加入到队列中去</span></span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(temp.index+<span class="number">1</span>,temp.valueNow+value[temp.index],temp.weightNow+weight[temp.index],getUpperBound(value,weight,temp.index+<span class="number">1</span>,w-temp.weightNow-weight[temp.index])));</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(temp.index+<span class="number">1</span>,temp.valueNow,temp.weightNow,getUpperBound(value,weight,temp.index+<span class="number">1</span>,w-temp.weightNow)));<span class="comment">//这是不装下一个物品的节点，由于不装下一个节点，所以除了上界以外的属性都和它的父节点相同。</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;背包所能装下的最大价值为：&quot;</span>+ans);<span class="comment">//输出结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getUpperBound</span><span class="params">(<span class="type">double</span>[] value,<span class="type">double</span>[] weight,<span class="type">int</span> index,<span class="type">double</span> weightRest)</span>&#123;<span class="comment">//index是从哪开始计算，因为要算的是剩下的空间最多还能装多少价值的东西所以已经决定选或不选的元素不参与计算，weightRest是背包剩余的可以装东西的重量</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;value.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(weightRest&gt;=weight[i])&#123;<span class="comment">//如果装的下就装</span></span><br><span class="line">                ans+=value[i];</span><br><span class="line">                weightRest-=weight[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果装不下就按照单位重量的价值计算最多能装的价值是多少</span></span><br><span class="line">                ans+=weightRest*(value[i]/weight[i]);</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//weightRest用光了，直接退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> index;<span class="comment">//下一个应该判断第几个要不要装了</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> valueNow;<span class="comment">//装到现在的价值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> weightNow;<span class="comment">//装到现在的重量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> upperBound;<span class="comment">//装到现在的可能的最大价值上界（也就是理论上最多还能装的价值）</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> index,<span class="type">double</span> valueNow,<span class="type">double</span> weightNow,<span class="type">double</span> upperBound)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.valueNow = valueNow;</span><br><span class="line">            <span class="built_in">this</span>.weightNow = weightNow;</span><br><span class="line">            <span class="built_in">this</span>.upperBound = upperBound;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="TSP问题的分支限界法解决"><a href="#TSP问题的分支限界法解决" class="headerlink" title="TSP问题的分支限界法解决"></a>TSP问题的分支限界法解决</h2><h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><h2 id="DP之编辑距离"><a href="#DP之编辑距离" class="headerlink" title="DP之编辑距离"></a>DP之编辑距离</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>很经典的一个问题，<strong>编辑距离指的是从一个字符串变更为另外一个字符串所需要的最少操作数</strong>，其中可以做三种操作：插入一个字符、删除一个字符、修改一个字符。</li></ul><h3 id="DP思想"><a href="#DP思想" class="headerlink" title="DP思想"></a>DP思想</h3><ul><li><strong>首先将大问题逐步分解为小问题</strong>，以there和here两个字符串为例，大问题是there到here的编辑距离，那么所有小问题就是：t到here、th到here、the到here……</li><li>经过上面对于大问题的分解，我们不难发现<strong>所有小问题的状态是需要一个m*n的二维数组来进行表示的</strong>，因此我们需要建立一个二维dp数组，数组元素dp[i][j]代表第一个字符串的前i个字符和第二个字符串的前j个字符的编辑距离，所以最后的dp[m][n]就是答案。</li><li>分解完问题之后，我们<strong>再来看看对于每个子问题解是否满足无后效性</strong>，也就是说每个子问题的解是否不影响后序子问题求解，很明显是不影响的。</li><li>再<strong>看看子问题是否具有重叠性</strong>。</li><li>然后<strong>再确定dp的状态转移方程</strong>，考虑中间某个值<strong>dp[i][j]可以从哪些值转移过来</strong>，以下都是以对第一个字符串做操作为基础，首先可以<strong>从dp[i-1][j]+1转移过来，这个转移对应着我们对第一个字符串删除一个元素</strong>，因为i-1能变到j，i对应的字符没用了；其次可以<strong>从dp[i][j-1]+1转移过来，这个转移对应着我们对第一个字符串增加一个元素使得其和第二个字符串j位置上的字符相同</strong>，因为都能从i变到j-1了，只需要插入一个和j对应的字符相同的字符就能成了；再者<strong>可以从dp[i-1][j-1]+!(a[i]&#x3D;&#x3D;b[j])转移过来，这个转移对应着我们对第一个字符串修改一个元素使得i对应的元素和j对应的元素相同</strong>，因为已经可以从i-1转移到j-1了，所以只需要将剩下的俩元素修改成一样的就行了，如果剩下得俩字符本来就相同的话，那就没必要修改了，值就和dp[i-1][j-1]一样了。综上所述，所有的三个操作对应三个可能的转移方向，确定值的时候只需要取个最小值即可。</li><li>确定好状态转移方程后，我们只是确定了中间那部分子问题的求解方式，但是边界子问题的求解方式不一定和中间那部分子问题的求解方式相同，所以我们<strong>要再确定边界子问题的求解方式</strong>。对于边界情况，也就是从一个字符串变成空串，所需要的操作数就是这个字符串的长度，因为只需要把字符串的所有元素都删掉就能达成目标。<strong>对于dp数组来说我们可以额外对每个维度再开出一个空间来，以保证较外层求解时可以使用中间层的求解范式而不至于造成数组越界或者是增加一些繁琐的判断操作</strong>。</li><li>确定完边界子问题的求解方式后，我们要<strong>先将边界子问题求出，这一步实际上就是初始化dp数组，然后再使用状态转移方程对其他子问题求解即可</strong>。</li></ul><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-15 20:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EditDistance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第一个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第二个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[a.length()+<span class="number">1</span>][b.length()+<span class="number">1</span>];<span class="comment">//每个维度大小加一对边界初始化后方便状态转移</span></span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;a.length();++i)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.print(a.indexOf(i)+&quot; &quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a.length();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=b.length();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>) dp[i][j] = Math.max(i,j);<span class="comment">//边界子问题求解</span></span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>,Math.min(dp[i][j-<span class="number">1</span>]+<span class="number">1</span>,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+(a.charAt(i-<span class="number">1</span>)==b.charAt(j-<span class="number">1</span>)?<span class="number">0</span>:<span class="number">1</span>)));<span class="comment">//状态转移</span></span><br><span class="line"><span class="comment">//                System.out.print(a.indexOf(i-1)+b.indexOf(j-1)+dp[i][j]);</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;答案为：&quot;</span>+dp[a.length()][b.length()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DP之TSP问题"><a href="#DP之TSP问题" class="headerlink" title="DP之TSP问题"></a>DP之TSP问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>就是旅行商问题，问的是，给你一个图，然后求从一个节点经过剩下所有节点之后回到一开始那个节点所用的最小花费。</li></ul><h3 id="DP思想-1"><a href="#DP思想-1" class="headerlink" title="DP思想"></a>DP思想</h3><ul><li>以下<strong>假设是从节点0开始出发</strong>。</li><li>可以<strong>把问题描述为：从节点0开始出发，经过集合中除了节点0的剩余节点，最后再返回到节点0所需要的最小费用</strong>。</li><li>然后我们可以定义子问题，每次从集合中的节点中拿出一个来当作子问题的起始节点，这样<strong>子问题就变成了：从取出来的节点开始出发，经过集合中除了节点0和取出来的节点的剩余节点，最后回到节点0所需要的最小费用</strong>。当从集合中把每个元素都取遍，实际上所有子问题也就被遍历过了，找到所有第一轮子问题中结果最小的那个就是答案，不过要确定第一轮子问题的答案，还需要将所有第一轮子问题分解出第二轮子问题，然后确定每一个第一轮子问题分解出的所有第二轮子问题的答案的最小值，那就是对应的第一轮子问题的答案……以此类推，直到无法再分后将答案一层层返回上来，思想像递归，不过在dp中是倒推。</li><li>再想想怎么进行状态转移，可以<strong>设置二维dp数组，第一维表示节点，第二位表示当前节点最后到达节点0所通过的子集(都不包括节点0)<strong>，对于子集更长的状态来说，应该从子集长度减一的所有状态中</strong>距离最短的状态</strong>中转移过来，<strong>所以子集更长的状态转移依赖于所有子集长度减一的状态</strong>，所以做状态转移的时候应该是<strong>按轮进行状态转移，子集长度相同的状态在同一轮被确定下来</strong>，这样才能为后面的状态进行确定的时候提供有效的前置状态。</li><li>如果是节点0作为起始点的话，最后的结果应该是dp数组中最右上角的那个元素，那个元素代表着节点0通过除了节点0的所有节点之后回到节点0的距离，<strong>这个答案是从所有子集长度减一的有效状态中转移过来的</strong>。</li></ul><h3 id="dp数组图解"><a href="#dp数组图解" class="headerlink" title="dp数组图解"></a>dp数组图解</h3><ul><li><p>dp状态转移方程：其中V’代表不包含它前面节点和起始节点的子集。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221023194550921.png" alt="image-20221023194550921"></p></li><li><p>dp数组示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221024202014918.png" alt="image-20221024202014918"></p></li></ul><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-22 17:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TSPQuestionDP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">inf</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;<span class="comment">//正无穷</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入节点数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] g = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];<span class="comment">//邻接矩阵存图</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>)];<span class="comment">//dp数组，第一维为节点，第二维为子集</span></span><br><span class="line">        <span class="comment">//int[][] subSet = new int[n][n];</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化邻接矩阵</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                g[i][j] = inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入边的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+(i+<span class="number">1</span> )+<span class="string">&quot;条边的起点、终点、权值：&quot;</span>);</span><br><span class="line">            g[scanner.nextInt()][scanner.nextInt()] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取子集</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subSet = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//所有子集</span></span><br><span class="line">        HashMap&lt;ArrayList&lt;Integer&gt;,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//子集对应的访问下标</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[n-<span class="number">1</span>];<span class="comment">//用于求子集</span></span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n-<span class="number">1</span>];<span class="comment">//用于求子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//初始化要求子集的集合</span></span><br><span class="line">            temp[i-<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(temp,<span class="number">0</span>,vis,subSet);<span class="comment">//求子集</span></span><br><span class="line">        subSet.sort((o1,o2) -&gt; &#123;<span class="comment">//按照自定义的排序方式进行排序，返回负数表示当前两者关系是有序（升序）的，无需做调整</span></span><br><span class="line">            <span class="keyword">if</span>(o1.size()==o2.size())&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;o1.size();++i)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(o1.get(i)!=o2.get(i))&#123;</span><br><span class="line">                        <span class="keyword">return</span> o1.get(i)&lt;=o2.get(i)?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.size()&lt;=o2.size()?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;subSet.size();++i)&#123;<span class="comment">//建立集合和下标的映射</span></span><br><span class="line">            <span class="comment">//System.out.println(subSet.get(i));</span></span><br><span class="line">            map.put(subSet.get(i),i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//初始化dp数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = g[i][<span class="number">0</span>];<span class="comment">//节点i经过空集到节点0，距离就是它们之间的距离</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//节点i经过集合中的单个元素（不能是当前节点）到节点0，距离就是当前节点到集合中的那个节点的距离再加上集合中的那个节点到节点0的距离</span></span><br><span class="line">                    <span class="keyword">if</span>(!subSet.get(j).contains(i) &amp;&amp; g[i][subSet.get(j).get(<span class="number">0</span>)]!=inf &amp;&amp; g[subSet.get(j).get(<span class="number">0</span>)][<span class="number">0</span>]!=inf) dp[i][j] = g[i][subSet.get(j).get(<span class="number">0</span>)] + g[subSet.get(j).get(<span class="number">0</span>)][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = inf;<span class="comment">//如果其中任意两节点无法到达，设置为正无穷，方便之后淘汰经过当前元素的转移方案。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>;m&lt;n;++m)&#123;<span class="comment">//由于更长的子集需要所有之前更短的子集转移出来的结果，所以每轮转移要保证子集长度都相同</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//记录dp的列应该从哪继续转移</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;++j)&#123;<span class="comment">//每一轮的子集数量和组合数有关</span></span><br><span class="line">                begin += C(n-<span class="number">1</span>,j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> begin+C(n-<span class="number">1</span>,m);<span class="comment">//记录dp的列这一轮应该转移到哪里</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">1</span>;--i)&#123;<span class="comment">//dp的行从下往上转移，从上往下也行，但是不转移节点0。</span></span><br><span class="line">                <span class="comment">//System.out.println(begin+&quot; &quot;+end);</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=begin;j&lt;end;++j) &#123;<span class="comment">//dp的列</span></span><br><span class="line">                    <span class="keyword">if</span> (!subSet.get(j).contains(i)) &#123;<span class="comment">//通过的子集中不能包含当前节点</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> inf;<span class="comment">//用于找所有方案中最短的那个</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; subSet.get(j).size(); ++k) &#123;<span class="comment">//依次试遍所有子问题</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">selectedNum</span> <span class="operator">=</span> subSet.get(j).get(k);<span class="comment">//被选中独立出来的元素</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//把一个元素独立出来后，剩下的子集对应的dp列的访问下标</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; subSet.size(); ++l) &#123;<span class="comment">//找独立出元素后的子集对应的dp列的访问下标</span></span><br><span class="line">                                <span class="comment">//先筛一波长度差一并且其中不含独立出来的元素的子集</span></span><br><span class="line">                                <span class="keyword">if</span> (subSet.get(l).size() + <span class="number">1</span> == subSet.get(j).size() &amp;&amp; !subSet.get(l).contains(selectedNum)) &#123;</span><br><span class="line">                                    <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//是否找到</span></span><br><span class="line">                                    <span class="keyword">for</span>(<span class="type">int</span> o=<span class="number">0</span>;o&lt;subSet.get(j).size();++o)&#123;<span class="comment">//检查初筛出来的子集是否包含刚才独立出元素后的子集的所有剩余元素</span></span><br><span class="line">                                        <span class="keyword">if</span>(subSet.get(j).get(o)==selectedNum) <span class="keyword">continue</span>;<span class="comment">//不看独立出来的元素</span></span><br><span class="line">                                        <span class="keyword">else</span>&#123;</span><br><span class="line">                                            <span class="keyword">if</span>(!subSet.get(l).contains(subSet.get(j).get(o)))&#123;<span class="comment">//如果有一个元素不包含，那当前这个子集就不是刚才独立出元素后变成的子集，要继续找</span></span><br><span class="line">                                                found = <span class="literal">false</span>;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">if</span>(found)&#123;<span class="comment">//找到了就通过之前做的映射拿到其访问下标</span></span><br><span class="line">                                        pos = map.get(subSet.get(l));</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//System.out.println(i+&quot; &quot;+j+&quot; &quot;+selectedNum+&quot; &quot;+pos);</span></span><br><span class="line">                            <span class="keyword">if</span> (min &gt; dp[selectedNum][pos] + g[i][selectedNum])<span class="comment">//尝试更新min的值</span></span><br><span class="line">                                min = dp[selectedNum][pos] + g[i][selectedNum];</span><br><span class="line">                        &#125;</span><br><span class="line">                        dp[i][j] = min;<span class="comment">//进行状态转移，由于初始化的时候不可达设置成了正无穷，所以可以保证不会从非法的地方转移过来</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为得到最终的答案进行状态转移</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;subSet.get((<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>))-<span class="number">1</span>).size();++k)&#123;<span class="comment">//遍历除了节点0的全集的子问题</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">selectedNum</span> <span class="operator">=</span> subSet.get((<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>))-<span class="number">1</span>).get(k);<span class="comment">//独立出一个元素来</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;subSet.size();++l)&#123;<span class="comment">//找独立出元素后的集合下标</span></span><br><span class="line">                <span class="comment">//由于全集的答案是从上一轮的子集中转移过来的，而上一轮的子集比全集只少1，因此如果一个子集不包含从全集中独立出来的那个元素，那么这个子集就是独立出元素后的全集，易证</span></span><br><span class="line">                <span class="keyword">if</span>(subSet.get(l).size()+<span class="number">1</span>==subSet.get((<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>))-<span class="number">1</span>).size()&amp;&amp;!subSet.get(l).contains(selectedNum))&#123;</span><br><span class="line">                    pos = map.get(subSet.get(l));<span class="comment">//拿到下标，不过写注释写到这我发现为啥不直接用l当下标。。。</span></span><br><span class="line">                    <span class="comment">//System.out.println(selectedNum+&quot; &quot;+pos+&quot; &quot;+subSet.get(l));</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(dp[selectedNum][pos]+&quot; &quot;+g[0][selectedNum]);</span></span><br><span class="line">            <span class="comment">//尝试更新min</span></span><br><span class="line">            <span class="keyword">if</span>(min &gt; dp[selectedNum][pos]+g[<span class="number">0</span>][selectedNum]) min = dp[selectedNum][pos]+g[<span class="number">0</span>][selectedNum];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][(<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>))-<span class="number">1</span>] = min;<span class="comment">//状态转移得到最后答案</span></span><br><span class="line">        <span class="comment">//输出dp数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>));++i)&#123;</span><br><span class="line">            System.out.print(subSet.get(i)+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>));++j)&#123;</span><br><span class="line">                System.out.print(dp[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出结论</span></span><br><span class="line">        System.out.println(<span class="string">&quot;从0号节点出发经过所有节点返回的最小距离是：&quot;</span>+dp[<span class="number">0</span>][(<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>))-<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] num,<span class="type">int</span> a,<span class="type">boolean</span>[] vis,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subSet)</span>&#123;<span class="comment">//求子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;vis.length;++i)&#123;<span class="comment">//回溯算法求子集</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(num,i+<span class="number">1</span>,vis,subSet);</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vis.length;++i)&#123;<span class="comment">//记录当前求得的子集</span></span><br><span class="line">            <span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">                list.add(num[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        subSet.add(list);<span class="comment">//加入子集的集合</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">C</span><span class="params">(<span class="type">int</span> down,<span class="type">int</span> up)</span>&#123;<span class="comment">//求组合数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;up;++i)&#123;</span><br><span class="line">            ans*=down-i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=up;++i)&#123;</span><br><span class="line">            ans/=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h1><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>单源无负权最短路径，即一个点到其他点的最短路径，所有的边不允许出现负权值。</li></ul><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li><p>每次外层循环确定一个节点到源点的最短距离</p></li><li><p>每次内层循环通过确定最短路径的点对与其相邻的点到源点的距离进行“松弛”操作以确保下一次外层循环能找到正确的距离源点最短的点。</p></li><li><p>贪心的思想，每次找最短路径的节点来对别的节点做“松弛”。</p></li></ul><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><ul><li><p>假设节点数量为n，那么首先我们需要一个<strong>n x n的矩阵g来存放图，或者用邻接表、链式前向星存</strong>，然后我们需要一个<strong>长度为n的boolean数组vis来标识节点到源点的最短距离是否已经被确定</strong>，然后<strong>需要一个长度为n的整型数组dis来记录源点到其他点的最短距离</strong>，如果要<strong>对时间复杂度进行优化的话，我们还需要维护一个优先队列（可以用堆实现）q来表示节点到源点的距离</strong>。</p></li><li><p>初始化g，除了自己到自己的距离为0，其他初始化为inf，然后根据输入的边进行调整；</p><p>初始化vis，源点src到自己的最短距离已经确认，所以让src为true，其余为false；</p><p>初始化dis，就是src到各点的距离，从g中拿就行。</p></li><li><p>然后外层循环n-1次，因为有n-1个节点到src的最短路径需要确认，外层循环每循环一次就确定一个节点到src的最短路径。</p><p>内层先用一个循环来找到当前与src直接或间接相连的节点到src的最短路径（如果使用优先队列进行优化的话就直接取优先队列的头元素即可，不用循环了就），找到之后对应的那个节点的最短路径就被固定了，因为别的路径都必须经过本轮遍历到的其他路径，而由于没有负权值，别的路径第一段就比最短的路径大了，再加上别的段就更不用说了，因此不存在从别的路径到这轮选中的节点距离更短，所以可以确定本轮选中的节点的最短路径。</p><p>确定后更新vis，然后再搞一层循环来更新与本轮选中的节点相邻的节点到src的最短距离，这一操作我们称为通过本轮选中的节点来对src到别的节点的距离进行“松弛”（优先队列的话要对优先队列进行更新操作），这一操作是为了在下一轮的循环中能正确找到距离src最短的节点。最后外层循环完毕，所有节点到src的最短距离也被确定下来了。</p></li></ul><h3 id="代码示例-7"><a href="#代码示例-7" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-28 19:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dijkstra</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">inf</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;<span class="comment">//正无穷</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入节点数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] g = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];<span class="comment">//邻接矩阵存图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化邻接矩阵</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) g[i][j]=<span class="number">0</span>;<span class="comment">//自己到自己的距离为0</span></span><br><span class="line">                <span class="keyword">else</span> g[i][j] = inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入边的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+(i+<span class="number">1</span> )+<span class="string">&quot;条边的起点、终点、权值：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="comment">//这里是无向图的写法，为了方便输入，需要有向图再改</span></span><br><span class="line">            g[begin][end] = value;</span><br><span class="line">            g[end][begin] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入想要看其到别的节点最短路径的节点：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">src</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];<span class="comment">//标识已经确定最小距离的节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) vis[i] = <span class="literal">false</span>;</span><br><span class="line">        vis[src] = <span class="literal">true</span>;<span class="comment">//源节点到自己的距离一直是0，所以是已经确定最小距离的节点</span></span><br><span class="line">        <span class="type">int</span>[] dis = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//源节点到对应节点的最小距离，比如dis[i]就是源节点到节点i的最小距离，动态更新，更新到最后就是答案。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化源节点到对应节点的最小距离为源节点到对应节点的距离，然后之后再动态更新。</span></span><br><span class="line">            dis[i] = g[src][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//还需要找到n-1个节点的最短路径，所以要循环n-1次</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> inf;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//每轮找到的节点下标，该节点应该是本轮中距离src最短的节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;<span class="comment">//找本轮中距离src最短的节点，由于其到src的距离是本轮最短，所以不存在另外一条路径使得被选中的节点和src的距离能更短，因为如果存在这样一条路径，那么一定会从本轮中的其他路径经过，而本轮中的其他路径在不考虑负权值的情况下一定比本轮中的最短路径要长，所以可以放心将本轮最短路径作为选中节点的最短路径。</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[j]&amp;&amp;min&gt;dis[j])&#123;<span class="comment">//只从还没有确定最短路径的节点中找最小值，记录下最小值和节点下标</span></span><br><span class="line">                    min = dis[j];</span><br><span class="line">                    pos = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[pos] = <span class="literal">true</span>;<span class="comment">//标记这一轮选中的节点已经确定了最短路径</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;<span class="comment">//以这一轮选中的节点作为桥梁来更新与其相邻的节点到src的最短距离</span></span><br><span class="line">                <span class="keyword">if</span>(g[pos][j]&lt;inf&amp;&amp;j!=src)&#123;<span class="comment">//找与这一轮选中的节点相邻的节点，不能是src</span></span><br><span class="line">                    <span class="keyword">if</span>(dis[j]&gt;dis[pos]+g[pos][j])&#123;<span class="comment">//如果以这一轮选中的节点为桥梁能使与其相邻的节点到src的距离更短，那就更新，相当于src和那个节点间接建立起了联系，下一轮就可以通过找最小值来固定和src直接或间接有联系的点的最短距离了。</span></span><br><span class="line">                        dis[j] = dis[pos]+g[pos][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;节点&quot;</span>+src+<span class="string">&quot;到各点的最短路径分别为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(dis[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h1><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>找出一个最短路径使得图中各节点连通，对于有n个节点的图来说，最小生成树需要用n-1条边来构建，该算法在稠密图中的效率较高。</li><li>适用于有负权边的情况。</li></ul><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>每次循环选择距离已经被选中的节点组成的集合最短的节点加入集合中，然后将与其连接的路径加入最小生成树中，更新与本轮被选中的节点相邻的节点到已经被选中的节点的集合的距离，以确保下一次循环可以找到正确的需要加入集合的节点，当所有节点都被加入到集合后，最小生成树就建立了。</li><li>实际上就是贪心的思想，每次找到集合最短的节点加入集合。</li></ul><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ul><li><p>基本上和Dijkstra算法差不多，虽然数据结构和Dijkstra的一样，但是Prim的数据结构的含义和Dijkstra中的数据结构的含义有点出入。</p></li><li><p>假设节点数量为n，那么首先我们需要一个<strong>n x n的矩阵g来存放图，或者用邻接表、链式前向星存</strong>，然后我们需要一个<strong>长度为n的boolean数组vis来表示已经被最小生成树选中的节点</strong>，然后<strong>需要一个长度为n的整型数组dis来记录已经被选中的节点的集合到其他未被选中的点的最短距离</strong>，如果要<strong>对时间复杂度进行优化的话，我们还需要维护一个优先队列（可以用堆实现）q来表示节点到已经被选中的节点的集合的距离</strong>，还需要一个<strong>变量sum来记录最小生成树的值</strong>。</p></li><li><p>初始化g，除了自己到自己的距离为0，其他初始化为inf，然后根据输入的边进行调整；</p><p>初始化vis，一开始被选中的节点集合中的节点只有源点src，所以让src为true，其余为false；</p><p>初始化dis，就是被选中的节点的集合到各点的距离，一开始就是src到各点的距离，从g中拿就行。</p></li><li><p>然后外层循环n-1次，因为有n-1条边需要被选择，外层循环每循环一次就选择一条边放到最小生成树中，同时也是选中一个节点放入已经被选中的节点的集合中。</p><p>内层先用一个循环来找到当前与被选中的节点的集合相连的节点到集合的最短路径（如果使用优先队列进行优化的话就直接取优先队列的头元素即可，不用循环了就），找到之后需要将该点加入集合中，并将该边加入最小生成树中，更新vis和sum，然后再搞一层循环来更新未被选中的节点与新集合的距离，实际上出现变动的只有与这一轮选中的节点相邻的节点，所以更新这一轮选中的节点的相邻节点到新集合的距离就好了，这一步是为了确保下一轮循环中可以正确的选中到集合的最短路径对应的节点。最后外层循环完毕，最小生成树也被确定下来了。</p></li></ul><h3 id="代码示例-8"><a href="#代码示例-8" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-29 14:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">inf</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;<span class="comment">//正无穷</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入节点数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] g = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];<span class="comment">//邻接矩阵存图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化邻接矩阵</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) g[i][j]=<span class="number">0</span>;<span class="comment">//自己到自己的距离为0</span></span><br><span class="line">                <span class="keyword">else</span> g[i][j] = inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入边的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+(i+<span class="number">1</span> )+<span class="string">&quot;条边的起点、终点、权值：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="comment">//这里是无向图的写法，为了方便输入，需要有向图再改</span></span><br><span class="line">            g[begin][end] = value;</span><br><span class="line">            g[end][begin] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入起始节点：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">src</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];<span class="comment">//标识已经确定最小距离的节点，同时也是算法工程中被最小生成树选中的节点集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) vis[i] = <span class="literal">false</span>;</span><br><span class="line">        vis[src] = <span class="literal">true</span>;<span class="comment">//源节点到自己的距离一直是0，所以是已经确定最小距离的节点</span></span><br><span class="line">        <span class="type">int</span>[] dis = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//被最小生成树选中的节点集合到与其相邻节点的距离，比如dis[i]就是被最小生成树选中的节点集合到节点i的距离，动态更新。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化源节点（此时最小生成树选中的节点只有源节点）到所有节点的距离为源节点到对应节点的距离，然后之后再动态更新。</span></span><br><span class="line">            dis[i] = g[src][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最小生成树的大小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//构建最小生成树一共需要n-1条边，所以要循环n-1遍，每一轮循环选中一条边</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> inf;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//到已经选中的节点集合距离最短的那个节点下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;<span class="comment">//找距离已经选中的节点集合距离最短的节点</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[j]&amp;&amp;min&gt;dis[j])&#123;<span class="comment">//从已经选中的节点集合之外找和已经选中的节点的集合相邻的节点中距离最短的那个节点</span></span><br><span class="line">                    min = dis[j];<span class="comment">//记录最小值</span></span><br><span class="line">                    pos = j;<span class="comment">//记录下标</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[pos] = <span class="literal">true</span>;<span class="comment">//将这轮被选中的节点加入到最小生成树选中节点的集合中</span></span><br><span class="line">            sum+=dis[pos];<span class="comment">//将本轮选中的边加入到最小生成树中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;<span class="comment">//由于本轮选中的节点加入了最小生成树，所以与本轮选中节点相邻的节点与最小生成树选中的节点集合也是相邻的，所以动态更新被最小生成树选中的节点集合到其他节点的距离</span></span><br><span class="line">                <span class="keyword">if</span>(g[pos][j]&lt;dis[j]&amp;&amp;!vis[j])&#123;<span class="comment">//更新与这一轮选中的节点相邻的没被最小生成树选中的节点到被最小生成树选中的节点集合的距离，方便下一轮筛选最小值加入最小生成树</span></span><br><span class="line">                    dis[j] = g[pos][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最小生成树的大小为：&quot;</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>找出一个最短路径使得图中各节点连通，对于有n个节点的图来说，最小生成树需要用n-1条边来构建，该算法在稀疏图中的效率较高。</li><li>适用于有负权边的情况。</li></ul><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li><strong>以贪心思想和并查集数据结构为基础</strong>，首先将<strong>所有边按照升序排序</strong>，然后遍历所有边，<strong>每当遍历到一个边就判断这条边是否能作为连接两个端点的最短边</strong>（由于边是升序排列，所以两个端点第一次遇到的可以连接它俩的边就一定是最优的，后面能连接它俩的边都不能选了因为不是最优的。）。<strong>如果能，那就将端点合并到已经被最小生成树选中的节点中，并将该边加入到最小生成树中，并且让选中的边数++；如果不能，就继续遍历，直到选中n-1条边后，最小生成树就形成了，退出循环即可</strong>。</li></ul><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><ul><li>上面描述的差不多了。。。。。。</li></ul><h3 id="代码示例-9"><a href="#代码示例-9" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-03 16:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kruskal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入点数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//并查集数组,f[i]=j说明i的父亲节点是j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化每个节点都是独立的，即他们的father都是自己</span></span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入边数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        Edge[] edges = <span class="keyword">new</span> <span class="title class_">Edge</span>[e];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;条边的两个节点和权值：&quot;</span>);</span><br><span class="line">            <span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Edge</span>();</span><br><span class="line">            edge.from = scanner.nextInt();</span><br><span class="line">            edge.to = scanner.nextInt();</span><br><span class="line">            edge.value = scanner.nextInt();</span><br><span class="line">            edges[i] = edge;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(edges,(e1,e2) -&gt; e1.value&lt;=e2.value?-<span class="number">1</span>:<span class="number">1</span>);<span class="comment">//按照边从小到大排序，返回负数不换位置，即顺序正确</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最小生成树的大小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e&amp;&amp;n&gt;<span class="number">1</span>;++i)&#123;<span class="comment">//n可以维护已经选了多少边，当n减到1的时候说明已经选了n-1条边了，最小生成树已经生成，可以走了</span></span><br><span class="line">            <span class="keyword">if</span>(merge(f,edges[i].from,edges[i].to))&#123;<span class="comment">//如果能合并说明可以选这条边作为最小代价连接这条边对应的两个节点</span></span><br><span class="line">                n--;</span><br><span class="line">                sum+=edges[i].value;</span><br><span class="line">                System.out.println(<span class="string">&quot;选择两个点和权值分别为&quot;</span>+edges[i].from+<span class="string">&quot; &quot;</span>+edges[i].to+<span class="string">&quot; &quot;</span>+edges[i].value+<span class="string">&quot;的边&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最小生成树的大小为：&quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span>&#123;<span class="comment">//边</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> from;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> to;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] f,<span class="type">int</span> v)</span>&#123;<span class="comment">//找一个元素的根节点</span></span><br><span class="line">        <span class="keyword">return</span> f[v]==v?v:(f[v] = find(f,f[v]));<span class="comment">//如果该点独立，直接返回;如果该点不独立,往后找根节点，顺便进行路径压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] f,<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;<span class="comment">//合并操作，其中可以做优化：直接把两者的根节点合并</span></span><br><span class="line">        <span class="keyword">return</span> (u = find(f,u))==(v = find(f,v))?<span class="literal">false</span>:(f[v]=u)==u;<span class="comment">//先找到各自的根，然后比较，如果相同说明已经合并无需再合并，返回false；如果不相同就合并，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Huffman编码算法"><a href="#Huffman编码算法" class="headerlink" title="Huffman编码算法"></a>Huffman编码算法</h1><h2 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li><p><strong>哈夫曼（Huffman）编码算法</strong>是基于二叉树构建编码压缩结构的，它是数据压缩中经典的一种算法。算法根据文本字符出现的频率，重新对字符进行编码。因为为了缩短编码的长度，我们自然<strong>希望频率越高的词，编码越短，这样最终才能最大化压缩存储文本数据的空间</strong>。</p></li><li><p>假设现在我们要对下面这句歌词“we will we will r u”进行压缩。我们可以想象，如果是使用ASCII码对这句话编码结果则为：119 101 32 119 105 108 108 32 119 101 32 119 105 108 108 32 114 32 117（十进制表示）。我们可以看出需要19个字节，也就是至少需要152位的内存空间去存储这些数据。</p></li><li><p>很显然直接ASCII码编码是很浪费空间的，Unicode就更不用说了，下面我们先来统计一下这句话中每个字符出现的频率。如下表，按频率高低已排序：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104174352182.png" alt="image-20221104174352182"></p></li></ul><h2 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h2><ul><li>让<strong>被编码的字符全部出现在编码树的叶节点上，这样可以做到没有一个字符的编码是另外一个字符编码的前缀，这样可以防止解码的时候出现歧义</strong>。</li><li><strong>出现频率越低的字符，在树上的深度就越深，最后对于这个字符的编码就越长，最后总的编码就越短，这其中也有贪心的思想</strong>。</li><li>建好哈夫曼树后，<strong>让连接左孩子的边的编码设置为0，让连接右孩子的边的编码设置为1，从根节点开始经过若干边后找到一个字符，那个字符的编码就是经过的所有边的编码的集合</strong>。</li></ul><h2 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h2><h3 id="初始化优先队列"><a href="#初始化优先队列" class="headerlink" title="初始化优先队列"></a>初始化优先队列</h3><ul><li><p>那么我们<strong>按字符出现频率的高低将其放入一个优先队列中，从左到右依次为频率逐渐增加</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104175410606.png" alt="image-20221104175410606"></p></li><li><p>下面我们需要将这个队列转换成哈夫曼二叉树，<strong>哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的</strong>。并且<strong>哈夫曼二叉树始终保证权重越大的字符出现在越高的地方</strong>。</p></li></ul><h3 id="第一步合并"><a href="#第一步合并" class="headerlink" title="第一步合并"></a>第一步合并</h3><ul><li><p>首先我们从左到右进行合并，依次构建二叉树。<strong>第一步取前两个字符u和r来构造初始二叉树，第一个字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新空元素，并且两者权重相加作为新元素的权重</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180042562.png" alt="image-20221104180042562"></p></li><li><p>同理，<strong>由于合并之后优先队列仍有序，所以新元素可以和字符i再合并</strong>，如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180101221.png" alt="image-20221104180101221"></p></li></ul><h3 id="重新调整队列"><a href="#重新调整队列" class="headerlink" title="重新调整队列"></a>重新调整队列</h3><ul><li><p>上图<strong>新元素权重相加后结果是变大了，需要对权重进行重新排序，也就是调整优先队列</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180152267.png" alt="image-20221104180152267"></p></li><li><p>然后再<strong>依次从左到右合并，每合并一次则进行一次队列重新排序调整</strong>。如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180234707.png" alt="image-20221104180234707"></p></li><li><p><strong>经过多步操作之后，优先队列中只剩一个元素，让队列中唯一的元素出队得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180311593.png" alt="image-20221104180311593"></p></li></ul><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><ul><li><p>有了上面带权重的二叉树之后，我们就可以进行编码了。我们<strong>把二叉树分支中左边的支路编码为0，右边分支表示为1</strong>，如下图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180540694.png" alt="image-20221104180540694"></p></li><li><p>这样<strong>依次遍历这颗二叉树就可以获取得到所有字符的编码了</strong>。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。<strong>经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。</strong></p></li><li><p>最终我们可以得到下面这张编码表：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180640922.png" alt="image-20221104180640922"></p></li></ul><h3 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h3><ul><li>有了上面的编码表之后，”we will we will r u”这句重新进行编码就可以得到很大的压缩，编码表示为：01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100。这样最终我们只需50位内存，比原ASCII码表示节约了2&#x2F;3空间，效果还是很理想的。当然<strong>现实中不是简单这样表示的，还需要考虑很多问题</strong>。</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>我们需要弄明白哈夫曼二叉树概念，<strong>它是带权路径达到最小的二叉树，也叫最优二叉树</strong>。它<strong>不一定是完全二叉树，也不一定是平衡二叉树，它们描述的完全不是一件事情，完全没有概念上的重叠关系</strong>。</li></ul><h2 id="代码示例-10"><a href="#代码示例-10" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-03 18:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Huffman</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line">        <span class="keyword">public</span> Node father;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">char</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//用队列+排序模拟优先队列</span></span><br><span class="line">        ArrayList&lt;Character&gt; charList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//存放所有字符</span></span><br><span class="line">        Node tree;<span class="comment">//Huffman树</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入字符种数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+i+<span class="string">&quot;种字符以及其出现的频数：&quot;</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            node.c = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            charList.add(node.c);</span><br><span class="line">            node.value = scanner.nextInt();</span><br><span class="line">            queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(queue,(n1,n2)-&gt;n1.value&lt;=n2.value?-<span class="number">1</span>:<span class="number">1</span>);<span class="comment">//按照频数排序，返回-1说明顺序正好不用调整</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;queue.size();++i) System.out.print(queue.get(i).c);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">while</span> (queue.size()&gt;<span class="number">1</span>)&#123;<span class="comment">//构建哈夫曼树，频率越低的元素越再下层，对应的编码越长，最后生成的总编码就越短，每次构建都会使队列长度减一，当队列长度为1时，唯一的那个元素就是哈夫曼树</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp1</span> <span class="operator">=</span> queue.poll();<span class="comment">//取出队首第一个元素</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp2</span> <span class="operator">=</span> queue.poll();<span class="comment">//取出队首第二个元素</span></span><br><span class="line">            <span class="comment">//System.out.println(temp1.c+&quot; &quot;+temp2.c);</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();<span class="comment">//准备进行元素合并</span></span><br><span class="line">            temp.value = temp1.value+temp2.value;<span class="comment">//合并权值到新的父节点</span></span><br><span class="line">            <span class="comment">//建立三个节点之间的关系</span></span><br><span class="line">            temp.left = temp1;</span><br><span class="line">            temp.right = temp2;</span><br><span class="line">            temp1.father = temp;</span><br><span class="line">            temp2.father = temp;</span><br><span class="line">            queue.push(temp);<span class="comment">//把合并后的节点加入到优先队列前面</span></span><br><span class="line">            Collections.sort(queue,(n1,n2)-&gt;n1.value&lt;=n2.value?-<span class="number">1</span>:<span class="number">1</span>);<span class="comment">//重新排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        tree = queue.poll();<span class="comment">//取出哈夫曼树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;charList.size();++i)&#123;<span class="comment">//找每个输入的字符对应的哈夫曼编码</span></span><br><span class="line">            ArrayList&lt;Character&gt; code = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            System.out.print(charList.get(i)+<span class="string">&quot;的哈夫曼编码为：&quot;</span>);</span><br><span class="line">            enCode(tree,charList.get(i),code);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">enCode</span><span class="params">(Node tree,<span class="type">char</span> c,ArrayList&lt;Character&gt; now)</span>&#123;<span class="comment">//递归找字符对应的编码，第一个参数是哈夫曼树，第二个参数是字符，第三个参数是当前的编码</span></span><br><span class="line">        <span class="keyword">if</span>(tree==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(tree.value);</span></span><br><span class="line">        <span class="keyword">if</span>(tree.c==c)&#123;<span class="comment">//找到目标了就输出</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> a:now)&#123;</span><br><span class="line">                System.out.print(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯算法遍历左右子树，左0右1</span></span><br><span class="line">        now.add(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        enCode(tree.left,c,now);</span><br><span class="line">        now.remove(now.size()-<span class="number">1</span>);</span><br><span class="line">        now.add(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        enCode(tree.right,c,now);</span><br><span class="line">        now.remove(now.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用霍夫曼编码压缩文件"><a href="#利用霍夫曼编码压缩文件" class="headerlink" title="利用霍夫曼编码压缩文件"></a>利用霍夫曼编码压缩文件</h2><ul><li>如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件。</li><li><strong>赫夫曼编码是按字节来处理的</strong>，因此**可以处理所有的文件(二进制文件、文本文件等)**。</li><li>如果一个文件中的内容，<strong>重复的数据不多，压缩效果也不会很明显</strong>。</li></ul><h2 id="利用霍夫曼编码解压文件"><a href="#利用霍夫曼编码解压文件" class="headerlink" title="利用霍夫曼编码解压文件"></a>利用霍夫曼编码解压文件</h2><h1 id="表达式算法"><a href="#表达式算法" class="headerlink" title="表达式算法"></a>表达式算法</h1><ul><li>这个板块儿<strong>主要是讲前缀、中缀、后缀表达式之间的转换和计算的</strong>。</li></ul><h2 id="中缀表达式算法"><a href="#中缀表达式算法" class="headerlink" title="中缀表达式算法"></a>中缀表达式算法</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>中缀表达式就是我们平时看到的算式，例如：a+b*c，我们想要实现的就是让计算机计算中缀表达式得到正确的结果。</li><li>除了中缀表达式外，还有<strong>运算符在操作数之前的前缀表达式（波兰表达式）和运算符在操作数之后的后缀表达式（逆波兰表达式）</strong>，这两种表达式会在它们的章节细讲。</li></ul><h3 id="使用栈完成中缀表达式计算的思路"><a href="#使用栈完成中缀表达式计算的思路" class="headerlink" title="使用栈完成中缀表达式计算的思路"></a>使用栈完成中缀表达式计算的思路</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106205752521.png" alt="image-20221106205752521"></p><ul><li>有一个小难点就是优先级的问题，<strong>当一个优先级小的符号想要入栈的时候要把之前的运算做了之后再入栈</strong>。</li></ul><h3 id="代码示例-11"><a href="#代码示例-11" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## 逆波兰表达式算法</span><br><span class="line"></span><br><span class="line">### 基本介绍</span><br><span class="line"></span><br><span class="line">- **逆波兰表达式就是后缀表达式**，就是操作符在操作数的后面，至于怎么从中缀表达式转换为后缀表达式下面给出了详细的转换方式。</span><br><span class="line">- 虽然对于人来说计算逆波兰表达式比较困难，但是**对于计算机来说计算逆波兰表达式是非常容易的**，计算机对逆波兰表达式进行计算用到了栈这一数据结构。</span><br><span class="line"></span><br><span class="line">### 算法思想</span><br><span class="line"></span><br><span class="line">- 遍历逆波兰表达式，如果**碰到数字就压入栈中，如果碰到操作符，就从栈顶出栈两个元素，对那两个元素进行对应的运算之后，将运算的结果再压入栈中**。</span><br><span class="line"></span><br><span class="line">### 代码示例</span><br><span class="line"></span><br><span class="line">```java</span><br></pre></td></tr></table></figure><h2 id="中缀表达式转换为后缀表达式"><a href="#中缀表达式转换为后缀表达式" class="headerlink" title="中缀表达式转换为后缀表达式"></a>中缀表达式转换为后缀表达式</h2><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>从上面可以看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此<strong>在开发中，我们需要将中缀表达式转成后缀表达式</strong>。</li><li>中缀表达式转换为后缀表达式的步骤比较繁琐，也<strong>需要借助栈来实现，不过需要两个栈，其中一个存操作数，另外一个存操作符</strong>。</li></ul><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2；</li><li>从左至右扫描中缀表达式；</li><li>遇到操作数时，将其压 s2；</li><li>遇到运算符时，比较其与 s1 栈顶运算符的优先级：<ol><li>如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</li><li>否则，若优先级比栈顶运算符的高，也将运算符压入 s1；</li><li>否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4.1)与 s1 中新的栈顶运算符相比较；</li></ol></li><li>遇到括号时：<ol><li>如果是左括号“(”，则直接压入 s1</li><li>如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃</li></ol></li><li>重复步骤 2 至 5，直到表达式的最右边</li><li>将 s1 中剩余的运算符依次弹出并压入 s2</li><li>依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</li></ol><ul><li>总结：其实就是<strong>根据运算的优先级来将每一部分的操作符放到俩操作数的后面</strong>，比如A*(B+C)+D，优先级最高的是小括号，所以先转换成A*(BC+)+D，然后乘法优先级比较高，把乘号放到俩操作数的后面，即(ABC+*)+D，最后只剩下加法运算了，把加号放到俩操作数后面，即ABC+*D+，这样就得到后缀表达式了，从过程中可以看到，<strong>每次都是选优先级最高的一部分，将其操作符放到它对应的俩操作数的后面</strong>。</li></ul><h3 id="转换举例"><a href="#转换举例" class="headerlink" title="转换举例"></a>转换举例</h3><ul><li><p>将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106232317323.png" alt="image-20221106232317323"></p></li><li><p>因此结果为 :”1 2 3 + 4 × + 5 –”</p></li></ul><h3 id="代码示例-12"><a href="#代码示例-12" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="KMP算法介绍"><a href="#KMP算法介绍" class="headerlink" title="KMP算法介绍"></a>KMP算法介绍</h2><ul><li>KMP 是一个<strong>解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法</strong>。</li><li>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法.</li><li>KMP 方法算法就<strong>利用之前判断过信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间</strong>。</li><li>参考资料：<a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html">https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</a></li></ul><h2 id="KMP算法思路分析"><a href="#KMP算法思路分析" class="headerlink" title="KMP算法思路分析"></a>KMP算法思路分析</h2><ul><li><p>举例来说，有一个字符串 Str1 &#x3D; “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 &#x3D;“ABCDABD”？</p><ol><li><p>首先，用 Str1 的第一个字符和 Str2 的第一个字符去比较，不符合，关键词向后移动一位：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094748049.png" alt="image-20221114094748049"></p></li><li><p>重复第一步，还是不符合，再后移：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094819926.png" alt="image-20221114094819926"></p></li><li><p>一直重复，直到 Str1 有一个字符与 Str2 的第一个字符符合为止：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094849647.png" alt="image-20221114094849647"></p></li><li><p>接着比较字符串和搜索词的下一个字符，还是符合：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094908612.png" alt="image-20221114094908612"></p></li><li><p>遇到 Str1 有一个字符与 Str2 对应的字符不符合：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094927607.png" alt="image-20221114094927607"></p></li><li><p>这时候，想到的是继续遍历 Str1 的下一个字符，重复第 1 步，如下图所示。(其实是很不明智的，因为此时 BCD 已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP 算法的想法是，<strong>设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率</strong>。)</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095220382.png" alt="image-20221114095220382"></p></li><li><p>怎么做到把刚刚重复的步骤省略掉？可以对 Str2 计算出一张《部分匹配表》，这张表的产生在后面介绍：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095249922.png" alt="image-20221114095249922"></p></li><li><p>已知空格与 D 不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符 B 对应的”部分匹配值”为 2，因此按照下面的公式算出向后移动的位数：<strong>移动位数 &#x3D; 已匹配的字符数 - 对应的部分匹配值</strong>，因为 6 - 2 等于 4，所以将搜索词向后移动 4 位：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095501622.png" alt="image-20221114095501622"></p></li><li><p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为 2（”AB”），对应的”部分匹配值”为 0。所以，移动位数 &#x3D; 2 - 0，结果为 2，于是将搜索词向后移 2 位：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095519913.png" alt="image-20221114095519913"></p></li><li><p>因为空格与 A 不匹配，str1的指针继续后移一位：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114100150053.png" alt="image-20221114100150053"></p></li><li><p>逐位比较，直到发现 C 与 D 不匹配。于是，移动位数 &#x3D; 6 - 2，继续将搜索词向后移动 4 位：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095539523.png" alt="image-20221114095539523"></p></li><li><p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 &#x3D; 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095654873.png" alt="image-20221114095654873"></p></li></ol></li></ul><h2 id="部分匹配表（next）是如何产生的？"><a href="#部分匹配表（next）是如何产生的？" class="headerlink" title="部分匹配表（next）是如何产生的？"></a>部分匹配表（next）是如何产生的？</h2><ul><li><p>先介绍介绍前缀和后缀是什么：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114100319241.png" alt="image-20221114100319241"></p></li><li><p>实际上<strong>部分匹配值就是从数组头到当前位置这个左闭右开区间（我喜欢这样表示）所表示的字符串的最长公共前后缀，当比较到当前位置产生失配之后，当前位置的指针可以根据当前位置的部分匹配值来进行相应的移动，从而节省开销</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114100955361.png" alt="image-20221114100955361"></p></li></ul><h2 id="代码示例-13"><a href="#代码示例-13" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"># 弗洛伊德(Floyd)算法</span><br><span class="line"></span><br><span class="line">## 算法介绍</span><br><span class="line"></span><br><span class="line">- 和 Dijkstra 算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、<span class="number">1978</span> 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名</span><br><span class="line">- 弗洛伊德算法(Floyd)**计算图中各个顶点之间的最短路径**</span><br><span class="line">- 迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。</span><br><span class="line">- 弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。</span><br><span class="line">- 也就是说**弗洛伊德算法是多源最短路算法**。</span><br><span class="line"></span><br><span class="line">## 算法思路分析</span><br><span class="line"></span><br><span class="line">- 其实比较简单，就是**搞三层循环，其中两层循环遍历任意两个节点，剩下的一层循环遍历除了那俩节点外的节点作为那两个节点之间的中转站尝试将那两个节点之间的距离进行”松弛“**，三层循环过后得到的二维数据的结果就是所有节点到其他节点的最短路径。</span><br><span class="line"></span><br><span class="line">## 代码示例</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="弗洛伊德-Floyd-判圈算法"><a href="#弗洛伊德-Floyd-判圈算法" class="headerlink" title="弗洛伊德(Floyd)判圈算法"></a>弗洛伊德(Floyd)判圈算法</h1><h1 id="Boyer-Moore投票算法"><a href="#Boyer-Moore投票算法" class="headerlink" title="Boyer-Moore投票算法"></a>Boyer-Moore投票算法</h1><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><ul><li><p>这算法也叫摩尔投票算法，是从一个无序的投票集合中找出最多的那个票。</p></li><li><p>具体见下题：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221211114712980.png" alt="image-20221211114712980"></p></li></ul><h2 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h2><ul><li>其实就是一个<strong>同类相容，异类相杀</strong>的场景，可以想象这样一个场景，有一个山顶有很多军队想要占领，如果第一个人到达了山顶，由于此时山顶没有军队占领，所以那个人就把自己所在的军队的旗帜插到山顶了以表示现在这个山顶归那个军队所有，然后山顶继续上人，如果下一个人是和自己一个军队的，那么他们就可以相容，山顶还是那个军队的；如果下一个人不是和自己一个军队的，那么目前山顶上的人会出来一个人和那个异类拼杀直至同归于尽，直到山顶上没人了，下一个到达山顶的人可以把自己所在军队的旗帜替换掉之前的旗帜，山顶的归属权发生变化，就这样一致进行下去，最后旗帜在山顶上的军队获得那个山顶的所有权。</li><li>我们需要一个<strong>变量winner来标识目前山顶归谁所有</strong>，然后需要一个<strong>变量count来标识目前山顶归属军队在山顶的人数，如果新来了同类就++，如果新来了异类就–，如果count等于0了，说明山顶没人了，那么山顶就会在下一个人到来的时候更换归属者</strong>，最后winner的值就是最后山顶的归属者，也就是票数最多的候选人。</li></ul><h2 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h2><h2 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h2><ul><li>摩尔投票算法有很好的时空复杂度，它只需遍历一次投票集合，所以**时间复杂度是O(n)<strong>的，它只需要额外开两个int型变量，所以</strong>空间复杂度是O(1)**的。</li></ul><h2 id="代码示例-14"><a href="#代码示例-14" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li><p>算法介绍中的那个题的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">winner</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>) winner = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==winner) count++;</span><br><span class="line">            <span class="keyword">else</span> count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> winner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><ul><li>就是从一组数据中找出给定的数据。</li></ul><h2 id="线性查找算法"><a href="#线性查找算法" class="headerlink" title="线性查找算法"></a>线性查找算法</h2><h3 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>就是遍历一遍数据，找到了对应元素就记下来，没啥好介绍的。</li></ul><h3 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>就是遍历一遍数据，找到了对应元素就记下来，没啥思想。</li></ul><h3 id="代码示例-15"><a href="#代码示例-15" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-11 15:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinearSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入集合中的数据个数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入集合中的数据，数据之间用空格分隔：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要查找的数据：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]==target)&#123;</span><br><span class="line">                System.out.println(target+<span class="string">&quot;第一次在集合中出现位置的下标是：&quot;</span>+i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(target+<span class="string">&quot;在集合中不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分-折半-查找算法"><a href="#二分-折半-查找算法" class="headerlink" title="二分(折半)查找算法"></a>二分(折半)查找算法</h2><h3 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>使用<strong>二分查找的前提是数据有序</strong>，然后<strong>每次找数据中间的数，然后根据那个数和要找的数之间的关系来决定继续向左还是向右进行查找</strong>。</li></ul><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107090928743.png" alt="image-20221107090928743"></p><h3 id="对于中间值下标计算的优化"><a href="#对于中间值下标计算的优化" class="headerlink" title="对于中间值下标计算的优化"></a>对于中间值下标计算的优化</h3><ul><li>上面计算中间值的下标mid用的是(left+right)&#x2F;2这个表达式，然而这个表达式实际上不够安全，<strong>如果left和right是两个非常大的数，那么left+right这一操作可能造成数值溢出</strong>。</li><li>鉴于上面的问题，我们可以<strong>将计算中间值下标mid用到的表达式换成left+(right-left)&#x2F;2</strong>，这样由于之前的两个大数的加法转换成了两个大数的减法，所以杜绝了正常数据下数值溢出的问题。</li></ul><h3 id="代码示例-16"><a href="#代码示例-16" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-11 15:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入集合中的数据个数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入集合中的数据，数据有序并且数据之间用空格分隔：&quot;</span>);<span class="comment">//二分查找的数组必须有序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要查找的数据：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//左边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n-<span class="number">1</span>;<span class="comment">//右边界</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;<span class="comment">//这里的等号是必要的，因为按照下面的写法，当两个下标重合的时候，重合处的元素还没有被判断过</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;<span class="comment">//这样写是为了在数据很大的情况下不至于造成算数溢出</span></span><br><span class="line">            <span class="keyword">if</span>(target==num[mid])&#123;<span class="comment">//找到了</span></span><br><span class="line">                System.out.println(target+<span class="string">&quot;在集合中出现位置对应的下标是：&quot;</span>+mid);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;num[mid])&#123;<span class="comment">//target比num[mid]小说明target在前半段</span></span><br><span class="line">                right = mid-<span class="number">1</span>;<span class="comment">//向前折半，注意这里由于是mid-1，所以下一轮的right是还没有被查过的，此时如果下一轮left和right重合了，还要再走一轮查重合的那个元素，所以在循环中的那个等号是必要的</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;num[mid])&#123;<span class="comment">//target比num[mid]大说明target在后半段</span></span><br><span class="line">                left = mid+<span class="number">1</span>;<span class="comment">//向后折半，注意这里由于是mid+1，所以下一轮的left是还没有被查过的，此时如果下一轮left和right重合了，还要再走一轮查重合的那个元素，所以在循环中的那个等号是必要的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(target+<span class="string">&quot;在集合中不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插值查找算法"><a href="#插值查找算法" class="headerlink" title="插值查找算法"></a>插值查找算法</h2><h3 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li><p><strong>如果要查找的元素位于数据的头部或者尾部左右，使用二分查找的话效率会比较低</strong>，因为每次不管数据在什么部分，对于数据的分割总是二分，这样我们就思考，<strong>如果有一种查找方式可以在每次分割数据的时候根据要找的数据的值来自适应地向最有可能存在目标数据的区间去寻找就好了</strong>，这就是插值查找算法的基本思路。</p></li><li><p>插值查找算法类似于二分查找，不同的是<strong>插值查找每次从自适应 mid 处开始查找</strong>。</p></li></ul><h3 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li><p>其思想就是<strong>利用一个插值参数代替二分查找计算中间值表达式的1&#x2F;2</strong>，而这个插值参数是自适应的，也就是说这个插值参数揭示了要找的元素最有可能出现在哪一部分，我的数学不是很好，看着应该是利用了比例。</p></li><li><p>将折半查找中的求 mid 索引的公式进行修改 , low 表示左边索引 left，high 表示右边索引 right，key 就是我们想要找的数据：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107092311759.png" alt="image-20221107092311759"></p></li><li><p>**int mid &#x3D; low + (high - low) * (key - arr[low]) &#x2F; (arr[high] - arr[low])**这就是插值索引mid的计算方法。</p></li></ul><h3 id="插值查找算法举例"><a href="#插值查找算法举例" class="headerlink" title="插值查找算法举例"></a>插值查找算法举例</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107092649559.png" alt="image-20221107092649559"></p><h3 id="插值查找注意事项"><a href="#插值查找注意事项" class="headerlink" title="插值查找注意事项"></a>插值查找注意事项</h3><ul><li>对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快。</li><li>关键字分布不均匀的情况下，该方法不一定比折半查找要好。</li></ul><h3 id="代码示例-17"><a href="#代码示例-17" class="headerlink" title="代码示例"></a>代码示例</h3><ul><li><p>和二分查找差不多，只是索引mid的计算方法变了而已：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-11 15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterpolationSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入集合中的数据个数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入集合中的数据，数据有序并且数据之间用空格分隔：&quot;</span>);<span class="comment">//插值查找的数组必须有序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要查找的数据：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//左边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n-<span class="number">1</span>;<span class="comment">//右边界</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;<span class="comment">//这里的等号是必要的，因为按照下面的写法，当两个下标重合的时候，重合处的元素还没有被判断过</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)*((target-num[left])/(num[right]-num[left]));<span class="comment">//插值看上去好像是表示某个比例，同理，这样写不至于算术溢出</span></span><br><span class="line">            <span class="keyword">if</span>(target==num[mid])&#123;<span class="comment">//找到了</span></span><br><span class="line">                System.out.println(target+<span class="string">&quot;在集合中出现位置对应的下标是：&quot;</span>+mid);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;num[mid])&#123;<span class="comment">//target比num[mid]小说明target在前段</span></span><br><span class="line">                right = mid-<span class="number">1</span>;<span class="comment">//向前折，注意这里由于是mid-1，所以下一轮的right是还没有被查过的，此时如果下一轮left和right重合了，还要再走一轮查重合的那个元素，所以在循环中的那个等号是必要的</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;num[mid])&#123;<span class="comment">//target比num[mid]大说明target在后段</span></span><br><span class="line">                left = mid+<span class="number">1</span>;<span class="comment">//向后折，注意这里由于是mid+1，所以下一轮的left是还没有被查过的，此时如果下一轮left和right重合了，还要再走一轮查重合的那个元素，所以在循环中的那个等号是必要的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(target+<span class="string">&quot;在集合中不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="斐波那契-黄金分割-查找算法"><a href="#斐波那契-黄金分割-查找算法" class="headerlink" title="斐波那契(黄金分割)查找算法"></a>斐波那契(黄金分割)查找算法</h2><h3 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是 0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不到的效果。</li><li>斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值0.618</li><li>也就是说<strong>找目标值的时候用到的所以是利用斐波那契数列两个相邻数的比例计算出来的</strong>。（怎么感觉这种查找这么玄学。。。）</li></ul><h3 id="算法思想-7"><a href="#算法思想-7" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li><p>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位于黄金分割点附近，即 <strong>mid&#x3D;low+F(k-1)-1（F 代表斐波那契数列）</strong>，如下图所示：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107093420069.png" alt="image-20221107093420069"></p></li><li><p>对F(k-1)-1的理解：</p><ol><li>由斐波那契数列 F[k]&#x3D;F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）&#x3D;（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：<strong>只要顺序表的长度为 F[k]-1，则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段，即如上图所示。从而中间位置为 mid&#x3D;low+F(k-1)-1</strong>。</li><li>类似的，每一子段也可以用相同的方式分割</li><li>但顺序表长度 n 不一定刚好等于 F[k]-1，所以<strong>需要将原来的顺序表长度 n 增加至 F[k]-1</strong>。这里的<strong>k 值只要能使得 F[k]-1 恰好大于或等于 n 即可</strong>，由以下代码得到,顺序表长度增加后，<strong>新增的位置（从 n+1 到 F[k]-1 位置），都赋为 n 位置的值即可</strong>。</li></ol></li><li></li></ul><h3 id="代码示例-18"><a href="#代码示例-18" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"># 数据结构-树</span><br><span class="line"></span><br><span class="line">## 二叉树</span><br><span class="line"></span><br><span class="line">### 为什么需要树这种数据结构</span><br><span class="line"></span><br><span class="line">- **数组存储方式**的分析：</span><br><span class="line"></span><br><span class="line">  - **优点**：通过下标方式访问元素，速度快。对于有序数组，还可使用**二分查找提高检索速度**。</span><br><span class="line"></span><br><span class="line">  - **缺点**：如果要检索具体某个值，或者**插入值(按一定顺序)会整体移动，效率较低**。</span><br><span class="line"></span><br><span class="line">    ![image-<span class="number">20221107201028421</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107201028421.png)</span></span><br><span class="line"></span><br><span class="line">- **链式存储方式**的分析：</span><br><span class="line"></span><br><span class="line">  - **优点**：在一定程度上对数组存储方式有优化(比如：**插入**一个数值节点，只需要将插入节点，链接到链表中即可，**删除效率也很好**)。</span><br><span class="line"></span><br><span class="line">  - **缺点**：**在进行检索时，效率仍然较低**，比如(检索某个值，需要从头节点开始遍历)</span><br><span class="line"></span><br><span class="line">    ![image-<span class="number">20221107201236741</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107201236741.png)</span></span><br><span class="line"></span><br><span class="line">- **树存储方式**的分析</span><br><span class="line"></span><br><span class="line">  - 能提高数据存储，读取的效率, 比如**利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度**。</span><br><span class="line"></span><br><span class="line">    ![image-<span class="number">20221107201333513</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107201333513.png)</span></span><br><span class="line"></span><br><span class="line">### 树示意图</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20221111195315513</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111195315513.png)</span></span><br><span class="line"></span><br><span class="line">### 树的常用术语</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20221111195347117</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111195347117.png)</span></span><br><span class="line"></span><br><span class="line">- 节点：就是树的节点</span><br><span class="line">- 根节点：就是最顶上那个节点</span><br><span class="line">- 父节点：指向这个节点的节点是这个节点的父节点</span><br><span class="line">- 子节点：被指向的节点是指向它的那个节点的子节点</span><br><span class="line">- 叶子节点：没有子节点的节点</span><br><span class="line">- 节点的权：就是节点的值</span><br><span class="line">- 路径：一个节点的路径就是从根节点找到该节点的路线</span><br><span class="line">- 层：横着看是一层，从根节点途经相同步数能到达的节点在同一层中</span><br><span class="line">- 子树：在二叉树中一个节点只有两个子树，分别是左子树和右子树，左右子树都是由是左右节点直接或间接的子节点来构成的</span><br><span class="line">- 树的高度：就是树的最大层数</span><br><span class="line">- 森林：多棵子树构成森林</span><br><span class="line"></span><br><span class="line">### 二叉树的概念</span><br><span class="line"></span><br><span class="line">- 树有很多种，**每个节点最多只能有两个子节点**的一种形式称为二叉树。</span><br><span class="line"></span><br><span class="line">- 二叉树的子节点分为左节点和右节点</span><br><span class="line"></span><br><span class="line">- 示意图：</span><br><span class="line"></span><br><span class="line">  ![image-<span class="number">20221111201052749</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201052749.png)</span></span><br><span class="line"></span><br><span class="line">- 如果该二叉树的**所有叶子节点都在最后一层，并且结点总数= <span class="number">2</span>^n -<span class="number">1</span> , n 为层数**，则我们称为**满二叉树**。</span><br><span class="line"></span><br><span class="line">  ![image-<span class="number">20221111201131764</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201131764.png)</span></span><br><span class="line"></span><br><span class="line">- 如果该二叉树的**所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续**，我们称为**完全二叉树**。更通俗一点的解释就是：**去掉最后一层是满二叉树，倒数第一层的节点全部紧靠在左边**。</span><br><span class="line"></span><br><span class="line">  ![image-<span class="number">20221111201217766</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201217766.png)</span></span><br><span class="line"></span><br><span class="line">### 二叉树遍历的说明</span><br><span class="line"></span><br><span class="line">- 我们可以使用**层序、前序、中序和后序**等对二叉树进行遍历。</span><br><span class="line">- 前序遍历：先输出父节点，再遍历左子树和右子树</span><br><span class="line">- 中序遍历：先遍历左子树，再输出父节点，再遍历右子树</span><br><span class="line">- 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点</span><br><span class="line">- 小结: 看输出父节点的顺序，就能确定是前序，中序还是后序</span><br><span class="line"></span><br><span class="line">### 二叉树遍历步骤</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20221111201731060</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201731060.png)</span></span><br><span class="line"></span><br><span class="line">### 二叉树查找指定节点</span><br><span class="line"></span><br><span class="line">- 思路分析图解：</span><br><span class="line"></span><br><span class="line">  ![image-<span class="number">20221111201900016</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201900016.png)</span></span><br><span class="line"></span><br><span class="line">### 二叉树删除节点</span><br><span class="line"></span><br><span class="line">- 思路分析图解：</span><br><span class="line"></span><br><span class="line">  ![image-<span class="number">20221111201942720</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201942720.png)</span></span><br><span class="line"></span><br><span class="line">- 注意这里的删除思路是针对普通二叉树来说的，后面的排序二叉树、平衡二叉树等的删除思路和普通二叉树不同，后面会详细介绍。</span><br><span class="line"></span><br><span class="line">## 顺序存储二叉树</span><br><span class="line"></span><br><span class="line">- 堆这个数据结构会用到顺序存储二叉树</span><br><span class="line"></span><br><span class="line">### 顺序存储二叉树的概念</span><br><span class="line"></span><br><span class="line">- 基本说明：从数据存储来看，数组存储方式和树的存储方式可以相互转换，即**数组可以转换成树，树也可以转换成数组**，看下面的示意图：</span><br><span class="line"></span><br><span class="line">  ![image-<span class="number">20221112112821494</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221112112821494.png)</span></span><br><span class="line"></span><br><span class="line">- 要求：在遍历数组 arr 时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历。</span><br><span class="line"></span><br><span class="line">- 顺序存储二叉树的特点：</span><br><span class="line"></span><br><span class="line">  <span class="number">1.</span> 顺序二叉树通常**只考虑完全二叉树**</span><br><span class="line">  <span class="number">2.</span> 第 n 个元素的**左子节点为 <span class="number">2</span> * n + <span class="number">1</span>**</span><br><span class="line">  <span class="number">3.</span> 第 n 个元素的**右子节点为 <span class="number">2</span> * n + <span class="number">2</span>**</span><br><span class="line">  <span class="number">4.</span> 第 n 个元素的**父节点为 (n-<span class="number">1</span>) / <span class="number">2</span>**</span><br><span class="line">  <span class="number">5.</span> n : 表示二叉树中的第几个元素(按 <span class="number">0</span> 开始编号如图所示)</span><br><span class="line"></span><br><span class="line">### 顺序存储二叉树的遍历</span><br><span class="line"></span><br><span class="line">- 其实思路和非顺序存储二叉树的遍历相同，也是递归，只不过就是访问左子节点和访问右子节点的方式变了一下，之前是通过指针访问，现在是通过下标访问。</span><br><span class="line"></span><br><span class="line">- 代码示例：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@create</span> 2022-11-12 11:39</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderTreeTraverse</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">          System.out.println(<span class="string">&quot;请输入树的节点数量（包括空节点）：&quot;</span>);</span><br><span class="line">          <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">          <span class="type">int</span>[] tree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">          System.out.println(<span class="string">&quot;请按层序输入树的节点权值，空节点用-1代替：&quot;</span>);</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">              tree[i] = scanner.nextInt();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">&quot;前序遍历的结果为：&quot;</span>);</span><br><span class="line">          before(tree,<span class="number">0</span>);</span><br><span class="line">          System.out.println();</span><br><span class="line">          System.out.println(<span class="string">&quot;中序遍历的结果为：&quot;</span>);</span><br><span class="line">          mid(tree,<span class="number">0</span>);</span><br><span class="line">          System.out.println();</span><br><span class="line">          System.out.println(<span class="string">&quot;后序遍历的结果为：&quot;</span>);</span><br><span class="line">          after(tree,<span class="number">0</span>);</span><br><span class="line">          System.out.println();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(<span class="type">int</span>[] tree,<span class="type">int</span> now)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(now&gt;=tree.length)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(tree[now]!=-<span class="number">1</span>)<span class="comment">//如果不是空节点就输出</span></span><br><span class="line">              System.out.print(tree[now]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">          before(tree,now*<span class="number">2</span>+<span class="number">1</span>);<span class="comment">//向左遍历</span></span><br><span class="line">          before(tree,now*<span class="number">2</span>+<span class="number">2</span>);<span class="comment">//向右遍历</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mid</span><span class="params">(<span class="type">int</span>[] tree,<span class="type">int</span> now)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(now&gt;=tree.length)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          mid(tree,now*<span class="number">2</span>+<span class="number">1</span>);<span class="comment">//向左遍历</span></span><br><span class="line">          <span class="keyword">if</span>(tree[now]!=-<span class="number">1</span>)<span class="comment">//如果不是空节点就输出</span></span><br><span class="line">              System.out.print(tree[now]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">          mid(tree,now*<span class="number">2</span>+<span class="number">2</span>);<span class="comment">//向右遍历</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(<span class="type">int</span>[] tree,<span class="type">int</span> now)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(now&gt;=tree.length)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          after(tree,now*<span class="number">2</span>+<span class="number">1</span>);<span class="comment">//向左遍历</span></span><br><span class="line">          after(tree,now*<span class="number">2</span>+<span class="number">2</span>);<span class="comment">//向右遍历</span></span><br><span class="line">          <span class="keyword">if</span>(tree[now]!=-<span class="number">1</span>)<span class="comment">//如果不是空节点就输出</span></span><br><span class="line">              System.out.print(tree[now]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h2><ul><li>在普通的非顺序存储的二叉树中，所有的没有两个子节点的节点会有空闲的指针没有被利用，<strong>线索二叉树做的实际上就是利用二叉树中空闲的指针再表示一些信息，从而使得在之后的操作中受益</strong>。比如树的Morris遍历，实际上就是利用了左子树最右节点的空闲指针从而使得遍历起来更加方便。</li></ul><h3 id="线索二叉树基本介绍"><a href="#线索二叉树基本介绍" class="headerlink" title="线索二叉树基本介绍"></a>线索二叉树基本介绍</h3><ul><li>n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)&#x3D;n+1】 个空指针域。<strong>利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”）</strong></li><li>这种<strong>加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)<strong>。根据线索性质的不同，线索二叉树可分为</strong>前序</strong>线索二叉树、<strong>中序</strong>线索二叉树和<strong>后序</strong>线索二叉树三种</li><li>一个结点的前一个结点，称为<strong>前驱结点</strong></li><li>一个结点的后一个结点，称为<strong>后继结点</strong></li></ul><h3 id="将二叉树线索化的流程"><a href="#将二叉树线索化的流程" class="headerlink" title="将二叉树线索化的流程"></a>将二叉树线索化的流程</h3><ul><li><p>将二叉树线索化实际上就是<strong>将特定遍历顺序中对应节点的前驱和后继记录到对应节点的空闲指针上去</strong>。所以根据遍历顺序的不同，线索二叉树可以分为前序、中序、后序线索二叉树三种，这些都是对于线索二叉树这个抽象的实现，实际上你也可以用别的方式实现不同的线索二叉树。</p></li><li><p>需要两个节点指针，其中一个<strong>node用来指向遍历到的节点</strong>，另外一个<strong>pre用来指向遍历到的节点的前一个遍历到的节点</strong>。<strong>设置当前节点的前驱节点需要让node对应节点（当前节点）的左指针指向pre对应的节点；设置当前节点的后继节点需要继续遍历到下一个节点（此时node指向了下一个遍历的节点，pre指向了当前节点）让pre对应节点（当前节点）的右指针指向node对应的节点</strong>。</p></li><li><p>中序线索二叉树示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221112122030580.png" alt="image-20221112122030580"></p><p>说明：当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况:</p><ol><li>left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点。</li><li>right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向的是后继节点。</li></ol></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  ```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 遍历线索化二叉树</span><br><span class="line"></span><br><span class="line">- 因为**线索化后，各个结点指向有变化，因此原来的遍历方式不能使用**，这时需要使用新的方式遍历线索化二叉树，各个节点**可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率**。 遍历的次序应当和线索化所用的遍历次序保持一致。</span><br><span class="line"></span><br><span class="line">- 代码示例：</span><br><span class="line"></span><br><span class="line">  ```java</span><br></pre></td></tr></table></figure></li></ul><h2 id="二叉排序-查找-树"><a href="#二叉排序-查找-树" class="headerlink" title="二叉排序(查找)树"></a>二叉排序(查找)树</h2><h3 id="先看一个需求"><a href="#先看一个需求" class="headerlink" title="先看一个需求"></a>先看一个需求</h3><ul><li>给你一个数列 (7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加</li></ul><h3 id="解决方案分析"><a href="#解决方案分析" class="headerlink" title="解决方案分析"></a>解决方案分析</h3><ul><li>使用数组：<ul><li>数组未排序：优点：接在数组尾添加，速度快。 缺点：查找速度慢。</li><li>数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。</li></ul></li><li>使用链式存储-链表：不管链表是否有序，查找速度都慢；添加数据速度比数组快，不需要数据整体移动。</li><li>使用二叉排序树：既可以保证较快的查找速度，也可以保证较高的插入效率。</li></ul><h3 id="二叉排序树介绍"><a href="#二叉排序树介绍" class="headerlink" title="二叉排序树介绍"></a>二叉排序树介绍</h3><ul><li><p><strong>二叉排序树：BST (Binary Sort(Search) Tree)</strong>, 对于二叉排序树的任何一个非叶子节点，<strong>要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大</strong>。从更宏观的角度来看，<strong>任何一个非叶子节点的左子树的所有值都比该节点小，右子树的所有值都比该节点大</strong>。</p></li><li><p>特别说明：<strong>如果有相同的值，可以将和父节点相同的节点放在左子节点或右子节点都可以</strong>。</p></li><li><p>针对前面的数据(7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113092545691.png" alt="image-20221113092545691"></p></li></ul><h3 id="二叉排序树的创建和插入节点"><a href="#二叉排序树的创建和插入节点" class="headerlink" title="二叉排序树的创建和插入节点"></a>二叉排序树的创建和插入节点</h3><ul><li><p>二叉排序树创建的时候，<strong>对于每个要插入的节点，都要先和根节点比较，比根节点小的话就往左走，比根节点大的话就往右走，然后继续和左子节点或者右子节点比较，重复上述操作直到找到空位置进行插入</strong>。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  ```</span><br><span class="line"></span><br><span class="line">### 二叉排序树查找节点</span><br><span class="line"></span><br><span class="line">- **从根节点开始，如果要查找的节点比当前节点要小，就向左找；如果要查找的节点比当前节点要大，就向右找，重复上述操作直到找到或者没找到**。没啥好说的</span><br><span class="line"></span><br><span class="line">- 代码示例：</span><br><span class="line"></span><br><span class="line">  ```java</span><br></pre></td></tr></table></figure></li></ul><h3 id="二叉排序树删除节点"><a href="#二叉排序树删除节点" class="headerlink" title="二叉排序树删除节点"></a>二叉排序树删除节点</h3><ul><li><p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑（以上面的数据为例）：</p><ol><li>删除叶子节点 (比如：2, 5, 9, 12)</li><li>删除只有一颗子树的节点 (比如：1)</li><li>删除有两颗子树的节点. (比如：7, 3，10 )</li></ol></li><li><p><strong>删除叶子节点的时候，只需要将其父节点对应的指针置空即可</strong>，没什么好说的；</p></li><li><p><strong>删除只有一颗子树的节点的时候，将其父节点的对应指针指向该节点的子节点即可</strong>，也就是要保证该节点的子树不会随着该节点的删除而丢失；</p></li><li><p><strong>删除有两棵子树的节点的时候</strong>，这种情况比较复杂但也比较巧妙，我们<strong>需要找到该节点的左子树的最大的节点或者右子树最小的节点，将找到的符合条件的节点的值赋值给该节点，然后对找到的那个符合条件的那个节点执行删除操作。由于找到的那个节点是左&#x2F;右子树的最值，根据二叉排序树的特性，它一定是叶节点，所以根据叶节点的删除方式对其删除即可</strong>。感慨一句，真是挺巧妙的，把删除非叶节点转换成了删除叶节点同时还保证了二叉排序树的结构。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h2 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h2><ul><li><strong>平衡二叉树本身就是一种特殊的二叉排序树，它身上有二叉排序树的所有特性</strong>。</li></ul><h3 id="通过一个案例来认识二叉排序树可能存在的问题"><a href="#通过一个案例来认识二叉排序树可能存在的问题" class="headerlink" title="通过一个案例来认识二叉排序树可能存在的问题"></a>通过一个案例来认识二叉排序树可能存在的问题</h3><ul><li>给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在。</li><li>如果让1作为根节点的话，后面所有的元素依次递增，也就是说后面的每一个元素都会是前一个元素的右子节点，这样的一颗<strong>二叉排序树实际上就退化成链表了，查询速度明显降低</strong>，数据一旦大起来，这样的性能折损显然是我们不能接受的。</li><li>就算不是上面这种非常极端的情况，平常也会出现<strong>二叉排序树的其中某些路径的深度很深的情况，那么查询这个路径上的节点的时候效率就会较低</strong>。</li><li>鉴于上面这种情况的存在，我们需要使用平衡二叉树来解决这种问题。</li></ul><h3 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li><p>平衡二叉树也叫<strong>平衡二叉搜索树（Self-balancing binary search tree）</strong>又被称为 AVL 树， 可以<strong>保证查询效率较高</strong>。</p></li><li><p>平衡二叉树具有以下特点：<strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树</strong>。平衡二叉树的常用实现方法有<strong>红黑树、AVL、替罪羊树、Treap、伸展树等</strong>。</p></li><li><p>平衡二叉树举例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113103456817.png" alt="image-20221113103456817"></p><p>最右边的二叉树不是平衡二叉树，因为根节点的左右子树的高度差为2（一个是2一个是0），大于1，不符合平衡二叉树的定义。</p></li></ul><h3 id="平衡二叉树左旋转"><a href="#平衡二叉树左旋转" class="headerlink" title="平衡二叉树左旋转"></a>平衡二叉树左旋转</h3><ul><li><p>如果要是<strong>树的最右路径（一直往右走）长度过长的话，我们就需要对整棵树进行左旋转来尝试将最右路径的长度变短</strong>。</p></li><li><p>由于在创建和维护平衡二叉树的时候，每次插入一个新的节点都会触发判断平衡二叉树是否需要进行旋转，所以<strong>最多会出现高度差为2的不平衡</strong>，所以只需要针对这种情况设计旋转的过程即可。</p></li><li><p>左旋转通过<strong>将最右路径的高度分一个单位给最左路径来将最右路径的高度降低</strong>，这种方式通常通过将根节点分到左边，将根节点的右子节点提升为根节点来实现。</p></li><li><p>具体步骤就是：<strong>创建一个新节点，值等于根节点的右节点的值，新节点的左指针指向根节点，右指针指向根节点的右节点的右节点，然后让根节点的右节点指向根节点的右节点的左节点</strong>。</p></li><li><p>上面的操作实际上就是<strong>让新节点替代了根节点的右节点变成了整个树的根节点，根节点的右节点由于失去引用被回收了，从整体上看就相当于最右路径向左转了一下</strong>，由于二叉排序树的性质，根节点的右节点的左子树的所有值肯定是比根节点的右节点的值要小的，那么根节点的右节点提升为根节点的话，根节点的右节点的左子树肯定要放到提升为根节点的那个节点的左边，同时由于二叉排序树的性质，根节点的右节点的左子树的所有值肯定比原来的根节点的值要大，原来的根节点降低为新根节点的左节点，同时空闲出来了右指针，所以可以把原根节点的右节点的左子树放到平衡后的原根节点的右指针上。</p></li><li><p>思路分析图解：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113111118855.png" alt="image-20221113111118855"></p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h3 id="平衡二叉树右旋转"><a href="#平衡二叉树右旋转" class="headerlink" title="平衡二叉树右旋转"></a>平衡二叉树右旋转</h3><ul><li><p>如果要是<strong>树的最左路径（一直往左走）长度过长的话，我们就需要对整棵树进行右旋转来尝试将最左路径的长度变短</strong>。</p></li><li><p>由于在创建和维护平衡二叉树的时候，每次插入一个新的节点都会触发判断平衡二叉树是否需要进行旋转，所以<strong>最多会出现高度差为2的不平衡</strong>，所以只需要针对这种情况设计旋转的过程即可。</p></li><li><p>右旋转通过<strong>将最左路径的高度分一个单位给最右路径来将最左路径的高度降低</strong>，这种方式通常通过将根节点分到右边，将根节点的左子节点提升为根节点来实现。</p></li><li><p>具体步骤就是：<strong>创建一个新节点，值等于根节点的左节点的值，新节点的右指针指向根节点，左指针指向根节点的左节点的左节点，然后让根节点的左节点指向根节点的左节点的右节点</strong>。</p></li><li><p>上面的操作实际上就是<strong>让新节点替代了根节点的左节点变成了整个树的根节点，根节点的左节点由于失去引用被回收了，从整体上看就相当于最左路径向右转了一下</strong>，由于二叉排序树的性质，根节点的左节点的右子树的所有值肯定是比根节点的左节点的值要大的，那么根节点的左节点提升为根节点的话，根节点的左节点的右子树肯定要放到提升为根节点的那个节点的右边，同时由于二叉排序树的性质，根节点的左节点的右子树的所有值肯定比原来的根节点的值要小，原来的根节点降低为新根节点的右节点，同时空闲出来了左指针，所以可以把原根节点的左节点的右子树放到平衡后的原根节点的左指针上。</p></li><li><p>思路分析图解：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113111357063.png" alt="image-20221113111357063"></p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h3 id="平衡二叉树双旋转"><a href="#平衡二叉树双旋转" class="headerlink" title="平衡二叉树双旋转"></a>平衡二叉树双旋转</h3><ul><li><p>如果要是<strong>树的非最左最右路径过长的话，单用一次或右旋转或左旋转无法将树调整为平衡二叉树</strong>，这种时候就需要使用双旋转，核心思路就是<strong>先把长出来的部分转移到最左或者最右路径上，这一步通常需要一个旋转操作来实现，然后再进行左旋转或者右旋转</strong>。</p></li><li><p><strong>当根节点左子树的高度大于右子树且高度差大于1的时候，理应发生右旋转</strong>，但是<strong>如果根节点的左子树的右子树的高度大于根节点的左子树的左子树，一次右旋转无法将其调整为平衡二叉树</strong>，这时我们就需要<strong>先对根节点的左子树做一次左旋转，将高出来的高度旋转到最左路径上，然后就可以通过右旋转进行调整了</strong>。</p></li><li><p><strong>当根节点右子树的高度大于左子树且高度差大于1的时候，理应发生左旋转</strong>，但是<strong>如果根节点的右子树的左子树的高度大于根节点的右子树的右子树，一次左旋转无法将其调整为平衡二叉树</strong>，这时我们就需要<strong>先对根节点的右子树做一次右旋转，将高出来的高度旋转到最右路径上，然后就可以通过左旋转进行调整了</strong>。</p></li><li><p>思路分析图解：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113113223559.png" alt="image-20221113113223559"></p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h1 id="数据结构-多路查找树"><a href="#数据结构-多路查找树" class="headerlink" title="数据结构-多路查找树"></a>数据结构-多路查找树</h1><h2 id="多叉树与B树"><a href="#多叉树与B树" class="headerlink" title="多叉树与B树"></a>多叉树与B树</h2><h3 id="二叉树的问题分析"><a href="#二叉树的问题分析" class="headerlink" title="二叉树的问题分析"></a>二叉树的问题分析</h3><ul><li><p>二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113114141432.png" alt="image-20221113114141432"></p></li><li><p>二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如 1 亿)， 就存在如下问题：</p><ol><li>在构建二叉树时，需要多次进行 i&#x2F;o 操作(海量数据存在数据库或文件中)，<strong>节点海量，构建二叉树时，对速度有影响</strong>。</li><li><strong>节点海量，也会造成二叉树的高度很大，会降低操作速度</strong>。</li></ol></li></ul><h3 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h3><ul><li><p>在二叉树中，每个节点有数据项，最多有两个子节点。<strong>如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）</strong>。</p></li><li><p>后面我们讲解的 2-3 树，2-3-4 树就是多叉树，<strong>多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化</strong>。</p></li><li><p>多叉树示例（下面的2-3树就是一棵多叉树）：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113114500386.png" alt="image-20221113114500386"></p></li></ul><h3 id="B树的基本介绍"><a href="#B树的基本介绍" class="headerlink" title="B树的基本介绍"></a>B树的基本介绍</h3><ul><li><p>B树<strong>通过重新组织节点，降低树的高度，并且通过减少I&#x2F;O读写次数来提升效率</strong>。</p></li><li><p>B树示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113114712207.png" alt="image-20221113114712207"></p></li><li><p>如图<strong>B树通过重新组织节点，降低了树的高度</strong>。</p></li><li><p><strong>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页（页的大小通常为4k），这样每个节点只需要一次I&#x2F;O就可以完全载入</strong>。</p></li><li><p>将树的度 M 设置为 1024，在 600 亿个元素中最多只需要 4 次 I&#x2F;O 操作就可以读取到想要的元素, <strong>B 树(B+)广泛应用于文件存储系统以及数据库系统中</strong>。</p></li><li><p>B树是个相对抽象的概念，2-3树、2-3-4树都是B树的一种实现。</p></li></ul><h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><h3 id="2-3树是最简单的B树结构"><a href="#2-3树是最简单的B树结构" class="headerlink" title="2-3树是最简单的B树结构"></a>2-3树是最简单的B树结构</h3><ul><li>2-3树具有如下特点：<ol><li>2-3 树的<strong>所有叶子节点都在同一层.(只要是 B 树都满足这个条件)</strong></li><li><strong>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点</strong>.</li><li><strong>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</strong>.</li><li>2-3 树是<strong>由二节点和三节点构成</strong>的树。</li></ol></li></ul><h3 id="2-3树应用案例"><a href="#2-3树应用案例" class="headerlink" title="2-3树应用案例"></a>2-3树应用案例</h3><ul><li><p>将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成 2-3 树，并保证数据插入的大小顺序：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114090342074.png" alt="image-20221114090342074"></p></li></ul><h3 id="2-3树节点插入规则"><a href="#2-3树节点插入规则" class="headerlink" title="2-3树节点插入规则"></a>2-3树节点插入规则</h3><ol><li>2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件)</li><li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li><li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</li><li>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，<strong>先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面 3 个条件</strong>。</li><li><strong>对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则，除此之外，三节点内部的两个元素也应该是有序的</strong>。</li></ol><h3 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h3><ul><li><p>除了 23 树，还有 234 树等，概念和 23 树类似，也是一种 B 树。 如图:</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114092600003.png" alt="image-20221114092600003"></p></li></ul><h2 id="B树、B-树和B-树"><a href="#B树、B-树和B-树" class="headerlink" title="B树、B+树和B*树"></a>B树、B+树和B*树</h2><h3 id="B树的介绍"><a href="#B树的介绍" class="headerlink" title="B树的介绍"></a>B树的介绍</h3><ul><li><p><strong>B-tree 树即 B 树，B 即 Balanced，平衡的意思</strong>。有人把 B-tree 翻译成 B-树，容易让人产生误解。会以为 B-树是一种树，而 B 树又是另一种树。实际上，<strong>B-tree 就是指的 B 树</strong>。</p></li><li><p>前面已经介绍了 2-3 树和 2-3-4 树，他们就是 B 树(英语：B-tree 也写成 B-树)，这里我们再做一个说明，我们在学习 Mysql 时，经常听到说某种类型的索引是基于 B 树或者 B+树的，如图:</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114092747019.png" alt="image-20221114092747019"></p></li><li><p>对B树的说明：</p><ol><li><strong>B树的阶：节点的最多子节点个数</strong>。比如 2-3 树的阶是 3，2-3-4 树的阶是 4</li><li>B-树的搜索，<strong>从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</strong>。</li><li>关键字集合分布在整颗树中, 即<strong>叶子节点和非叶子节点都存放数据</strong>。</li><li><strong>搜索有可能在非叶子结点结束</strong></li><li>其<strong>搜索性能等价于在关键字全集内做一次二分查找</strong></li></ol></li></ul><h3 id="B-树的介绍"><a href="#B-树的介绍" class="headerlink" title="B+树的介绍"></a>B+树的介绍</h3><ul><li><p>B+树是B树的变体，也是一种多路搜索树：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114093141034.png" alt="image-20221114093141034"></p></li><li><p>对B+树的说明：</p><ol><li>B+树的搜索与 B 树也基本相同，区别是<strong>B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</strong>。</li><li><strong>所有关键字都出现在叶子结点的链表中</strong>（即<strong>数据只能在叶子节点</strong>【也叫<strong>稠密索引</strong>】），且<strong>链表中的关键字(数据)恰好是有序的</strong>。</li><li><strong>不可能在非叶子结点命中</strong></li><li><strong>非叶子结点相当于是叶子结点的索引（稀疏索引）</strong>，<strong>叶子结点相当于是存储（关键字）数据的数据层</strong></li><li>更<strong>适合文件索引系统</strong></li><li>B 树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.</li></ol></li></ul><h3 id="B-树的介绍-1"><a href="#B-树的介绍-1" class="headerlink" title="B*树的介绍"></a>B*树的介绍</h3><ul><li><p>B*树是 B+树的变体，<strong>在B+树的非根和非叶子结点再增加指向兄弟的指针</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114093538855.png" alt="image-20221114093538855"></p></li><li><p>对B*树的说明：</p><ol><li>B*树定义了<strong>非叶子结点关键字个数至少为(2&#x2F;3)*M</strong>，即<strong>块的最低使用率为 2&#x2F;3</strong>，而<strong>B+树的块的最低使用率为的1&#x2F;2</strong>。</li><li>从第 1 个特点我们可以看出，<strong>B*树分配新结点的概率比B+树要低，空间使用率更高</strong>。</li></ol></li></ul><h1 id="数据结构-并查集"><a href="#数据结构-并查集" class="headerlink" title="数据结构-并查集"></a>数据结构-并查集</h1><h2 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>并查集作为一种简洁而优雅的树形数据结构，主要用于解决一些<strong>元素分组</strong>的问题，它<strong>管理着一系列不相交的集合</strong>，并支持两种操作：<ol><li><strong>合并（Union）</strong>：把两个不相交的集合合并为一个集合。</li><li><strong>查询（Find）</strong>：查询两个元素是否在同一个集合中。</li></ol></li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><p>在最基础的应用中，抽象后的点集都是按顺序的数字，此时我们只<strong>需要一个一维数组f来表示元素之间的关系</strong>，如果<strong>f[i]&#x3D;j说明i的父节点是j</strong>，那么它们肯定有相同的根节点，也就是说明i和j是属于同一组的，在这个一维数组中，<strong>两者拥有相同根节点的元素都是属于同一组的</strong>。</p></li><li><p>对于一维数组f的初始化，应该<strong>把每个元素的值初始化成它的下标，表示刚开始的时候所有元素彼此独立</strong>，互相之间没有从属关系，所以<strong>如果后面出现一个元素的值为它的下标，说明它是独立的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//并查集数组,f[i]=j说明i的父亲节点是j</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化每个节点都是独立的，即他们的father都是自己</span></span><br><span class="line">    f[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>首先来看<strong>查询（Find）操作</strong>，这个操作的最终目的是查询两个元素是否在同一个集合中，那么我们不妨<strong>把这个操作的粒度降低，让每次Find操作都查询一个元素的根节点，这样可以在后续编码时带来更高的灵活性</strong>，判定两个元素是否同一组就是判断两个元素的根节点是否相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] f,<span class="type">int</span> v)</span>&#123;<span class="comment">//找一个元素的根节点</span></span><br><span class="line">        <span class="keyword">return</span> f[v]==v?v:(f[v] = find(f,f[v]));<span class="comment">//如果该点独立，直接返回;如果该点不独立,往后找根节点，顺便进行路径压缩</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们<strong>通过递归去找元素对应的根节点</strong>，实际上<strong>在递归的过程中做了一个路径压缩的优化</strong>，路径压缩就是说<strong>把递归过程中经过的所有节点的父节点都变成它们的根节点，这样做可以使后面再次查找这条递归链上元素根节点的时间复杂度降低，由于递归过程中经过的节点拥有相同的根节点，所以保证了该操作的正确性</strong>。</p></li><li><p>再来看<strong>合并（Union）操作</strong>，这个操作的目的是<strong>如果两个元素本来不是同一组的，那么就将两个元素合并到同一组中</strong>，反映到数据结构上就是让一个元素变成另外一个元素的父亲。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] f,<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;<span class="comment">//合并操作，其中可以做优化：直接把两者的根节点合并</span></span><br><span class="line">        <span class="keyword">return</span> (u = find(f,u))==(v = find(f,v))?<span class="literal">false</span>:(f[v]=u)==u;<span class="comment">//先找到各自的根，然后比较，如果相同说明已经合并无需再合并，返回false；如果不相同就合并，返回true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>本来是让其中一个元素的根节点合并到另外一个元素上面的，但是上面的代码中也做了一个优化，那就是<strong>直接把两者的根节点合并，可以缩短递归链的长度，优化时间复杂度</strong>。</p></li></ul><h1 id="数据结构-稀疏数组（sparsearray）"><a href="#数据结构-稀疏数组（sparsearray）" class="headerlink" title="数据结构-稀疏数组（sparsearray）"></a>数据结构-稀疏数组（sparsearray）</h1><h2 id="需求场景示例"><a href="#需求场景示例" class="headerlink" title="需求场景示例"></a>需求场景示例</h2><ul><li><p>编写一个五子棋程序，有存盘退出的功能和续上盘的功能。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031201730800.png" alt="image-20221031201730800"></p></li><li><p>问题分析：要想实现这些功能，就需要对棋局进行持久化，而大部分情况下棋局对应的二维数组都是比较稀疏的，因此有很多没有意义的数据，这些没有意义的数据如果做持久化，就会对空间产生额外的消耗，因此为了应对这种情况，我们<strong>可以使用稀疏数组来对数组进行存储，在特定情况下使用可以减少空间的开销</strong>。</p></li></ul><h2 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p></li><li><p>稀疏数组的处理方法是:</p><ol><li>在稀疏数组的<strong>第一个元素中存放原数组的行数、列数、元素数</strong>。</li><li>在稀疏数组<strong>除了第一个元素后面的每一个空间中记录原数组的一个元素所在的行数、列数和值</strong>。</li></ol></li><li><p>稀疏数组举例说明：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031202328310.png" alt="image-20221031202328310"></p></li></ul><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><ul><li><p>使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)</p></li><li><p>把稀疏数组存盘，并且可以重新恢复原来的二维数组。</p></li><li><p>整体思路分析：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031202449600.png" alt="image-20221031202449600"></p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.sparsearray;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 创建一个原始的二维数组 11 * 11</span></span><br><span class="line"><span class="comment">// 0: 表示没有棋子， 1 表示 黑子 2 表蓝子</span></span><br><span class="line"><span class="type">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">chessArr1[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 输出原始的二维数组</span></span><br><span class="line">System.out.println(<span class="string">&quot;原始的二维数组~~&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr1) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将二维数组 转 稀疏数组的思</span></span><br><span class="line"><span class="comment">// 1. 先遍历二维数组 得到非 0 数据的个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 创建对应的稀疏数组</span></span><br><span class="line"><span class="type">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 给稀疏数组赋值</span></span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"><span class="comment">// 遍历二维数组，将非 0 的值存放到 sparseArr 中</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//count 用于记录是第几个非 0 数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出稀疏数组的形式</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;得到稀疏数组为~~~~&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;%d\t%d\t%d\t\n&quot;</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//将稀疏数组 --》 恢复成 原始的二维数组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2 = int[11][11]</span></span><br><span class="line"><span class="comment">   2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line"><span class="type">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"><span class="comment">//2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;恢复后的二维数组&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr2) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h1&gt;&lt;h2 id=&quot;常用排序算法的总结和</summary>
      
    
    
    
    
    <category term="算法" scheme="https://konjacor.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://konjacor.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用操作</title>
    <link href="https://konjacor.github.io/2022/09/14/Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>https://konjacor.github.io/2022/09/14/Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</id>
    <published>2022-09-14T03:18:47.000Z</published>
    <updated>2022-12-20T12:11:43.197Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="解压目标到另外一个文件夹"><a href="#解压目标到另外一个文件夹" class="headerlink" title="解压目标到另外一个文件夹"></a>解压目标到另外一个文件夹</h2><ul><li><p><strong>tar -zxvf 文件名 -C 文件夹路径</strong>，一定要加-C来说明要解压到指定目录</p></li><li><p>示例：<strong>tar -zxvf redis-6.0.6.tar.gz -C ..&#x2F;redis</strong></p></li></ul><h2 id="永久关闭防火墙"><a href="#永久关闭防火墙" class="headerlink" title="永久关闭防火墙"></a>永久关闭防火墙</h2><ul><li><strong>systemctl disable firewalld</strong></li></ul><h2 id="查找含有某字符串的进程"><a href="#查找含有某字符串的进程" class="headerlink" title="查找含有某字符串的进程"></a>查找含有某字符串的进程</h2><ul><li><strong>ps -ef | grep redis</strong></li></ul><h2 id="CentOS中暂时修改gcc的版本"><a href="#CentOS中暂时修改gcc的版本" class="headerlink" title="CentOS中暂时修改gcc的版本"></a>CentOS中暂时修改gcc的版本</h2><ul><li><p>使用这个命令之前需要进行安装操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build #SCL(Software Collections)是一个CentOS/RHEL Linux平台的软件多版本共存解决方案，为RHEL/CentOS  Linux用户提供一种方便、安全地安装和使用应用程序和运行时环境的多个版本的方式，同时避免把系统搞乱。</span><br><span class="line">yum install -y devtoolset-8-toolchain #安装工具集</span><br></pre></td></tr></table></figure></li><li><p>然后使用<strong>scl enable devtoolset-8 bash</strong>会将gcc的版本暂时设置为8.*，在终端会话结束时恢复。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h1&gt;&lt;h2 id=&quot;解压目标到另外一个文</summary>
      
    
    
    
    
    <category term="linux" scheme="https://konjacor.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>算法刷题心得</title>
    <link href="https://konjacor.github.io/2022/09/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    <id>https://konjacor.github.io/2022/09/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/</id>
    <published>2022-09-13T11:12:44.000Z</published>
    <updated>2022-12-20T12:11:43.206Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="2022-x2F-9-x2F-13-一维数组专题"><a href="#2022-x2F-9-x2F-13-一维数组专题" class="headerlink" title="2022&#x2F;9&#x2F;13 一维数组专题"></a>2022&#x2F;9&#x2F;13 一维数组专题</h1><ul><li>其实今天的题都是很基础的题，但是其中有一道题确实是让我懂了一点新的东西，下面就给出这道题。</li></ul><h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220913204141478.png" alt="image-20220913204141478"></p><ul><li><p>看一眼数据量，可以跑O(n^2)的算法，而且目测如果对二维数组的第一维进行排序后会更好做一点，排序之后用两个变量left和right记录一次合并的左端点和右端点，直到遇到不进行合并的集合，然后把当前的left和right作为一组数据加入到最后的数据集中，再更新left和right为当前集合的左右端点，然后继续往后遍历，遍历到最后推出循环后还要再记录一次答案，因为最后那个答案还没收录进答案中。</p></li><li><p>这当中要注意，每次做完合并之后都要把当前位置的数组的右端点设置为right的值，因为后面的数组是要和前面合并后的大数组进行比较的，大数组咱又不好拿出来，只好用部分替代整体，反正只用到了大数组的右端点。</p></li><li><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">0</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        ArrayList&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left=intervals[<span class="number">0</span>][<span class="number">0</span>],right=intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=idx;i&lt;intervals.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;=intervals[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                right = Math.max(intervals[i][<span class="number">1</span>],intervals[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                intervals[i][<span class="number">1</span>] = right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left,right&#125;);</span><br><span class="line">                left = intervals[i][<span class="number">0</span>];</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left,right&#125;);</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> ans_i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] a : list)&#123;</span><br><span class="line">            ans[ans_i][<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">            ans[ans_i++][<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建匿名数组并赋值"><a href="#创建匿名数组并赋值" class="headerlink" title="创建匿名数组并赋值"></a>创建匿名数组并赋值</h3><ul><li>要这样写(示例)：**new int[]{1,2,3}**，要注意中括号里不能填具体的长度。</li></ul><h3 id="定义数组并初始化的两种方式"><a href="#定义数组并初始化的两种方式" class="headerlink" title="定义数组并初始化的两种方式"></a>定义数组并初始化的两种方式</h3><ol><li>int[] a &#x3D; new int[]{1,2,3};</li><li>int[] a &#x3D; {1,2,3};</li></ol><h3 id="以多维数组中的其中一维给多维数组排序"><a href="#以多维数组中的其中一维给多维数组排序" class="headerlink" title="以多维数组中的其中一维给多维数组排序"></a>以多维数组中的其中一维给多维数组排序</h3><ul><li><p>主要是用到了Comparator类的方法、lambda表达式和函数式接口的相关知识，我看了看Comparator的源码也没看出多少道道来，之后再分析吧，下面是以第一维给二维数组排序的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure></li></ul><h2 id="罕见的定义数组的方式"><a href="#罕见的定义数组的方式" class="headerlink" title="罕见的定义数组的方式"></a>罕见的定义数组的方式</h2><ul><li>今天还真是长见识了。。。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220913205514046.png" alt="image-20220913205514046"></p><h1 id="2022-x2F-10-x2F-4-Morris遍历"><a href="#2022-x2F-10-x2F-4-Morris遍历" class="headerlink" title="2022&#x2F;10&#x2F;4 Morris遍历"></a>2022&#x2F;10&#x2F;4 Morris遍历</h1><ul><li>搞了二叉树的简单题，用递归倒是随便写，用非递归想要尝试尝试昨天新学的Morris遍历来优化空间复杂度，所以就尝试写了写试试。</li></ul><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221004204500176.png" alt="image-20221004204500176"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221004204516138.png" alt="image-20221004204516138"></p><ul><li><p>思路主要就是<strong>同时从两个方向来遍历，不过由于是轴对称，所以遍历时候的左右优先级要对称而非相同</strong>，剩下的就是看代码怎么写了，写了一手Morris，没有很细致的进行优化，重点都写注释里了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution125</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    TreeNode left,right,mostRight,mostLeft;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//特殊情况</span></span><br><span class="line">        left = root.left;right = root.right;<span class="comment">//left遍历左子树，right遍历右子树，由于判断的是轴对称，所有左子树遍历的时候左子树优先，右子树遍历的时候右子树优先，或者是采用其他的轴对称遍历方式。</span></span><br><span class="line">        <span class="keyword">while</span> (left!=<span class="literal">null</span>&amp;&amp;right!=<span class="literal">null</span>)&#123;<span class="comment">//每次循环都是一次访问到下一个节点的操作，如果循环退出说明至少有一方走到了null(即那一方遍历完了)</span></span><br><span class="line">            <span class="keyword">if</span>(left.val!=right.val)&#123;<span class="comment">//判断遍历到的位置的值是否相等，如果不相等就可以直接判断为非轴对称</span></span><br><span class="line">                ans = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mostRight=left.left;mostLeft = right.right;<span class="comment">//左子树要找最右边的节点，右子树要找最左边的节点（都是找他们那棵树上最后访问到的节点）</span></span><br><span class="line">            <span class="keyword">if</span>(mostRight!=<span class="literal">null</span>&amp;&amp;mostLeft!=<span class="literal">null</span>) &#123;<span class="comment">//有左子树/右子树的情况，要找最右/最左的节点（即最晚遍历到的节点），来设置线索</span></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="literal">null</span> &amp;&amp; mostRight.right != left) &#123;<span class="comment">//找最右边的节点</span></span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (mostLeft.left != <span class="literal">null</span> &amp;&amp; mostLeft.left != right)&#123;<span class="comment">//找最左边的节点</span></span><br><span class="line">                    mostLeft = mostLeft.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(mostRight.right==<span class="literal">null</span>)&#123;<span class="comment">//没有线索，说明没有遍历过左子树，故设置线索为当前节点后向左遍历</span></span><br><span class="line">                    mostRight.right = left;</span><br><span class="line">                    left = left.left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//有线索，说明遍历过左子树了，故洗掉线索然后向右遍历</span></span><br><span class="line">                    mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                    left = left.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(mostLeft.left==<span class="literal">null</span>)&#123;<span class="comment">//没有线索，说明没有遍历过右子树，故设置线索为当前节点后向右遍历</span></span><br><span class="line">                    mostLeft.left = right;</span><br><span class="line">                    right = right.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//有线索，说明遍历过右子树了，故洗掉线索然后向左遍历</span></span><br><span class="line">                    mostLeft.left = <span class="literal">null</span>;</span><br><span class="line">                    right = right.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//没有左子树/右子树的情况,直接向右/左转移</span></span><br><span class="line">                <span class="keyword">if</span>(mostRight!=mostLeft)&#123;<span class="comment">//由于至少有一方为null，所以如果两者不相等，可以直接判定不是轴对称</span></span><br><span class="line">                    ans = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left = left.right;</span><br><span class="line">                right = right.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left!=right)&#123;<span class="comment">//最后做个判断，如果这俩相等说明是同时遍历完的，如果不相等说明有一边先遍历完了，就不是轴对称了。</span></span><br><span class="line">            ans = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>感觉这个算法要是理解了本质的话不算难，写起来也挺顺手的，算法的详细信息见《数据结构与算法》博客。</p></li></ul><h1 id="2022-x2F-10-x2F-5-知两种顺序的遍历结果重建二叉树"><a href="#2022-x2F-10-x2F-5-知两种顺序的遍历结果重建二叉树" class="headerlink" title="2022&#x2F;10&#x2F;5 知两种顺序的遍历结果重建二叉树"></a>2022&#x2F;10&#x2F;5 知两种顺序的遍历结果重建二叉树</h1><h2 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h2><ul><li><p>这题主要考察对二叉树中序遍历和后序遍历的理解，<strong>后序遍历的最后一个元素一定是这个二叉树的顶点，知道顶点之后，去中序遍历中找到顶点所在的位置，顶点左边是左子树的遍历结果，顶点右边是右子树的遍历结果，分别再对两边的遍历结果递归执行上面的操作即可</strong>。</p></li><li><p>其中要注意由于中序遍历和后序遍历都遵循着<strong>先遍历左子树再遍历右子树</strong>的原则，所以右子树的遍历结果都出现在遍历结果比较偏后的部分，所以<strong>后序遍历结果的倒数第二个元素是顶点的右子树的顶点，同理，后序遍历结果的倒数第三个元素是顶点的右子树的右子树的顶点，但是想要通过后序遍历结果找到左子树的顶点需要有一个右子树数量的偏移量，偏移一次之后再以步长为1向前访问就能依次访问到所有左子树的顶点了</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005233039617.png" alt="image-20221005233039617"></p></li><li><p>详细信息写在代码的注释中了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode ans;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();<span class="comment">//新建个树</span></span><br><span class="line">        dfs(inorder,postorder,postorder.length-<span class="number">1</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] subTree,<span class="type">int</span>[] postorder,<span class="type">int</span> postorder_i,TreeNode now)</span>&#123;<span class="comment">//subTree是当前子树，now是当前正在构建的节点，postorder_i是当前子树的顶点在postorder中的索引</span></span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(subTree));</span></span><br><span class="line">        <span class="keyword">if</span>(subTree.length==<span class="number">1</span>) &#123;<span class="comment">//如果当前子树只有一个节点，那么这个节点在要构建的树上是个叶节点，直接赋值然后返回</span></span><br><span class="line">            now.val = subTree[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;subTree.length;++i)&#123;<span class="comment">//在当前子树的中序遍历中找到顶点的索引进行下一步dfs</span></span><br><span class="line">            <span class="keyword">if</span>(subTree[i]==postorder[postorder_i])&#123;<span class="comment">//找到了顶点</span></span><br><span class="line">                <span class="comment">//System.out.println(subTree[i]);</span></span><br><span class="line">                now.val = subTree[i];<span class="comment">//给当前正在构建的节点赋值</span></span><br><span class="line">                <span class="keyword">if</span>(subTree.length&gt;i+<span class="number">1</span>) &#123;<span class="comment">//如果满足这个条件说明这个节点还有右节点，因为中序遍历数组的顶点右边还有遍历记录</span></span><br><span class="line">                    now.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();<span class="comment">//新建右节点，待会儿当参数传进去</span></span><br><span class="line">                    dfs(Arrays.copyOfRange(subTree, i + <span class="number">1</span>, subTree.length), postorder, postorder_i - <span class="number">1</span>, now.right);<span class="comment">//将右边的遍历结果当成一个树继续dfs，postorder由于是后序遍历结果，所以右子树的遍历结果在偏后边，所以往前访问一个即是新的树的顶点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>) &#123;<span class="comment">//如果满足这个条件说明这个节点还有左节点，因为中序遍历数组的顶点左边还有遍历记录</span></span><br><span class="line">                    now.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();<span class="comment">//新建右节点，待会儿当参数传进去</span></span><br><span class="line">                    dfs(Arrays.copyOfRange(subTree, <span class="number">0</span>, i), postorder, postorder_i - <span class="number">1</span>-(subTree.length-(i+<span class="number">1</span>)), now.left);<span class="comment">//将左边的遍历结果当成一个树继续dfs，postorder由于是后序遍历结果，所以左子树的遍历结果在偏前边，所以往前访问的时候要跳过右子树的节点才是新的树的顶点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h2><ul><li><p>类比上面那个，顺序啥的换一下就行了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005233327985.png" alt="image-20221005233327985"></p></li><li><p>注释还都是用的上面那个的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode ans;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();<span class="comment">//新建个树</span></span><br><span class="line">        dfs(inorder,preorder,<span class="number">0</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] subTree,<span class="type">int</span>[] preorder,<span class="type">int</span> preorder_i,TreeNode now)</span>&#123;<span class="comment">//subTree是当前子树，now是当前正在构建的节点，postorder_i是当前子树的顶点在postorder中的索引</span></span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(subTree));</span></span><br><span class="line">        <span class="keyword">if</span>(subTree.length==<span class="number">1</span>) &#123;<span class="comment">//如果当前子树只有一个节点，那么这个节点在要构建的树上是个叶节点，直接赋值然后返回</span></span><br><span class="line">            now.val = subTree[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;subTree.length;++i)&#123;<span class="comment">//在当前子树的中序遍历中找到顶点的索引进行下一步dfs</span></span><br><span class="line">            <span class="keyword">if</span>(subTree[i]==preorder[preorder_i])&#123;<span class="comment">//找到了顶点</span></span><br><span class="line">                <span class="comment">//System.out.println(subTree[i]);</span></span><br><span class="line">                now.val = subTree[i];<span class="comment">//给当前正在构建的节点赋值</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>) &#123;<span class="comment">//如果满足这个条件说明这个节点还有左节点，因为中序遍历数组的顶点左边还有遍历记录</span></span><br><span class="line">                    now.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();<span class="comment">//新建右节点，待会儿当参数传进去</span></span><br><span class="line">                    dfs(Arrays.copyOfRange(subTree, <span class="number">0</span>, i), preorder, preorder_i + <span class="number">1</span>, now.left);<span class="comment">//将左边的遍历结果当成一个树继续dfs，postorder由于是后序遍历结果，所以左子树的遍历结果在偏前边，所以往前访问的时候要跳过右子树的节点才是新的树的顶点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(subTree.length&gt;i+<span class="number">1</span>) &#123;<span class="comment">//如果满足这个条件说明这个节点还有右节点，因为中序遍历数组的顶点右边还有遍历记录</span></span><br><span class="line">                    now.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();<span class="comment">//新建右节点，待会儿当参数传进去</span></span><br><span class="line">                    dfs(Arrays.copyOfRange(subTree, i + <span class="number">1</span>, subTree.length), preorder, preorder_i +<span class="number">1</span>+(i-<span class="number">0</span>), now.right);<span class="comment">//将右边的遍历结果当成一个树继续dfs，postorder由于是后序遍历结果，所以右子树的遍历结果在偏后边，所以往前访问一个即是新的树的顶点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2022-x2F-10-x2F-10-二叉树的最近公共祖先-LCA"><a href="#2022-x2F-10-x2F-10-二叉树的最近公共祖先-LCA" class="headerlink" title="2022&#x2F;10&#x2F;10 二叉树的最近公共祖先(LCA)"></a>2022&#x2F;10&#x2F;10 二叉树的最近公共祖先(LCA)</h1><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010195910781.png" alt="image-20221010195910781"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010195928345.png" alt="image-20221010195928345"></p><h2 id="递归解决"><a href="#递归解决" class="headerlink" title="递归解决"></a>递归解决</h2><ul><li><p>由于这个题指定了这个树是二叉树，每个节点的度小于等于2，所以我们可以利用递归进行解题，思路就是<strong>利用递归的先自顶向下，再自底向上的特性</strong>，在<strong>自顶向下的时候寻找目标节点</strong>，在<strong>自底向上的时候将答案带回</strong>。</p></li><li><p>每到一个节点都向左右方向递归，如果<strong>遇到null或者p或者q就进行返回，记录左右递归的结果</strong>，<strong>如果两者都为null，那就返回null</strong>，说明这个子树中没有目标值；<strong>如果两者都不为null，那就返回当前节点</strong>，因为两者都不为null说明分别在左右两边找到了目标值，那么当前节点就是他们的公共祖先，由于递归的返回阶段是自底向上的，所以可以确定当前节点就是他们的最近公共祖先；<strong>如果两者中其中一个为null，那么就返回那个不为null的值</strong>，这样可以保证答案或者找到的节点送到上层。</p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>||cur == p||cur == q) <span class="keyword">return</span> cur;<span class="comment">//找到节点或者到头了，就返回当前节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(cur.left,p,q);<span class="comment">//向左递归</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(cur.right,p,q);<span class="comment">//向右递归</span></span><br><span class="line">        <span class="comment">//向上传null或者是找到的p/q</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="comment">//左右都不为null，说明当前节点是最近公共祖先，将当前节点向上传</span></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="非递归解决"><a href="#非递归解决" class="headerlink" title="非递归解决"></a>非递归解决</h2><ul><li><p>非递归的方法不仅可以解决二叉树的LCA问题，<strong>对于任何树的LCA问题都能解决</strong>，具有普适性。</p></li><li><p>首先我们<strong>需要一个方法来取得当前节点在树中的深度</strong>，然后<strong>遍历树直到将两个目标节点遍历完，记录下两个节点深度，然后比较两个节点的深度，将比较深的那个节点的指针向上移动直到和另外一个节点处于同一层，然后将两个节点指针同时向上移动直到两个节点指针碰头，此时两个节点指针指向的节点就是两个目标节点的最近公共祖先</strong>。</p></li><li><p>优化方面可以<strong>考虑向上移动的时候使用倍增</strong>。</p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h1 id="2022-x2F-10-x2F-11-二叉树的序列化和反序列化"><a href="#2022-x2F-10-x2F-11-二叉树的序列化和反序列化" class="headerlink" title="2022&#x2F;10&#x2F;11 二叉树的序列化和反序列化"></a>2022&#x2F;10&#x2F;11 二叉树的序列化和反序列化</h1><h2 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011212529671.png" alt="image-20221011212529671"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011212544238.png" alt="image-20221011212544238"></p><ul><li><p>看到这题的时候实际上就是有两种思路，<strong>第一种使用层序遍历并还原</strong>的方式，但是处理其中的null相对比较复杂，不如<strong>第二种使用递归遍历并还原的方式</strong>，使用先序遍历或者中序遍历或者后序遍历<strong>记录下含有null的字符串</strong>，解析的时候再用相同的遍历顺序构建树即可，注意做好特殊情况的处理。</p></li><li><p>受之前知两种顺序的遍历结果重建二叉树那题的影响，搞得我以为必须要两种遍历结果才能还原二叉树，实际上对于不含null的遍历结果确实是这样的，因为只知道一种遍历结果无法准确定位空节点，但是<strong>对于含有null的遍历结果，只知道它是怎样的遍历顺序，就能用同样的顺序重建二叉树，因为其中的null保证了你可以准确知道空节点的位置</strong>。</p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfsBefore(root);</span><br><span class="line">        <span class="comment">//dfsMid(root);</span></span><br><span class="line"><span class="comment">//        char[] shift = new char[temp.size()];</span></span><br><span class="line"><span class="comment">//        int i=0;</span></span><br><span class="line"><span class="comment">//        for(int num:temp)&#123;</span></span><br><span class="line"><span class="comment">//            shift[i++] = (char)num;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> temp.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(data.equals(<span class="string">&quot;[null]&quot;</span>)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(data);</span><br><span class="line">        data = data.substring(<span class="number">1</span>,data.length()-<span class="number">1</span>);</span><br><span class="line">        String[] dataArray = data.split(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        buildTree(dataArray,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfsBefore</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            temp.add(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.add(cur.val);</span><br><span class="line">        dfsBefore(cur.left);</span><br><span class="line">        dfsBefore(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildTree</span><span class="params">(String[] data,TreeNode cur)</span>&#123;<span class="comment">//前序重建二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=data.length)&#123;<span class="comment">//没有节点了就返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.val = Integer.parseInt(data[i]);<span class="comment">//给当前节点赋值</span></span><br><span class="line">        <span class="keyword">if</span>(!data[i+<span class="number">1</span>].equals(<span class="string">&quot;null&quot;</span>))&#123;<span class="comment">//下一个元素（即左儿子）如果不为空就开空间然后往下递归。</span></span><br><span class="line">            i++;</span><br><span class="line">            cur.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">            buildTree(data,cur.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> i++;<span class="comment">//左儿子为空就不开空间跳过</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=data.length)&#123;<span class="comment">//防止下面访问数组越界，再检查一遍</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!data[i+<span class="number">1</span>].equals(<span class="string">&quot;null&quot;</span>))&#123;<span class="comment">//下一个元素（即右儿子）如果不为空就开空间然后往下递归。</span></span><br><span class="line">            i++;</span><br><span class="line">            cur.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">            buildTree(data,cur.right);</span><br><span class="line">        &#125;<span class="keyword">else</span> i++;<span class="comment">//右儿子为空就不开空间跳过。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="2022-x2F-10-x2F-17-旋转矩阵-amp-交换两数的原地算法"><a href="#2022-x2F-10-x2F-17-旋转矩阵-amp-交换两数的原地算法" class="headerlink" title="2022&#x2F;10&#x2F;17 旋转矩阵&amp;交换两数的原地算法"></a>2022&#x2F;10&#x2F;17 旋转矩阵&amp;交换两数的原地算法</h1><h2 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221017210609463.png" alt="image-20221017210609463"></p><ul><li><p>可以<strong>将旋转操作转换为先对角线翻转然后再水平翻转</strong>，但是怎么做到原地算法呢？这就涉及到一个很巧妙的<strong>原地将两个变量的值做交换的算法</strong>了，这个算法充分利用到了两数之和的性质，算法描述如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************交换a和b的值************************/</span></span><br><span class="line">a += b;</span><br><span class="line">b = a - b;</span><br><span class="line">a -= b;</span><br></pre></td></tr></table></figure></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="comment">//对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matrix.length;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;matrix[i].length;++j)&#123;</span><br><span class="line">                matrix[i][j] += matrix[j][i];</span><br><span class="line">                matrix[j][i] = matrix[i][j] - matrix[j][i];</span><br><span class="line">                matrix[i][j] -= matrix[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//水平翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;matrix.length;++k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=matrix[k].length-<span class="number">1</span>;i&lt;j;++i,--j)&#123;</span><br><span class="line">                matrix[k][i] += matrix[k][j];</span><br><span class="line">                matrix[k][j] = matrix[k][i] - matrix[k][j];</span><br><span class="line">                matrix[k][i] -= matrix[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2022-x2F-10-x2F-25-阶乘后的零"><a href="#2022-x2F-10-x2F-25-阶乘后的零" class="headerlink" title="2022&#x2F;10&#x2F;25 阶乘后的零"></a>2022&#x2F;10&#x2F;25 阶乘后的零</h1><h2 id="阶乘后的零"><a href="#阶乘后的零" class="headerlink" title="阶乘后的零"></a>阶乘后的零</h2><ul><li>又是个数学题。。。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221026110923001.png" alt="image-20221026110923001"></p><ul><li><p>先来考虑什么情况下才会在末尾贡献0，很明显，<strong>只有2、5两个因子相乘的时候才会在结尾贡献0</strong>，而5因子一定比2因子要少，所以只需要找这个阶乘中有几个5因子就知道末尾有几个零了。</p></li><li><p>由于阶乘的乘法运算的顺序是按照数字顺序且步长为1的，所以参照<strong>自然数中每过5个数就可以分解出一个5因子，n的阶乘中第一轮分解出来的5因子的个数就是n&#x2F;5</strong>，让n&#x3D;n&#x2F;5，从现在开始n就指代这一轮分解出来的5因子的个数了，<strong>分解出来的每个含有5因子的数，每隔5个又会分解出来一个5因子，这个对应的就是那些是25的倍数的数</strong>，以此类推，直到无法再分解出5因子来了，表现为n&#x3D;0。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans += n/<span class="number">5</span>;<span class="comment">//每隔五个数就有一个因子5</span></span><br><span class="line">            n /= <span class="number">5</span>;<span class="comment">//选出有因子5的数中每隔五个数又有一个因子5</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;2022-x2F-9-x2F-13-一维数组专题&quot;&gt;&lt;a href=&quot;#2022-x2F-9-x2F-13-一维数组专题&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="算法" scheme="https://konjacor.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://konjacor.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门</title>
    <link href="https://konjacor.github.io/2022/09/11/SpringBoot%E5%85%A5%E9%97%A8/"/>
    <id>https://konjacor.github.io/2022/09/11/SpringBoot%E5%85%A5%E9%97%A8/</id>
    <published>2022-09-11T09:22:45.000Z</published>
    <updated>2022-12-20T12:11:43.200Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="Spring-与-SpringBoot"><a href="#Spring-与-SpringBoot" class="headerlink" title="Spring 与 SpringBoot"></a>Spring 与 SpringBoot</h1><h2 id="Spring能做什么"><a href="#Spring能做什么" class="headerlink" title="Spring能做什么"></a>Spring能做什么</h2><h3 id="Spring的能力"><a href="#Spring的能力" class="headerlink" title="Spring的能力"></a>Spring的能力</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221123164723364.png" alt="image-20221123164723364"></p><h3 id="Spring的生态"><a href="#Spring的生态" class="headerlink" title="Spring的生态"></a>Spring的生态</h3><ul><li>详情可见：<strong><a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></strong></li><li>覆盖了：web开发、数据访问、安全控制、分布式、消息服务、移动开发、批处理……</li></ul><h3 id="Spring5重大升级"><a href="#Spring5重大升级" class="headerlink" title="Spring5重大升级"></a>Spring5重大升级</h3><h4 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h4><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221123165218680.png" alt="image-20221123165218680"></p><h4 id="内部源码设计"><a href="#内部源码设计" class="headerlink" title="内部源码设计"></a>内部源码设计</h4><ul><li>基于Java8的一些新特性，如：接口的默认实现，重新设计源码架构等。</li></ul><h2 id="为什么用SpringBoot"><a href="#为什么用SpringBoot" class="headerlink" title="为什么用SpringBoot"></a>为什么用SpringBoot</h2><ul><li>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.即能快速创建出生产级别的Spring应用。</li></ul><h3 id="SpringBoot的优点"><a href="#SpringBoot的优点" class="headerlink" title="SpringBoot的优点"></a>SpringBoot的优点</h3><ul><li>Create stand-alone Spring applications 创建独立Spring应用</li><li>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files) 内嵌web服务器</li><li>Provide opinionated ‘starter’ dependencies to simplify your build configuration 自动starter依赖，简化构建配置</li><li>Automatically configure Spring and 3rd party libraries whenever possible 自动配置Spring以及第三方功能</li><li>Provide production-ready features such as metrics, health checks, and externalized configuration 提供生产级别的监控、健康检查及外部化配置</li><li>Absolutely no code generation and no requirement for XML configuration 无代码生成、无需编写XML</li><li>SpringBoot是整合Spring技术栈的一站式框架</li><li>SpringBoot是简化Spring技术栈的快速开发脚手架</li></ul><h3 id="SpringBoot的缺点"><a href="#SpringBoot的缺点" class="headerlink" title="SpringBoot的缺点"></a>SpringBoot的缺点</h3><ul><li>人称版本帝，迭代快，需要时刻关注变化。</li><li>封装太深，内部原理复杂，不容易精通。</li></ul><h2 id="时代背景"><a href="#时代背景" class="headerlink" title="时代背景"></a>时代背景</h2><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><ul><li><p><a href="https://martinfowler.com/articles/microservices.html">James Lewis and Martin Fowler (2014)</a>  提出微服务完整概念。<a href="https://martinfowler.com/microservices/">https://martinfowler.com/microservices/</a></p><blockquote><p>In short, the <strong>microservice architectural style</strong> is an approach to developing a single application as a <strong>suite of small services</strong>, each <strong>running in its own process</strong> and communicating with <strong>lightweight</strong> mechanisms, often an <strong>HTTP</strong> resource API. These services are <strong>built around business capabilities</strong> and <strong>independently deployable</strong> by fully <strong>automated deployment</strong> machinery. There is a <strong>bare minimum of centralized management</strong> of these services, which may be <strong>written in different programming languages</strong> and use different data storage technologies.– <a href="https://martinfowler.com/articles/microservices.html">James Lewis and Martin Fowler (2014)</a></p></blockquote></li><li><p>微服务是一种架构风格</p></li><li><p>一个应用拆分为一组小型服务</p></li><li><p>每个服务运行在自己的进程内，也就是可独立部署和升级</p></li><li><p>服务之间使用轻量级HTTP交互</p></li><li><p>服务围绕业务功能拆分</p></li><li><p>可以由全自动部署机制独立部署</p></li><li><p>去中心化，服务自治。服务可以使用不同的语言、不同的存储技术</p></li></ul><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><ul><li>分布式系统是<strong>多个服务器通过网络互联而构建的松耦合系统</strong>：<img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221123170745193.png" alt="image-20221123170745193"></li></ul><h4 id="分布式的困难"><a href="#分布式的困难" class="headerlink" title="分布式的困难"></a>分布式的困难</h4><ul><li>远程调用</li><li>服务发现</li><li>负载均衡</li><li>服务容错</li><li>配置管理</li><li>服务监控</li><li>链路追踪</li><li>日志管理</li><li>任务调度</li><li>……</li></ul><h4 id="分布式的解决"><a href="#分布式的解决" class="headerlink" title="分布式的解决"></a>分布式的解决</h4><ul><li><p>SpringBoot+SpringCloud</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221123190035913.png" alt="image-20221123190035913"></p></li></ul><h3 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h3><ul><li>原生应用如何上云。-Cloud Native</li></ul><h4 id="上云的困难"><a href="#上云的困难" class="headerlink" title="上云的困难"></a>上云的困难</h4><ul><li>服务自愈</li><li>弹性伸缩</li><li>服务隔离</li><li>自动化部署</li><li>灰度发布</li><li>流量治理</li><li>……</li></ul><h2 id="如何学习SpringBoot"><a href="#如何学习SpringBoot" class="headerlink" title="如何学习SpringBoot"></a>如何学习SpringBoot</h2><h3 id="官网文档架构"><a href="#官网文档架构" class="headerlink" title="官网文档架构"></a>官网文档架构</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221123190342774.png" alt="image-20221123190342774"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221123190358243.png" alt="image-20221123190358243"></p><ul><li><p>查看版本新特性：<a href="https://github.com/spring-projects/spring-boot/wiki#release-notes">https://github.com/spring-projects/spring-boot/wiki#release-notes</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221123190453858.png" alt="image-20221123190453858"></p></li></ul><h1 id="SpringBoot2入门"><a href="#SpringBoot2入门" class="headerlink" title="SpringBoot2入门"></a>SpringBoot2入门</h1><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><ul><li>Java 8 &amp; 兼容java14 .</li><li>Maven 3.3+</li><li>idea 2019.1.2</li></ul><h2 id="maven配置文件设置"><a href="#maven配置文件设置" class="headerlink" title="maven配置文件设置"></a>maven配置文件设置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><ul><li>需求：浏览发送&#x2F;hello请求，响应Hello，Spring Boot 2</li></ul><h3 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h3><ul><li>在IDEA中创建maven工程</li></ul><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建主程序"><a href="#创建主程序" class="headerlink" title="创建主程序"></a>创建主程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主程序类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span>：这是一个SpringBoot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写业务"><a href="#编写业务" class="headerlink" title="编写业务"></a>编写业务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot 2!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>直接运行main方法</li></ul><h3 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h3><ul><li><p>可以将配置写到自己在Resources中创建的application.properties中，写在其中的配置对整个应用都生效：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8888</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="简化部署"><a href="#简化部署" class="headerlink" title="简化部署"></a>简化部署</h3><ul><li>可以在项目的pom文件中添加以下插件，这样把项目打成jar包后直接在目标服务器执行即可。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="了解自动配置原理"><a href="#了解自动配置原理" class="headerlink" title="了解自动配置原理"></a>了解自动配置原理</h1><h2 id="SpringBoot特点"><a href="#SpringBoot特点" class="headerlink" title="SpringBoot特点"></a>SpringBoot特点</h2><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><ul><li><p>父项目做依赖管理（话说这个不是maven工程的特点嘛）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">依赖管理</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">他的父项目</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">几乎声明了所有开发中常用的依赖的版本号,自动版本仲裁机制</span><br></pre></td></tr></table></figure></li><li><p>开发导入starter场景启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、见到很多 spring-boot-starter-* ： *就某种场景</span><br><span class="line">2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入</span><br><span class="line">3、SpringBoot所有支持的场景</span><br><span class="line">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</span><br><span class="line">4、见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。</span><br><span class="line">5、所有场景启动器最底层的依赖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>无需关注版本号，自动版本仲裁：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、引入依赖默认都可以不写版本</span><br><span class="line">2、引入非版本仲裁的jar，要写版本号。</span><br></pre></td></tr></table></figure></li><li><p>可以修改默认版本号：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。</span><br><span class="line">2、在当前项目里面重写配置</span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><ul><li><p>自动配置好Tomcat：手动引入Tomcat依赖，SpringBoot会帮我们自动配置好Tomcat。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>自动配置好SpringMVC：</p><ul><li>引入SpringMVC全套组件</li><li>自动配好SpringMVC常用组件（功能）。</li></ul></li><li><p>自动配好Web常见功能，如：字符编码问题：</p><ul><li>SpringBoot帮我们配置好了所有web开发的常见场景</li></ul></li><li><p>具有默认的包结构：</p><ul><li><p><strong>主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来</strong></p></li><li><p>无需以前的包扫描配置</p></li><li><p>想要改变扫描路径，可以在主程序的注解中添加参数显式指定@SpringBootApplication(scanBasePackages&#x3D;<strong>“路径”</strong>)或者使用@ComponentScan(<strong>“路径”</strong>)注解指定扫描路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">等同于</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;默认路径&quot;)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>各种配置拥有默认值：</p><ul><li><strong>默认配置最终都是映射到某个类上</strong>，如：MultipartProperties</li><li><strong>配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</strong></li></ul></li><li><p>按需加载所有自动配置项：</p><ul><li>非常多的starter</li><li><strong>引入了哪些场景这个场景的自动配置才会开启</strong></li><li>SpringBoot所有的<strong>自动配置功能都在 spring-boot-autoconfigure 包里面</strong></li></ul></li><li><p>还有很多自动配置方面的特性，这里就不继续往下写了。</p></li></ul><h2 id="容器功能"><a href="#容器功能" class="headerlink" title="容器功能"></a>容器功能</h2><h3 id="组件添加"><a href="#组件添加" class="headerlink" title="组件添加"></a>组件添加</h3><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><ul><li><p><strong>被这个注解修饰的类会被springboot识别为配置类，在其中做操作相当于在配置文件中做配置</strong>。</p></li><li><p>这个注解可以在<strong>Full模式和Lite模式</strong>中选其一使用。</p></li><li><p>配置类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断；配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#############################Configuration使用示例######################################################</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、配置类里面使用<span class="doctag">@Bean</span>标注在方法上给容器注册组件，默认也是单实例的</span></span><br><span class="line"><span class="comment"> * 2、配置类本身也是组件</span></span><br><span class="line"><span class="comment"> * 3、proxyBeanMethods：代理bean的方法</span></span><br><span class="line"><span class="comment"> *      Full(proxyBeanMethods = true)、【保证每个<span class="doctag">@Bean</span>方法被调用多少次返回的组件都是单实例的】</span></span><br><span class="line"><span class="comment"> *      Lite(proxyBeanMethods = false)【每个<span class="doctag">@Bean</span>方法被调用多少次返回的组件都是新创建的】</span></span><br><span class="line"><span class="comment"> *      组件依赖必须使用Full模式默认。其他默认是否Lite模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件，这是使用的Lite模式，不使用代理检查Bean是否已经存在，直接用到的时候new。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//user组件依赖了Pet组件</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">tomcatPet</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pet</span>(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">################################<span class="meta">@Configuration</span>测试代码如下########################################</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.boot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">        String[] names = run.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、从容器中获取组件</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">tom01</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">tom02</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;组件：&quot;</span>+(tom01 == tom02));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892</span></span><br><span class="line">        <span class="type">MyConfig</span> <span class="variable">bean</span> <span class="operator">=</span> run.getBean(MyConfig.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。</span></span><br><span class="line">        <span class="comment">//保持组件单实例</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> bean.user01();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> bean.user01();</span><br><span class="line">        System.out.println(user == user1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user01</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;user01&quot;</span>, User.class);</span><br><span class="line">        <span class="type">Pet</span> <span class="variable">tom</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;用户的宠物：&quot;</span>+(user01.getPet() == tom));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Bean、-Component、-Controller、-Service、-Repository"><a href="#Bean、-Component、-Controller、-Service、-Repository" class="headerlink" title="@Bean、@Component、@Controller、@Service、@Repository"></a>@Bean、@Component、@Controller、@Service、@Repository</h4><ul><li>这些都是<strong>用来向spring容器中注册组件的注解</strong>，他们的作用基本相同，但是为了体现我们项目的层次规范，我们用不同的注解来注册不同层的组件。</li><li><strong>@Bean</strong>：@Bean 需要在配置类中使用，即类上需要加上@Component或者@Configuration注解， 通常加上@Configuration。这个注解用来修饰方法，表示一个方法实例化、配置或者初始化一个Spring ioc容器管理的新对象。</li><li><strong>@Component</strong>：用来修饰类，表示被注解的类会被ComponentScan扫描，然后被注册到spring ioc容器中。</li><li><strong>@Controller</strong>：和@Component效果相同，只不过我们通常用它来修饰控制器类或者表现层组件。</li><li><strong>@Service</strong>：和@Component效果相同，只不过我们通常用它来修饰业务层的组件。</li><li><strong>@Repository</strong>：和@Component效果相同，只不过我们通常用它来修饰持久层的组件。</li></ul><h4 id="ComponentScan、-Import"><a href="#ComponentScan、-Import" class="headerlink" title="@ComponentScan、@Import"></a>@ComponentScan、@Import</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;Spring-与-SpringBoot&quot;&gt;&lt;a href=&quot;#Spring-与-SpringBoot&quot; class=&quot;headerlink&quot; title=&quot;Spring </summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://konjacor.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://konjacor.github.io/2022/09/11/Spring/"/>
    <id>https://konjacor.github.io/2022/09/11/Spring/</id>
    <published>2022-09-11T09:22:29.000Z</published>
    <updated>2022-12-20T12:11:43.200Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="Spring5框架概述"><a href="#Spring5框架概述" class="headerlink" title="Spring5框架概述"></a>Spring5框架概述</h1><ul><li>Spring是轻量级的开源的JavaEE框架</li><li>Spring可以解决企业应用开发的复杂性</li><li>Spring有两个核心部分：<strong>IOC 和 AOP</strong><ul><li>IOC：即<strong>控制反转</strong>，把创建对象的过程交给Spring进行管理</li><li>AOP：即<strong>面向切面编程</strong>，能够不修改源代码而对其功能进行增强</li></ul></li><li>Spring的特点：<ol><li>方便解耦，简化开发</li><li>支持aop编程</li><li>方便程序测试</li><li>方便和其他框架进行整合</li><li>方便进行事务操作</li><li>降低API的开发难度</li></ol></li><li>以下的内容选取Spring的版本是5.x</li></ul><h1 id="Spring5入门案例"><a href="#Spring5入门案例" class="headerlink" title="Spring5入门案例"></a>Spring5入门案例</h1><h2 id="下载Spring5"><a href="#下载Spring5" class="headerlink" title="下载Spring5"></a>下载Spring5</h2><ol><li><p>使用Spring的最新稳定版（Lastest Stable）：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126191152434.png" alt="image-20221126191152434"></p></li><li><p>下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/">https://repo.spring.io/release/org/springframework/spring/</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126191224742.png" alt="image-20221126191224742"></p></li></ol><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><ul><li><p>打开idea工具，创建普通java工程：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126191350331.png" alt="image-20221126191350331"></p></li></ul><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><ul><li><p>导入Spring5相关jar包，主要是导入几个核心的包，以及关于日志的一个包：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126191551005.png" alt="image-20221126191551005"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126191610031.png" alt="image-20221126191610031"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126191620655.png" alt="image-20221126191620655"></p></li></ul><h2 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><ul><li><p>创建一个普通类，在这个类中创建普通方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;add......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建Spring配置文件"><a href="#创建Spring配置文件" class="headerlink" title="创建Spring配置文件"></a>创建Spring配置文件</h2><ul><li><p>创建Spring配置文件，<strong>在配置文件配置刚才创建的对象，配置之后这个类创建对象的过程就被委托给Spring了，Spring会在需要的时候创建对象</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126191949719.png" alt="image-20221126191949719"></p></li><li><p>Spring配置文件使用xml格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置 User 对象创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li><p>编写测试代码进行测试，注意这里获取刚才创建类的对象是先读取了刚才写的配置文件生成ApplicationContext对象，然后再利用ApplicationContext对象获取对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//1 加载 spring 配置文件</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line"><span class="comment">//2 获取配置创建的对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">System.out.println(user);</span><br><span class="line">user.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126192309190.png" alt="image-20221126192309190"></p></li></ul><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="概念和原理"><a href="#概念和原理" class="headerlink" title="概念和原理"></a>概念和原理</h2><h3 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h3><ol><li><strong>控制反转</strong>，<strong>把对象创建和对象之间的调用过程，交给Spring进行管理</strong>。</li><li>使用IOC的目的：为了<strong>降低客户端代码和客户端使用到的包中类的对象的耦合度</strong>。</li><li>上面的案例的实现就是利用到了IOC。</li></ol><h2 id="IOC容器相关接口"><a href="#IOC容器相关接口" class="headerlink" title="IOC容器相关接口"></a>IOC容器相关接口</h2><ol><li><p>IOC思想基于IOC容器实现，<strong>IOC容器底层就是对象工厂</strong>。</p></li><li><p>Spring提供IOC容器实现的两种方式（两个接口）：</p><ul><li><strong>BeanFactory</strong>：IOC容器的基本实现，是<strong>Spring内部的使用接口，不提供给开发人员进行使用</strong>。使用这个接口，<strong>加载配置文件的时候不会创建对象，在获取对象的时候才去创建对象</strong>。</li><li><strong>ApplicationContext</strong>：<strong>BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用</strong>。使用这个接口，<strong>加载配置文件的时候就会把在配置文件中注册的对象进行创建</strong>。</li></ul></li><li><p>ApplicationContext接口有实现类：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126193548520.png" alt="image-20221126193548520"></p></li></ol><h2 id="Bean管理的概念"><a href="#Bean管理的概念" class="headerlink" title="Bean管理的概念"></a>Bean管理的概念</h2><h3 id="什么是Bean管理"><a href="#什么是Bean管理" class="headerlink" title="什么是Bean管理"></a>什么是Bean管理</h3><ul><li>Spring管理Bean指的是两个操作：<ol><li>Spring创建Bean对象</li><li>Spring向Bean对象中注入属性</li></ol></li><li>Bean管理操作有两种方式：<ol><li>基于xml配置文件方式实现</li><li>基于注解方式实现</li></ol></li></ul><h2 id="基于xml的方式实现Bean管理"><a href="#基于xml的方式实现Bean管理" class="headerlink" title="基于xml的方式实现Bean管理"></a>基于xml的方式实现Bean管理</h2><h2 id="基于注解的方式实现Bean管理"><a href="#基于注解的方式实现Bean管理" class="headerlink" title="基于注解的方式实现Bean管理"></a>基于注解的方式实现Bean管理</h2><h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><ol><li>注解<strong>是代码的特殊标记</strong>，<strong>格式为：@注解名称(属性名称&#x3D;属性值，属性名称&#x3D;属性值……)</strong></li><li><strong>注解可以作用在类、方法、属性上面</strong></li><li>使用注解实现Bean管理的目的：简化xml配置（不得不说，配置xml太繁琐了）</li></ol><h3 id="Spring针对Bean管理中创建对象的操作提供的注解"><a href="#Spring针对Bean管理中创建对象的操作提供的注解" class="headerlink" title="Spring针对Bean管理中创建对象的操作提供的注解"></a>Spring针对Bean管理中创建对象的操作提供的注解</h3><ol><li><strong>@Component</strong></li><li><strong>@Service</strong></li><li><strong>@Controller</strong></li><li><strong>@Repository</strong></li><li>上面的四个注解功能是一样的，都是<strong>写在类上面，能够被ComponentScan扫描到，被扫描到之后将会把被注解的类注册到IOC容器中</strong>，但是<strong>为了保证项目的层次结构清晰明了，我们对不同层的Bean进行注册的时候，应该使用该层对应的注解</strong>，比如业务层注册Bean就应该使用@Service，控制层注册Bean就应该使用@Controller，持久层注册Bean就应该使用@Repository。</li></ol><h3 id="Spring针对Bean管理中注入属性的操作提供的注解"><a href="#Spring针对Bean管理中注入属性的操作提供的注解" class="headerlink" title="Spring针对Bean管理中注入属性的操作提供的注解"></a>Spring针对Bean管理中注入属性的操作提供的注解</h3><ol><li><p><strong>@Autowired</strong>：根据类型进行注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">//定义 dao 类型属性</span></span><br><span class="line"><span class="comment">//不需要添加 set 方法</span></span><br><span class="line"><span class="comment">//添加注入属性注解</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line">userDao.add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Qualifier</strong>：根据名称进行注入，需要一个名为value的参数，可以和@Autowired搭配进行使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 dao 类型属性</span></span><br><span class="line"><span class="comment">//不需要添加 set 方法</span></span><br><span class="line"><span class="comment">//添加注入属性注解</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="comment">//根据类型进行注入</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;userDaoImpl1&quot;)</span></span><br><span class="line"><span class="comment">//根据名称进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Resource</strong>：带名称参数name使用就是根据名称进行注入，不带名称参数name使用就是根据类型进行注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Resource //根据类型进行注入</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;userDaoImpl1&quot;)</span></span><br><span class="line"><span class="comment">//根据名称进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Value</strong>：注入普通类型的属性，需要一个名为value的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;abc&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li></ol><h3 id="基于注解的方式实现对象的创建"><a href="#基于注解的方式实现对象的创建" class="headerlink" title="基于注解的方式实现对象的创建"></a>基于注解的方式实现对象的创建</h3><ol><li><p>引入依赖：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126195059119.png" alt="image-20221126195059119"></p></li><li><p>开启组件扫描，<strong>组件扫描会扫描指定的包及其子包，扫描到被标识为Bean的类，会将其加入注册到IOC容器中</strong>（这里我有个问题，扫描到的时候会直接创建对象吗？还是说等使用的时候再创建相应的对象？），这里是使用xml配置的方式开启组件扫描，这一步也可以用注解进行实现。</p></li><li><p>创建类，在类上面添加注解将其标识为Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在注解里面 value 属性值可以省略不写，</span></span><br><span class="line"><span class="comment">//默认值是类名称，首字母小写</span></span><br><span class="line"><span class="comment">//UserService -- userService</span></span><br><span class="line"><span class="meta">@Component(value = &quot;userService&quot;)</span></span><br><span class="line"><span class="comment">//&lt;bean id=&quot;userService&quot; class=&quot;..&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>详细配置组件扫描的参数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--示例 1</span></span><br><span class="line"><span class="comment">use-default-filters=&quot;false&quot; 表示现在不使用默认 filter，自己配置 filter</span></span><br><span class="line"><span class="comment">context:include-filter ，设置扫描哪些内容</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--示例 2</span></span><br><span class="line"><span class="comment">下面配置扫描包所有内容</span></span><br><span class="line"><span class="comment">context:exclude-filter： 设置哪些内容不进行扫描</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>基于注解方式实现属性注入：第一步 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解；第二步 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">//定义 dao 类型属性</span></span><br><span class="line"><span class="comment">//不需要添加 set 方法</span></span><br><span class="line"><span class="comment">//添加注入属性注解</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line">userDao.add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完全注解开发：上面的实现中还设计到xml配置文件的编写，这样实际上是比较不方便的，但是<strong>xml配置文件也可以用注解来实现</strong>，可以使用**@Configuration<strong>注解，</strong>被这个注解修饰的类会作为配置类，替代 xml 配置文件，在这个类上做的操作就相当于在之前的xml文件中做的配置**，这样整个实现就是完全基于注解的了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">//被这个注解修饰的类会作为配置类，替代 xml 配置文件，在这个类上做的操作就相当于在之前的xml文件中做的配置</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)</span><span class="comment">//配置组件扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试类进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testService2</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//加载配置类</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>,</span><br><span class="line">UserService.class);</span><br><span class="line">System.out.println(userService);</span><br><span class="line">    userService.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><ul><li><p>AOP即是<strong>面向切面（方面）编程</strong>，利用AOP可以<strong>对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率</strong>。</p></li><li><p>对于面向切面编程比较通俗的描述是：<strong>不通过修改源代码的方式，在主干功能里面添加新功能</strong>。</p></li><li><p>使用登录例子来说明AOP：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221127195023595.png" alt="image-20221127195023595"></p></li></ul><h2 id="AOP的底层原理"><a href="#AOP的底层原理" class="headerlink" title="AOP的底层原理"></a>AOP的底层原理</h2><ul><li>AOP的底层使用的是动态代理，有两种动态代理，分别是<strong>JDK动态代理和CGLIB动态代理</strong>。</li></ul><h3 id="被增强的类实现了接口的情况使用JDK动态代理"><a href="#被增强的类实现了接口的情况使用JDK动态代理" class="headerlink" title="被增强的类实现了接口的情况使用JDK动态代理"></a>被增强的类实现了接口的情况使用JDK动态代理</h3><ul><li><p>创建接口实现类代理对象，增强类的方法：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221127195703994.png" alt="image-20221127195703994"></p></li></ul><h3 id="被增强的类没实现接口的情况使用CGLIB动态代理"><a href="#被增强的类没实现接口的情况使用CGLIB动态代理" class="headerlink" title="被增强的类没实现接口的情况使用CGLIB动态代理"></a>被增强的类没实现接口的情况使用CGLIB动态代理</h3><ul><li><p>创建子类的代理对象增强类的方法：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221127195742084.png" alt="image-20221127195742084"></p></li></ul><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><h3 id="使用JDK动态代理，使用Proxy类里面的方法创建代理对象"><a href="#使用JDK动态代理，使用Proxy类里面的方法创建代理对象" class="headerlink" title="使用JDK动态代理，使用Proxy类里面的方法创建代理对象"></a>使用JDK动态代理，使用Proxy类里面的方法创建代理对象</h3><ul><li><p>用到的类在这儿：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221127201557295.png" alt="image-20221127201557295"></p></li><li><p>调用newProxyInstance方法来创建代理对象：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221127201704106.png" alt="image-20221127201704106"></p><p>这个方法有三个参数：</p><p>第一个参数是类加载器</p><p>第二个参数是增强方法所在的类实现的接口，支持多个接口</p><p>第三个参数是InvocationHandler这个接口的实现类，创建代理对象，写增强的部分</p></li></ul><h3 id="编写JDK动态代理的代码"><a href="#编写JDK动态代理的代码" class="headerlink" title="编写JDK动态代理的代码"></a>编写JDK动态代理的代码</h3><ol><li><p>创建接口，定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建接口实现类，实现方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(String id)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Proxy类创建接口代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建接口实现类代理对象</span></span><br><span class="line">Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line"><span class="comment">//Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() &#123;</span></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span></span><br><span class="line"><span class="comment">//return null;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;);</span></span><br><span class="line"><span class="type">UserDaoImpl</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line"><span class="type">UserDao</span> <span class="variable">dao</span> <span class="operator">=</span> (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces,<span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao));</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> dao.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建代理对象代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"><span class="comment">//1 把创建的是谁的代理对象，把谁传递过来</span></span><br><span class="line"><span class="comment">//有参数构造传递</span></span><br><span class="line"><span class="keyword">private</span> Object obj;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.obj = obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增强的逻辑</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">//方法之前</span></span><br><span class="line">System.out.println(<span class="string">&quot;方法之前执行....&quot;</span>+method.getName()+<span class="string">&quot; :传递的参数...&quot;</span>+ Arrays.toString(args));</span><br><span class="line"><span class="comment">//被增强的方法执行</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line"><span class="comment">//方法之后</span></span><br><span class="line">System.out.println(<span class="string">&quot;方法之后执行....&quot;</span>+obj);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="AOP常用术语"><a href="#AOP常用术语" class="headerlink" title="AOP常用术语"></a>AOP常用术语</h2><h3 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a>连接点</h3><ul><li><strong>类里面那些可以被增强的方法称为连接点</strong>。</li></ul><h3 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h3><ul><li><strong>实际被真正增强的方法称为切入点</strong>。</li></ul><h3 id="增强（通知）"><a href="#增强（通知）" class="headerlink" title="增强（通知）"></a>增强（通知）</h3><ul><li><strong>实际增强的逻辑部分称为增强（通知）</strong>。</li><li>增强（通知）有多种类型：<strong>前置增强（通知）、后置增强（通知）、环绕增强（通知）、异常增强（通知）、最终增强（通知）</strong>。</li></ul><h3 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h3><ul><li>是一种动作，就是<strong>把增强（通知）应用到切入点的过程</strong>。</li></ul><h2 id="AOP操作的准备工作"><a href="#AOP操作的准备工作" class="headerlink" title="AOP操作的准备工作"></a>AOP操作的准备工作</h2><ul><li><p><strong>Spring框架一般都是基于AspectJ实现AOP操作，但是AspectJ不是Spring的组成部分</strong>，它是一个独立的AOP框架，一般我们把AspectJ和Spring框架一起使用，进行AOP操作。</p></li><li><p>基于AspectJ实现AOP操作有两种方式：<strong>第一种是基于xml配置文件实现，第二种是基于注解方式实现，第二种方式是我们普遍采用的方式</strong>。</p></li><li><p>在项目工程里面引入AOP相关依赖：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221128110244039.png" alt="image-20221128110244039"></p></li><li><p><strong>切入点表达式</strong>：</p><p>切入点表达式的作用：<strong>表示对哪个类里面的哪个方法进行增强</strong>。</p><p>语法结构：<strong>execution ( [权限修饰符] [返回类型] [类全路径] [方法名称] ( [参数列表] ) )</strong></p><p>举例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强 </p><p>execution(* com.atguigu.dao.BookDao.add(..))<br>举例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强<br>execution(* com.atguigu.dao.BookDao.* (..))</p><p>举例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强<br>execution(* com.atguigu.dao.*.* (..))</p></li></ul><h2 id="基于AspectJ相关注解实现AOP操作"><a href="#基于AspectJ相关注解实现AOP操作" class="headerlink" title="基于AspectJ相关注解实现AOP操作"></a>基于AspectJ相关注解实现AOP操作</h2><ol><li><p>创建类，在类里面定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;add.......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建增强类（编写增强逻辑）</p><ul><li><p>在增强类里面创建方法，<strong>可以让不同方法代表不同的增强（通知）类型</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;<span class="comment">//前置通知</span></span><br><span class="line">System.out.println(<span class="string">&quot;before......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>进行增强（通知）的配置：</p><ul><li><p>在spring的配置文件中<strong>开启注解扫描</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.spring5.aopanno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用注解注册User和UserProxy对象</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221128111224087.png" alt="image-20221128111224087"></p></li><li><p><strong>在增强类上面添加注解@Aspect表示生成代理对象</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在spring配置文件中<strong>开启Aspect生成代理对象的功能</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启 Aspect 生成代理对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置不同类型的增强（通知）：</p><ul><li><p>在增强类的里面，<strong>在作为增强（通知）方法上面添加增强（通知）类型注解，使用切入点表达式配置</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line"><span class="comment">//前置通知</span></span><br><span class="line"><span class="comment">//@Before 注解表示作为前置通知</span></span><br><span class="line"><span class="meta">@Before(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;before.........&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置通知（返回通知）</span></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(*com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;afterReturning.........&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终通知</span></span><br><span class="line"><span class="meta">@After(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;after.........&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异常通知</span></span><br><span class="line"><span class="meta">@AfterThrowing(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;afterThrowing.........&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line"><span class="meta">@Around(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;环绕之前.........&quot;</span>);</span><br><span class="line"><span class="comment">//被增强的方法执行</span></span><br><span class="line">proceedingJoinPoint.proceed();</span><br><span class="line">System.out.println(<span class="string">&quot;环绕之后.........&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>相同的切入点抽取</strong>：</p><ul><li><p>可以<strong>在类上使用@Pointcut(value &#x3D; 切入点表达式)来将被修饰的类作为切入点表达式的别名，以后可以直接使用”类名()”的形式来代指对应的切入点表达式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相同切入点抽取</span></span><br><span class="line"><span class="meta">@Pointcut(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointdemo</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置通知</span></span><br><span class="line"><span class="comment">//@Before 注解表示作为前置通知</span></span><br><span class="line"><span class="meta">@Before(value = &quot;pointdemo()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;before.........&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>有多个增强类对同一个方法进行增强，可以<strong>设置增强类的优先级</strong>：</p><ul><li><p><strong>在增强类上面添加注解@Order(数字类型值)，数字类型值越小优先级越高</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span> <span class="comment">//提问：这个注解可以应用在增强方法上吗？如果不能，那么对于被这个增强类增强的多个类对这个类分别有不同的优先级要求该怎么办？还是说不可能出现这种情况？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>完全使用注解开发：</p><ul><li><p>创建配置类，不需要创建xml配置文件，<strong>使用@EnableAspectJAutoProxy(proxyTargetClass &#x3D; true)来开启 Aspect 生成代理对象的功能</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigAop</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="基于配置文件中AspectJ的相关配置实现AOP操作"><a href="#基于配置文件中AspectJ的相关配置实现AOP操作" class="headerlink" title="基于配置文件中AspectJ的相关配置实现AOP操作"></a>基于配置文件中AspectJ的相关配置实现AOP操作</h2><h1 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h1><h2 id="概念和准备"><a href="#概念和准备" class="headerlink" title="概念和准备"></a>概念和准备</h2><h3 id="什么是JDBCTemplate"><a href="#什么是JDBCTemplate" class="headerlink" title="什么是JDBCTemplate"></a>什么是JDBCTemplate</h3><ul><li>Spring框架对JDBC进行了封装，使用JDBCTemplate方便对数据库进行操作。</li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><p>引入相关jar包：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221129103952874.png" alt="image-20221129103952874"></p></li><li><p>在spring配置文件中配置数据库连接池：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///user_db&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置JDBCTemplate对象，注入DataSource：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JdbcTemplate 对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注入 dataSource--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建service类，创建dao接口实现类，在dao类中注入JDBCTemplate对象：</p><p>配置文件中开启组件扫描：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Service类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"><span class="comment">//注入 dao</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dao接口实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"><span class="comment">//注入 JdbcTemplate</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="JDBCTemplate操作数据库"><a href="#JDBCTemplate操作数据库" class="headerlink" title="JDBCTemplate操作数据库"></a>JDBCTemplate操作数据库</h2><h3 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h3><ol><li><p>创建对应数据库表的实体类：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221129104705354.png" alt="image-20221129104705354"></p></li><li><p>编写service和dao：</p><ul><li><p>调用JDBCTemplate对象里面的update方法实现添加操作，在dao接口的实现类中对数据库进行添加操作：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221129105140096.png" alt="image-20221129105140096"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"><span class="comment">//注入 JdbcTemplate</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"><span class="comment">//添加的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Book book)</span> &#123;</span><br><span class="line"><span class="comment">//1 创建 sql 语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_book values(?,?,?)&quot;</span>;</span><br><span class="line"><span class="comment">//2 调用方法实现</span></span><br><span class="line">Object[] args = &#123;book.getUserId(), book.getUsername(), book.getUstatus()&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql,args);</span><br><span class="line">System.out.println(update);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJdbcTemplate</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line"><span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;bookService&quot;</span>,BookService.class);</span><br><span class="line"><span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">book.setUserId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">book.setUsername(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">book.setUstatus(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">bookService.addBook(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221129104920764.png" alt="image-20221129104920764"></p></li></ol><h3 id="修改和删除操作"><a href="#修改和删除操作" class="headerlink" title="修改和删除操作"></a>修改和删除操作</h3><ul><li><p>修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_book set username=?,ustatus=? where user_id=?&quot;</span>;</span><br><span class="line">Object[] args = &#123;book.getUsername(), book.getUstatus(),book.getUserId()&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, args);</span><br><span class="line">System.out.println(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String id)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from t_book where user_id=?&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, id);</span><br><span class="line">System.out.println(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查询返回某个值"><a href="#查询返回某个值" class="headerlink" title="查询返回某个值"></a>查询返回某个值</h3><ul><li><p>场景：查询表里面有多少条记录，返回的是某个值</p></li><li><p>使用JDBCTemplate实现查询返回某个值的代码：<br><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221129105851998.png" alt="image-20221129105851998"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询表记录数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">selectCount</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from t_book&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查询返回对象"><a href="#查询返回对象" class="headerlink" title="查询返回对象"></a>查询返回对象</h3><ul><li><p>场景：查询图书详情</p></li><li><p>使用JDBCTemplate实现查询返回对象：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221129110122369.png" alt="image-20221129110122369"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询返回对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">findBookInfo</span><span class="params">(String id)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_book where user_id=?&quot;</span>;</span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line"><span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Book&gt;(Book.class), id);</span><br><span class="line"><span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查询返回集合"><a href="#查询返回集合" class="headerlink" title="查询返回集合"></a>查询返回集合</h3><ul><li><p>场景：查询图书列表分页</p></li><li><p>使用JDBCTemplate实现查询返回集合：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221129110640049.png" alt="image-20221129110640049"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询返回集合</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">findAllBook</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_book&quot;</span>;</span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">List&lt;Book&gt; bookList = jdbcTemplate.query(sql, <span class="keyword">new</span></span><br><span class="line"><span class="title class_">BeanPropertyRowMapper</span>&lt;Book&gt;(Book.class));</span><br><span class="line"><span class="keyword">return</span> bookList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><ul><li><p>批量操作：操作表里面多条记录</p></li><li><p>JDBCTemplate实现批量添加操作：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221129110903601.png" alt="image-20221129110903601"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量添加</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchAddBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_book values(?,?,?)&quot;</span>;</span><br><span class="line"><span class="type">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量添加测试</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Object[] o1 = &#123;<span class="string">&quot;3&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line">Object[] o2 = &#123;<span class="string">&quot;4&quot;</span>,<span class="string">&quot;c++&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line">Object[] o3 = &#123;<span class="string">&quot;5&quot;</span>,<span class="string">&quot;MySQL&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">batchArgs.add(o1);</span><br><span class="line">batchArgs.add(o2);</span><br><span class="line">batchArgs.add(o3);</span><br><span class="line"><span class="comment">//调用批量添加</span></span><br><span class="line">bookService.batchAdd(batchArgs);</span><br></pre></td></tr></table></figure></li><li><p>JDBCTemplate实现批量修改操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量修改</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchUpdateBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_book set username=?,ustatus=? where user_id=?&quot;</span>;</span><br><span class="line"><span class="type">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量修改</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Object[] o1 = &#123;<span class="string">&quot;java0909&quot;</span>,<span class="string">&quot;a3&quot;</span>,<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">Object[] o2 = &#123;<span class="string">&quot;c++1010&quot;</span>,<span class="string">&quot;b4&quot;</span>,<span class="string">&quot;4&quot;</span>&#125;;</span><br><span class="line">Object[] o3 = &#123;<span class="string">&quot;MySQL1111&quot;</span>,<span class="string">&quot;c5&quot;</span>,<span class="string">&quot;5&quot;</span>&#125;;</span><br><span class="line">batchArgs.add(o1);</span><br><span class="line">batchArgs.add(o2);</span><br><span class="line">batchArgs.add(o3);</span><br><span class="line"><span class="comment">//调用方法实现批量修改</span></span><br><span class="line">bookService.batchUpdate(batchArgs);</span><br></pre></td></tr></table></figure></li><li><p>JDBCTemplate实现批量删除操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量删除</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchDeleteBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from t_book where user_id=?&quot;</span>;</span><br><span class="line"><span class="type">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量删除</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Object[] o1 = &#123;<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">Object[] o2 = &#123;<span class="string">&quot;4&quot;</span>&#125;;</span><br><span class="line">batchArgs.add(o1);</span><br><span class="line">batchArgs.add(o2);</span><br><span class="line"><span class="comment">//调用方法实现批量删除</span></span><br><span class="line">bookService.batchDelete(batchArgs);</span><br></pre></td></tr></table></figure></li></ul><h1 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h1><h2 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><ul><li>事务<strong>是数据库操作最基本的单元</strong>，事务<strong>是逻辑上的一组操作</strong>，其<strong>具有原子性</strong>，<strong>要么都成功，如果其中有一个操作失败那么所有的操作都会失败</strong>。</li><li>典型场景：银行转账，a转账100给b，a会少100而b会多100，转账这个操作实际上就是一个事务，a少100和b多100要么都成功，如果a没有少100或者b没有多100，事务都会失败，然后回滚，如果事务没有原子性，很明显像上面这种场景下就没有办法保证转账的安全性了。</li></ul><h3 id="事务的四个特性（ACID）"><a href="#事务的四个特性（ACID）" class="headerlink" title="事务的四个特性（ACID）"></a>事务的四个特性（ACID）</h3><ul><li><strong>原子性（Atomicity）</strong>：<strong>一系列操作，要么都成功，要么都失败</strong>。</li><li><strong>一致性（Consistency）</strong>：一致性是指事务<strong>必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态</strong>。以上面的转账操作为例就是，这100元不能凭空消失，必须在a和b两者之一的手中。</li><li><strong>隔离性（Isolation）</strong>：<strong>多个并发的事务之间应该相互隔离，不能相互干扰</strong>。</li><li><strong>持久性（Durability）</strong>：<strong>一个事务一旦提交，对于数据库中的数据的改变是永久性的</strong>，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li></ul><h2 id="搭建事务的操作环境"><a href="#搭建事务的操作环境" class="headerlink" title="搭建事务的操作环境"></a>搭建事务的操作环境</h2><ul><li><p>以上面的转账场景为例子，需要实现的结构大致如下图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221130170842331.png" alt="image-20221130170842331"></p></li></ul><ol><li><p>创建数据库表，添加记录：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221130170943485.png" alt="image-20221130170943485"></p></li><li><p>创建service，搭建dao，完成对象创建和注入关系：</p><ul><li><p><strong>service注入dao，在dao注入JDBCTemplate，在JDBCTemplate注入DataSource</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">//注入 dao</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在dao创建两个方法：多钱和少钱的方法（分成两个方法主要是为了<strong>遵守单一职责原则</strong>），在service创建转账的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//lucy 转账 100 给 mary</span></span><br><span class="line"><span class="comment">//少钱</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduceMoney</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_account set money=money-? where username=?&quot;</span>;</span><br><span class="line">jdbcTemplate.update(sql,<span class="number">100</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//多钱</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMoney</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_account set money=money+? where username=?&quot;</span>;</span><br><span class="line">jdbcTemplate.update(sql,<span class="number">100</span>,<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">//注入 dao</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//转账的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accountMoney</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//lucy 少 100</span></span><br><span class="line">userDao.reduceMoney();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//mary 多 100</span></span><br><span class="line">userDao.addMoney();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面代码，如果正常执行没有问题的，但是如果代码执行过程中出现异常的话：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221130231843794.png" alt="image-20221130231843794"></p><p>如果中间没有出现异常的话，转账的流程是正确的，但是<strong>由于中间出现了一个异常，所以后面加钱的操作就无法执行了，这样就不满足一致性了，因为100块钱凭空消失了，并不是从一个一致性的状态转移道另外一个一致性状态了，这样的情况肯定是我们不想看到的</strong>，那么上面的问题该如何解决呢？可以<strong>使用事务进行解决</strong>，因为<strong>事务天生自带四个特性，中间出现异常之后由于事务的原子性，整个操作会回滚，虽然转账也没有成功，但是保证了一致性，100块钱没有凭空消失，这样的结果是我们可以接受的</strong>。</p></li><li><p>对上面的操作进行事务操作的理论流程：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221130232519954.png" alt="image-20221130232519954"></p></li></ol><h2 id="Spring事务管理介绍"><a href="#Spring事务管理介绍" class="headerlink" title="Spring事务管理介绍"></a>Spring事务管理介绍</h2><ul><li><p><strong>事务应该添加到JavaEE三层结构里面的Service层（业务逻辑层）中</strong></p></li><li><p>利用Spring进行事务管理操作有两种方式：<strong>编程式事务管理和声明式事务管理</strong>，后者是我们普遍使用的。</p></li><li><p>声明式事务管理有两种实现方式：可以<strong>基于注解方式实现（这也是普遍使用的方式）</strong>，也可以<strong>基于xml配置文件方式实现</strong>。</p></li><li><p>利用Spring进行声明式事务管理，<strong>底层使用到了AOP的原理</strong>。</p></li><li><p>Spring事务管理的API：</p><ul><li><p><strong>Spring提供了一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221130233116323.png" alt="image-20221130233116323"></p></li></ul></li></ul><h2 id="注解声明式事务管理（基于注解实现事务操作）"><a href="#注解声明式事务管理（基于注解实现事务操作）" class="headerlink" title="注解声明式事务管理（基于注解实现事务操作）"></a>注解声明式事务管理（基于注解实现事务操作）</h2><ol><li><p>在Spring配置文件中<strong>配置事务管理器</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在Spring配置文件中<strong>开启事务注解</strong>：</p><ul><li><p>在Spring配置文件<strong>引入名称空间tx</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>开启事务注解</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启事务注解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-</span></span></span><br><span class="line"><span class="tag"><span class="attr">manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>在service类上面（或者service类里面的方法上面）添加事务注解：</p><ul><li><p><strong>@Transactional，这个注解可以添加到类上面，也可以添加方法上面</strong></p></li><li><p>如果把这个注解添加类上面，这个类里面所有的方法都添加事务</p></li><li><p>如果把这个注解添加方法上面，为这个方法添加事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="声明式事务管理参数配置"><a href="#声明式事务管理参数配置" class="headerlink" title="声明式事务管理参数配置"></a>声明式事务管理参数配置</h2><ul><li><p>在service类上面添加注解**@Transactional**，在这个注解里面可以配置事务相关参数：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221201103415495.png" alt="image-20221201103415495"></p></li></ul><h3 id="propagation参数设置事务传播行为"><a href="#propagation参数设置事务传播行为" class="headerlink" title="propagation参数设置事务传播行为"></a>propagation参数设置事务传播行为</h3><ul><li><p><strong>有多个事务的方法直接进行调用，这个过程中事务是如何进行管理的？事务的传播行为就是来指定这个问题的解决方案的</strong>，这个问题有多种解决方案，通过设置这个参数来使用最符合场景的解决方案。</p></li><li><p><strong>事务方法：含有对数据库表数据进行变化的操作的方法</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221201104343196.png" alt="image-20221201104343196"></p></li><li><p><strong>Spring框架事务传播行为有七种</strong>，可以结合它们的特性和具体场景来选择使用哪种：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221201104621016.png" alt="image-20221201104621016"></p></li><li><p>参数的设置方式如下，实参是相应常量类中的常量：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221201105014480.png" alt="image-20221201105014480"></p></li></ul><h3 id="isolation参数设置事务隔离级别"><a href="#isolation参数设置事务隔离级别" class="headerlink" title="isolation参数设置事务隔离级别"></a>isolation参数设置事务隔离级别</h3><ul><li><p>事务有一个特性称为隔离性，这个隔离性也就是让多个事务操作之间不会互相产生影响，在实际应用中，如果不考虑事务的隔离性的话就会产生很多的问题。</p></li><li><p>其中有三种问题是事务的隔离级别不够造成的，它们分别是：<strong>脏读、不可重复读、虚（幻）读</strong></p></li><li><p><strong>脏读</strong>：即<strong>一个未提交事务读取到另一个未提交事务的数据</strong>，在下面的例子中事务A读取到了事务B中的还未进行提交的<strong>脏数据</strong>60000，而之后事务B进行了回滚，数据还是5000，这样就导致事务A读取到的数据是错误的。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221201110004055.png" alt="image-20221201110004055"></p></li><li><p><strong>不可重复读</strong>：即<strong>一个事务范围内两个相同的查询却返回了不同数据，这是由于查询时系统中其他事务修改的提交而引起的</strong>，比如下面这个例子，事务A进行了两次查询，第一次查询到的是5000，但是在第二次查询之前，事务B提交了修改数据的操作，事务A第一次读到的数据就被修改了，此时事务A再读一次，结果就和第一次读的时候的结果不同了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221203113144852.png" alt="image-20221203113144852"></p></li><li><p><strong>虚（幻）读</strong>：即<strong>一个事务进行多次相同条件的查询或修改时出现了原本不存在的数据或者原本存在的数据消失了，就像是产生幻觉一样，这通常是由于在当前事务的多个操作之间有别的事务添加或删除了一条或多条记录造成的</strong>，<strong>其定义和不可重复读有些相似，只不过造成不可重复读的是记录的修改，而造成幻读的是记录的添加和删除</strong>。比如事务A按照某个条件进行了一次查询，在事务A想要第二次查询的时候，事务B提交了一个增加数据的操作，这样事务A第二次查询出来的内容就和第一次查询出来的内容不同了。</p></li><li><p>对于以上三种读问题，我们可以通过设置参数isolation（即事物的隔离级别）来进行解决，但是要注意，<strong>事务的隔离级别越高，事务的读写性能就越低，因为是通过加锁来实现的嘛</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221203114513492.png" alt="image-20221203114513492"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221203114530378.png" alt="image-20221203114530378"></p></li></ul><h3 id="timeout参数设置超时时间"><a href="#timeout参数设置超时时间" class="headerlink" title="timeout参数设置超时时间"></a>timeout参数设置超时时间</h3><ul><li><strong>设置了超时时间之后，事务需要在指定的时间内进行提交，如果在指定的时间内事务没有进行提交，那么事务会进行回滚</strong>。</li><li><strong>这个参数的默认值是-1，也就是永不超时</strong>；设置的时间是<strong>以秒为单位</strong>的。</li></ul><h3 id="readOnly参数设置是否只读"><a href="#readOnly参数设置是否只读" class="headerlink" title="readOnly参数设置是否只读"></a>readOnly参数设置是否只读</h3><ul><li><strong>读就是查询操作</strong>，写就是添加、修改、删除操作</li><li><strong>readOnly的默认值是false，表示可以进行所有crud操作</strong></li><li><strong>将readOnly的值设置为true后，事务就只能进行查询操作</strong></li></ul><h3 id="rollbackFor参数设置哪些异常回滚"><a href="#rollbackFor参数设置哪些异常回滚" class="headerlink" title="rollbackFor参数设置哪些异常回滚"></a>rollbackFor参数设置哪些异常回滚</h3><ul><li>设置<strong>出现哪些异常后进行事务回滚</strong></li></ul><h3 id="noRollbackFor参数设置哪些异常不回滚"><a href="#noRollbackFor参数设置哪些异常不回滚" class="headerlink" title="noRollbackFor参数设置哪些异常不回滚"></a>noRollbackFor参数设置哪些异常不回滚</h3><ul><li>设置<strong>出现哪些异常之后不进行事务回滚</strong></li></ul><h2 id="XML声明式事务管理（基于XML配置文件实现事务操作）"><a href="#XML声明式事务管理（基于XML配置文件实现事务操作）" class="headerlink" title="XML声明式事务管理（基于XML配置文件实现事务操作）"></a>XML声明式事务管理（基于XML配置文件实现事务操作）</h2><h2 id="完全注解声明式事务管理"><a href="#完全注解声明式事务管理" class="headerlink" title="完全注解声明式事务管理"></a>完全注解声明式事务管理</h2><ul><li><p>创建配置类，使用配置类替代xml配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu&quot;)</span><span class="comment">//组件扫描</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span><span class="comment">//开启事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxConfig</span> &#123;</span><br><span class="line"><span class="comment">//创建数据库连接池</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DruidDataSource <span class="title function_">getDruidDataSource</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">dataSource.setUrl(<span class="string">&quot;jdbc:mysql:///user_db&quot;</span>);</span><br><span class="line">dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建 JdbcTemplate 对象</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> JdbcTemplate <span class="title function_">getJdbcTemplate</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line"><span class="comment">//到 ioc 容器中根据类型找到 dataSource</span></span><br><span class="line"><span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line"><span class="comment">//注入 dataSource</span></span><br><span class="line">jdbcTemplate.setDataSource(dataSource);</span><br><span class="line"><span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建事务管理器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">getDataSourceTransactionManager</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line"><span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">transactionManager.setDataSource(dataSource);</span><br><span class="line"><span class="keyword">return</span> transactionManager;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Spring5框架新功能"><a href="#Spring5框架新功能" class="headerlink" title="Spring5框架新功能"></a>Spring5框架新功能</h1><h2 id="代码上的修改"><a href="#代码上的修改" class="headerlink" title="代码上的修改"></a>代码上的修改</h2><ul><li>整个Spring5框架的代码基于Java8，运行时兼容JDK9，许多不建议使用的类和方法在代码库中删除了。</li></ul><h2 id="通用的日志封装"><a href="#通用的日志封装" class="headerlink" title="通用的日志封装"></a>通用的日志封装</h2><ul><li><p>Spring5框架自带了通用的日志封装</p></li><li><p>Spring5已经移除Log4jConfigListener，官方<strong>建议使用Log4j2</strong></p></li><li><p>Spring5框架整合Log4j2：</p><ol><li><p>引入jar包：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221206162148512.png" alt="image-20221206162148512"></p></li><li><p>创建log4j2.xml配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span></span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt;</span></span><br><span class="line"><span class="comment">ALL --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Configuration 后面的 status 用于设置 log4j2 自身内部的信息输出，可以不设置，</span></span><br><span class="line"><span class="comment">当设置成 trace 时，可以看到 log4j2 内部各种详细输出--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--先定义所有的 appender--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--输出日志信息到控制台--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--控制日志输出的格式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--然后定义 logger，只有定义 logger 并引入的 appender，appender 才会生效--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--root：用于指定项目的根日志，如果没有单独指定 Logger，则会使用 root 作为</span></span><br><span class="line"><span class="comment">默认的日志输出--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="核心容器支持-Nullable注解"><a href="#核心容器支持-Nullable注解" class="headerlink" title="核心容器支持@Nullable注解"></a>核心容器支持@Nullable注解</h2><ul><li><p>@Nullable注解<strong>可以使用在方法、属性、参数上面，表示方法返回值、属性值、参数值可以为空</strong>。</p></li><li><p>@Nullable注解用在方法上面，表示方法返回值可以为空：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221206162703285.png" alt="image-20221206162703285"></p></li><li><p>@Nullable注解用在方法参数前面，表示方法参数可以为空：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221206162757312.png" alt="image-20221206162757312"></p></li><li><p>@Nullable注解使用在属性上面，表示属性值可以为空：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221206162843955.png" alt="image-20221206162843955"></p></li></ul><h2 id="核心容器支持函数式风格（GenericApplicationContext）"><a href="#核心容器支持函数式风格（GenericApplicationContext）" class="headerlink" title="核心容器支持函数式风格（GenericApplicationContext）"></a>核心容器支持函数式风格（GenericApplicationContext）</h2><ul><li><p>下面是一个用函数式风格创建对象交给Spring进行管理的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数式风格创建对象，交给 spring 进行管理</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGenericApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//1 创建 GenericApplicationContext 对象</span></span><br><span class="line"><span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"><span class="comment">//2 调用 context 的方法对象注册</span></span><br><span class="line">context.refresh();</span><br><span class="line">context.registerBean(<span class="string">&quot;user1&quot;</span>,User.class,() -&gt; <span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">    <span class="comment">//3 获取在 spring 注册的对象</span></span><br><span class="line"><span class="comment">// User user = (User)context.getBean(&quot;com.atguigu.spring5.test.User&quot;);</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)context.getBean(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="支持整合JUnit5"><a href="#支持整合JUnit5" class="headerlink" title="支持整合JUnit5"></a>支持整合JUnit5</h2><ul><li><p>整合JUnit4：</p><ol><li><p>引入Spring相关针对测试的依赖：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221206164908060.png" alt="image-20221206164908060"></p></li><li><p>创建测试类，使用注解方式完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span><span class="comment">//单元测试框架</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean1.xml&quot;)</span><span class="comment">//加载配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JTest4</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">userService.accountMoney();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>整合JUnit5：</p><ol><li><p>引入JUnit5的jar包：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221206165041897.png" alt="image-20221206165041897"></p></li><li><p>创建测试类，使用注解完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean1.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JTest5</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">userService.accountMoney();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用一个<strong>复合注解@SpringJUnitConfig</strong>来替代上面两个注解完成整合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(locations = &quot;classpath:bean1.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JTest5</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">userService.accountMoney();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="WebFlux"><a href="#WebFlux" class="headerlink" title="WebFlux"></a>WebFlux</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;Spring5框架概述&quot;&gt;&lt;a href=&quot;#Spring5框架概述&quot; class=&quot;headerlink&quot; title=&quot;Spring5框架概述&quot;&gt;&lt;/a&gt;Spring</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://konjacor.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis入门</title>
    <link href="https://konjacor.github.io/2022/09/08/Mybatis%E5%85%A5%E9%97%A8/"/>
    <id>https://konjacor.github.io/2022/09/08/Mybatis%E5%85%A5%E9%97%A8/</id>
    <published>2022-09-08T14:25:24.000Z</published>
    <updated>2022-12-20T12:11:43.198Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><ol><li>获取参数用${}不会自动加单引号，获取参数用#{}会自动加单引号</li></ol><h1 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h1><h2 id="MyBatis历史"><a href="#MyBatis历史" class="headerlink" title="MyBatis历史"></a>MyBatis历史</h2><ul><li><strong>MyBatis最初是Apache的一个开源项目iBatis</strong>, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github。</li><li>iBatis一词来源于“internet”和“abatis”的组合，是一个<strong>基于Java的持久层框架</strong>。 iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）。</li></ul><h2 id="MyBatis特性"><a href="#MyBatis特性" class="headerlink" title="MyBatis特性"></a>MyBatis特性</h2><ol><li>MyBatis 是支持<strong>定制化 SQL</strong>、<strong>存储过程</strong>以及<strong>高级映射</strong>的优秀的持久层框架</li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li><li>MyBatis可以使用<strong>简单的XML或注解</strong>用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录</li><li>MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架</li></ol><h2 id="MyBatis下载"><a href="#MyBatis下载" class="headerlink" title="MyBatis下载"></a>MyBatis下载</h2><ul><li><p>下载地址：<a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220916105207380.png" alt="image-20220916105207380"></p></li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220916105221318.png" alt="image-20220916105221318"></p><h2 id="SpringBoot整合MyBatis"><a href="#SpringBoot整合MyBatis" class="headerlink" title="SpringBoot整合MyBatis"></a>SpringBoot整合MyBatis</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><ul><li><p>Spring Boot 整合 MyBatis 的第一步，就是在项目的 pom.xml 中引入 mybatis-spring-boot-starter 的依赖，示例代码如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入 mybatis-spring-boot-starter 的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="配置MyBatis"><a href="#配置MyBatis" class="headerlink" title="配置MyBatis"></a>配置MyBatis</h3><ul><li><p>在 Spring Boot 的配置文件（application.properties&#x2F;yml）中对 MyBatis 进行配置，例如指定 mapper.xml 的位置、实体类的位置、是否开启驼峰命名法等等，示例代码如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###################################### MyBatis 配置######################################</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment"># 指定 mapper.xml 的位置</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span></span><br><span class="line">  <span class="comment">#扫描实体类的位置,在此处指明扫描实体类的包，在 mapper.xml 中就可以不写实体类的全路径名</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.konjacer.service.bean</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#默认开启xia&#x27;hua，可以不用设置该属性</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span>  </span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：使用 MyBatis 时，必须配置数据源信息，例如数据库 URL、数据库用户型、数据库密码和数据库驱动等。</p></blockquote><h3 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h3><h3 id="创建Mapper接口"><a href="#创建Mapper接口" class="headerlink" title="创建Mapper接口"></a>创建Mapper接口</h3><blockquote><p>当 mapper 接口较多时，我们可以在 Spring Boot 主启动类或者配置类上使用 @MapperScan 注解扫描指定包下的 mapper 接口，而不再需要在每个 mapper 接口上都标注@Mapper 注解。</p></blockquote><h3 id="创建Mapper映射文件"><a href="#创建Mapper映射文件" class="headerlink" title="创建Mapper映射文件"></a>创建Mapper映射文件</h3><ul><li>在配置文件 application.properties&#x2F;yml 通过 mybatis.mapper-locations 指定的位置中创建 UserMapper.xml</li><li>使用 Mapper 进行开发时，需要遵循以下规则：<ol><li>mapper 映射文件中 namespace 必须与对应的 mapper 接口的完全限定名一致。</li><li>mapper 映射文件中 statement 的 id 必须与 mapper 接口中的方法的方法名一致。</li><li>mapper 映射文件中 statement 的 parameterType 指定的类型必须与 mapper 接口中方法的参数类型一致。</li><li>mapper 映射文件中 statement 的 resultType 指定的类型必须与 mapper 接口中方法的返回值类型一致。</li></ol></li></ul><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><ul><li><p>MyBatis 针对实际实际业务中使用最多的“增伤改查”操作，分别提供了以下注解来替换 mapper 映射文件，简化配置：</p><ol><li>@Select</li><li>@Insert</li><li>@Update</li><li>@Delete</li></ol></li><li><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where user_name = #&#123;userName,jdbcType=VARCHAR&#125; and password = #&#123;password,jdbcType=VARCHAR&#125;&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">getByUserNameAndPassword</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="meta">@Delete(&quot;delete from user where id = #&#123;id,jdbcType=INTEGER&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByPrimaryKey</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user ( user_id, user_name, password, email)&quot; +</span></span><br><span class="line"><span class="meta">            &quot;values ( #&#123;userId,jdbcType=VARCHAR&#125;, #&#123;userName,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, #&#123;email,jdbcType=VARCHAR&#125;)&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(User record)</span>;</span><br><span class="line">    <span class="meta">@Update(&quot; update user&quot; +</span></span><br><span class="line"><span class="meta">            &quot;    set user_id = #&#123;userId,jdbcType=VARCHAR&#125;,\n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;      user_name = #&#123;userName,jdbcType=VARCHAR&#125;,\n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;      password = #&#123;password,jdbcType=VARCHAR&#125;,\n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;      email = #&#123;email,jdbcType=VARCHAR&#125;\n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;    where id = #&#123;id,jdbcType=INTEGER&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateByPrimaryKey</span><span class="params">(User record)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意事项：mapper 接口中的任何一个方法，都只能使用一种配置方式，即注解和 mapper 映射文件二选一，但不同方法之间，这两种方式则可以混合使用，例如方法 1 使用注解方式，方法 2 使用 mapper 映射文件方式。</p></li><li><p>我们可以根据 SQL 的复杂程度，选择不同的方式来提高开发效率：</p><ul><li>如果<strong>没有复杂的连接查询，我们可以使用注解的方式来简化配置</strong>（不过这个可以被MyBatisPlus的基本功能实现代替）；</li><li>如果<strong>涉及的 sql 较为复杂时，则使用 XML （mapper 映射文件）的方式更好一些</strong>。</li></ul></li></ul><h2 id="和其他持久化层技术对比"><a href="#和其他持久化层技术对比" class="headerlink" title="和其他持久化层技术对比"></a>和其他持久化层技术对比</h2><ul><li><p>JDBC</p><ol><li>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤</li><li>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见</li><li>代码冗长，开发效率低</li></ol></li><li><p>Hibernate 和 JPA</p><ol><li>操作简便，开发效率高</li><li>程序中的长难复杂 SQL 需要绕过框架</li><li>内部自动生产的 SQL，不容易做特殊优化</li><li>基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。</li><li>反射操作太多，导致数据库性能下降</li></ol></li><li><p>MyBatis</p><ol><li>轻量级，性能出色</li><li>SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据</li><li>开发效率稍逊于Hibernate，但是完全能够接受</li></ol></li></ul><h1 id="搭建MyBatis"><a href="#搭建MyBatis" class="headerlink" title="搭建MyBatis"></a>搭建MyBatis</h1><h2 id="示例开发环境"><a href="#示例开发环境" class="headerlink" title="示例开发环境"></a>示例开发环境</h2><ul><li>IDE：idea 2019.2</li><li>构建工具：maven 3.5.4</li><li>MySQL版本：MySQL 5.7</li><li>MyBatis版本：MyBatis 3.5.7</li></ul><h2 id="创建Maven工程"><a href="#创建Maven工程" class="headerlink" title="创建Maven工程"></a>创建Maven工程</h2><ul><li><p>打包方式jar：<code>&lt;packaging&gt;jar&lt;/packaging&gt;</code></p></li><li><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mybatis核心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="创建MyBatis的核心配置文件"><a href="#创建MyBatis的核心配置文件" class="headerlink" title="创建MyBatis的核心配置文件"></a>创建MyBatis的核心配置文件</h2><ul><li><p>习惯上命名为<strong>mybatis-config.xml</strong>，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。</p></li><li><p><strong>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息</strong></p></li><li><p>核心配置文件存放的位置是src&#x2F;main&#x2F;resources目录下</p></li><li><p>配置示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置连接数据库的环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/MyBatis&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="创建mapper接口"><a href="#创建mapper接口" class="headerlink" title="创建mapper接口"></a>创建mapper接口</h2><ul><li><p>MyBatis中的mapper接口<strong>相当于以前的dao</strong>。但是区别在于，mapper仅仅是接口，我们不需要提供实现类。底层估计是用到了<strong>cglib代理</strong>。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加用户信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建MyBatis的映射文件"><a href="#创建MyBatis的映射文件" class="headerlink" title="创建MyBatis的映射文件"></a>创建MyBatis的映射文件</h2><ul><li><p>相关概念：ORM（Object Relationship Mapping）对象关系映射。</p><ol><li>对象：Java的实体类对象</li><li>关系：关系型数据库</li><li>映射：二者之间的对应关系</li></ol></li><li><table><thead><tr><th>Java概念</th><th>数据库概念</th></tr></thead><tbody><tr><td>类</td><td>表</td></tr><tr><td>属性</td><td>字段&#x2F;列</td></tr><tr><td>对象</td><td>记录&#x2F;行</td></tr></tbody></table></li><li><p>映射文件的命名规则：<strong>表所对应的实体类的类名+Mapper.xml</strong><br>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml，因此一个映射文件对应一个实体类，对应一张表的操作MyBatis映射文件用于编写SQL，访问以及操作表中的数据，MyBatis映射文件存放的位置是src&#x2F;main&#x2F;resources&#x2F;mappers目录下</p></li><li><p>MyBatis中可以面向接口操作数据，要保证两个一致：</p><ol><li><strong>mapper接口的全类名和映射文件的命名空间（namespace）保持一致</strong></li><li>mapper接口中方法的<strong>方法名和映射文件中编写SQL的标签的id属性保持一致</strong></li></ol></li><li><p>代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--int insertUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,&#x27;张三&#x27;,&#x27;123&#x27;,23,&#x27;女&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="通过junit测试功能"><a href="#通过junit测试功能" class="headerlink" title="通过junit测试功能"></a>通过junit测试功能</h2><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取MyBatis的核心配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SqlSessionFactoryBuilder对象</span></span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务</span></span><br><span class="line"><span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession();</span></span><br><span class="line"><span class="comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过代理模式创建UserMapper接口的代理实现类对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insertUser();</span><br><span class="line"></span><br><span class="line"><span class="comment">//sqlSession.commit();</span></span><br><span class="line">System.out.println(<span class="string">&quot;结果：&quot;</span>+result);</span><br></pre></td></tr></table></figure></li><li><p>SqlSession：代表<strong>Java程序和数据库之间的会话</strong>。（HttpSession是Java程序和浏览器之间的会话）</p></li><li><p>SqlSessionFactory：是“生产”SqlSession的“工厂”。</p></li><li><p>用到了工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。</p></li></ul><h2 id="加入log4j日志功能"><a href="#加入log4j日志功能" class="headerlink" title="加入log4j日志功能"></a>加入log4j日志功能</h2><ul><li><p>加入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>加入log4j的配置文件（log4j的配置文件名为log4j.xml，存放的位置是src&#x2F;main&#x2F;resources目录下）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">log4j</span>:configuration <span class="keyword">SYSTEM</span> <span class="string">&quot;log4j.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;Encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ConversionPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \n&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="日志的级别"><a href="#日志的级别" class="headerlink" title="日志的级别"></a>日志的级别</h3><ul><li>FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试)  从左到右打印的内容越来越详细</li></ul><h1 id="核心配置文件详解"><a href="#核心配置文件详解" class="headerlink" title="核心配置文件详解"></a>核心配置文件详解</h1><ul><li><p>核心配置文件中的标签必须按照固定的顺序书写：properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers? 如果不按照这个顺序书写的话就会报错。</p></li><li><p>示例配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//MyBatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">typeAlias：设置某个具体的类型的别名</span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">type：需要设置别名的类型的全类名</span></span><br><span class="line"><span class="comment">alias：设置此类型的别名，若不设置此属性，该类型拥有默认的别名，即类名且不区分大小写</span></span><br><span class="line"><span class="comment">若设置此属性，此时该类型的别名只能使用alias所设置的值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&gt;&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;abc&quot;&gt;</span></span><br><span class="line"><span class="comment">&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.bean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">environments：设置多个连接数据库的环境</span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">default：设置默认使用的环境的id</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">environment：设置具体的连接数据库的环境信息</span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">transactionManager：设置事务管理方式</span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;</span></span><br><span class="line"><span class="comment">type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理</span></span><br><span class="line"><span class="comment">type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">dataSource：设置数据源</span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span></span><br><span class="line"><span class="comment">type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建</span></span><br><span class="line"><span class="comment">type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建</span></span><br><span class="line"><span class="comment">type=&quot;JNDI&quot;：调用上下文中的数据源</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置驱动类的全类名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置连接数据库的连接地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置连接数据库的用户名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置连接数据库的密码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">以包为单位，将包下所有的映射文件引入核心配置文件</span></span><br><span class="line"><span class="comment">注意：此方式必须保证mapper接口和mapper映射文件必须在相同的包下</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="MyBatis的增删改查"><a href="#MyBatis的增删改查" class="headerlink" title="MyBatis的增删改查"></a>MyBatis的增删改查</h1><ul><li>这里的例子是在mapper接口对应的xml文件中进行配置，<strong>一般会将mapper中的方法签名复制到对应的xml文件中当作注释来辅助配置的编写</strong>，除了在配置文件中进行配置外也可以使用注解进行开发。</li></ul><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><ul><li><p>示例代码：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span>&gt;</span></span><br><span class="line">delete from t_user where id = 7</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int updateUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">update t_user set username=&#x27;ybc&#x27;,password=&#x27;123&#x27; where id = 6</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="查询一个实体类对象"><a href="#查询一个实体类对象" class="headerlink" title="查询一个实体类对象"></a>查询一个实体类对象</h2><ul><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserById();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where id = 2</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="查询集合"><a href="#查询集合" class="headerlink" title="查询集合"></a>查询集合</h2><ul><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><p>查询的标签select必须设置属性<strong>resultType或resultMap</strong>，用于设置实体类和数据库表的映射关系，设置了这个mybatis才直到要把查出来的东西以什么样的规则放到哪里。</p><ul><li>resultType：自动映射，用于属性名和表中字段名一致的情况，mybatis会把查出来的记录的字段按照名称（或是一定的映射关系，如下划线和驼峰之间的映射）对设置的实体类中的属性进行赋值。<strong>注意：就算是查询结果有多条，也不能声明其类型为list，只需让方法的返回值为List即可，因为这个属性的作用是指定映射关系，所以无论返回值有多少，我们应该在其中声明需要进行映射的实体类而不是其容器。</strong></li><li>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</li></ul></li><li><p><strong>当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常<br>TooManyResultsException</strong>；但是若查询的数据只有一条，可以使用实体类或集合作为返回值</p></li></ol><h1 id="MyBatis获取参数值的两种方式（重点）"><a href="#MyBatis获取参数值的两种方式（重点）" class="headerlink" title="MyBatis获取参数值的两种方式（重点）"></a>MyBatis获取参数值的两种方式（重点）</h1><ul><li>MyBatis获取参数值的两种方式：**${}** 和 <strong>#{}<strong>，${}的本质就是</strong>字符串拼接</strong>，#{}的本质就是<strong>占位符赋值</strong></li><li><strong>${}<strong>使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号，</strong>不会自动添加单引号</strong>；但是**#{}<strong>使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以</strong>自动添加单引号**。</li></ul><h2 id="单个字面量类型的参数"><a href="#单个字面量类型的参数" class="headerlink" title="单个字面量类型的参数"></a>单个字面量类型的参数</h2><ul><li>若mapper接口中的方法参数为单个的字面量类型此时可以使用${}和#{}在大括号中间指定<strong>以任意的名称</strong>获取参数的值，注意${}需要手动加单引号</li></ul><h2 id="多个字面量类型的参数"><a href="#多个字面量类型的参数" class="headerlink" title="多个字面量类型的参数"></a>多个字面量类型的参数</h2><ul><li>若mapper接口中的方法参数为多个时，此时MyBatis会<strong>自动将这些参数放在一个map集合中，以arg0,arg1…为键，以参数为值；以param1,param2…为键，以参数为值</strong>；因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</li></ul><h2 id="map集合类型的参数"><a href="#map集合类型的参数" class="headerlink" title="map集合类型的参数"></a>map集合类型的参数</h2><ul><li>若mapper接口中的方法需要的参数为多个时，此时可以<strong>手动创建map集合并将其作为参数传入mapper中的方法中</strong>，将这些数据放在map中只需要<strong>通过${}和#{}访问map集合的键</strong>就可以获取相对应的值，注意${}需要手动加单引号</li></ul><h2 id="实体类类型的参数"><a href="#实体类类型的参数" class="headerlink" title="实体类类型的参数"></a>实体类类型的参数</h2><ul><li>若mapper接口中的方法参数为实体类对象时此时可以<strong>使用${}和#{}，通过访问实体类对象中的属性名</strong>获取属性值，注意${}需要手动加单引号</li></ul><h2 id="使用-Param标识参数"><a href="#使用-Param标识参数" class="headerlink" title="使用@Param标识参数"></a>使用@Param标识参数</h2><ul><li>可以<strong>通过@Param注解标识mapper接口中的方法参数</strong>，此时会将这些参数放在map集合中，<strong>以@Param注解的value属性值为键，以参数为值；以param1,param2…为键，以参数为值</strong>；只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</li><li>实际情况下mapper中的方法参数有很多种情况，<strong>推荐都使用@Param注解对参数进行标识来实现一种统一的访问形式</strong>。</li></ul><h1 id="MyBatis的各种查询功能的实现"><a href="#MyBatis的各种查询功能的实现" class="headerlink" title="MyBatis的各种查询功能的实现"></a>MyBatis的各种查询功能的实现</h1><h2 id="查询一个实体类对象-1"><a href="#查询一个实体类对象-1" class="headerlink" title="查询一个实体类对象"></a>查询一个实体类对象</h2><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据用户id查询用户信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserById(@Param(&quot;id&quot;) int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="查询一个list集合"><a href="#查询一个list集合" class="headerlink" title="查询一个list集合"></a>查询一个list集合</h2><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询所有用户信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUserList</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="查询单个数据"><a href="#查询单个数据" class="headerlink" title="查询单个数据"></a>查询单个数据</h2><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询用户的总记录数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* 在MyBatis中，对于Java中常用的类型都设置了类型别名</span></span><br><span class="line"><span class="comment">* 例如：java.lang.Integer--&gt;int|integer</span></span><br><span class="line"><span class="comment">* 例如：int--&gt;_int|_integer</span></span><br><span class="line"><span class="comment">* 例如：Map--&gt;map,List--&gt;list</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int getCount();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;_integer&quot;</span>&gt;</span></span><br><span class="line">select count(id) from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="查询一条数据为map集合"><a href="#查询一条数据为map集合" class="headerlink" title="查询一条数据为map集合"></a>查询一条数据为map集合</h2><ul><li>通过Map&lt;String,Object&gt;类型来接受查出来的记录，MyBatis会自动将转换后的字段名为key，字段对应的值为value存放到map中，不和List一样，<strong>map类型需要在resultType属性中进行声明</strong>，因为<strong>map本身就表示一种处理映射关系的方式，可以作为一种规则被提供</strong>，还是那句话，<strong>resultType和resultMap是为了指定映射的方式，因此在填这个属性的时候一定要先想一想自己填的这个是否能为MyBatis准确地提供一种映射方式</strong>，不然你懵机器也懵。</li></ul><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><ul><li>代码示例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询所有用户信息为map集合</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此</span></span><br><span class="line"><span class="comment">时可以将这些map放在一个list集合中获取</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><ul><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询所有用户信息为map集合</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并</span></span><br><span class="line"><span class="comment">且最终要以一个map的方式返回数据，此时需要通过<span class="doctag">@MapKey</span>注解设置map集合的键，值是每条数据所对应的</span></span><br><span class="line"><span class="comment">map集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">结果：</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">1=&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span></span><br><span class="line"><span class="comment">2=&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span></span><br><span class="line"><span class="comment">3=&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="特殊SQL的执行"><a href="#特殊SQL的执行" class="headerlink" title="特殊SQL的执行"></a>特殊SQL的执行</h1><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 测试模糊查询</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> mohu</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">testMohu</span><span class="params">(<span class="meta">@Param(&quot;mohu&quot;)</span> String mohu)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; testMohu(@Param(&quot;mohu&quot;) String mohu);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;testMohu&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27; 会有sql注入的风险，不推荐使用--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;)--&gt;</span></span><br><span class="line">select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;<span class="comment">&lt;!--推荐使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 批量删除</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteMore</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> String ids)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteMore(@Param(&quot;ids&quot;) String ids);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMore&quot;</span>&gt;</span></span><br><span class="line">delete from t_user where id in ($&#123;ids&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="动态设置表名"><a href="#动态设置表名" class="headerlink" title="动态设置表名"></a>动态设置表名</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 动态设置表名，查询所有的用户信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> tableName</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getAllUser</span><span class="params">(<span class="meta">@Param(&quot;tableName&quot;)</span> String tableName)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getAllUser(@Param(&quot;tableName&quot;) String tableName);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from $&#123;tableName&#125;<span class="comment">&lt;!--注意表名是没有单引号的，所以这个地方不适合用#&#123;&#125;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="添加功能获取自增的主键"><a href="#添加功能获取自增的主键" class="headerlink" title="添加功能获取自增的主键"></a>添加功能获取自增的主键</h2><ul><li>有表：t_clazz(clazz_id,clazz_name)和t_student(student_id,student_name,clazz_id)</li><li>要求：<ol><li>添加班级信息</li><li>获取新添加的班级的id</li><li>为班级分配学生，即将某学的班级id修改为新添加的班级的id</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加用户信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* useGeneratedKeys：设置使用自增的主键</span></span><br><span class="line"><span class="comment">* keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参</span></span><br><span class="line"><span class="comment">数user对象的某个属性中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="自定义映射resultMap"><a href="#自定义映射resultMap" class="headerlink" title="自定义映射resultMap"></a>自定义映射resultMap</h1><h2 id="resultMap处理字段和属性的映射关系"><a href="#resultMap处理字段和属性的映射关系" class="headerlink" title="resultMap处理字段和属性的映射关系"></a>resultMap处理字段和属性的映射关系</h2><ul><li><p>若<strong>字段名和实体类中的属性名不一致或是不能通过特定的映射方式（如下划线映射驼峰）进行映射</strong>，则可以通过resultMap设置自定义映射。</p></li><li><p>实例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">resultMap：设置自定义映射</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">id：表示自定义映射的唯一标识</span></span><br><span class="line"><span class="comment">type：查询的数据要映射的实体类的类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">子标签：</span></span><br><span class="line"><span class="comment">id：设置主键的映射关系</span></span><br><span class="line"><span class="comment">result：设置普通字段的映射关系</span></span><br><span class="line"><span class="comment">association：设置多对一的映射关系</span></span><br><span class="line"><span class="comment">collection：设置一对多的映射关系</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">property：设置映射关系中实体类中的属性名</span></span><br><span class="line"><span class="comment">column：设置映射关系中表中的字段名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--List&lt;User&gt; testMohu(@Param(&quot;mohu&quot;) String mohu);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;testMohu&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt;</span></span><br><span class="line">select id,user_name,password,age,sex from t_user where user_name like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰），此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系：</p><ol><li>可以通过<strong>为字段起别名</strong>的方式，保证和实体类中的属性名保持一致</li><li>可以在MyBatis的核心配置文件中设置一个全局配置信息<strong>mapUnderscoreToCamelCase&#x3D;true</strong>，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为<br>userName</li></ol></li></ul><h2 id="多对一映射处理"><a href="#多对一映射处理" class="headerlink" title="多对一映射处理"></a>多对一映射处理</h2><ul><li>要求查询员工信息以及员工所对应部门的信息，员工和员工所属部门是多对一的关系。</li><li>其中这个<strong>“一”可以在resultMap中用association表示</strong>。</li></ul><h3 id="单步查询并用级联方式处理映射关系"><a href="#单步查询并用级联方式处理映射关系" class="headerlink" title="单步查询并用级联方式处理映射关系"></a>单步查询并用级联方式处理映射关系</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empDeptMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.dname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDeptByEid(@Param(&quot;eid&quot;) int eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByEid&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empDeptMap&quot;</span>&gt;</span></span><br><span class="line">select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did = dept.did where emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用association处理映射关系"><a href="#使用association处理映射关系" class="headerlink" title="使用association处理映射关系"></a>使用association处理映射关系</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empDeptMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDeptByEid(@Param(&quot;eid&quot;) int eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByEid&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empDeptMap&quot;</span>&gt;</span></span><br><span class="line">select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did = dept.did where emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="分步查询"><a href="#分步查询" class="headerlink" title="分步查询"></a>分步查询</h3><ul><li><p>这样做往往效率比较高</p></li><li><p>首先查询员工信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 通过分步查询查询员工信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> eid</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Emp <span class="title function_">getEmpByStep</span><span class="params">(<span class="meta">@Param(&quot;eid&quot;)</span> <span class="type">int</span> eid)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empDeptStepMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">select：设置分步查询，查询某个属性的值的sql的标识（namespace.sqlId）</span></span><br><span class="line"><span class="comment">column：将sql以及查询结果中的某个字段设置为分步查询的条件</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.atguigu.MyBatis.mapper.DeptMapper.getEmpDeptByStep&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="comment">&lt;!--在这里配置了下一步要进行的查询语句，查询出来的内容会被映射到这个association中--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpByStep(@Param(&quot;eid&quot;) int eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByStep&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empDeptStepMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后根据员工所对应的部门id查询部门信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分步查询的第二步：根据员工所对应的did查询部门信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> did</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Dept <span class="title function_">getEmpDeptByStep</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> <span class="type">int</span> did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Dept getEmpDeptByStep(@Param(&quot;did&quot;) int did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpDeptByStep&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="一对多映射处理"><a href="#一对多映射处理" class="headerlink" title="一对多映射处理"></a>一对多映射处理</h2><ul><li><p>要求查询部门信息以及部门中的所有员工信息，部门和部门下的员工是一对多的关系。</p></li><li><p>这个“多”可以在resultMap中用collection表示</p></li></ul><h3 id="单步查询并使用collection处理映射关系"><a href="#单步查询并使用collection处理映射关系" class="headerlink" title="单步查询并使用collection处理映射关系"></a>单步查询并使用collection处理映射关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据部门id查新部门以及部门中的员工信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> did</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Dept <span class="title function_">getDeptEmpByDid</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> <span class="type">int</span> did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptEmpMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">ofType：设置collection标签所处理的集合属性中存储数据的类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptEmpByDid(@Param(&quot;did&quot;) int did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptEmpByDid&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;deptEmpMap&quot;</span>&gt;</span></span><br><span class="line">select dept.*,emp.* from t_dept dept left join t_emp emp on dept.did = emp.did where dept.did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="分步查询-1"><a href="#分步查询-1" class="headerlink" title="分步查询"></a>分步查询</h3><ul><li><p>这样做往往效率比较高</p></li><li><p>首先查询部门信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分步查询部门和部门中的员工</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> did</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Dept <span class="title function_">getDeptByStep</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> <span class="type">int</span> did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptEmpStep&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;eager&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.atguigu.MyBatis.mapper.EmpMapper.getEmpListByDid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptByStep(@Param(&quot;did&quot;) int did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptByStep&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;deptEmpStep&quot;</span>&gt;</span></span><br><span class="line">select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>根据部门id查询部门中的所有员工</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据部门id查询员工信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> did</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;Emp&gt; <span class="title function_">getEmpListByDid</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> <span class="type">int</span> did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpListByDid(@Param(&quot;did&quot;) int did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpListByDid&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="分步查询的优点"><a href="#分步查询的优点" class="headerlink" title="分步查询的优点"></a>分步查询的优点</h2><ul><li><p>可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：</p><ol><li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载</li><li>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载</li></ol></li><li><p>设置完以上的配置后，就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时<strong>可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载</strong>，<strong>fetchType&#x3D;”lazy(延迟加载)|eager(立即加载)”</strong></p></li></ul><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><ul><li>Mybatis框架的动态SQL技术是一种<strong>根据特定条件动态拼装SQL语句的功能</strong>，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题。</li></ul><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><ul><li><p>if标签<strong>可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</strong>。</p></li><li><p>要注意可能会出现冗余的关键字影响mybatis解析代码。</p></li><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpListByMoreTJ(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpListByMoreTJ&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where 1=1<span class="comment">&lt;!--防止出现冗余的and--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != &#x27;&#x27; and ename != null&quot;</span>&gt;</span></span><br><span class="line">and ename = #&#123;ename&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != &#x27;&#x27; and age != null&quot;</span>&gt;</span></span><br><span class="line">and age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != &#x27;&#x27; and sex != null&quot;</span>&gt;</span></span><br><span class="line">and sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><ul><li><p>是消除冗余的关键字的另外一种可行的方式</p></li><li><p>where和if一般结合使用：</p><ol><li>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字</li><li>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and去</li><li><strong>where标签不能去掉条件最后多余的and</strong></li></ol></li><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpListByMoreTJ2&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != &#x27;&#x27; and ename != null&quot;</span>&gt;</span></span><br><span class="line">ename = #&#123;ename&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != &#x27;&#x27; and age != null&quot;</span>&gt;</span></span><br><span class="line">and age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != &#x27;&#x27; and sex != null&quot;</span>&gt;</span></span><br><span class="line">and sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><ul><li><p>trim用于<strong>去掉或者添加标签中的内容</strong>，常用属性：</p><ol><li>prefix：在trim标签中的内容的前面添加某些内容</li><li>prefixOverrides：在trim标签中的内容的前面去掉某些内容</li><li>suffix：在trim标签中的内容的后面添加某些内容</li><li>suffixOverrides：在trim标签中的内容的后面去掉某些内容</li></ol></li><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpListByMoreTJ&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != &#x27;&#x27; and ename != null&quot;</span>&gt;</span></span><br><span class="line">ename = #&#123;ename&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != &#x27;&#x27; and age != null&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != &#x27;&#x27; and sex != null&quot;</span>&gt;</span></span><br><span class="line">sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h2><ul><li><p>choose、when、otherwise类似于if…else if…else</p></li><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpListByChoose(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpListByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;ename != &#x27;&#x27; and ename != null&quot;</span>&gt;</span></span><br><span class="line">ename = #&#123;ename&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;age != &#x27;&#x27; and age != null&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sex != &#x27;&#x27; and sex != null&quot;</span>&gt;</span></span><br><span class="line">sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;email != &#x27;&#x27; and email != null&quot;</span>&gt;</span></span><br><span class="line">email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><ul><li><p>常用属性：</p><ol><li>collection：设置要循环的数组或集合</li><li>item：表示集合或数组中的每一个数据</li><li>separator：设置循环体之间的分隔符</li><li>open：设置foreach标签中的内容的开始符</li><li>close：设置foreach标签中的内容的结束符</li></ol></li><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertMoreEmp(List&lt;Emp&gt; emps);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertMoreEmp&quot;</span>&gt;</span></span><br><span class="line">insert into t_emp values</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">(null,#&#123;emp.ename&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null)</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--int deleteMoreByArray(int[] eids);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMoreByArray&quot;</span>&gt;</span></span><br><span class="line">delete from t_emp where</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;eids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span>&gt;</span></span><br><span class="line">eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--int deleteMoreByArray(int[] eids);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMoreByArray&quot;</span>&gt;</span></span><br><span class="line">delete from t_emp where eid in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;eids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">#&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h2><ul><li><p>sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入</p></li><li><p>代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span></span><br><span class="line">    eid,ename,age,sex,did</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> from t_emp</span><br></pre></td></tr></table></figure></li></ul><h1 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h1><h2 id="MyBatis的一级缓存"><a href="#MyBatis的一级缓存" class="headerlink" title="MyBatis的一级缓存"></a>MyBatis的一级缓存</h2><ul><li><p>一级缓存是SqlSession级别的，<strong>通过同一个SqlSession查询的数据会被缓存</strong>，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问。</p></li><li><p>使一级缓存失效的四种情况（还是挺容易想到的）：</p><ol><li>不同的SqlSession对应不同的一级缓存</li><li>同一个SqlSession但是查询条件不同</li><li>同一个SqlSession两次查询期间执行了任何一次增删改操作</li><li>同一个SqlSession两次查询期间手动清空了缓存</li></ol></li></ul><h2 id="MyBatis的二级缓存"><a href="#MyBatis的二级缓存" class="headerlink" title="MyBatis的二级缓存"></a>MyBatis的二级缓存</h2><ul><li><p>二级缓存是SqlSessionFactory级别，<strong>通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存</strong>；此后若再次执行相同的查询语句，结果就会从缓存中获取</p></li><li><p>二级缓存开启的条件：</p><ol><li>在核心配置文件中，设置<strong>全局配置属性cacheEnabled&#x3D;”true”<strong>，</strong>默认为true</strong>，不需要设置</li><li>在映射文件中设置标签&lt;cache &#x2F;&gt;</li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型<strong>必须实现序列化的接口</strong></li></ol></li><li><p>使二级缓存失效的情况：<strong>两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</strong></p></li></ul><h2 id="二级缓存的相关配置"><a href="#二级缓存的相关配置" class="headerlink" title="二级缓存的相关配置"></a>二级缓存的相关配置</h2><ul><li><p>在mapper配置文件中添加的cache标签可以设置一些属性：</p><ol><li><p>eviction属性：缓存回收策略</p><p><strong>LRU（Least Recently Used）</strong> – 最近最少使用的：移除最长时间不被使用的对象。<br><strong>FIFO（First in First out）</strong> – 先进先出：按对象进入缓存的顺序来移除它们。<br><strong>SOFT – 软引用</strong>：移除基于垃圾回收器状态和软引用规则的对象。<br><strong>WEAK – 弱引用</strong>：更积极地移除基于垃圾收集器状态和弱引用规则的对象。<br><strong>默认的是 LRU</strong>。</p></li><li><p>flushInterval属性：刷新间隔，单位毫秒<br><strong>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新</strong></p></li><li><p>size属性：引用数目，正整数<br>代表<strong>缓存最多可以存储多少个对象</strong>，太大容易导致内存溢出</p></li><li><p>readOnly属性：只读，true&#x2F;false<br>true：只读缓存；<strong>会给所有调用者返回缓存对象的相同实例</strong>。因此<strong>这些对象不能被修改</strong>。这提供了很重要的<strong>性能优势</strong>。<br>false：读写缓存；会<strong>返回缓存对象的拷贝（通过序列化）</strong>。这会<strong>慢一些</strong>，但是<strong>安全</strong>，因此默认是false。</p></li></ol></li></ul><h2 id="MyBatis缓存查询的顺序"><a href="#MyBatis缓存查询的顺序" class="headerlink" title="MyBatis缓存查询的顺序"></a>MyBatis缓存查询的顺序</h2><ul><li><strong>先查询二级缓存</strong>，因为<strong>二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用</strong>。</li><li>如果二级缓存没有命中，再查询一级缓存</li><li>如果一级缓存也没有命中，则查询数据库</li><li><strong>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</strong></li></ul><h2 id="整合第三方缓存EHCache"><a href="#整合第三方缓存EHCache" class="headerlink" title="整合第三方缓存EHCache"></a>整合第三方缓存EHCache</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mybatis EHCache整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- slf4j日志门面的一个具体实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="各jar包的功能"><a href="#各jar包的功能" class="headerlink" title="各jar包的功能"></a>各jar包的功能</h3><table><thead><tr><th>jar包名称</th><th>作用</th></tr></thead><tbody><tr><td>mybatis-ehcache</td><td>Mybatis和EHCache的整合包</td></tr><tr><td>ehcache</td><td>EHCache核心包</td></tr><tr><td>slf4j-api</td><td>SLF4J日志门面包</td></tr><tr><td>logback-classic</td><td>支持SLF4J门面接口的一个具体实现</td></tr></tbody></table><h3 id="创建EHCache的配置文件ehcache-xml"><a href="#创建EHCache的配置文件ehcache-xml" class="headerlink" title="创建EHCache的配置文件ehcache.xml"></a>创建EHCache的配置文件ehcache.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;../config/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 磁盘保存路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;D:\atguigu\ehcache&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxElementsOnDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="设置二级缓存的类型"><a href="#设置二级缓存的类型" class="headerlink" title="设置二级缓存的类型"></a>设置二级缓存的类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="加入logback日志"><a href="#加入logback日志" class="headerlink" title="加入logback日志"></a>加入logback日志</h3><ul><li><p>存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。创建<strong>logback的配置文件logback.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定日志输出的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 日志输出的格式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread][%logger][%msg]%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 根据特殊需求指定局部日志级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.crowd.mapper&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="EHCache配置文件说明"><a href="#EHCache配置文件说明" class="headerlink" title="EHCache配置文件说明"></a>EHCache配置文件说明</h3><table><thead><tr><th>属性名</th><th>是否必须</th><th>作用</th></tr></thead><tbody><tr><td>maxElementsInMemory</td><td>是</td><td>在内存中缓存的element的最大数目</td></tr><tr><td>maxElementsOnDisk</td><td>是</td><td>在磁盘上缓存的element的最大数目，若是0表示无穷大</td></tr><tr><td>eternal</td><td>是</td><td>设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断</td></tr><tr><td>overflowToDisk</td><td>是</td><td>设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上</td></tr><tr><td>timeToIdleSeconds</td><td>否</td><td>当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大</td></tr><tr><td>timeToLiveSeconds</td><td>否</td><td>缓存element的有效生命期，默认是0.,也就是element存活时间无穷大</td></tr><tr><td>diskSpoolBufferSizeMB</td><td>否</td><td>DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区</td></tr><tr><td>diskPersistent</td><td>否</td><td>在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。</td></tr><tr><td>diskExpiryThreadIntervalSeconds</td><td>否</td><td>磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作</td></tr><tr><td>memoryStoreEvictionPolicy</td><td>否</td><td>当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出）</td></tr></tbody></table><h1 id="MyBatis的逆向工程"><a href="#MyBatis的逆向工程" class="headerlink" title="MyBatis的逆向工程"></a>MyBatis的逆向工程</h1><ul><li>正向工程：<strong>先创建Java实体类，由框架负责根据实体类生成数据库表</strong>。Hibernate是支持正向工程的。</li><li>逆向工程：<strong>先创建数据库表，由框架负责根据数据库表</strong>，反向生成如下资源：<ol><li>Java实体类</li><li>Mapper接口</li><li>Mapper映射文件</li></ol></li></ul><h2 id="创建逆向工程的步骤"><a href="#创建逆向工程的步骤" class="headerlink" title="创建逆向工程的步骤"></a>创建逆向工程的步骤</h2><h3 id="添加依赖和插件"><a href="#添加依赖和插件" class="headerlink" title="添加依赖和插件"></a>添加依赖和插件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 依赖MyBatis核心包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 构建过程中用到的插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">&lt;!-- 插件的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                </span><br><span class="line"><span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                </span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建MyBatis的核心配置文件-1"><a href="#创建MyBatis的核心配置文件-1" class="headerlink" title="创建MyBatis的核心配置文件"></a>创建MyBatis的核心配置文件</h3><ul><li>前面写过了</li></ul><h3 id="创建逆向工程的配置文件"><a href="#创建逆向工程的配置文件" class="headerlink" title="创建逆向工程的配置文件"></a>创建逆向工程的配置文件</h3><ul><li><p>文件名必须是：<strong>generatorConfig.xml</strong></p></li><li><p>代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span> </span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">targetRuntime: 执行生成的逆向工程的版本</span></span><br><span class="line"><span class="comment">MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span></span><br><span class="line"><span class="comment">MyBatis3: 生成带条件的CRUD（奢华尊享版）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库的连接信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- javaBean的生成策略--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.bean&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\resources&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mapper接口的生成策略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 逆向分析的表 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_emp&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Emp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_dept&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Dept&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="执行MBG插件的generate目标"><a href="#执行MBG插件的generate目标" class="headerlink" title="执行MBG插件的generate目标"></a>执行MBG插件的generate目标</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220923211033152.png" alt="image-20220923211033152"></p><ul><li><p>效果：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220923211049760.png" alt="image-20220923211049760"></p></li></ul><h2 id="QBC查询"><a href="#QBC查询" class="headerlink" title="QBC查询"></a>QBC查询</h2><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMBG</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is).openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="type">EmpExample</span> <span class="variable">empExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmpExample</span>();</span><br><span class="line"><span class="comment">//创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系</span></span><br><span class="line">empExample.createCriteria().andEnameLike(<span class="string">&quot;a&quot;</span>).andAgeGreaterThan(<span class="number">20</span>).andDidIsNotNull();</span><br><span class="line"><span class="comment">//将之前添加的条件通过or拼接其他条件</span></span><br><span class="line">empExample.or().andSexEqualTo(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">List&lt;Emp&gt; list = mapper.selectByExample(empExample);</span><br><span class="line"><span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">System.out.println(emp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h1><h2 id="分页插件配置步骤"><a href="#分页插件配置步骤" class="headerlink" title="分页插件配置步骤"></a>分页插件配置步骤</h2><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置分页插件"><a href="#配置分页插件" class="headerlink" title="配置分页插件"></a>配置分页插件</h3><ul><li><p>在MyBatis的核心配置文件中配置插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置分页插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="分页插件的使用"><a href="#分页插件的使用" class="headerlink" title="分页插件的使用"></a>分页插件的使用</h2><ul><li><p>在<strong>查询功能之前</strong>使用**PageHelper.startPage(int pageNum, int pageSize)**开启分页功能：</p><ol><li>pageNum：表示当前页的页码</li><li>pageSize：表示每页显示的条数</li></ol></li><li><p>在<strong>查询获取list集合之后</strong>，使用**PageInfo&lt;T&gt; pageInfo &#x3D; new PageInfo&lt;&gt;(List&lt;T&gt; list, int navigatePages)**获取分页相关数据：</p><ol><li>list：分页之后的数据</li><li>navigatePages：导航分页的页码数</li></ol></li><li><p>分页相关数据示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PageInfo&#123;</span><br><span class="line">pageNum=8, pageSize=4, size=2, startRow=29, endRow=30, total=30, pages=8,</span><br><span class="line">list=Page&#123;count=true, pageNum=8, pageSize=4, startRow=28, endRow=32, total=30,pages=8, reasonable=false, pageSizeZero=false&#125;,</span><br><span class="line">prePage=7, nextPage=0, isFirstPage=false, isLastPage=true, hasPreviousPage=true,hasNextPage=false, navigatePages=5,navigateFirstPage4, navigateLastPage8,</span><br><span class="line">navigatepageNums=[4, 5, 6, 7, 8]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分页数据中的常用数据，可以通过这些数据的组合来渲染页面：</p><ol><li>pageNum：当前页的页码</li><li>pageSize：每页显示的条数</li><li>size：当前页显示的真实条数</li><li>total：总记录数</li><li>pages：总页数</li><li>prePage：上一页的页码</li><li>nextPage：下一页的页码</li><li>isFirstPage&#x2F;isLastPage：是否为第一页&#x2F;最后一页</li><li>hasPreviousPage&#x2F;hasNextPage：是否存在上一页&#x2F;下一页</li><li>navigatePages：导航分页的页码数</li><li>navigatePageNums：导航分页的页码，如[12,3,4,5]</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;ol&gt;
&lt;li&gt;获取参数用${}不会自动加单引号，获取参数用#{}会自动加单引号&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;MyBatis简介&quot;&gt;&lt;a href=&quot;#MyBatis简介&quot; </summary>
      
    
    
    
    
    <category term="Mybatis" scheme="https://konjacor.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC入门</title>
    <link href="https://konjacor.github.io/2022/09/07/SpringMVC%E5%85%A5%E9%97%A8/"/>
    <id>https://konjacor.github.io/2022/09/07/SpringMVC%E5%85%A5%E9%97%A8/</id>
    <published>2022-09-07T06:52:36.000Z</published>
    <updated>2022-12-20T12:11:43.201Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><ol><li>classpath指什么？</li><li>属性和成员变量的区别？</li><li>servletContext中getRealPath方法的理解？找到开发路径的文件对应的<strong>部署路径</strong>？根路径是？</li><li>file对象可以指代文件夹吗？</li></ol><h1 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h1><ul><li>SpringMVC中重要的两个组件Filter（过滤器）和Interceptor（拦截器）分别在请求打到DispatcherServlet之前和执行Handler（Controller）之前执行，其中具体方法的执行位置之后详细说明。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220911162932581.png" alt="image-20220911162932581"></p><ol><li>用户点击某个请求路径，发起一个HTTP request请求，该请求会先通过过滤器链然后被提交到DispatcherServlet（前端控制器）。</li><li>由DispatcherServlet请求一个或多个HandlerMapping（处理器映射器），并返回一个执行链（HandlerExecutionChain）。</li><li>DispatcherServlet将执行链返回的Handler信息发送给HandlerAdapter（处理器适配器）。</li><li>HandlerAdapter根据Handler信息找到并执行相应的Handler（常称为Controller）。</li><li>Handler执行完毕后会返回给HandlerAdapter一个ModelAndView对象（SpringMVC的底层对象，包括 Model 数据模型和 View 视图信息，常用Model来存放模型层的数据以便于传输到视图层）。</li><li>HandlerAdapter接收到ModelAndView对象后，将其返回给DispatcherServlet。</li><li>DispatcherServlet接收到ModelAndView对象后，会请求ViewResolver（视图解析器）对视图进行解析。</li><li>ViewResolver根据View信息匹配到相应的视图结果，并返回给DispatcherServlet。</li><li>DispatcherServlet接收到具体的View视图后，进行视图渲染，将Model中的模型数据填充到View视图中的 request 域，生成最终的 View（视图）。</li><li>视图负责将结果显示到浏览器（客户端）</li></ol><h1 id="JavaWeb项目中的classpath指什么"><a href="#JavaWeb项目中的classpath指什么" class="headerlink" title="JavaWeb项目中的classpath指什么"></a>JavaWeb项目中的classpath指什么</h1><ul><li>在学习SpringMVC的时候，其中一个概念总是搞得不是很懂，就是配置SpringMVC配置文件、MyBatis的mapper路径或者是配置别的什么东西的路径的时候，有一个东西叫classpath，这个东西我知道是个路径，但是具体是什么的路径我总是有点说不准，所以今天借这个整理笔记的机会上网搜索了一下以彻底搞明白这个路径是什么。</li><li>顾名思义，classpath就是class的path，也就是类文件（*.class的路径）。一谈到文件的路径，我们就很有必要了解一个java项目（通常也是web项目）它在真正运行时候，这个项目内部的目录、文件的结构；这样，我们才好分析、理解classpath。</li></ul><h2 id="开发时期的web项目结构"><a href="#开发时期的web项目结构" class="headerlink" title="开发时期的web项目结构"></a>开发时期的web项目结构</h2><ul><li><p>以ssm的项目为例，根据maven的约定，开发时的项目目录结构图如下所示：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220924162511021.png" alt="image-20220924162511021"></p></li><li><p>一般情况下在开发阶段配置classpath的地方基本上都是为了告诉配置文件，在项目跑起来之后去哪里寻找这些个资源，所以要想知道classpath的具体指代，还得再知道web项目发布之后的目录结构，这样两个目录结构一对照，基本上就知道classpath分别在两个阶段代表什么东西了。</p></li></ul><h2 id="web项目发布后的目录结构"><a href="#web项目发布后的目录结构" class="headerlink" title="web项目发布后的目录结构"></a>web项目发布后的目录结构</h2><ul><li><p>以下是IDEA对项目进行war格式的打包之后解压后的目录结构：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220924162903624.png" alt="image-20220924162903624"></p></li><li><p>经过对比，我们注意到，开发时期的项目中，<strong>src&#x2F;main&#x2F;下面的java和resources文件夹都被（编译）打包到了生产包的WEB-INF&#x2F;classes&#x2F;目录下</strong>；而<strong>原来WEB-INF下面的views和web.xml则仍然还是在WEB-INF下面</strong>。同时<strong>由maven引入的依赖都被放入到了WEB-INF&#x2F;lib&#x2F;下面</strong>；最后，<strong>编译后的class文件和资源文件都放在了classes目录下</strong>:</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220924163303238.png" alt="image-20220924163303238"></p></li></ul><h2 id="真相大白"><a href="#真相大白" class="headerlink" title="真相大白"></a>真相大白</h2><ul><li>由于写classpath的地方找资源的时候是运行时环境，所以肯定是在打包后的资源结构中寻找资源，那么既然是class文件所在的路径，那么它的指代就只有一种可能，那就是<strong>WEB-INF&#x2F;classes文件夹</strong>，而这个文件夹，在开发时实际上是<strong>src&#x2F;main&#x2F;java文件夹和src&#x2F;main&#x2F;resources文件夹</strong>这两个文件夹，所以开发时和打包后classpath的指代就都清楚了。</li></ul><h1 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h1><h2 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h2><ul><li><p>MVC是一种<strong>软件架构的思想</strong>，将软件按照<strong>模型、视图、控制器</strong>来划分</p><ul><li><p>M：Model，模型层，指工程中的JavaBean，作用是<strong>处理数据</strong>，JavaBean分为两类：</p><ol><li>一类称为<strong>实体类Bean</strong>：专门<strong>存储业务数据</strong>的，如Student、User等</li><li>一类称为<strong>业务处理Bean</strong>：指Service或Dao对象，专门<strong>用于处理业务逻辑和数据访问</strong>。</li></ol></li><li><p>V：View，视图层，指工程中的html或jsp等页面，作用是<strong>与用户进行交互，展示数据</strong>。</p></li><li><p>C：Controller，控制层，指工程中的servlet，作用是<strong>接收请求和响应浏览器</strong></p></li></ul></li><li><p>MVC的简要工作流程：用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器。</p></li></ul><h2 id="什么是SpringMVC"><a href="#什么是SpringMVC" class="headerlink" title="什么是SpringMVC"></a>什么是SpringMVC</h2><ul><li>SpringMVC是Spring的一个后续产品，是Spring的一个子项目。</li><li>SpringMVC 是 <strong>Spring 为表述层开发提供的一整套完备的解决方案</strong>。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的<strong>首选方案</strong>。</li></ul><blockquote><p>注：三层架构分为<strong>表述层（或表示层）、业务逻辑层、数据访问层</strong>，<strong>表述层表示前台页面和后台servlet</strong></p></blockquote><h2 id="SpringMVC的特点"><a href="#SpringMVC的特点" class="headerlink" title="SpringMVC的特点"></a>SpringMVC的特点</h2><ul><li><strong>Spring 家族原生产品</strong>，与 IOC 容器等基础设施无缝对接</li><li><strong>基于原生的Servlet</strong>，通过了功能强大的<strong>前端控制器DispatcherServlet</strong>，对请求和响应进行统一处理</li><li>表述层各细分领域需要解决的问题<strong>全方位覆盖</strong>，提供<strong>全面解决方案</strong></li><li><strong>代码清新简洁</strong>，大幅度提升开发效率</li><li>内部组件化程度高，可插拔式组件<strong>即插即用</strong>，想要什么功能配置相应组件即可</li><li><strong>性能卓著</strong>，尤其适合现代大型、超大型互联网项目要求</li></ul><h1 id="用SpringMVC写出HelloWorld"><a href="#用SpringMVC写出HelloWorld" class="headerlink" title="用SpringMVC写出HelloWorld"></a>用SpringMVC写出HelloWorld</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>IDE：idea 2019.2</li><li>构建工具：maven3.5.4</li><li>服务器：tomcat7</li><li>Spring版本：5.3.1</li></ul><h2 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h2><ul><li><p>创建时添加web模块</p></li><li><p>打包方式：war</p></li><li><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringMVC --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ServletAPI --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Spring5和Thymeleaf整合包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.thymeleaf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-spring5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.12.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注：由于<strong>Maven的传递性</strong>，我们不必将所有需要的包全部配置依赖，而是<strong>配置最顶端的依赖，其他靠传递性导入</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220924093209658.png" alt="image-20220924093209658"></p></li></ul><h2 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h2><ul><li>注册SpringMVC的前端控制器DispatcherServlet</li></ul><h3 id="默认配置方式"><a href="#默认配置方式" class="headerlink" title="默认配置方式"></a>默认配置方式</h3><ul><li><p>此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt;servlet-name&gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">        但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="扩展配置方式"><a href="#扩展配置方式" class="headerlink" title="扩展配置方式"></a>扩展配置方式</h3><ul><li><p>可通过<strong>init-param</strong>标签<strong>设置SpringMVC配置文件的位置和名称</strong>，通过<strong>load-on-startup</strong>标签<strong>设置SpringMVC前端控制器DispatcherServlet的初始化时间</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- contextConfigLocation为固定值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment"> 作为框架的核心组件，在启动过程中有大量的初始化操作要做</span></span><br><span class="line"><span class="comment">而这些操作放在第一次请求时才执行会严重影响访问速度</span></span><br><span class="line"><span class="comment">因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springMVC<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        设置springMVC的核心控制器所能处理的请求的请求路径</span></span><br><span class="line"><span class="comment">        /所匹配的请求可以是/login或.html或.js或.css方式的请求路径</span></span><br><span class="line"><span class="comment">        但是/不能匹配.jsp请求路径的请求</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注：&lt;url-pattern&gt;标签中使用&#x2F;和&#x2F;*的区别：</p><p>&#x2F;所匹配的请求可以是&#x2F;login或.html或.js或.css方式的请求路径，但是&#x2F;不能匹配.jsp请求路径的请求</p><p>因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面</p><p>&#x2F;*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用&#x2F;*的写法</p></blockquote><h2 id="创建请求控制器"><a href="#创建请求控制器" class="headerlink" title="创建请求控制器"></a>创建请求控制器</h2><ul><li><p>由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此<strong>需要创建处理具体请求的类，即请求控制器（Controller）</strong></p></li><li><p>请求控制器中每一个处理请求的方法称为<strong>控制器方法</strong></p></li><li><p>因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过**@Controller注解将其标识为一个控制层组件<strong>，交给Spring的IOC容器管理，再配合</strong>@ComponentScan进行包扫描**，此时SpringMVC才能够识别控制器的存在。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建SpringMVC的配置文件"><a href="#创建SpringMVC的配置文件" class="headerlink" title="创建SpringMVC的配置文件"></a>创建SpringMVC的配置文件</h2><ul><li><p>这个之后被SpringBoot整合后可以使用配置类和SpringBoot的配置文件代替。</p></li><li><p>配置示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自动扫描包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.mvc.controller&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置Thymeleaf视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;order&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateEngine&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateResolver&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">&lt;!-- 视图前缀 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/templates/&quot;</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">                    <span class="comment">&lt;!-- 视图后缀 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.html&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;templateMode&quot;</span> <span class="attr">value</span>=<span class="string">&quot;HTML5&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;characterEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">   处理静态资源，例如html、js、css、jpg</span></span><br><span class="line"><span class="comment">  若只设置该标签，则只能访问静态资源，其他请求则无法访问</span></span><br><span class="line"><span class="comment">  此时必须设置&lt;mvc:annotation-driven/&gt;解决问题</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启mvc注解驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 处理响应中文内容乱码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultCharset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;supportedMediaTypes&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>text/html<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>application/json<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="测试HelloWorld"><a href="#测试HelloWorld" class="headerlink" title="测试HelloWorld"></a>测试HelloWorld</h2><h3 id="实现对首页的访问"><a href="#实现对首页的访问" class="headerlink" title="实现对首页的访问"></a>实现对首页的访问</h3><ul><li><p>在请求控制器中创建处理请求的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @RequestMapping注解：处理请求和控制器方法之间的映射关系</span></span><br><span class="line"><span class="comment">// @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径</span></span><br><span class="line"><span class="comment">// localhost:8080/springMVC/</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//设置视图名称</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="通过超链接跳转到指定页面"><a href="#通过超链接跳转到指定页面" class="headerlink" title="通过超链接跳转到指定页面"></a>通过超链接跳转到指定页面</h3><ul><li><p>在主页index.html中设置超链接：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/hello&#125;&quot;</span>&gt;</span>HelloWorld<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在请求控制器中创建处理请求的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">HelloWorld</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面</li></ul><h1 id="RequestMapping注解"><a href="#RequestMapping注解" class="headerlink" title="@RequestMapping注解"></a>@RequestMapping注解</h1><h2 id="RequestMapping注解的功能"><a href="#RequestMapping注解的功能" class="headerlink" title="@RequestMapping注解的功能"></a>@RequestMapping注解的功能</h2><ul><li>从注解名称上我们可以看到，@RequestMapping注解的作用就是<strong>将请求和处理请求的控制器方法关联起来，建立映射关系</strong>。</li><li>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</li></ul><h2 id="RequestMapping注解的位置"><a href="#RequestMapping注解的位置" class="headerlink" title="@RequestMapping注解的位置"></a>@RequestMapping注解的位置</h2><ul><li><p>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息</p></li><li><p>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestMappingController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时请求映射所映射的请求的请求路径为：/test/testRequestMapping</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/testRequestMapping&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="RequestMapping注解的value属性"><a href="#RequestMapping注解的value属性" class="headerlink" title="@RequestMapping注解的value属性"></a>@RequestMapping注解的value属性</h2><ul><li><p>@RequestMapping注解的value属性<strong>通过请求的请求地址匹配请求映射</strong></p></li><li><p>@RequestMapping注解的value属性是一个<strong>字符串类型的数组</strong>，表示<strong>该请求映射能够匹配多个请求地址所对应的请求</strong></p></li><li><p>@RequestMapping注解的value属性<strong>必须设置</strong>，至少通过请求地址匹配请求映射</p></li><li><p>代码示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRequestMapping&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/testRequestMapping<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="RequestMapping注解的method属性"><a href="#RequestMapping注解的method属性" class="headerlink" title="@RequestMapping注解的method属性"></a>@RequestMapping注解的method属性</h2><ul><li><p>@RequestMapping注解的method属性<strong>通过请求的请求方式（get或post）匹配请求映射</strong></p></li><li><p>@RequestMapping注解的method属性是一个<strong>RequestMethod类型的数组</strong>，表示<strong>该请求映射能够匹配多种请求方式的请求</strong>。</p></li><li><p>若当前请求的请求地址满足请求映射的value属性，但是<strong>请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported</strong></p></li><li><p>代码示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span>&gt;</span>测试@RequestMapping的value属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/test&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;,</span></span><br><span class="line"><span class="meta">        method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注：</p><p>1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解</p><p>处理get请求的映射–&gt;@GetMapping</p><p>处理post请求的映射–&gt;@PostMapping</p><p>处理put请求的映射–&gt;@PutMapping</p><p>处理delete请求的映射–&gt;@DeleteMapping</p><p>2、常用的请求方式有get，post，put，delete</p><p>但是目前浏览器只支持get和post，<strong>若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理</strong></p><p>若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到</p></blockquote><h2 id="RequestMapping注解的params属性"><a href="#RequestMapping注解的params属性" class="headerlink" title="@RequestMapping注解的params属性"></a>@RequestMapping注解的params属性</h2><ul><li><p>@RequestMapping注解的params属性<strong>通过请求的请求参数匹配请求映射</strong></p></li><li><p>@RequestMapping注解的params属性是一个<strong>字符串类型的数组</strong>，<strong>可以通过四种表达式设置请求参数和请求映射的匹配关系</strong>：</p><ol><li>“param”：要求请求映射所匹配的请求必须携带param请求参数</li><li>“!param”：要求请求映射所匹配的请求必须不能携带param请求参数</li><li>“param&#x3D;value”：要求请求映射所匹配的请求必须携带param请求参数且param&#x3D;value</li><li>“param!&#x3D;value”：要求请求映射所匹配的请求必须携带param请求参数但是param!&#x3D;value</li></ol></li><li><p>代码示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/test(username=&#x27;admin&#x27;,password=123456)&quot;</span>&gt;</span>测试@RequestMapping的params属性--&gt;/test<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(</span></span><br><span class="line"><span class="meta">        value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;</span></span><br><span class="line"><span class="meta">        ,method = &#123;RequestMethod.GET, RequestMethod.POST&#125;</span></span><br><span class="line"><span class="meta">        ,params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestMapping</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注：</p><p>若当前请求满足@RequestMapping注解的value和method属性，但是<strong>不满足params属性，此时页面会报错400</strong>：Parameter conditions “username, password!&#x3D;123456” not met for actual request parameters: username&#x3D;{admin}, password&#x3D;{123456}</p></blockquote><h2 id="RequestMapping注解的headers属性"><a href="#RequestMapping注解的headers属性" class="headerlink" title="@RequestMapping注解的headers属性"></a>@RequestMapping注解的headers属性</h2><ul><li><p>@RequestMapping注解的headers属性<strong>通过请求的请求头信息匹配请求映射</strong></p></li><li><p>@RequestMapping注解的headers属性是一个<strong>字符串类型的数组</strong>，可以通过四种表达式设置请求头信息和请求映射的匹配关系：</p><ol><li>“header”：要求请求映射所匹配的请求必须携带header请求头信息</li><li>“!header”：要求请求映射所匹配的请求必须不能携带header请求头信息</li><li>“header&#x3D;value”：要求请求映射所匹配的请求必须携带header请求头信息且header&#x3D;value</li><li>“header!&#x3D;value”：要求请求映射所匹配的请求必须携带header请求头信息且header!&#x3D;value</li></ol></li><li><p>若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到</p></li></ul><h2 id="SpringMVC支持ant风格的路径"><a href="#SpringMVC支持ant风格的路径" class="headerlink" title="SpringMVC支持ant风格的路径"></a>SpringMVC支持ant风格的路径</h2><ul><li>？：表示任意的单个字符</li><li>*：表示任意的0个或多个字符</li><li>**：表示任意的一层或多层目录，注意在使用**时，只能使用&#x2F;**&#x2F;xxx的方式</li></ul><h2 id="SpringMVC支持路径中的占位符"><a href="#SpringMVC支持路径中的占位符" class="headerlink" title="SpringMVC支持路径中的占位符"></a>SpringMVC支持路径中的占位符</h2><ul><li><p>原始方式：&#x2F;deleteUser?id&#x3D;1</p></li><li><p>rest方式：&#x2F;deleteUser&#x2F;1</p></li><li><p>SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中<strong>通过占位符{xxx}表示传输的数据</strong>，再<strong>通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参</strong></p></li><li><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testRest/1/admin&#125;&quot;</span>&gt;</span>测试路径中的占位符--&gt;/testRest<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRest</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> String id, <span class="meta">@PathVariable(&quot;username&quot;)</span> String username)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id:&quot;</span>+id+<span class="string">&quot;,username:&quot;</span>+username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终输出的内容为--&gt;id:1,username:admin</span></span><br></pre></td></tr></table></figure><h1 id="SpringMVC获取请求参数"><a href="#SpringMVC获取请求参数" class="headerlink" title="SpringMVC获取请求参数"></a>SpringMVC获取请求参数</h1></li></ul><h2 id="通过ServletAPI获取"><a href="#通过ServletAPI获取" class="headerlink" title="通过ServletAPI获取"></a>通过ServletAPI获取</h2><ul><li><p>将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象，然后使用HttpServletRequest类中封装的方法来获取请求参数。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParam</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="通过控制器方法的形参获取请求参数"><a href="#通过控制器方法的形参获取请求参数" class="headerlink" title="通过控制器方法的形参获取请求参数"></a>通过控制器方法的形参获取请求参数</h2><ul><li><p>在控制器方法的形参位置，<strong>设置和请求参数同名的形参</strong>，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参。</p></li><li><p>代码示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testParam(username=&#x27;admin&#x27;,password=123456)&#125;&quot;</span>&gt;</span>测试获取请求参数--&gt;/testParam<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testParam&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testParam</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注：</p><p>若请求所传输的请求参数中有<strong>多个同名的请求参数</strong>，此时可以在控制器方法的形参中<strong>设置字符串数组或者字符串类型的形参接收此请求参数</strong></p><p>若使用字符串数组类型的形参，此参数的数组中包含了每一个数据</p><p>若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果</p></blockquote><h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h2><ul><li>@RequestParam是<strong>将请求参数和控制器方法的形参创建映射关系</strong></li><li>@RequestParam注解一共有三个属性：<ol><li>value：指定为形参赋值的请求参数的参数名</li><li>required：设置是否必须传输此请求参数，默认值为true，若<strong>设置为true时，则当前请求必须传输value所指定的请求参数</strong>，若<strong>没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present</strong>；若<strong>设置为false，则当前请求不是必须传输value所指定的请求参数</strong>，若<strong>没有传输，则注解所标识的形参的值为null</strong></li><li>defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值</li></ol></li></ul><h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h2><ul><li>@RequestHeader是<strong>将请求头信息和控制器方法的形参创建映射关系</strong></li><li>@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</li></ul><h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h2><ul><li>@CookieValue是<strong>将cookie数据和控制器方法的形参创建映射关系</strong></li><li>@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam</li></ul><h2 id="通过POJO获取请求参数"><a href="#通过POJO获取请求参数" class="headerlink" title="通过POJO获取请求参数"></a>通过POJO获取请求参数</h2><ul><li><p>可以在控制器方法的形参位置<strong>设置一个实体类类型的形参</strong>，此时若浏览器传输的<strong>请求参数的参数名和实体类中的属性名一致</strong>，那么请求参数就会为此属性赋值</p></li><li><p>代码示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testpojo&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span>男<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span>女<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    邮箱：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testpojo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testPOJO</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终结果--&gt;User&#123;id=null, username=&#x27;张三&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="解决获取请求参数的乱码问题"><a href="#解决获取请求参数的乱码问题" class="headerlink" title="解决获取请求参数的乱码问题"></a>解决获取请求参数的乱码问题</h2><ul><li><p>有的时候我们获取到的请求参数是一堆乱码，这种情况一般是因为编码方式和解码方式不同造成的，因此我们<strong>需要对解码方式手动进行设置</strong>。</p></li><li><p>解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置springMVC的编码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceResponseEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：<strong>SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前</strong>，否则无效，因为<strong>一旦获取了其中一个请求参数，整体的编码格式就定下来了，再怎么设置编码格式也无济于事了</strong>。</p></blockquote><h1 id="域对象共享数据"><a href="#域对象共享数据" class="headerlink" title="域对象共享数据"></a>域对象共享数据</h1><h2 id="使用ServletAPI向request域对象共享数据"><a href="#使用ServletAPI向request域对象共享数据" class="headerlink" title="使用ServletAPI向request域对象共享数据"></a>使用ServletAPI向request域对象共享数据</h2><ul><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testServletAPI&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testServletAPI</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,servletAPI&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用ModelAndView向request域对象共享数据"><a href="#使用ModelAndView向request域对象共享数据" class="headerlink" title="使用ModelAndView向request域对象共享数据"></a>使用ModelAndView向request域对象共享数据</h2><ul><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelAndView&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testModelAndView</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ModelAndView有Model和View的功能</span></span><br><span class="line"><span class="comment">     * Model主要用于向请求域共享数据</span></span><br><span class="line"><span class="comment">     * View主要用于设置视图，实现页面跳转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">    <span class="comment">//向请求域共享数据</span></span><br><span class="line">    mav.addObject(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,ModelAndView&quot;</span>);</span><br><span class="line">    <span class="comment">//设置视图，实现页面跳转</span></span><br><span class="line">    mav.setViewName(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用Model向request域对象共享数据"><a href="#使用Model向request域对象共享数据" class="headerlink" title="使用Model向request域对象共享数据"></a>使用Model向request域对象共享数据</h2><ul><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testModel</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,Model&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用map向request域对象共享数据"><a href="#使用map向request域对象共享数据" class="headerlink" title="使用map向request域对象共享数据"></a>使用map向request域对象共享数据</h2><ul><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testMap</span><span class="params">(Map&lt;String, Object&gt; map)</span>&#123;</span><br><span class="line">    map.put(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,Map&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用ModelMap向request域对象共享数据"><a href="#使用ModelMap向request域对象共享数据" class="headerlink" title="使用ModelMap向request域对象共享数据"></a>使用ModelMap向request域对象共享数据</h2><ul><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testModelMap&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testModelMap</span><span class="params">(ModelMap modelMap)</span>&#123;</span><br><span class="line">    modelMap.addAttribute(<span class="string">&quot;testScope&quot;</span>, <span class="string">&quot;hello,ModelMap&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Model、ModelMap、Map的关系"><a href="#Model、ModelMap、Map的关系" class="headerlink" title="Model、ModelMap、Map的关系"></a>Model、ModelMap、Map的关系</h2><ul><li><p>Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的，他们之间的关系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Model</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ModelMap</span> <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;String, Object&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendedModelMap</span> <span class="keyword">extends</span> <span class="title class_">ModelMap</span> <span class="keyword">implements</span> <span class="title class_">Model</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BindingAwareModelMap</span> <span class="keyword">extends</span> <span class="title class_">ExtendedModelMap</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="向session域共享数据"><a href="#向session域共享数据" class="headerlink" title="向session域共享数据"></a>向session域共享数据</h2><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testSession&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testSession</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">    session.setAttribute(<span class="string">&quot;testSessionScope&quot;</span>, <span class="string">&quot;hello,session&quot;</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="向application域共享数据"><a href="#向application域共享数据" class="headerlink" title="向application域共享数据"></a>向application域共享数据</h2><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testApplication&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testApplication</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    application.setAttribute(<span class="string">&quot;testApplicationScope&quot;</span>, <span class="string">&quot;hello,application&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="SpringMVC的视图"><a href="#SpringMVC的视图" class="headerlink" title="SpringMVC的视图"></a>SpringMVC的视图</h1><ul><li>SpringMVC中的<strong>视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户</strong>。</li><li>SpringMVC视图的种类很多，默认有<strong>转发视图和重定向视图</strong>。</li><li>当工程引入jstl的依赖，转发视图会自动转换为JstlView</li><li>若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView</li></ul><h2 id="ThymeleafView"><a href="#ThymeleafView" class="headerlink" title="ThymeleafView"></a>ThymeleafView</h2><ul><li><p>当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称<strong>拼接视图前缀和视图后缀所得到的最终路径</strong>，会<strong>通过转发的方式实现跳转</strong>。</p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testHello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testHello</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/img002.png" alt="img002"></p></li></ul><h2 id="转发视图"><a href="#转发视图" class="headerlink" title="转发视图"></a>转发视图</h2><ul><li><p>SpringMVC中默认的<strong>转发视图是InternalResourceView</strong></p></li><li><p>SpringMVC中创建转发视图的情况：</p><p>当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过<strong>转发的方式</strong>实现跳转，例如”forward:&#x2F;“，”forward:&#x2F;employee”</p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testForward&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testForward</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/img003.png" alt="img003"></p></li></ul><h2 id="重定向视图"><a href="#重定向视图" class="headerlink" title="重定向视图"></a>重定向视图</h2><ul><li><p>SpringMVC中默认的<strong>重定向视图是RedirectView</strong></p></li><li><p>当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过<strong>重定向的方式</strong>实现跳转</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRedirect&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRedirect</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/testHello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/img004.png" alt="img004"></p></li></ul><blockquote><p>注：重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以&#x2F;开头，若是则会自动拼接上下文路径</p></blockquote><h2 id="视图控制器view-controller"><a href="#视图控制器view-controller" class="headerlink" title="视图控制器view-controller"></a>视图控制器view-controller</h2><ul><li><p>当控制器方法中，如果一个控制器方法仅仅用来实现页面跳转，即<strong>只需要返回视图名称时</strong>，可以不用写这个控制器方法转而将控制器方法使用view-controller标签进行表示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">path：设置处理的请求地址</span></span><br><span class="line"><span class="comment">view-name：设置请求地址所对应的视图名称</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/testView&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;success&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注：当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：&lt;mvc:annotation-driven &#x2F;&gt;</p></blockquote><h1 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h1><h2 id="RESTful简介"><a href="#RESTful简介" class="headerlink" title="RESTful简介"></a>RESTful简介</h2><ul><li>REST：<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer，<strong>表现层资源状态转移</strong>。</li></ul><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><ul><li>资源是一种看待服务器的方式，即，<strong>将服务器看作是由很多离散的资源组成</strong>。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。<strong>一个资源可以由一个或多个URI来标识</strong>。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。</li></ul><h3 id="资源的表述"><a href="#资源的表述" class="headerlink" title="资源的表述"></a>资源的表述</h3><ul><li>资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML&#x2F;XML&#x2F;JSON&#x2F;纯文本&#x2F;图片&#x2F;视频&#x2F;音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。</li></ul><h3 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h3><ul><li>状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。</li></ul><h2 id="RESTful的实现"><a href="#RESTful的实现" class="headerlink" title="RESTful的实现"></a>RESTful的实现</h2><ul><li><p>具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。</p></li><li><p>它们分别对应四种基本操作：<strong>GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源</strong>。</p></li><li><p><strong>REST 风格提倡 URL 地址使用统一的风格设计</strong>，从前到后各个单词使用斜杠分开，<strong>不使用问号键值对方式携带请求参数</strong>，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。</p></li><li><table><thead><tr><th>操作</th><th>传统方式</th><th>REST风格</th></tr></thead><tbody><tr><td>查询操作</td><td>getUserById?id&#x3D;1</td><td>user&#x2F;1–&gt;get请求方式</td></tr><tr><td>保存操作</td><td>saveUser</td><td>user–&gt;post请求方式</td></tr><tr><td>删除操作</td><td>deleteUser?id&#x3D;1</td><td>user&#x2F;1–&gt;delete请求方式</td></tr><tr><td>更新操作</td><td>updateUser</td><td>user–&gt;put请求方式</td></tr></tbody></table></li></ul><h2 id="HiddenHttpMethodFilter"><a href="#HiddenHttpMethodFilter" class="headerlink" title="HiddenHttpMethodFilter"></a>HiddenHttpMethodFilter</h2><ul><li><p>由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？</p></li><li><p>SpringMVC 提供了 <strong>HiddenHttpMethodFilter</strong> 帮助我们<strong>将 POST 请求转换为 DELETE 或 PUT 请求</strong></p></li><li><p><strong>HiddenHttpMethodFilter</strong> 处理put和delete请求的条件：</p><ol><li>当前请求的请求方式必须为post</li><li>当前请求必须传输请求参数_method</li></ol><p>满足以上条件，<strong>HiddenHttpMethodFilter</strong> 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此<strong>请求参数_method的值才是最终的请求方式</strong></p></li><li><p>在web.xml中注册<strong>HiddenHttpMethodFilter</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注：</p><p>目前为止，我们在SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter</p><p>在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter</p><p>原因：</p><ul><li><p>在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的</p></li><li><p>request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作</p></li><li><p>而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：<code>String paramValue = request.getParameter(this.methodParam);</code>所以如果HiddenHttpMethodFilter注册在前，会使CharacterEncodingFilter设置的字符集无效</p></li></ul></blockquote><h1 id="RESTful案例"><a href="#RESTful案例" class="headerlink" title="RESTful案例"></a>RESTful案例</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p>和传统 CRUD 一样，实现对员工信息的增删改查。</p></li><li><p>首先搭建环境</p></li><li><p>然后准备实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mvc.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Integer id;</span><br><span class="line">   <span class="keyword">private</span> String lastName;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String email;</span><br><span class="line">   <span class="comment">//1 male, 0 female</span></span><br><span class="line">   <span class="keyword">private</span> Integer gender;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> lastName;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> email;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.email = email;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Integer <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> gender;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(Integer gender)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.gender = gender;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(Integer id, String lastName, String email, Integer gender)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">      <span class="built_in">this</span>.id = id;</span><br><span class="line">      <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">      <span class="built_in">this</span>.email = email;</span><br><span class="line">      <span class="built_in">this</span>.gender = gender;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>准备DAO模拟数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mvc.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.mvc.bean.Employee;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeDao</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, Employee&gt; employees = <span class="literal">null</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">      employees = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Employee&gt;();</span><br><span class="line"></span><br><span class="line">      employees.put(<span class="number">1001</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;E-AA&quot;</span>, <span class="string">&quot;aa@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">      employees.put(<span class="number">1002</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1002</span>, <span class="string">&quot;E-BB&quot;</span>, <span class="string">&quot;bb@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">      employees.put(<span class="number">1003</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1003</span>, <span class="string">&quot;E-CC&quot;</span>, <span class="string">&quot;cc@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">      employees.put(<span class="number">1004</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1004</span>, <span class="string">&quot;E-DD&quot;</span>, <span class="string">&quot;dd@163.com&quot;</span>, <span class="number">0</span>));</span><br><span class="line">      employees.put(<span class="number">1005</span>, <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1005</span>, <span class="string">&quot;E-EE&quot;</span>, <span class="string">&quot;ee@163.com&quot;</span>, <span class="number">1</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">initId</span> <span class="operator">=</span> <span class="number">1006</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Employee employee)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(employee.getId() == <span class="literal">null</span>)&#123;</span><br><span class="line">         employee.setId(initId++);</span><br><span class="line">      &#125;</span><br><span class="line">      employees.put(employee.getId(), employee);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> Collection&lt;Employee&gt; <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> employees.values();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> employees.get(id);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">      employees.remove(id);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="功能清单"><a href="#功能清单" class="headerlink" title="功能清单"></a>功能清单</h2><table><thead><tr><th>功能</th><th>URL 地址</th><th>请求方式</th></tr></thead><tbody><tr><td>访问首页√</td><td>&#x2F;</td><td>GET</td></tr><tr><td>查询全部数据√</td><td>&#x2F;employee</td><td>GET</td></tr><tr><td>删除√</td><td>&#x2F;employee&#x2F;2</td><td>DELETE</td></tr><tr><td>跳转到添加数据页面√</td><td>&#x2F;toAdd</td><td>GET</td></tr><tr><td>执行保存√</td><td>&#x2F;employee</td><td>POST</td></tr><tr><td>跳转到更新数据页面√</td><td>&#x2F;employee&#x2F;2</td><td>GET</td></tr><tr><td>执行更新√</td><td>&#x2F;employee</td><td>PUT</td></tr></tbody></table><h2 id="具体功能：访问首页"><a href="#具体功能：访问首页" class="headerlink" title="具体功能：访问首页"></a>具体功能：访问首页</h2><ul><li><p>配置view-controller：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;index&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span>&gt;</span>访问员工信息<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="具体功能：查询所有员工数据"><a href="#具体功能：查询所有员工数据" class="headerlink" title="具体功能：查询所有员工数据"></a>具体功能：查询所有员工数据</h2><ul><li><p>控制器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getEmployeeList</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">    Collection&lt;Employee&gt; employeeList = employeeDao.getAll();</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employeeList&quot;</span>, employeeList);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建employee_list.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Employee Info<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dataTable&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;5&quot;</span>&gt;</span>Employee Info<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>lastName<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>email<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>gender<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>options(<span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/toAdd&#125;&quot;</span>&gt;</span>add<span class="tag">&lt;/<span class="name">a</span>&gt;</span>)<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;employee : $&#123;employeeList&#125;&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;deleteA&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;deleteEmployee&quot;</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>delete<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="具体功能：删除"><a href="#具体功能：删除" class="headerlink" title="具体功能：删除"></a>具体功能：删除</h2><ul><li><p>创建处理delete请求方式的表单：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;delete_form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;delete&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>有删除功能的超链接绑定点击事件：</p><ul><li><p>引入vue.js：<code>&lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt;</code></p></li><li><p>删除超链接：<code>&lt;a class=&quot;deleteA&quot; @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#39;/employee/&#39;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt;</code></p></li><li><p>通过vue处理点击事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#dataTable&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//event表示当前事件</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">deleteEmployee</span>:<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//通过id获取表单标签</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> delete_form = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;delete_form&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//将触发事件的超链接的href属性为表单的action属性赋值</span></span></span><br><span class="line"><span class="language-javascript">                delete_form.<span class="property">action</span> = event.<span class="property">target</span>.<span class="property">href</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//提交表单</span></span></span><br><span class="line"><span class="language-javascript">                delete_form.<span class="title function_">submit</span>();</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//阻止超链接的默认跳转行为</span></span></span><br><span class="line"><span class="language-javascript">                event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>控制器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">deleteEmployee</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>&#123;</span><br><span class="line">    employeeDao.delete(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="具体功能：跳转到添加数据页面"><a href="#具体功能：跳转到添加数据页面" class="headerlink" title="具体功能：跳转到添加数据页面"></a>具体功能：跳转到添加数据页面</h2><ul><li><p>配置view-controller：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:view-controller</span> <span class="attr">path</span>=<span class="string">&quot;/toAdd&quot;</span> <span class="attr">view-name</span>=<span class="string">&quot;employee_add&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:view-controller</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建employee_add.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Add Employee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    lastName:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    email:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    gender:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>male</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;add&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="具体功能：执行保存"><a href="#具体功能：执行保存" class="headerlink" title="具体功能：执行保存"></a>具体功能：执行保存</h2><ul><li><p>控制器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addEmployee</span><span class="params">(Employee employee)</span>&#123;</span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="具体功能：跳转到更新数据页面"><a href="#具体功能：跳转到更新数据页面" class="headerlink" title="具体功能：跳转到更新数据页面"></a>具体功能：跳转到更新数据页面</h2><ul><li><p>修改超链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;&#x27;/employee/&#x27;+$&#123;employee.id&#125;&#125;&quot;</span>&gt;</span>update<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>控制器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getEmployeeById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id, Model model)</span>&#123;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeDao.get(id);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;employee&quot;</span>, employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;employee_update&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建employee_update.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Update Employee<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/employee&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_method&quot;</span> <span class="attr">value</span>=<span class="string">&quot;put&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.id&#125;&quot;</span>&gt;</span></span><br><span class="line">    lastName:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.lastName&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    email:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">th:value</span>=<span class="string">&quot;$&#123;employee.email&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        th:field=&quot;$&#123;employee.gender&#125;&quot;可用于单选框或复选框的回显</span></span><br><span class="line"><span class="comment">        若单选框的value和employee.gender的值一致，则添加checked=&quot;checked&quot;属性</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    gender:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>male</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;$&#123;employee.gender&#125;&quot;</span>&gt;</span>female<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;update&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="具体功能：执行更新"><a href="#具体功能：执行更新" class="headerlink" title="具体功能：执行更新"></a>具体功能：执行更新</h2><ul><li><p>控制器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.PUT)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">updateEmployee</span><span class="params">(Employee employee)</span>&#123;</span><br><span class="line">    employeeDao.save(employee);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/employee&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h1><ul><li><p>HttpMessageConverter，<strong>报文信息转换器</strong>，将请求报文转换为Java对象，或将Java对象转换为响应报文</p></li><li><p>HttpMessageConverter提供了两个注解和两个类型：**@RequestBody，@ResponseBody，RequestEntity，ResponseEntity**</p></li></ul><h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h2><ul><li><p>@RequestBody可以<strong>获取请求体</strong>，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值。</p></li><li><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/testRequestBody&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestBody&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestBody</span><span class="params">(<span class="meta">@RequestBody</span> String requestBody)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestBody);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：requestBody:username&#x3D;admin&amp;password&#x3D;123456</p></li></ul><h2 id="RequestEntity"><a href="#RequestEntity" class="headerlink" title="RequestEntity"></a>RequestEntity</h2><ul><li><p>RequestEntity封装请求报文的一种类型，<strong>需要在控制器方法的形参中设置该类型的形参</strong>，当前请求的请求报文就会赋值给该形参，可以<strong>通过getHeaders()获取请求头信息，通过getBody()获取请求体信息</strong></p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testRequestEntity&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testRequestEntity</span><span class="params">(RequestEntity&lt;String&gt; requestEntity)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;requestHeader:&quot;</span>+requestEntity.getHeaders());</span><br><span class="line">    System.out.println(<span class="string">&quot;requestBody:&quot;</span>+requestEntity.getBody());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>requestHeader:[host:”localhost:8080”, connection:”keep-alive”, content-length:”27”, cache-control:”max-age&#x3D;0”, sec-ch-ua:”” Not A;Brand”;v&#x3D;”99”, “Chromium”;v&#x3D;”90”, “Google Chrome”;v&#x3D;”90””, sec-ch-ua-mobile:”?0”, upgrade-insecure-requests:”1”, origin:”<a href="http://localhost:8080&quot;">http://localhost:8080&quot;</a>, user-agent:”Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;90.0.4430.93 Safari&#x2F;537.36”]<br>requestBody:username&#x3D;admin&amp;password&#x3D;123</p></li></ul><h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><ul><li><p>@ResponseBody用于标识一个控制器方法，可以<strong>将该方法的返回值直接作为响应报文的响应体响应到浏览器</strong></p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseBody&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testResponseBody</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：浏览器页面显示success</p></li></ul><h2 id="SpringMVC处理json"><a href="#SpringMVC处理json" class="headerlink" title="SpringMVC处理json"></a>SpringMVC处理json</h2><ul><li><p>导入<strong>jackson</strong>的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在SpringMVC的核心配置文件中<strong>开启mvc的注解驱动</strong>：<code>&lt;mvc:annotation-driven /&gt;</code>，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串</p></li><li><p>在处理器方法上使用@ResponseBody注解进行标识</p></li><li><p><strong>将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testResponseUser&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">testResponseUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1001</span>,<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器的页面中展示的结果：{“id”:1001,”username”:”admin”,”password”:”123456”,”age”:23,”sex”:”男”}</p></li></ul><h2 id="SpringMVC处理ajax"><a href="#SpringMVC处理ajax" class="headerlink" title="SpringMVC处理ajax"></a>SpringMVC处理ajax</h2><ul><li><p>请求超链接：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/testAjax&#125;&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;testAjax&quot;</span>&gt;</span>testAjax<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>通过vue和axios处理点击事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/vue.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">th:src</span>=<span class="string">&quot;@&#123;/static/js/axios.min.js&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>:<span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">testAjax</span>:<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">url</span>:event.<span class="property">target</span>.<span class="property">href</span>,</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">params</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">username</span>:<span class="string">&quot;admin&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">                        <span class="attr">password</span>:<span class="string">&quot;123456&quot;</span></span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="title function_">alert</span>(response.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">                event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>控制器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testAjax&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAjax</span><span class="params">(String username, String password)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;,password:&quot;</span>+password);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello,ajax&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="RestController注解"><a href="#RestController注解" class="headerlink" title="@RestController注解"></a>@RestController注解</h2><ul><li>@RestController注解是springMVC提供的一个复合注解，<strong>标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解</strong></li></ul><h2 id="ResponseEntity"><a href="#ResponseEntity" class="headerlink" title="ResponseEntity"></a>ResponseEntity</h2><ul><li><strong>ResponseEntity用于控制器方法的返回值类型</strong>，该控制器方法的返回值就是响应到浏览器的响应报文</li></ul><h1 id="文件上传和下载"><a href="#文件上传和下载" class="headerlink" title="文件上传和下载"></a>文件上传和下载</h1><h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><ul><li><p>使用ResponseEntity实现下载文件的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testDown&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;<span class="type">byte</span>[]&gt; testResponseEntity(HttpSession session) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取ServletContext对象</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    <span class="comment">//获取服务器中文件的真实路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;/static/img/1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//创建输入流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line">    <span class="comment">//创建字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">    <span class="comment">//将流读到字节数组中</span></span><br><span class="line">    is.read(bytes);</span><br><span class="line">    <span class="comment">//创建HttpHeaders对象设置响应头信息</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; headers = <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">    <span class="comment">//设置要下载方式以及下载文件的名字</span></span><br><span class="line">    headers.add(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=1.jpg&quot;</span>);</span><br><span class="line">    <span class="comment">//设置响应状态码</span></span><br><span class="line">    <span class="type">HttpStatus</span> <span class="variable">statusCode</span> <span class="operator">=</span> HttpStatus.OK;</span><br><span class="line">    <span class="comment">//创建ResponseEntity对象</span></span><br><span class="line">    ResponseEntity&lt;<span class="type">byte</span>[]&gt; responseEntity = <span class="keyword">new</span> <span class="title class_">ResponseEntity</span>&lt;&gt;(bytes, headers, statusCode);</span><br><span class="line">    <span class="comment">//关闭输入流</span></span><br><span class="line">    is.close();</span><br><span class="line">    <span class="keyword">return</span> responseEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><ul><li>文件上传要求<strong>form表单的请求方式必须为post</strong>，并且<strong>添加属性enctype&#x3D;”multipart&#x2F;form-data”</strong></li><li>SpringMVC中<strong>将上传的文件封装到MultipartFile对象中</strong>，通过此对象可以获取文件相关信息</li></ul><h3 id="上传步骤"><a href="#上传步骤" class="headerlink" title="上传步骤"></a>上传步骤</h3><ul><li><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在SpringMVC的配置文件中添加配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>控制器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testUp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testUp</span><span class="params">(MultipartFile photo, HttpSession session)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获取上传的文件的文件名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> photo.getOriginalFilename();</span><br><span class="line">    <span class="comment">//处理文件重名问题</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">hzName</span> <span class="operator">=</span> fileName.substring(fileName.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    fileName = UUID.randomUUID().toString() + hzName;</span><br><span class="line">    <span class="comment">//获取服务器中photo目录的路径</span></span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">    <span class="type">String</span> <span class="variable">photoPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;photo&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(photoPath);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        file.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">finalPath</span> <span class="operator">=</span> photoPath + File.separator + fileName;</span><br><span class="line">    <span class="comment">//实现上传功能</span></span><br><span class="line">    photo.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(finalPath));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h1><h2 id="拦截器的配置"><a href="#拦截器的配置" class="headerlink" title="拦截器的配置"></a>拦截器的配置</h2><ul><li><p>SpringMVC中的拦截器<strong>用于拦截控制器方法的执行</strong></p></li><li><p>SpringMVC中的拦截器需要实现HandlerInterceptor</p></li><li><p>SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.interceptor.FirstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">&quot;/testRequestEntity&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;firstInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="拦截器的三个抽象方法"><a href="#拦截器的三个抽象方法" class="headerlink" title="拦截器的三个抽象方法"></a>拦截器的三个抽象方法</h2><ul><li>SpringMVC中的拦截器有三个抽象方法：<ol><li><strong>preHandle</strong>：<strong>控制器方法执行之前</strong>执行preHandle()，其boolean类型的返回值表示是否拦截或放行，<strong>返回true为放行</strong>，即调用控制器方法；<strong>返回false表示拦截</strong>，即不调用控制器方法。</li><li><strong>postHandle</strong>：<strong>控制器方法执行之后</strong>执行postHandle()</li><li><strong>afterComplation</strong>：处理完视图和模型数据，<strong>渲染视图完毕之后</strong>执行afterComplation()</li></ol></li></ul><h2 id="多个拦截器的执行顺序"><a href="#多个拦截器的执行顺序" class="headerlink" title="多个拦截器的执行顺序"></a>多个拦截器的执行顺序</h2><ul><li>若每个拦截器的preHandle()都返回true，此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：<strong>preHandle()会按照配置的顺序执行</strong>，而<strong>postHandle()和afterComplation()会按照配置的反序执行</strong>。（类似一个栈）</li><li>若某个拦截器的preHandle()返回了false，<strong>preHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行</strong>。</li></ul><h1 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h1><h2 id="基于配置的异常处理"><a href="#基于配置的异常处理" class="headerlink" title="基于配置的异常处理"></a>基于配置的异常处理</h2><ul><li><p>SpringMVC提供了一个<strong>处理控制器方法执行过程中所出现的异常的接口</strong>：HandlerExceptionResolver</p></li><li><p>HandlerExceptionResolver接口的实现类有：<strong>DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver</strong></p></li><li><p>SpringMVC提供了<strong>自定义的异常处理器SimpleMappingExceptionResolver</strong>，使用方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionMappings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        properties的键表示处理器方法执行过程中出现的异常</span></span><br><span class="line"><span class="comment">        properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ArithmeticException&quot;</span>&gt;</span>error<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;exceptionAttribute&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="基于注解的异常处理"><a href="#基于注解的异常处理" class="headerlink" title="基于注解的异常处理"></a>基于注解的异常处理</h2><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ControllerAdvice将当前类标识为异常处理的组件</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@ExceptionHandler用于设置所标识方法处理的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line">    <span class="comment">//ex表示当前请求处理中出现的异常对象</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handleArithmeticException</span><span class="params">(Exception ex, Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;ex&quot;</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="注解配置SpringMVC"><a href="#注解配置SpringMVC" class="headerlink" title="注解配置SpringMVC"></a>注解配置SpringMVC</h1><ul><li><strong>使用配置类和注解</strong>代替web.xml和SpringMVC配置文件的功能。</li></ul><h2 id="创建初始化类，代替web-xml"><a href="#创建初始化类，代替web-xml" class="headerlink" title="创建初始化类，代替web.xml"></a>创建初始化类，代替web.xml</h2><ul><li><p>在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，<strong>当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文</strong>。</p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebInit</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定spring的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定SpringMVC的配置类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定DispatcherServlet的映射规则，即url-pattern</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">encodingFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        encodingFilter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        encodingFilter.setForceRequestEncoding(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">HiddenHttpMethodFilter</span> <span class="variable">hiddenHttpMethodFilter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HiddenHttpMethodFilter</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建SpringConfig配置类，代替spring的配置文件"><a href="#创建SpringConfig配置类，代替spring的配置文件" class="headerlink" title="创建SpringConfig配置类，代替spring的配置文件"></a>创建SpringConfig配置类，代替spring的配置文件</h2><ul><li><p>主要是用到了**@Configuration注解 **，被这个注解修饰的类就是一个配置类，在里面做配置相当于在spring的配置文件中做配置。</p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"><span class="comment">//ssm整合之后，spring的配置信息写在此类中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建WebConfig配置类，代替SpringMVC的配置文件"><a href="#创建WebConfig配置类，代替SpringMVC的配置文件" class="headerlink" title="创建WebConfig配置类，代替SpringMVC的配置文件"></a>创建WebConfig配置类，代替SpringMVC的配置文件</h2><ul><li><p><strong>实现WebMvcConfigurer这个接口的类就是WebConfig配置类</strong>，在里面做的配置就相当于在SpringMVC的配置文件中做的配置。</p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//扫描组件</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.mvc.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启MVC注解驱动</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用默认的servlet处理静态资源</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置文件上传解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CommonsMultipartResolver <span class="title function_">multipartResolver</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonsMultipartResolver</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="type">FirstInterceptor</span> <span class="variable">firstInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FirstInterceptor</span>();</span><br><span class="line">        registry.addInterceptor(firstInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置视图控制</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span></span><br><span class="line"><span class="comment">        registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置异常映射</span></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123;</span></span><br><span class="line"><span class="comment">        SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver();</span></span><br><span class="line"><span class="comment">        Properties prop = new Properties();</span></span><br><span class="line"><span class="comment">        prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;);</span></span><br><span class="line"><span class="comment">        //设置异常映射</span></span><br><span class="line"><span class="comment">        exceptionResolver.setExceptionMappings(prop);</span></span><br><span class="line"><span class="comment">        //设置共享异常信息的键</span></span><br><span class="line"><span class="comment">        exceptionResolver.setExceptionAttribute(&quot;ex&quot;);</span></span><br><span class="line"><span class="comment">        resolvers.add(exceptionResolver);</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置生成模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ITemplateResolver <span class="title function_">templateResolver</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">WebApplicationContext</span> <span class="variable">webApplicationContext</span> <span class="operator">=</span> ContextLoader.getCurrentWebApplicationContext();</span><br><span class="line">        <span class="comment">// ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得</span></span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(</span><br><span class="line">                webApplicationContext.getServletContext());</span><br><span class="line">        templateResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">        templateResolver.setSuffix(<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line">        <span class="keyword">return</span> templateResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成模板引擎并为模板引擎注入模板解析器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SpringTemplateEngine <span class="title function_">templateEngine</span><span class="params">(ITemplateResolver templateResolver)</span> &#123;</span><br><span class="line">        <span class="type">SpringTemplateEngine</span> <span class="variable">templateEngine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringTemplateEngine</span>();</span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">        <span class="keyword">return</span> templateEngine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成视图解析器并未解析器注入模板引擎</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ViewResolver <span class="title function_">viewResolver</span><span class="params">(SpringTemplateEngine templateEngine)</span> &#123;</span><br><span class="line">        <span class="type">ThymeleafViewResolver</span> <span class="variable">viewResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThymeleafViewResolver</span>();</span><br><span class="line">        viewResolver.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        viewResolver.setTemplateEngine(templateEngine);</span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="测试功能"><a href="#测试功能" class="headerlink" title="测试功能"></a>测试功能</h2><ul><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="SpringMVC执行流程-1"><a href="#SpringMVC执行流程-1" class="headerlink" title="SpringMVC执行流程"></a>SpringMVC执行流程</h1><h2 id="SpringMVC常用组件"><a href="#SpringMVC常用组件" class="headerlink" title="SpringMVC常用组件"></a>SpringMVC常用组件</h2><h3 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h3><ul><li><strong>前端控制器</strong>，不需要工程师开发，由框架提供。</li><li>作用：<strong>统一处理请求和响应</strong>，整个流程控制的中心，由它调用其它组件处理用户的请求</li></ul><h3 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h3><ul><li><strong>处理器映射器</strong>，不需要工程师开发，由框架提供</li><li>作用：<strong>根据请求的url、method等信息查找Handler</strong>，即控制器方法</li></ul><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><ul><li><strong>处理器（控制器）</strong>，需要工程师开发</li><li>作用：在DispatcherServlet的控制下Handler<strong>对具体的用户请求进行处理</strong></li></ul><h3 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h3><ul><li><strong>处理器适配器</strong>，不需要工程师开发，由框架提供</li><li>作用：通过HandlerAdapter<strong>对处理器（控制器方法）进行执行</strong></li></ul><h3 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h3><ul><li><strong>视图解析器</strong>，不需要工程师开发，由框架提供</li><li>作用：<strong>进行视图解析，得到相应的视图</strong>，例如：ThymeleafView、InternalResourceView、RedirectView</li></ul><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><ul><li><strong>视图</strong>，需要工程师开发</li><li>作用：<strong>将模型数据通过页面展示给用户</strong></li></ul><h2 id="DispatcherServlet初始化过程"><a href="#DispatcherServlet初始化过程" class="headerlink" title="DispatcherServlet初始化过程"></a>DispatcherServlet初始化过程</h2><ul><li>DispatcherServlet 本质上是一个 Servlet，所以天然的<strong>遵循 Servlet 的生命周期</strong>。所以<strong>宏观上是 Servlet 生命周期来进行调度</strong>。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/img005.png" alt="img005"></p><h3 id="初始化WebApplicationContext"><a href="#初始化WebApplicationContext" class="headerlink" title="初始化WebApplicationContext"></a>初始化WebApplicationContext</h3><ul><li><p>所在类：<strong>org.springframework.web.servlet.FrameworkServlet</strong></p></li><li><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">initWebApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">rootContext</span> <span class="operator">=</span></span><br><span class="line">        WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    <span class="type">WebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.webApplicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">        wac = <span class="built_in">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">cwac</span> <span class="operator">=</span> (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">                <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">                    <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">        <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">        <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">        <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">        wac = findWebApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">        <span class="comment">// 创建WebApplicationContext</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.refreshEventReceived) &#123;</span><br><span class="line">        <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">        <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">        <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">            <span class="comment">// 刷新WebApplicationContext</span></span><br><span class="line">            onRefresh(wac);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">        <span class="comment">// 将IOC容器在应用域共享</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> getServletContextAttributeName();</span><br><span class="line">        getServletContext().setAttribute(attrName, wac);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建WebApplicationContext"><a href="#创建WebApplicationContext" class="headerlink" title="创建WebApplicationContext"></a>创建WebApplicationContext</h3><ul><li><p>所在类：<strong>org.springframework.web.servlet.FrameworkServlet</strong></p></li><li><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> WebApplicationContext <span class="title function_">createWebApplicationContext</span><span class="params">(<span class="meta">@Nullable</span> ApplicationContext parent)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApplicationContextException</span>(</span><br><span class="line">            <span class="string">&quot;Fatal initialization error in servlet with name &#x27;&quot;</span> + getServletName() +</span><br><span class="line">            <span class="string">&quot;&#x27;: custom WebApplicationContext class [&quot;</span> + contextClass.getName() +</span><br><span class="line">            <span class="string">&quot;] is not of type ConfigurableWebApplicationContext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过反射创建 IOC 容器对象</span></span><br><span class="line">    <span class="type">ConfigurableWebApplicationContext</span> <span class="variable">wac</span> <span class="operator">=</span></span><br><span class="line">        (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line"></span><br><span class="line">    wac.setEnvironment(getEnvironment());</span><br><span class="line">    <span class="comment">// 设置父容器</span></span><br><span class="line">    wac.setParent(parent);</span><br><span class="line">    <span class="type">String</span> <span class="variable">configLocation</span> <span class="operator">=</span> getContextConfigLocation();</span><br><span class="line">    <span class="keyword">if</span> (configLocation != <span class="literal">null</span>) &#123;</span><br><span class="line">        wac.setConfigLocation(configLocation);</span><br><span class="line">    &#125;</span><br><span class="line">    configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="DispatcherServlet初始化策略"><a href="#DispatcherServlet初始化策略" class="headerlink" title="DispatcherServlet初始化策略"></a>DispatcherServlet初始化策略</h3><ul><li><p>FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件</p></li><li><p>所在类：<strong>org.springframework.web.servlet.DispatcherServlet</strong></p></li><li><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">   initMultipartResolver(context);</span><br><span class="line">   initLocaleResolver(context);</span><br><span class="line">   initThemeResolver(context);</span><br><span class="line">   initHandlerMappings(context);</span><br><span class="line">   initHandlerAdapters(context);</span><br><span class="line">   initHandlerExceptionResolvers(context);</span><br><span class="line">   initRequestToViewNameTranslator(context);</span><br><span class="line">   initViewResolvers(context);</span><br><span class="line">   initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="DispatcherServlet调用组件处理请求"><a href="#DispatcherServlet调用组件处理请求" class="headerlink" title="DispatcherServlet调用组件处理请求"></a>DispatcherServlet调用组件处理请求</h2><h3 id="processRequest"><a href="#processRequest" class="headerlink" title="processRequest()"></a>processRequest()</h3><ul><li><p>FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)</p></li><li><p>所在类：<strong>org.springframework.web.servlet.FrameworkServlet</strong></p></li><li><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">failureCause</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">LocaleContext</span> <span class="variable">previousLocaleContext</span> <span class="operator">=</span> LocaleContextHolder.getLocaleContext();</span><br><span class="line">    <span class="type">LocaleContext</span> <span class="variable">localeContext</span> <span class="operator">=</span> buildLocaleContext(request);</span><br><span class="line"></span><br><span class="line">    <span class="type">RequestAttributes</span> <span class="variable">previousAttributes</span> <span class="operator">=</span> RequestContextHolder.getRequestAttributes();</span><br><span class="line">    <span class="type">ServletRequestAttributes</span> <span class="variable">requestAttributes</span> <span class="operator">=</span> buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> <span class="title class_">RequestBindingInterceptor</span>());</span><br><span class="line"></span><br><span class="line">    initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写</span></span><br><span class="line">        doService(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException | IOException ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        failureCause = ex;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Request processing failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">            requestAttributes.requestCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">        logResult(request, response, failureCause, asyncManager);</span><br><span class="line">        publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="doService"><a href="#doService" class="headerlink" title="doService()"></a>doService()</h3><ul><li><p>所在类：<strong>org.springframework.web.servlet.DispatcherServlet</strong></p></li><li><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    logRequest(request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Keep a snapshot of the request attributes in case of an include,</span></span><br><span class="line">    <span class="comment">// to be able to restore the original attributes after the include.</span></span><br><span class="line">    Map&lt;String, Object&gt; attributesSnapshot = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</span><br><span class="line">        attributesSnapshot = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</span><br><span class="line">        <span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">attrName</span> <span class="operator">=</span> (String) attrNames.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;</span><br><span class="line">                attributesSnapshot.put(attrName, request.getAttribute(attrName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make framework objects available to handlers and view objects.</span></span><br><span class="line">    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</span><br><span class="line">    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.localeResolver);</span><br><span class="line">    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="built_in">this</span>.themeResolver);</span><br><span class="line">    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.flashMapManager != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">FlashMap</span> <span class="variable">inputFlashMap</span> <span class="operator">=</span> <span class="built_in">this</span>.flashMapManager.retrieveAndUpdate(request, response);</span><br><span class="line">        <span class="keyword">if</span> (inputFlashMap != <span class="literal">null</span>) &#123;</span><br><span class="line">            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> <span class="title class_">FlashMap</span>());</span><br><span class="line">        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="built_in">this</span>.flashMapManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">RequestPath</span> <span class="variable">requestPath</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123;</span><br><span class="line">        requestPath = ServletRequestPathUtils.parseAndCache(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 处理请求和响应</span></span><br><span class="line">        doDispatch(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Restore the original attribute snapshot, in case of an include.</span></span><br><span class="line">            <span class="keyword">if</span> (attributesSnapshot != <span class="literal">null</span>) &#123;</span><br><span class="line">                restoreAttributesAfterInclude(request, attributesSnapshot);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestPath != <span class="literal">null</span>) &#123;</span><br><span class="line">            ServletRequestPathUtils.clearParsedRequestPath(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="doDispatcher"><a href="#doDispatcher" class="headerlink" title="doDispatcher()"></a>doDispatcher()</h3><ul><li><p>所在类：<strong>org.springframework.web.servlet.DispatcherServlet</strong></p></li><li><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">processedRequest</span> <span class="operator">=</span> request;</span><br><span class="line">    <span class="type">HandlerExecutionChain</span> <span class="variable">mappedHandler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">multipartRequestParsed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">WebAsyncManager</span> <span class="variable">asyncManager</span> <span class="operator">=</span> WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            mappedHandler：调用链</span></span><br><span class="line"><span class="comment">                包含handler、interceptorList、interceptorIndex</span></span><br><span class="line"><span class="comment">            handler：浏览器发送的请求所匹配的控制器方法</span></span><br><span class="line"><span class="comment">            interceptorList：处理控制器方法的所有拦截器集合</span></span><br><span class="line"><span class="comment">            interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="literal">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">           <span class="comment">// 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法</span></span><br><span class="line">            <span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isGet</span> <span class="operator">=</span> <span class="string">&quot;GET&quot;</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">&quot;HEAD&quot;</span>.equals(method)) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastModified</span> <span class="operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用拦截器的preHandle()</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            <span class="comment">// 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">// 调用拦截器的postHandle()</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 后续处理：处理模型数据和渲染视图</span></span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                               <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="processDispatchResult"><a href="#processDispatchResult" class="headerlink" title="processDispatchResult()"></a>processDispatchResult()</h3><ul><li><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv,</span></span><br><span class="line"><span class="params">                                   <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">errorView</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">            logger.debug(<span class="string">&quot;ModelAndViewDefiningException encountered&quot;</span>, exception);</span><br><span class="line">            mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> (mappedHandler != <span class="literal">null</span> ? mappedHandler.getHandler() : <span class="literal">null</span>);</span><br><span class="line">            mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">            errorView = (mv != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Did the handler return a view to render?</span></span><br><span class="line">    <span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">        <span class="comment">// 处理模型数据和渲染视图</span></span><br><span class="line">        render(mv, request, response);</span><br><span class="line">        <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">            WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;No view rendering, null ModelAndView returned.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">        <span class="comment">// Concurrent handling started during a forward</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mappedHandler != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Exception (if any) is already handled..</span></span><br><span class="line">        <span class="comment">// 调用拦截器的afterCompletion()</span></span><br><span class="line">        mappedHandler.triggerAfterCompletion(request, response, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h2><ol><li><p>用户向服务器发送请求，<strong>请求被SpringMVC 前端控制器 DispatcherServlet捕获</strong>。</p></li><li><p><strong>DispatcherServlet对请求URL进行解析</strong>，得到请求资源标识符（URI），判断请求URI对应的映射：</p><ul><li><p>若映射不存在：</p><p>i. 再判断是否配置了mvc:default-servlet-handler</p><p>ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/img006.png" alt="img006"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/img007.png" alt="img007"></p><p>iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/img008.png" alt="img008"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/img009.png" alt="img009"></p></li><li><p>若映射存在，则会继续执行下面的流程</p></li></ul></li><li><p>根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后<strong>以HandlerExecutionChain执行链对象的形式返回</strong>。</p></li><li><p>DispatcherServlet 根据获得的Handler，<strong>选择一个合适的HandlerAdapter</strong>。</p></li><li><p>如果成功获得HandlerAdapter，此时将<strong>开始执行拦截器的preHandler(…)方法（顺序）</strong></p></li><li><p>提取Request中的模型数据，填充Handler入参，<strong>开始执行Handler（Controller)方法，处理请求</strong>。<strong>在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作</strong>：</p><ul><li><strong>HttpMessageConveter</strong>： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</li><li><strong>数据转换</strong>：对请求消息进行数据转换。如String转换成Integer、Double等</li><li><strong>数据格式化</strong>：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</li><li><strong>数据验证</strong>： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</li></ul></li><li><p>Handler执行完成后，<strong>向DispatcherServlet 返回一个ModelAndView对象</strong>。</p></li><li><p>此时将<strong>开始执行拦截器的postHandle(…)方法（逆序）</strong>。</p></li><li><p>根据返回的ModelAndView（<strong>此时会判断是否存在异常</strong>：如果存在异常，则执行HandlerExceptionResolver进行异常处理）<strong>选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图</strong>。</p></li><li><p>渲染视图完毕<strong>执行拦截器的afterCompletion(…)方法（逆序）</strong>。</p></li><li><p><strong>将渲染结果返回给客户端</strong>。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;ol&gt;
&lt;li&gt;classpath指什么？&lt;/li&gt;
&lt;li&gt;属性和成员变量的区别？&lt;/li&gt;
&lt;li&gt;servletContext中getRealPath方法的理解？找到开发路径的文</summary>
      
    
    
    
    
    <category term="SpringMVC" scheme="https://konjacor.github.io/tags/SpringMVC/"/>
    
    <category term="SSM" scheme="https://konjacor.github.io/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>搭建问卷系统的基本流程</title>
    <link href="https://konjacor.github.io/2022/09/03/%E6%90%AD%E5%BB%BA%E9%97%AE%E5%8D%B7%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/"/>
    <id>https://konjacor.github.io/2022/09/03/%E6%90%AD%E5%BB%BA%E9%97%AE%E5%8D%B7%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/</id>
    <published>2022-09-03T13:17:51.000Z</published>
    <updated>2022-12-20T12:11:43.204Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><ul><li>实验室最近要做个新的项目，是在实验室老项目的基础上增加一个问卷系统，我是其中的开发者之一，所以想要借这个机会，写个博客，熟悉一下软件项目从头开始的搭建流程，学习一下过程中用到的新的技术和思想。</li></ul><h1 id="需求分析阶段"><a href="#需求分析阶段" class="headerlink" title="需求分析阶段"></a>需求分析阶段</h1><ul><li><p>在这个阶段，主要是分析一下将要做的软件的基本功能，可以画一个数据流图(DFD)来说明我们应该”怎么做”，一张质量好的DFD可以让开发事半功倍（我画的比较拉），矩形为实体，双横线为数据存储的地方，箭头代表数据的流向，圆形代表对数据的处理。：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220903212534563.png" alt="image-20220903212534563"></p></li><li><p>然后可以画一下ER图来说明数据库各表之间的逻辑和各表的设计规范，ER图可以画成描述型的或者是图解型的，大文本最好用text类型：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220903212948506.png" alt="image-20220903212948506"></p></li><li><p>然后就是要根据之前画好的ER图开始建各种数据库的实体表，不过在这之前出现了一些问题，就是由于历史遗留原因，用户的表是两种类型的，这两种类型的表分别对应着不同的人群，但是在这个项目中，如果每次都需要联表增删改查未免有些不方便，因此我们想到<strong>可以将两个表中相同的部分抽取出来做成一个视图，然后放到redis里面供操作</strong>，但是这样又出现了一个问题，由于视图的select语句使用到了union，所以这就使得这个视图不支持增删改操作了，所以暂时是建立一个视图仅用于查询，添加操作还是对原表进行操作。</p></li></ul><h1 id="后端基本crud的搭建"><a href="#后端基本crud的搭建" class="headerlink" title="后端基本crud的搭建"></a>后端基本crud的搭建</h1><ul><li><p>首先用代码生成器生成相关表的代码，没什么好说的。</p></li><li><p>然后就是编写每个表对应的基础crud操作，要注意<strong>controller层是面向service层进行编程</strong>，所以与service层无关的操作尽量不要出现在controller层中，要将具体的操作细节写道service层中。</p><h2 id="自动注释生成"><a href="#自动注释生成" class="headerlink" title="自动注释生成"></a>自动注释生成</h2></li><li><p>在编写代码的时候，可以在每个api上用**IDEA的自动生成注释的功能(敲&#x2F;**加回车)**，通过注释来说明这个api的参数、返回值的具体信息。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220905170140754.png" alt="image-20220905170140754"></p></li></ul><h1 id="编写后端业务接口"><a href="#编写后端业务接口" class="headerlink" title="编写后端业务接口"></a>编写后端业务接口</h1><ul><li>根据前端具体的需求来完善后端接口，复杂的sql语句需要依靠mybatis框架来实现。</li></ul><h2 id="一对多的查询需求实现"><a href="#一对多的查询需求实现" class="headerlink" title="一对多的查询需求实现"></a>一对多的查询需求实现</h2><ul><li><p>业务需求中有一个需求是通过问卷id来查询id对应问卷的结构，由于一个问卷对应着多个问题，每个问题又可能对应着多个选项，因此这是一个<strong>一对多的查询需求</strong>，可以使用mybatis的分步查询来实现。</p></li><li><p>在编写代码之前先要在springboot的配置文件中对mybatisplus进行一些配置，要注意在配置实体类别名的时候，后面的路径不用引号包裹，直接写，包裹反而会报错，这个可能是properties文件的规范：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置mybatis延迟加载和下划线命名自动映射为驼峰命名</span></span><br><span class="line"><span class="attr">mybatis-plus.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#按需加载</span></span><br><span class="line"><span class="comment">#mybatis-plus.configuration.lazy-loading-enabled=true</span></span><br><span class="line"><span class="comment">#mybatis-plus.configuration.aggressive-lazy-loading=false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#设置entity下的实体类的别名为其类名而非全类名</span></span><br><span class="line"><span class="attr">mybatis-plus.type-aliases-package</span>=<span class="string">com.sdnu.iosclub.qvs.entity</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#开mybatisplus的日志</span></span><br><span class="line"><span class="attr">mybatis-plus.configuration.log-impl</span>=<span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure></li><li><p>然后controller-service那一套都比较熟练了，主要看看mapper和mapper的配置文件，通过源码可以分析出service自带的baseMapper实际上就是那个service对应表的mapper，通过直接调用mapper中的方法可以实现crud功能，不过不知道mapper是在哪通过类似cglib代理的方式产生实现类的。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909150006488.png" alt="image-20220909150006488"></p></li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909150018123.png" alt="image-20220909150018123"></p><ul><li><p>然后就是在mapper中写接口，然后再mapper的配置文件中配置sql语句，写接口的时候注意<strong>属性用@param(“”)注解来修饰</strong>，比较规范，然后就是在写resultMap的时候，其<strong>type属性为返回值要映射到的实体类</strong>，这个由于写resultMap的目的就是要自定义字段和属性的映射，所以就算返回值是一个带泛型的list或者别的什么东西，这个<strong>type也要写泛型的类型</strong>，因为毕竟要做映射，你传个list让人家怎么映射嘛。还有就是在写resultMap的时候，如果别的字段能保证映射到属性上，那么在resultMap里面对应的配置可以省略不写，但是<strong>id属性必须在resultMap中显式声明</strong>，不然会出现id查不出来的情况。还有就是<strong>collection或者association标签中的column属性是用来指明以当前实体的什么属性作为参数来执行下一步的查询，所以写的应该是当前实体中的具有唯一性的属性</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;getSurveyInfoByIdResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;QvsSurvey&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span></span></span><br><span class="line"><span class="tag">            <span class="attr">property</span>=<span class="string">&quot;questions&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">column</span>=<span class="string">&quot;id&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">select</span>=<span class="string">&quot;com.sdnu.iosclub.qvs.mapper.QvsQuestionMapper.getQuestionById&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">ofType</span>=<span class="string">&quot;QvsQuestion&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getSurveyInfoById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;getSurveyInfoByIdResultMap&quot;</span>&gt;</span></span><br><span class="line">    select * from qvs_survey where id = #&#123;id&#125; order by update_time desc</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>由于查出来的question要放到QvsSurvey的实体类中，但是实体类中没有这个属性，所以要添加一个，其他的类也应该如法炮制，但是添加之后又会出现默认的查询方法中会将自定义添加的属性作为字段来填充sql语句，所以要使用**@TableField(exist &#x3D; false)**显式声明一下忽略该成员变量和数据库字段之间的映射，来表明自定义添加的这个属性不在数据库中：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909151056743.png" alt="image-20220909151056743"></p></li><li><p>然后按照上面的注意事项来完成这个<strong>一对多的分步查询功能</strong>就好了，下面给出三个mapper接口和三个xml文件的部分内容：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909151705423.png" alt="image-20220909151705423"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909151750148.png" alt="image-20220909151750148"></p></li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909151832747.png" alt="image-20220909151832747"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909151846534.png" alt="image-20220909151846534"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909151904457.png" alt="image-20220909151904457"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220909151915488.png" alt="image-20220909151915488"></p><h2 id="多对一的需求实现"><a href="#多对一的需求实现" class="headerlink" title="多对一的需求实现"></a>多对一的需求实现</h2><ul><li><p>主要是用mybatis配置文件中的resultMap中的<strong>association标签</strong>来实现，属性啥的和上面写到的collection差不多，只不过<strong>ofType要改成javaType代表返回值类型</strong>，如果要从别的地方查实体中的某个属性，可以用这个标签。</p></li><li><p>而且association标签好像必须在collection标签的上面</p></li><li><p>实例：要查question的数量</p><ol><li><p>在resultMap中写好association</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220912180420467.png" alt="image-20220912180420467"></p></li><li><p>在question mapper中写好对应的方法并绑定到之前的association中（<strong>在方法名上右键点击Copy-Copy Reference可以直接复制到全类名</strong>）</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220912180547798.png" alt="image-20220912180547798"><br>3.在question mapper的配置文件中写好实现</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220912180813976.png" alt="image-20220912180813976"></p></li></ol></li></ul><h1 id="打通前端和后端的连接"><a href="#打通前端和后端的连接" class="headerlink" title="打通前端和后端的连接"></a>打通前端和后端的连接</h1><h2 id="关于在测试阶段启动nacos的相关事项"><a href="#关于在测试阶段启动nacos的相关事项" class="headerlink" title="关于在测试阶段启动nacos的相关事项"></a>关于在测试阶段启动nacos的相关事项</h2><ul><li>在测试阶段启动nacos需要进入nacos的bin目录下使用命令**.&#x2F;startup.cmd -m standalone**进行单机启动，因为在nacos1.4以上默认是以集群启动，所以直接启动是以集群启动，需要手动使用以上命令进行单机启动以进行测试。</li></ul><h2 id="封装网络请求类"><a href="#封装网络请求类" class="headerlink" title="封装网络请求类"></a>封装网络请求类</h2><ul><li><p>主要是用flutter框架作移动端的开发，flutter中有个关于网络请求的库是dio，这个库用起来很方便，我写了个很捞的封装了dio库的请求类，配置单独一个文件，肯定有很多问题，之后再改吧：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">String</span> qvsHost = <span class="string">&quot;http://127.0.0.1:8003/&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:dio/dio.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;Config.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Future&lt;T&gt; request&lt;T&gt;(<span class="built_in">String</span> url,</span><br><span class="line">      &#123;<span class="built_in">String</span> method = <span class="string">&#x27;get&#x27;</span>, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;? params&#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    url = Config.qvsHost + url;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.toLowerCase().compareTo(<span class="string">&quot;get&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        Response response = <span class="keyword">await</span> Dio().<span class="keyword">get</span>(url,</span><br><span class="line">            queryParameters: params,</span><br><span class="line">            options:</span><br><span class="line">                <span class="keyword">new</span> Options(contentType: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>));</span><br><span class="line">        <span class="comment">//print(response);</span></span><br><span class="line">        <span class="keyword">return</span> response.data;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.toLowerCase().compareTo(<span class="string">&quot;post&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//print(params);</span></span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> Dio().post(url,</span><br><span class="line">            data: params,</span><br><span class="line">            options:</span><br><span class="line">                <span class="keyword">new</span> Options(contentType: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>));<span class="comment">//数据类型</span></span><br><span class="line">        <span class="keyword">return</span> response.data;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.toLowerCase().compareTo(<span class="string">&quot;put&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> Dio().put(url,</span><br><span class="line">            data: params,</span><br><span class="line">            options:</span><br><span class="line">                <span class="keyword">new</span> Options(contentType: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>));</span><br><span class="line">        <span class="keyword">return</span> response.data;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.toLowerCase().compareTo(<span class="string">&quot;delete&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> Dio().delete(url,</span><br><span class="line">            data: params,</span><br><span class="line">            options:</span><br><span class="line">                <span class="keyword">new</span> Options(contentType: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>));</span><br><span class="line">        <span class="keyword">return</span> response.data;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> Exception();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">return</span> Future.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return Future.error(new Exception());</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="出现跨域问题"><a href="#出现跨域问题" class="headerlink" title="出现跨域问题"></a>出现跨域问题</h2><ul><li><p>然后就是通过调用写好的网络请求接口来实现对接口的访问并拿到返回的数据，但是在调用本机的接口时出现了这个问题：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220918225354061.png" alt="image-20220918225354061"></p></li></ul><p>​后来一查是个跨域的问题，在后端controller代码中加上允许跨域访问的注解（**@CrossOrigin**）即可。</p><p>​<img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220918225507786.png" alt="image-20220918225507786"></p><h2 id="前端处理后端返回的数据"><a href="#前端处理后端返回的数据" class="headerlink" title="前端处理后端返回的数据"></a>前端处理后端返回的数据</h2><ul><li><p>然后就是处理返回的数据，由于封装的网络请求方法的返回值是个Future&lt;T&gt;，所以在调用这个方法的时候应该使用异步方法的处理方式进行处理，通过**.then((res) &#x3D;&gt; {})<strong>来获取到返回值，返回值是json格式，需要通过解析成dart对象后才能使用，但是在对返回值进行</strong>json.decode()**的时候却出现了问题：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220919090947141.png" alt="image-20220919090947141"></p><p>这意思大概是形参是String类型的，但是实参是_JsonMap类型的，这个_JsonMap网上也没查到相关的资料，初步推测<strong>它本身就是一个dart的map对象</strong>，可以直接使用操作map的方式操作里面的数据，然后我就试了试，结果还真是这样，通过map的访问方式，访问到其中的列表，可以直接赋值给另外一个List类型的变量：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220919091148010.png" alt="image-20220919091148010"></p></li><li><p>经过上面的步骤之后发现<strong>dataList总是取不到值</strong>，因为<strong>异步内容在页面渲染之后到达</strong>，所以页面渲染的时候dataList就是空，什么也渲染不出来，这种情况<strong>应该在异步内容到达后让页面重新渲染</strong>，应该<strong>使用setState()方法来对dataList进行赋值</strong>，<strong>这样在dataList赋值后会让页面重新渲染</strong>，这样页面就能渲染出异步请求的数据了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220919105528017.png" alt="image-20220919105528017"></p></li></ul><h2 id="后端接收前端发送的数据（List类型）"><a href="#后端接收前端发送的数据（List类型）" class="headerlink" title="后端接收前端发送的数据（List类型）"></a>后端接收前端发送的数据（List类型）</h2><ul><li><p>做完问卷填写页面之后要写提交页面的逻辑，由于后端的添加结果的方法是批量添加，所以不得不去<strong>发送一个经过json.encode之后的List集合</strong>，但是后端怎么接收这个List集合呢，上网上搜了搜，是<strong>用@RequestBody先接收请求体的json数据放到String类型的形参中</strong>，然后<strong>再用fastjson的相关方法来将这个json数据解析成List集合</strong>，然后就能用了，以下是代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 批量添加选择题答题结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data 选择题答题结果集合json数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 是否添加成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;批量添加选择题答题结果&quot;)</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;addResultByBatch&quot;)</span></span><br><span class="line"><span class="keyword">public</span> R <span class="title function_">addResultByBatch</span><span class="params">(<span class="meta">@RequestBody</span> String data)</span>&#123;</span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONObject.parseObject(data);</span><br><span class="line">    List&lt;QvsResult&gt; list = JSON.parseArray(jsonObject.get(<span class="string">&quot;list&quot;</span>).toString(),QvsResult.class);</span><br><span class="line">    <span class="keyword">return</span> qvsResultService.saveBatch(list)?R.ok().message(<span class="string">&quot;添加成功&quot;</span>):R.error().message(<span class="string">&quot;添加失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="在向数据库存入对象后获得其自动生成的id"><a href="#在向数据库存入对象后获得其自动生成的id" class="headerlink" title="在向数据库存入对象后获得其自动生成的id"></a>在向数据库存入对象后获得其自动生成的id</h2><ul><li><p>写需求的时候碰到了这样的问题，想要获得存入对象自动生成的id，难道要重新查一遍不成？实际上不用，应该是<strong>mybatis先将生成的id赋值给了传入对象的id属性后再执行的sql语句，所以直接通过传入对象的引用访问id就可以访问到了</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220922160514745.png" alt="image-20220922160514745"></p></li></ul><h1 id="SpringBoot项目中整合Redis实现数据缓存"><a href="#SpringBoot项目中整合Redis实现数据缓存" class="headerlink" title="SpringBoot项目中整合Redis实现数据缓存"></a>SpringBoot项目中整合Redis实现数据缓存</h1><ul><li>准备在项目中引入Redis非关系型数据库来当作缓存使用，这样可以大大优化查询效率，大大提升在高并发的情况下进行查询的效率和系统的健壮性。</li></ul><h2 id="在maven中引入依赖"><a href="#在maven中引入依赖" class="headerlink" title="在maven中引入依赖"></a>在maven中引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="在SpringBoot的配置文件中进行相关配置"><a href="#在SpringBoot的配置文件中进行相关配置" class="headerlink" title="在SpringBoot的配置文件中进行相关配置"></a>在SpringBoot的配置文件中进行相关配置</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment">#Redis服务器连接端口</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="attr">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line"><span class="attr">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><h2 id="添加Redis的配置类"><a href="#添加Redis的配置类" class="headerlink" title="添加Redis的配置类"></a>添加Redis的配置类</h2><ul><li>至于这个配置类的作用还是之后再分析吧</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.CachingConfigurerSupport;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.cache.RedisCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-09-24 20:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"><span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line"><span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"><span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"><span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"><span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在Service的实现类上开启缓存"><a href="#在Service的实现类上开启缓存" class="headerlink" title="在Service的实现类上开启缓存"></a>在Service的实现类上开启缓存</h2><ul><li><p>通过**@CacheConfig注解<strong>来声明当前的类开启缓存，其中的</strong>cacheNames属性可能和Redis缓存的命名**有关，至于有啥关系还是之后再说吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@CacheConfig(cacheNames = &quot;survey&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QvsSurveyServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;QvsSurveyMapper, QvsSurvey&gt; <span class="keyword">implements</span> <span class="title class_">QvsSurveyService</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="在想要做缓存的方法上开启缓存"><a href="#在想要做缓存的方法上开启缓存" class="headerlink" title="在想要做缓存的方法上开启缓存"></a>在想要做缓存的方法上开启缓存</h2><ul><li><p>需要在对应的方法上加上**@Cacheable注解**，这样做之后，对应方法的查询结果会被放到缓存中，下次查询的时候会直接从缓存中取，不用再查数据库了，可以开MyBaits的日志输出来验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable</span></span><br><span class="line"><span class="keyword">public</span> List&lt;QvsSurvey&gt; <span class="title function_">getAllSurvey</span><span class="params">()</span> &#123;</span><br><span class="line">    QueryWrapper&lt;QvsSurvey&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.orderByDesc(<span class="string">&quot;update_time&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.list(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;实验室最近要做个新的项目，是在实验</summary>
      
    
    
    
    
    <category term="项目" scheme="https://konjacor.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="问卷系统" scheme="https://konjacor.github.io/tags/%E9%97%AE%E5%8D%B7%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>flutter应用基本结构及搭建流程</title>
    <link href="https://konjacor.github.io/2022/08/24/flutter%E5%BA%94%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%8F%8A%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/"/>
    <id>https://konjacor.github.io/2022/08/24/flutter%E5%BA%94%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%8F%8A%E6%90%AD%E5%BB%BA%E6%B5%81%E7%A8%8B/</id>
    <published>2022-08-24T03:46:22.000Z</published>
    <updated>2022-12-20T12:11:43.201Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="Flutter避坑"><a href="#Flutter避坑" class="headerlink" title="Flutter避坑"></a>Flutter避坑</h1><h2 id="xxxx-is-not-a-valid-Dart-package-name"><a href="#xxxx-is-not-a-valid-Dart-package-name" class="headerlink" title="xxxx is not a valid Dart package name"></a>xxxx is not a valid Dart package name</h2><ul><li>文件夹路径根目录不能有大写字母。</li></ul><h2 id="Error-The-getter-‘body1’-isn’t-defined-for-the-class-‘TextTheme’"><a href="#Error-The-getter-‘body1’-isn’t-defined-for-the-class-‘TextTheme’" class="headerlink" title="Error: The getter ‘body1’ isn’t defined for the class ‘TextTheme’."></a>Error: The getter ‘body1’ isn’t defined for the class ‘TextTheme’.</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220824220653658.png" alt="image-20220824220653658"></p><ul><li>body1在TextTheme中好像改名成<strong>bodyText1</strong>了。</li></ul><h2 id="Flutter显示有依赖不符合空安全规范不让启动"><a href="#Flutter显示有依赖不符合空安全规范不让启动" class="headerlink" title="Flutter显示有依赖不符合空安全规范不让启动"></a>Flutter显示有依赖不符合空安全规范不让启动</h2><ul><li>使用<strong>flutter run –no-sound-null-safety</strong>，可以在启动的时候避开空安全检查。</li></ul><h2 id="Flutter访问阿里云oss中的图片产生的跨域问题"><a href="#Flutter访问阿里云oss中的图片产生的跨域问题" class="headerlink" title="Flutter访问阿里云oss中的图片产生的跨域问题"></a>Flutter访问阿里云oss中的图片产生的跨域问题</h2><ul><li>要在阿里云oss的后台配置跨域规则：<ol><li>点开你想要设置跨域规则的<strong>bucket</strong></li><li>点击<strong>权限管理</strong>，找到<strong>跨域设置</strong>一栏，点击<strong>设置</strong></li><li>点击<strong>创建规则</strong>，在来源处写对应的来源，<strong>直接写*就是允许所有跨域请求</strong>，然后根据需要填写下面的内容，填写完毕后点击<strong>确定</strong>即可完成设置。</li><li>然后再在前端访问阿里云oss中的图片就能访问到了。</li></ol></li></ul><h2 id="Another-exception-was-thrown-A-RenderFlex-overflowed-by-150-pixels-on-the-bottom"><a href="#Another-exception-was-thrown-A-RenderFlex-overflowed-by-150-pixels-on-the-bottom" class="headerlink" title="Another exception was thrown: A RenderFlex overflowed by 150 pixels on the bottom."></a>Another exception was thrown: A RenderFlex overflowed by 150 pixels on the bottom.</h2><ul><li>一般是由于在Row或者Column布局中，可变大小的子元素没有使用Expanded包裹导致的越界问题，将Row或者Column中的可变大小的子元素使用Expanded进行包裹即可。</li></ul><h2 id="Unexpected-Null-Value"><a href="#Unexpected-Null-Value" class="headerlink" title="Unexpected Null Value"></a>Unexpected Null Value</h2><ul><li>这个一般是<strong>flutter在渲染页面的时候使用到了值为空的对象</strong>，比如这个对象是用来接收异步数据的，在第一次渲染页面的时候异步数据还没到达，此时如果使用这个对象来对页面进行渲染的话就会报这个错，因此应该保证在flutter渲染页面的时候使用到的数据都已经存在。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220919151513259.png" alt="image-20220919151513259"></p><h2 id="如何快速定位报错位置"><a href="#如何快速定位报错位置" class="headerlink" title="如何快速定位报错位置"></a>如何快速定位报错位置</h2><ul><li>根据报错时flutter输出到终端上的日志，从上往下找，直到找到第一个自己写的文件的具体位置，那就是报错的位置。</li></ul><h1 id="Flutter常用技巧"><a href="#Flutter常用技巧" class="headerlink" title="Flutter常用技巧"></a>Flutter常用技巧</h1><h2 id="实现瀑布流式布局"><a href="#实现瀑布流式布局" class="headerlink" title="实现瀑布流式布局"></a>实现瀑布流式布局</h2><h3 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220826211908936.png" alt="image-20220826211908936"></p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ol><li><p>要实现这个瀑布流式布局方式，可以自己手写，但是最方便的还是使用一个名为<strong>flutter_staggered_grid_view</strong>的包来实现，还需要一个包<strong>cached_network_image</strong>，来将图片放入缓存中然后再显示，具体的包的版本如下，不同版本的包的类和方法名有不小的出入，实现代码的写法也不同，因此尽量使用相同版本的包，防止出现问题，还有这些包的版本好像都不支持空安全，所以启动的时候要在关闭空安全检查的情况下启动。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flutter_staggered_grid_view:</span> <span class="string">^0.4.0</span></span><br><span class="line"><span class="attr">cached_network_image:</span> <span class="string">^2.2.0+1</span></span><br></pre></td></tr></table></figure></li><li><p>然后要将包导入你想要写代码的页面中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter_staggered_grid_view/flutter_staggered_grid_view.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:cached_network_image/cached_network_image.dart&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>编写瀑布流的每个子项：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//瀑布流的每个子项</span></span><br><span class="line">Widget itemWidget(context, <span class="built_in">int</span> index) &#123;</span><br><span class="line">  <span class="comment">// if (_isLoad &lt; 2) _isLoad++;</span></span><br><span class="line">  <span class="comment">// print(_isLoad);</span></span><br><span class="line">  <span class="built_in">String</span> imgPath = dataList[index][<span class="string">&quot;url&quot;</span>];</span><br><span class="line">  <span class="built_in">int</span> isLoad = dataList[index][<span class="string">&quot;isLoad&quot;</span>] &lt; <span class="number">2</span></span><br><span class="line">      ? dataList[index][<span class="string">&quot;isLoad&quot;</span>]++</span><br><span class="line">      : dataList[index][<span class="string">&quot;isLoad&quot;</span>];</span><br><span class="line">  <span class="comment">//print(imgPath+&quot; &quot;+isLoad.toString());</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Material(</span><br><span class="line">    elevation: <span class="number">8.0</span>, <span class="comment">//海拔为8，显得更加立体</span></span><br><span class="line">    borderRadius: <span class="keyword">new</span> BorderRadius.all(<span class="keyword">new</span> Radius.circular(<span class="number">8.0</span>)), <span class="comment">//圆角</span></span><br><span class="line">    child: <span class="keyword">new</span> InkWell(</span><br><span class="line">      <span class="comment">//被包裹起来的元素可以被点击</span></span><br><span class="line">      <span class="comment">// child:</span></span><br><span class="line">      <span class="comment">// new Hero(</span></span><br><span class="line">      <span class="comment">//实现元素共享动画效果</span></span><br><span class="line">      <span class="comment">// tag: imgPath,</span></span><br><span class="line">      <span class="comment">// child: CachedNetworkImage(</span></span><br><span class="line">      <span class="comment">//   // 加载网络图片过程中显示的内容 , 这里显示进度条</span></span><br><span class="line">      <span class="comment">//   placeholder: (context, url) =&gt; CircularProgressIndicator(),</span></span><br><span class="line">      <span class="comment">//   // 网络图片地址</span></span><br><span class="line">      <span class="comment">//   imageUrl: imgPath,</span></span><br><span class="line">      <span class="comment">// ),</span></span><br><span class="line">      child: Column(</span><br><span class="line">        <span class="comment">//竖直方向容器</span></span><br><span class="line">        <span class="comment">// mainAxisSize: MainAxisSize.min,</span></span><br><span class="line">        children: [</span><br><span class="line">          <span class="comment">// Expanded(</span></span><br><span class="line">          <span class="comment">// child:</span></span><br><span class="line">          Padding(</span><br><span class="line">            <span class="comment">//让图片和左右边界有点距离</span></span><br><span class="line">            padding: EdgeInsets.fromLTRB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">            child: ClipRRect(</span><br><span class="line">              <span class="comment">//让图片有个圆角效果</span></span><br><span class="line">              borderRadius: <span class="keyword">new</span> BorderRadius.only(</span><br><span class="line">                  topLeft: <span class="keyword">new</span> Radius.circular(<span class="number">8.0</span>),</span><br><span class="line">                  topRight: <span class="keyword">new</span> Radius.circular(<span class="number">8.0</span>)),</span><br><span class="line">              child: <span class="comment">// isLoad == 2</span></span><br><span class="line">                  <span class="comment">// ?</span></span><br><span class="line">                  Hero(</span><br><span class="line">                tag: imgPath,</span><br><span class="line">                child: Image(image: CachedNetworkImageProvider(imgPath)),</span><br><span class="line">              ),</span><br><span class="line">              <span class="comment">// : CachedNetworkImage(</span></span><br><span class="line">              <span class="comment">//     //将网络图片缓存到本地并显示</span></span><br><span class="line">              <span class="comment">//     // 加载网络图片过程中显示的内容 , 这里显示进度条</span></span><br><span class="line">              <span class="comment">//     placeholder: (context, url) =&gt;</span></span><br><span class="line">              <span class="comment">//         CircularProgressIndicator(),</span></span><br><span class="line">              <span class="comment">//     // 网络图片地址</span></span><br><span class="line">              <span class="comment">//     imageUrl: imgPath,</span></span><br><span class="line">              <span class="comment">//     //图片加载失败时的动作</span></span><br><span class="line">              <span class="comment">//     errorWidget: (context, url, error) =&gt;</span></span><br><span class="line">              <span class="comment">//         Icon(Icons.error),</span></span><br><span class="line">              <span class="comment">//     // imageBuilder: (context, imageProvider) =&gt; Container(</span></span><br><span class="line">              <span class="comment">//     //   decoration: BoxDecoration(</span></span><br><span class="line">              <span class="comment">//     //     image: DecorationImage(</span></span><br><span class="line">              <span class="comment">//     //         image: imageProvider,</span></span><br><span class="line">              <span class="comment">//     //         fit: BoxFit.cover,</span></span><br><span class="line">              <span class="comment">//     //         colorFilter: ColorFilter.mode(</span></span><br><span class="line">              <span class="comment">//     //             Colors.red, BlendMode.colorBurn)),</span></span><br><span class="line">              <span class="comment">//     //   ),</span></span><br><span class="line">              <span class="comment">//     // ),</span></span><br><span class="line">              <span class="comment">//   ),</span></span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          <span class="comment">// ),</span></span><br><span class="line">          <span class="comment">// SizedBox(height: 12,),</span></span><br><span class="line">          SizedBox(</span><br><span class="line">            <span class="comment">//间隔12逻辑像素</span></span><br><span class="line">            height: <span class="number">12</span>,</span><br><span class="line">          ),</span><br><span class="line">          <span class="comment">// Expanded(</span></span><br><span class="line">          <span class="comment">// child:</span></span><br><span class="line">          Text(</span><br><span class="line">            <span class="string">&quot;   测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字&quot;</span>,</span><br><span class="line">            maxLines: <span class="number">2</span>,</span><br><span class="line">            overflow: TextOverflow.fade,</span><br><span class="line">          ),</span><br><span class="line">          <span class="comment">// ),</span></span><br><span class="line">          SizedBox(</span><br><span class="line">            height: <span class="number">6</span>,</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">      <span class="comment">// ),</span></span><br><span class="line">      onTap: () &#123;</span><br><span class="line">        Navigator.pushNamed(context, <span class="string">&#x27;/detail&#x27;</span>, arguments: &#123;</span><br><span class="line">          <span class="string">&quot;imgPath&quot;</span>: imgPath,</span><br><span class="line">          <span class="string">&quot;text&quot;</span>:</span><br><span class="line">              <span class="string">&quot;   测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字测试文字&quot;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写实现瀑布流的body代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Widget TabsBody() &#123;</span><br><span class="line">  <span class="comment">// return Center(</span></span><br><span class="line">  <span class="comment">//     child: LinearProgressIndicator(</span></span><br><span class="line">  <span class="comment">//   minHeight: 8.0,</span></span><br><span class="line">  <span class="comment">//   value: 0,</span></span><br><span class="line">  <span class="comment">//   backgroundColor: Colors.yellow,</span></span><br><span class="line">  <span class="comment">//   valueColor: AlwaysStoppedAnimation&lt;Color&gt;(Colors.red),</span></span><br><span class="line">  <span class="comment">// ));</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StaggeredGridView.countBuilder(</span><br><span class="line">    <span class="comment">//瀑布流式布局</span></span><br><span class="line">    shrinkWrap: <span class="keyword">true</span>,</span><br><span class="line">    padding: EdgeInsets.all(<span class="number">8.0</span>),</span><br><span class="line">    crossAxisCount: <span class="number">4</span>,</span><br><span class="line">    itemCount: dataList.length,</span><br><span class="line">    itemBuilder: (context, i) &#123;</span><br><span class="line">      <span class="comment">//构建流式布局的item，item放到tile里面</span></span><br><span class="line">      <span class="keyword">return</span> itemWidget(context, i);</span><br><span class="line">    &#125;,</span><br><span class="line">    staggeredTileBuilder: (<span class="built_in">int</span> index) =&gt;</span><br><span class="line">        <span class="keyword">new</span> StaggeredTile.fit(<span class="number">2</span>), <span class="comment">//fit是让每个tile都自适应，里面的参数是交叉轴上tile的数量。</span></span><br><span class="line">    <span class="comment">//new StaggeredTile.count(2, index == 0 ? 2.5 : 3),</span></span><br><span class="line">    mainAxisSpacing: <span class="number">8.0</span>,</span><br><span class="line">    crossAxisSpacing: <span class="number">8.0</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="利用Hero组件实现路由切换时的图片飞行动画"><a href="#利用Hero组件实现路由切换时的图片飞行动画" class="headerlink" title="利用Hero组件实现路由切换时的图片飞行动画"></a>利用Hero组件实现路由切换时的图片飞行动画</h2><ul><li><p>使用Hero组件可以使路由切换时，图片从原本的页面飞行到切换到的页面。</p></li><li><p>首先要在原页面中<strong>将且只将图片用Hero组件包裹起来</strong>，并设置一个tag值：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hero(</span><br><span class="line">tag: imgPath,</span><br><span class="line">    child: Image(image: CachedNetworkImageProvider(imgPath)),</span><br><span class="line">),</span><br></pre></td></tr></table></figure></li><li><p>然后在想要切换到的页面中也<strong>将且仅将图片包裹起来</strong>，tag的值要和原页面Hero中的tag值相同：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hero(</span><br><span class="line">tag: arguments![<span class="string">&quot;imgPath&quot;</span>],</span><br><span class="line">    <span class="comment">//因为前面加载图片是用的cached_network_image，加载完了直接存在缓存中了，因此可以直接从缓存中拿，减少加载时间，提升Hero动画的流畅性。</span></span><br><span class="line">child:Image(image: CachedNetworkImageProvider(arguments![<span class="string">&quot;imgPath&quot;</span>])),</span><br><span class="line">),</span><br></pre></td></tr></table></figure></li><li><p>然后在切换页面时就能看到图片的飞行动画了，要注意使用<strong>Hero只能包裹图片（以我目前的水平来看）</strong>，因为之前在使用的时候由于包裹了其他东西，在路由切换的时候报了**Another exception was thrown: A RenderFlex overflowed by 150 pixels on the bottom.**导致debug了好几个小时，最后才发现是Hero位置的问题。</p></li></ul><h2 id="给Flutter中的有状态组件-StatefulWidget-传参"><a href="#给Flutter中的有状态组件-StatefulWidget-传参" class="headerlink" title="给Flutter中的有状态组件(StatefulWidget)传参"></a>给Flutter中的有状态组件(StatefulWidget)传参</h2><ol><li><p>类中定义final全局变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QYInput</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> minLines;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数中初始化变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QYInput</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> minLines;</span><br><span class="line">  <span class="keyword">const</span> QYInput(&#123;Key? key, <span class="keyword">this</span>.minLines = <span class="number">1</span>&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>继承于State抽象类的类中通过widget.xxx调用变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_QYInputState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">QYInput</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> TextField(minLines: widget.minLines);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="写一个带图标、文字的方形按钮，并调整到合适的大小"><a href="#写一个带图标、文字的方形按钮，并调整到合适的大小" class="headerlink" title="写一个带图标、文字的方形按钮，并调整到合适的大小"></a>写一个带图标、文字的方形按钮，并调整到合适的大小</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ElevatedButton.icon(</span><br><span class="line">  <span class="comment">//带图标、文字的方形按钮</span></span><br><span class="line">  onPressed: () &#123;<span class="comment">//点击事件</span></span><br><span class="line">    Navigator.pushNamed(context, <span class="string">&#x27;/exam&#x27;</span>,</span><br><span class="line">        arguments: &#123;<span class="string">&quot;id&quot;</span>: arguments![<span class="string">&quot;id&quot;</span>]&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  icon: Icon(Icons.create),<span class="comment">//图标</span></span><br><span class="line">  label: Text(<span class="string">&quot;开始填写&quot;</span>),<span class="comment">//文字</span></span><br><span class="line">  style: ElevatedButton.styleFrom(</span><br><span class="line">    <span class="comment">//调整按钮大小用</span></span><br><span class="line">    minimumSize: <span class="keyword">const</span> Size(<span class="number">150</span>, <span class="number">60</span>),</span><br><span class="line">  ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><h2 id="写一个进度条"><a href="#写一个进度条" class="headerlink" title="写一个进度条"></a>写一个进度条</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinearProgressIndicator(</span><br><span class="line">    value: <span class="number">0.3</span>,<span class="comment">//当前进度（最高为1）</span></span><br><span class="line">    minHeight: <span class="number">8</span>,<span class="comment">//进度条最小高度</span></span><br><span class="line">),</span><br></pre></td></tr></table></figure><h2 id="写一个多行输入框"><a href="#写一个多行输入框" class="headerlink" title="写一个多行输入框"></a>写一个多行输入框</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">    maxLines: <span class="number">4</span>,<span class="comment">//最大行数</span></span><br><span class="line">    decoration: InputDecoration(<span class="comment">//装饰器</span></span><br><span class="line">   hintText: <span class="string">&quot;请输入回答&quot;</span>,<span class="comment">//没输入之前默认显示的文本</span></span><br><span class="line">    border: OutlineInputBorder()<span class="comment">//边框样式</span></span><br><span class="line">),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><ul><li><p>可以通过<strong>在其Controller属性中增加TextEditingController然后在之后的代码中访问TextEditingController的text属性来实现从控制器中取到输入的内容</strong>，这是flutter官方推荐的技术方案。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TextField(</span><br><span class="line">  controller: questionData[index]</span><br><span class="line">      [<span class="string">&quot;textFieldController&quot;</span>], <span class="comment">//官方推荐通过这个来获取textfield中的内容</span></span><br><span class="line">  maxLines: <span class="number">4</span>, <span class="comment">//最大行数</span></span><br><span class="line">  decoration: InputDecoration(</span><br><span class="line">      hintText: <span class="string">&quot;请输入回答&quot;</span>, <span class="comment">//没输入之前默认显示的文本</span></span><br><span class="line">      border: OutlineInputBorder() <span class="comment">//边框样式</span></span><br><span class="line">      ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure></li></ul><h2 id="写一个可以选择时间的按钮，选择的时间显示到按钮上"><a href="#写一个可以选择时间的按钮，选择的时间显示到按钮上" class="headerlink" title="写一个可以选择时间的按钮，选择的时间显示到按钮上"></a>写一个可以选择时间的按钮，选择的时间显示到按钮上</h2><ul><li><p>需要一个第三方库，不过这个库好像不怎么兼容Flutter3，会报一点错，要么等更新，要么自己根据提示改改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flutter_datetime_picker:</span> <span class="string">^1.5.1</span></span><br></pre></td></tr></table></figure></li><li><p>然后就是代码实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ElevatedButton(</span><br><span class="line">    onPressed: () &#123;</span><br><span class="line">      DatePicker.showDatePicker(context,</span><br><span class="line">          showTitleActions: <span class="keyword">true</span>,</span><br><span class="line">          minTime: <span class="built_in">DateTime</span>(<span class="number">1500</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">          maxTime: <span class="built_in">DateTime</span>(<span class="number">3000</span>, <span class="number">12</span>, <span class="number">31</span>), onChanged: (date) &#123;<span class="comment">//选项切换时的行为</span></span><br><span class="line">        <span class="comment">//print(&#x27;change $date&#x27;);</span></span><br><span class="line">      &#125;, onConfirm: (selected) &#123;<span class="comment">//选好后的行为</span></span><br><span class="line">        <span class="comment">//print(date);</span></span><br><span class="line">        setState(() &#123;</span><br><span class="line">          <span class="comment">//更新date</span></span><br><span class="line">          <span class="comment">//拼接成年/月/日的日期格式</span></span><br><span class="line">          date = selected.year.toString() +</span><br><span class="line">              <span class="string">&quot;/&quot;</span> +</span><br><span class="line">              selected.month.toString() +</span><br><span class="line">              <span class="string">&quot;/&quot;</span> +</span><br><span class="line">              selected.day.toString();</span><br><span class="line">          <span class="comment">//print(date);</span></span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;, currentTime: <span class="built_in">DateTime</span>.now(), locale: LocaleType.en);</span><br><span class="line">    &#125;,</span><br><span class="line">    child: date.compareTo(<span class="string">&quot;&quot;</span>) == <span class="number">0</span></span><br><span class="line">        ? Text(<span class="string">&quot;请选择时间&quot;</span>)</span><br><span class="line">        : Text(date), <span class="comment">//文字</span></span><br><span class="line">    style: ElevatedButton.styleFrom(</span><br><span class="line">      <span class="comment">//调整按钮大小用</span></span><br><span class="line">      minimumSize: <span class="keyword">const</span> Size(<span class="number">150</span>, <span class="number">60</span>),</span><br><span class="line">    ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure></li></ul><h2 id="循环动态生成组件"><a href="#循环动态生成组件" class="headerlink" title="循环动态生成组件"></a>循环动态生成组件</h2><ul><li><p>有一个需求，让你生成一个问题，问题的选项不固定，怎么搞？可以用循环生成组件的方式来动态生成组件：</p></li><li><p>单选版本：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Widget&gt; options = []; <span class="comment">//问题选项</span></span><br><span class="line">Widget optionsContainer = <span class="keyword">new</span> Column(</span><br><span class="line">  <span class="comment">//这个封装了一下所有循环生成的组件，就可以用在别的地方了。</span></span><br><span class="line">  children: options,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (questionType &lt; <span class="number">3</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; optionNum; ++i) &#123;</span><br><span class="line">    <span class="comment">//循环生成选项</span></span><br><span class="line">    Widget option = <span class="keyword">new</span> Row(</span><br><span class="line">      mainAxisAlignment: MainAxisAlignment.center, <span class="comment">//居中</span></span><br><span class="line">      children: [</span><br><span class="line">        Radio(</span><br><span class="line">            value: i, <span class="comment">//当前这个单选框的id</span></span><br><span class="line">            groupValue: <span class="keyword">this</span>.optionSelected, <span class="comment">//当前这个组中被选中的单选框的id</span></span><br><span class="line">            onChanged: (v) &#123;</span><br><span class="line">              <span class="comment">//在改变选择的时候的行为，v是重新选择的那个单选框的id</span></span><br><span class="line">              setState(() &#123;</span><br><span class="line">                <span class="keyword">if</span> (v <span class="keyword">is</span> <span class="built_in">int</span>) &#123;</span><br><span class="line">                  <span class="comment">//加个类型判断，不然不好过编译</span></span><br><span class="line">                  <span class="keyword">this</span>.optionSelected = v;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;),</span><br><span class="line">        SizedBox(</span><br><span class="line">          width: <span class="number">10</span>,</span><br><span class="line">        ),</span><br><span class="line">        Text(questions[index][<span class="string">&quot;options&quot;</span>][i][<span class="string">&quot;optionContent&quot;</span>]),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">    options.add(option);</span><br><span class="line">    options.add(<span class="keyword">new</span> SizedBox(</span><br><span class="line">      height: <span class="number">30</span>,</span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多选版本：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (questionType == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; optionNum; ++i) &#123;</span><br><span class="line">  optionSelectedMulti.add(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; optionNum; ++i) &#123;</span><br><span class="line">  <span class="comment">//循环生成选项</span></span><br><span class="line">  Widget option = <span class="keyword">new</span> Row(</span><br><span class="line">    mainAxisAlignment: MainAxisAlignment.center, <span class="comment">//居中</span></span><br><span class="line">    children: [</span><br><span class="line">      Checkbox(</span><br><span class="line">          value: optionSelectedMulti[i],<span class="comment">//是否被选中，是个bool</span></span><br><span class="line">          onChanged: (v) &#123;<span class="comment">//这个v是true</span></span><br><span class="line">            <span class="comment">//print(v);</span></span><br><span class="line">            <span class="keyword">if</span> (v <span class="keyword">is</span> <span class="built_in">bool</span>) &#123;</span><br><span class="line">              setState(() &#123;</span><br><span class="line">                optionSelectedMulti[i] = v;</span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;),</span><br><span class="line">      SizedBox(</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">      ),</span><br><span class="line">      Text(questions[index][<span class="string">&quot;options&quot;</span>][i][<span class="string">&quot;optionContent&quot;</span>]),</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">  options.add(option);</span><br><span class="line">  options.add(<span class="keyword">new</span> SizedBox(</span><br><span class="line">    height: <span class="number">30</span>,</span><br><span class="line">  ));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="写一个下拉选择列表"><a href="#写一个下拉选择列表" class="headerlink" title="写一个下拉选择列表"></a>写一个下拉选择列表</h2><ul><li><p>写这个的时候挺有讲究，我改的官方的例子，官方的例子写的真不错，我写的flutter老是推断不出来泛型&#x3D; &#x3D;</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (questionType == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">String</span> value = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; temp = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; optionNum; ++i) &#123;</span><br><span class="line">  temp.add(questions[index][<span class="string">&quot;options&quot;</span>][i][<span class="string">&quot;optionContent&quot;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dropdownValue.isEmpty)</span><br><span class="line">  value = temp[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  value = dropdownValue;</span><br><span class="line"><span class="comment">//dropdownValue = temp[0];</span></span><br><span class="line"><span class="comment">//print(temp);</span></span><br><span class="line">optionsContainer = <span class="keyword">new</span> DropdownButton&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">    hint: Text(<span class="string">&quot;请输入&quot;</span>),</span><br><span class="line">    value: value, <span class="comment">//显示的值</span></span><br><span class="line">    items: temp.map&lt;DropdownMenuItem&lt;<span class="built_in">String</span>&gt;&gt;((<span class="built_in">String</span> value) &#123;</span><br><span class="line">      <span class="comment">//列表项，这里用map来生成</span></span><br><span class="line">      <span class="keyword">return</span> DropdownMenuItem&lt;<span class="built_in">String</span>&gt;(</span><br><span class="line">        value: value,</span><br><span class="line">        child: Text(value),</span><br><span class="line">      );</span><br><span class="line">    &#125;).toList(),</span><br><span class="line">    onChanged: (v) &#123;</span><br><span class="line">      <span class="comment">//改变选择时的行为</span></span><br><span class="line">      <span class="comment">//print(v);</span></span><br><span class="line">      setState(() &#123;</span><br><span class="line">        <span class="keyword">if</span> (v <span class="keyword">is</span> <span class="built_in">String</span>) <span class="keyword">this</span>.dropdownValue = v;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="显示SnackBar"><a href="#显示SnackBar" class="headerlink" title="显示SnackBar"></a>显示SnackBar</h2><ul><li>SnackBar就是最下面的那个提示信息。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220921111214108.png" alt="image-20220921111214108"></p><ul><li><p>示例代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ScaffoldMessenger.of(context).showSnackBar(<span class="comment">//不能直接在Scaffold里使用</span></span><br><span class="line">    SnackBar(</span><br><span class="line">  content: Text(<span class="string">&#x27;没有上一题了哦&#x27;</span>),</span><br><span class="line">  action: SnackBarAction(</span><br><span class="line">    label: <span class="string">&quot;关闭&quot;</span>,</span><br><span class="line">    onPressed: () &#123;</span><br><span class="line">      <span class="comment">//print(&#x27;撤回&#x27;);</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ),</span><br><span class="line">));</span><br></pre></td></tr></table></figure></li></ul><h2 id="flutter实现组件的绝对定位"><a href="#flutter实现组件的绝对定位" class="headerlink" title="flutter实现组件的绝对定位"></a>flutter实现组件的绝对定位</h2><ul><li><p>平时写组件的位置都是相对位置，但是需求需要实现组件的绝对定位，于时就去网上看了看实现方式，实现起来也不是很复杂。</p></li><li><p>效果图如下，最下面的两个按钮是绝对位置：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220921113214382.png" alt="image-20220921113214382"></p></li><li><p>需要使用到的组件：</p><ol><li>ConstrainedBox：尺寸限制类容器组件。</li><li>Stack：将子组件叠加显示。</li><li>Positioned：用于定位Stack子组件</li></ol></li><li><p>实现代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="comment">//print(widget.arguments![&quot;id&quot;]);</span></span><br><span class="line">  <span class="keyword">return</span> Scaffold(</span><br><span class="line">    appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">      title: <span class="keyword">new</span> Text(</span><br><span class="line">        <span class="string">&quot;正在填写:&quot;</span> + arguments![<span class="string">&quot;title&quot;</span>],</span><br><span class="line">        style: <span class="keyword">new</span> TextStyle(color: Colors.white),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">    body: Center(</span><br><span class="line">      <span class="comment">//搞绝对定位</span></span><br><span class="line">      child: ConstrainedBox(</span><br><span class="line">        constraints: BoxConstraints.expand(),</span><br><span class="line">        child: Stack(</span><br><span class="line">          alignment: Alignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            ExamBody(), <span class="comment">//进度条和问题部分</span></span><br><span class="line">            Positioned(<span class="comment">//对其包裹的组件进行绝对定位</span></span><br><span class="line">              bottom: <span class="number">70</span>,<span class="comment">//距离底部70的绝对位置</span></span><br><span class="line">              child: Row(</span><br><span class="line">                mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">                children: [</span><br><span class="line">                  ElevatedButton(</span><br><span class="line">                      style: ElevatedButton.styleFrom(</span><br><span class="line">                        minimumSize: Size(<span class="number">100</span>, <span class="number">50</span>),</span><br><span class="line">                      ),</span><br><span class="line">                      onPressed: () &#123;</span><br><span class="line">                        <span class="keyword">if</span> (questionNow == <span class="number">0</span>) &#123;</span><br><span class="line">                          ScaffoldMessenger.of(context)</span><br><span class="line">                              .showSnackBar(<span class="comment">//不能直接在Scaffold里使用</span></span><br><span class="line">                                  SnackBar(</span><br><span class="line">                            content: Text(<span class="string">&#x27;没有上一题了哦&#x27;</span>),</span><br><span class="line">                            action: SnackBarAction(</span><br><span class="line">                              label: <span class="string">&quot;关闭&quot;</span>,</span><br><span class="line">                              onPressed: () &#123;</span><br><span class="line">                                <span class="comment">//print(&#x27;撤回&#x27;);</span></span><br><span class="line">                              &#125;,</span><br><span class="line">                            ),</span><br><span class="line">                          ));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                          setState(() &#123;</span><br><span class="line">                            questionNow--;</span><br><span class="line">                            <span class="comment">// print(questionNow.toString() +</span></span><br><span class="line">                            <span class="comment">//     &quot; &quot; +</span></span><br><span class="line">                            <span class="comment">//     questionTotal.toString());</span></span><br><span class="line">                          &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;,</span><br><span class="line">                      child: Text(<span class="string">&quot;上一题&quot;</span>)),</span><br><span class="line">                  SizedBox(</span><br><span class="line">                    width: <span class="number">150</span>,</span><br><span class="line">                  ),</span><br><span class="line">                  ElevatedButton(</span><br><span class="line">                      style: ElevatedButton.styleFrom(</span><br><span class="line">                        minimumSize: Size(<span class="number">100</span>, <span class="number">50</span>),</span><br><span class="line">                      ),</span><br><span class="line">                      onPressed: () &#123;</span><br><span class="line">                        <span class="keyword">if</span> (questionNow == questionTotal - <span class="number">1</span>) &#123;</span><br><span class="line">                          ScaffoldMessenger.of(context)</span><br><span class="line">                              .showSnackBar(<span class="comment">//不能直接在Scaffold里使用</span></span><br><span class="line">                                  SnackBar(</span><br><span class="line">                            content: Text(<span class="string">&#x27;没有下一题了哦&#x27;</span>),</span><br><span class="line">                            action: SnackBarAction(</span><br><span class="line">                              label: <span class="string">&quot;关闭&quot;</span>,</span><br><span class="line">                              onPressed: () &#123;</span><br><span class="line">                                <span class="comment">//print(&#x27;撤回&#x27;);</span></span><br><span class="line">                              &#125;,</span><br><span class="line">                            ),</span><br><span class="line">                          ));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                          setState(() &#123;</span><br><span class="line">                            questionNow++;</span><br><span class="line">                            <span class="comment">// print(questionNow.toString() +</span></span><br><span class="line">                            <span class="comment">//     &quot; &quot; +</span></span><br><span class="line">                            <span class="comment">//     questionTotal.toString());</span></span><br><span class="line">                          &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;,</span><br><span class="line">                      child: Text(<span class="string">&quot;下一题&quot;</span>)),</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="在顶部导航栏上增加按钮"><a href="#在顶部导航栏上增加按钮" class="headerlink" title="在顶部导航栏上增加按钮"></a>在顶部导航栏上增加按钮</h2><ul><li><p>效果图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220921114740153.png" alt="image-20220921114740153"></p></li><li><p>示例代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          leading: IconButton(</span><br><span class="line">            icon: Icon(Icons.menu),</span><br><span class="line">            tooltip: <span class="string">&#x27;Navigreation&#x27;</span>,</span><br><span class="line">            onPressed: () =&gt; debugPrint(<span class="string">&#x27;Navigreation button is pressed&#x27;</span>),</span><br><span class="line">          ),</span><br><span class="line">          title: Text(<span class="string">&#x27;导航&#x27;</span>),</span><br><span class="line">          actions: &lt;Widget&gt;[</span><br><span class="line">            IconButton(<span class="comment">//也可以换成TextButton啥的=w=</span></span><br><span class="line">              icon: Icon(Icons.search),</span><br><span class="line">              tooltip: <span class="string">&#x27;Search&#x27;</span>,</span><br><span class="line">              onPressed: () =&gt; debugPrint(<span class="string">&#x27;Search button is pressed&#x27;</span>),</span><br><span class="line">            ),</span><br><span class="line">            IconButton(</span><br><span class="line">              icon: Icon(Icons.more_horiz),</span><br><span class="line">              tooltip: <span class="string">&#x27;More&#x27;</span>,</span><br><span class="line">              onPressed: () =&gt; debugPrint(<span class="string">&#x27;More button is pressed&#x27;</span>),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        body: <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="AppBar-leading"><a href="#AppBar-leading" class="headerlink" title="AppBar:leading"></a>AppBar:leading</h3><ul><li>它是顶部导航栏最左边的按钮,IconButton便是按钮组件，里面的icon就是按钮图标,Icons是内置的一些图标样式。tooltip是按钮说明，onPressed是按钮事件，我们通过debugPrint可以看到点击按钮后，在控制台输出对应的文字。</li></ul><h3 id="AppBar-actions"><a href="#AppBar-actions" class="headerlink" title="AppBar:actions"></a>AppBar:actions</h3><ul><li>它是顶部导航栏右方的一排组件。 上面代码我们定义了搜索和…两个按钮，分别设置了其对应的按钮事件。</li></ul><h2 id="Dio类中的方法的参数说明"><a href="#Dio类中的方法的参数说明" class="headerlink" title="Dio类中的方法的参数说明"></a>Dio类中的方法的参数说明</h2><ul><li><p>queryParameters：这个是指明请求参数，就是在请求路径后面拼接的参数。</p></li><li><p>data：这个是请求体，别和上面那个搞混了。</p></li><li><p>网络请求类代码示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:dio/dio.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;Config.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Future&lt;T&gt; request&lt;T&gt;(<span class="built_in">String</span> url,</span><br><span class="line">      &#123;<span class="built_in">String</span> method = <span class="string">&#x27;get&#x27;</span>, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;? params&#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    url = Config.qvsHost + url;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.toLowerCase().compareTo(<span class="string">&quot;get&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        Response response = <span class="keyword">await</span> Dio().<span class="keyword">get</span>(url,</span><br><span class="line">            queryParameters: params,</span><br><span class="line">            options:</span><br><span class="line">                <span class="keyword">new</span> Options(contentType: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>));</span><br><span class="line">        <span class="comment">//print(response);</span></span><br><span class="line">        <span class="keyword">return</span> response.data;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.toLowerCase().compareTo(<span class="string">&quot;post&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//print(params);</span></span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> Dio().post(url,</span><br><span class="line">            data: params,</span><br><span class="line">            options:</span><br><span class="line">                <span class="keyword">new</span> Options(contentType: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>));</span><br><span class="line">        <span class="keyword">return</span> response.data;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.toLowerCase().compareTo(<span class="string">&quot;put&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> Dio().put(url,</span><br><span class="line">            data: params,</span><br><span class="line">            options:</span><br><span class="line">                <span class="keyword">new</span> Options(contentType: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>));</span><br><span class="line">        <span class="keyword">return</span> response.data;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.toLowerCase().compareTo(<span class="string">&quot;delete&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> response = <span class="keyword">await</span> Dio().delete(url,</span><br><span class="line">            data: params,</span><br><span class="line">            options:</span><br><span class="line">                <span class="keyword">new</span> Options(contentType: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>));</span><br><span class="line">        <span class="keyword">return</span> response.data;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> Exception();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">return</span> Future.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return Future.error(new Exception());</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="弹出提示框"><a href="#弹出提示框" class="headerlink" title="弹出提示框"></a>弹出提示框</h2><ul><li><p>可以用<strong>showDialog方法</strong>实现，不过里面的builder比较难写，要返回一个具体的提示框实例，下面是示例代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">showDialog(</span><br><span class="line">  context: context,</span><br><span class="line">  builder: (context) &#123;</span><br><span class="line">    <span class="keyword">return</span> AlertDialog(</span><br><span class="line">      title: Text(<span class="string">&quot;提示&quot;</span>),</span><br><span class="line">      <span class="comment">//title 的内边距，默认 left: 24.0,top: 24.0, right 24.0</span></span><br><span class="line">      <span class="comment">//默认底部边距 如果 content 不为null 则底部内边距为0</span></span><br><span class="line">      <span class="comment">//            如果 content 为 null 则底部内边距为20</span></span><br><span class="line">      titlePadding: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">      <span class="comment">//标题文本样式</span></span><br><span class="line">      titleTextStyle: TextStyle(</span><br><span class="line">          color: Colors.black87, fontSize: <span class="number">25</span>),</span><br><span class="line">      <span class="comment">//中间显示的内容</span></span><br><span class="line">      content: Text(<span class="string">&quot;提交成功！&quot;</span>),</span><br><span class="line">      <span class="comment">//中间显示的内容边距</span></span><br><span class="line">      <span class="comment">//默认 EdgeInsets.fromLTRB(24.0, 20.0, 24.0, 24.0)</span></span><br><span class="line">      contentPadding: EdgeInsets.all(<span class="number">10</span>),</span><br><span class="line">      <span class="comment">//中间显示内容的文本样式</span></span><br><span class="line">      contentTextStyle: TextStyle(</span><br><span class="line">          color: Colors.black54, fontSize: <span class="number">20</span>),</span><br><span class="line">      <span class="comment">//底部按钮区域</span></span><br><span class="line">      actions: &lt;Widget&gt;[</span><br><span class="line">        <span class="comment">// TextButton(</span></span><br><span class="line">        <span class="comment">//   child: Text(&quot;取消&quot;),</span></span><br><span class="line">        <span class="comment">//   onPressed: () &#123;</span></span><br><span class="line">        <span class="comment">//     关闭 返回 false</span></span><br><span class="line">        <span class="comment">//     Navigator.of(context).pop(false);</span></span><br><span class="line">        <span class="comment">//   &#125;,</span></span><br><span class="line">        <span class="comment">// ),</span></span><br><span class="line">        TextButton(</span><br><span class="line">          child: Text(</span><br><span class="line">            <span class="string">&quot;确认&quot;</span>,</span><br><span class="line">            style: TextStyle(fontSize: <span class="number">15</span>),</span><br><span class="line">          ),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            <span class="comment">//关闭 返回true</span></span><br><span class="line">            Navigator.of(context).pop(<span class="keyword">true</span>);</span><br><span class="line">            Navigator.pop(context);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="写一个巨丑无比的上导航栏搜索框"><a href="#写一个巨丑无比的上导航栏搜索框" class="headerlink" title="写一个巨丑无比的上导航栏搜索框"></a>写一个巨丑无比的上导航栏搜索框</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220921182908894.png" alt="image-20220921182908894"></p><ul><li><p>实现代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">AppBar(</span><br><span class="line">  title: Text(<span class="string">&quot;山师问卷系统&quot;</span>),</span><br><span class="line">  actions: [</span><br><span class="line">    Container(</span><br><span class="line">      <span class="comment">//在这儿TextField必须要设置长宽，不然会报错</span></span><br><span class="line">      alignment: Alignment.center, <span class="comment">//居中</span></span><br><span class="line">      height: <span class="number">20</span>,</span><br><span class="line">      width: <span class="number">270</span>,</span><br><span class="line">      child: TextField(</span><br><span class="line">        controller: textFieldController,</span><br><span class="line">        decoration: InputDecoration(</span><br><span class="line">          hintText: <span class="string">&quot;搜索&quot;</span>,</span><br><span class="line">          hintStyle: TextStyle(</span><br><span class="line">            color: Color.fromARGB(<span class="number">255</span>, <span class="number">80</span>, <span class="number">80</span>, <span class="number">80</span>),</span><br><span class="line">          ),</span><br><span class="line">          border: InputBorder.none, <span class="comment">//设置为无边框</span></span><br><span class="line">        ),</span><br><span class="line">        maxLines: <span class="number">1</span>,</span><br><span class="line">      ),</span><br><span class="line">    ),</span><br><span class="line">    IconButton(</span><br><span class="line">        <span class="comment">//图标按钮</span></span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          <span class="built_in">print</span>(textFieldController.text);</span><br><span class="line">        &#125;,</span><br><span class="line">        icon: Icon(Icons.search)),</span><br><span class="line">  ],</span><br><span class="line">),</span><br></pre></td></tr></table></figure></li></ul><h2 id="写个宽度无限的按钮，并设置成自己喜欢的颜色"><a href="#写个宽度无限的按钮，并设置成自己喜欢的颜色" class="headerlink" title="写个宽度无限的按钮，并设置成自己喜欢的颜色"></a>写个宽度无限的按钮，并设置成自己喜欢的颜色</h2><ul><li><p>宽度无限关键在于<strong>给Container中的width属性设置为double.infinite</strong>，颜色的设置主要通过ButtonStyle实现，不过里面的写法有点讲究：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">  height: <span class="number">300</span>,</span><br><span class="line">  width: <span class="built_in">double</span>.infinity,</span><br><span class="line">  child: ElevatedButton.icon(</span><br><span class="line">      style: <span class="keyword">new</span> ButtonStyle(</span><br><span class="line">          backgroundColor: MaterialStateProperty.all(Colors.blue),<span class="comment">//设置按钮颜色</span></span><br><span class="line">      ),</span><br><span class="line">      onPressed: () &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我要登录了！！！&quot;</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">      icon: Icon(</span><br><span class="line">        Icons.person,</span><br><span class="line">        size: <span class="number">100</span>,</span><br><span class="line">      ),</span><br><span class="line">      label: user[<span class="string">&quot;id&quot;</span>].isEmpty</span><br><span class="line">          ? Text(</span><br><span class="line">              <span class="string">&quot;点击登录&quot;</span>,</span><br><span class="line">              style: TextStyle(fontSize: <span class="number">30</span>),</span><br><span class="line">            )</span><br><span class="line">          : Text(</span><br><span class="line">              user[<span class="string">&quot;username&quot;</span>],</span><br><span class="line">              style: TextStyle(fontSize: <span class="number">30</span>),</span><br><span class="line">            )),</span><br><span class="line">),</span><br></pre></td></tr></table></figure></li></ul><h2 id="给Container加上边框"><a href="#给Container加上边框" class="headerlink" title="给Container加上边框"></a>给Container加上边框</h2><ul><li><p>主要是用到了Container的decoration属性</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">decoration:</span><br><span class="line"><span class="comment">//黑色，宽度为1的全包围边框</span></span><br><span class="line">BoxDecoration(border: Border.all(color: Colors.black, width: <span class="number">1</span>)),</span><br></pre></td></tr></table></figure></li></ul><h2 id="写一个可以填写内容的弹框"><a href="#写一个可以填写内容的弹框" class="headerlink" title="写一个可以填写内容的弹框"></a>写一个可以填写内容的弹框</h2><ul><li><p>从网上毛的，有好几个组成部分，结构挺清晰的，可以根据自己的需要进行魔改：</p></li><li><p>工具类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/cupertino.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/widgets.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;../../ui/Alert/ShowInputAlertWidget.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import &#x27;package:flutter_app1/module/dialogs/widget/bottom_widget.dart&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// import &#x27;package:flutter_app1/module/dialogs/widget/center_dialog.dart&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// import &#x27;package:flutter_app1/module/dialogs/widget/define_widget.dart&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// import &#x27;package:flutter_app1/module/dialogs/widget/input_dialog.dart&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// import &#x27;package:flutter_app1/module/dialogs/widget/style_dialog.dart&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">自定义弹窗</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppTool</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">底部弹出2个选项框</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  showBottomAlert(BuildContext context, confirmCallback, String title,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  String option1, String option2) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// showCupertinoModalPopup(</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// context: context,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  builder: (context) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// return BottomCustomAlterWidget(</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// confirmCallback, title, option1, option2);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">中间弹出提示框</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  showCenterTipsAlter(</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BuildContext context, confirmCallback, String title, String desText) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// showDialog(</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// context: context,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  builder: (BuildContext context) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// return CenterTipsAlterWidget(confirmCallback, title, desText);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">中间弹出输入框</span></span></span><br><span class="line"></span><br><span class="line">  showCenterInputAlert(BuildContext context, <span class="built_in">String</span> title, <span class="built_in">String</span> placeholder,</span><br><span class="line">      <span class="built_in">String</span> placeholder2) &#123;</span><br><span class="line">    showDialog(</span><br><span class="line">        context: context,</span><br><span class="line">        builder: (BuildContext context) &#123;</span><br><span class="line">          <span class="keyword">return</span> ShowInputAlertWidget(title, placeholder, placeholder2);</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///<span class="language-markdown">自定义弹框</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  showStyleAlert(BuildContext context, confirmCallback, String title,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  String contentTitle) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// showDialog(</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// context: context,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  builder: (BuildContext context) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// return StyleDialog(confirmCallback, title, contentTitle);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">///<span class="language-markdown">只有一个确定按钮的弹窗</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  showDefineAlert(</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BuildContext context, confirmCallback, String title, String hintText) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// showDialog(</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// context: context,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  builder: (BuildContext context) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// return ShowDefineAlertWidget(confirmCallback, title, hintText);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>弹框本体：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/cupertino.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/gestures.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/widgets.dart&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:questionnaire/utils/requests/Request.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">输入提示框</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShowInputAlertWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> placeholder;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Placeholder2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ShowInputAlertWidget(<span class="keyword">this</span>.title, <span class="keyword">this</span>.placeholder, <span class="keyword">this</span>.Placeholder2);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ShowInputAlertWidgetState createState() =&gt; _ShowInputAlertWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ShowInputAlertWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ShowInputAlertWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> number = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="built_in">String</span> password = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> CupertinoAlertDialog(</span><br><span class="line">      title: Text(widget.title),</span><br><span class="line">      content: Column(</span><br><span class="line">        children: [</span><br><span class="line">          SizedBox(</span><br><span class="line">            height: <span class="number">10</span>,</span><br><span class="line">          ),</span><br><span class="line">          CupertinoTextField(</span><br><span class="line">            placeholder: widget.placeholder,</span><br><span class="line">            onChanged: (value) &#123;</span><br><span class="line">              number = value;</span><br><span class="line">            &#125;,</span><br><span class="line">          ),</span><br><span class="line">          SizedBox(</span><br><span class="line">            height: <span class="number">5</span>,</span><br><span class="line">          ),</span><br><span class="line">          CupertinoTextField(</span><br><span class="line">            placeholder: widget.Placeholder2,</span><br><span class="line">            onChanged: (value) &#123;</span><br><span class="line">              password = value;</span><br><span class="line">            &#125;,</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">      actions: [</span><br><span class="line">        CupertinoDialogAction(</span><br><span class="line">          child: Text(<span class="string">&#x27;取消&#x27;</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            Navigator.pop(context);</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">        CupertinoDialogAction(</span><br><span class="line">          child: Text(<span class="string">&#x27;确定&#x27;</span>),</span><br><span class="line">          onPressed: () &#123;</span><br><span class="line">            <span class="comment">//print(&quot;进行登录操作。。。&quot; + number + &quot; &quot; + password);</span></span><br><span class="line">            Request.request(<span class="string">&quot;ucenter/uni/user/login&quot;</span>,</span><br><span class="line">                    method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">                    params: &#123;<span class="string">&quot;number&quot;</span>: number, <span class="string">&quot;password&quot;</span>: password&#125;,</span><br><span class="line">                    service: <span class="string">&#x27;ucenter&#x27;</span>)</span><br><span class="line">                .then((value) &#123;</span><br><span class="line">              <span class="built_in">print</span>(value[<span class="string">&quot;data&quot;</span>]);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;,</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AppTool().showCenterInputAlert(context, <span class="string">&quot;登录&quot;</span>, <span class="string">&quot;帐号&quot;</span>, <span class="string">&quot;密码&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="路由pop时携带参数返回，返回到的页面接收返回的参数"><a href="#路由pop时携带参数返回，返回到的页面接收返回的参数" class="headerlink" title="路由pop时携带参数返回，返回到的页面接收返回的参数"></a>路由pop时携带参数返回，返回到的页面接收返回的参数</h2><ul><li><p>携带参数返回时要将参数写到<strong>Navigator.pop()方法的第二个参数中</strong>，然后调用该方法的方法<strong>返回值写成Future&lt;T&gt;<strong>，然后</strong>在调用处用then接收异步参数</strong>。</p></li><li><p>路由pop的位置：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value[<span class="string">&quot;success&quot;</span>]) &#123;</span><br><span class="line">  Navigator.pop(context, &#123;</span><br><span class="line">    <span class="string">&quot;success&quot;</span>: value[<span class="string">&quot;success&quot;</span>],</span><br><span class="line">    <span class="string">&quot;id&quot;</span>: value[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;userVo&quot;</span>][<span class="string">&quot;id&quot;</span>],</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: value[<span class="string">&quot;data&quot;</span>][<span class="string">&quot;userVo&quot;</span>][<span class="string">&quot;name&quot;</span>]</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  Navigator.pop(context, &#123;<span class="string">&quot;success&quot;</span>: value[<span class="string">&quot;success&quot;</span>]&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>封装的方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;T?&gt; showCenterInputAlert&lt;T&gt;(BuildContext context, <span class="built_in">String</span> title,</span><br><span class="line">    <span class="built_in">String</span> placeholder, <span class="built_in">String</span> placeholder2) &#123;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  showDialog(</span><br><span class="line">      context: context,</span><br><span class="line">      builder: (BuildContext context) &#123;</span><br><span class="line">        <span class="keyword">return</span> ShowInputAlertWidget(title, placeholder, placeholder2);</span><br><span class="line">      &#125;).then((v) &#123;</span><br><span class="line">    value = v;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用处（这里没用封装的方法来调用）：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">showDialog(</span><br><span class="line">    context: context,</span><br><span class="line">    builder: (BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">return</span> ShowInputAlertWidget(<span class="string">&quot;登录&quot;</span>, <span class="string">&quot;帐号&quot;</span>, <span class="string">&quot;密码&quot;</span>);</span><br><span class="line">    &#125;).then((value) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value[<span class="string">&quot;success&quot;</span>]) &#123;</span><br><span class="line">    ScaffoldMessenger.of(context)</span><br><span class="line">        .showSnackBar(<span class="comment">//不能直接在Scaffold里使用</span></span><br><span class="line">            SnackBar(</span><br><span class="line">      content: Text(<span class="string">&#x27;登录成功！&#x27;</span>),</span><br><span class="line">      action: SnackBarAction(</span><br><span class="line">        label: <span class="string">&quot;关闭&quot;</span>,</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          <span class="comment">//print(&#x27;撤回&#x27;);</span></span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    ));</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      user[<span class="string">&quot;id&quot;</span>] = value[<span class="string">&quot;id&quot;</span>];</span><br><span class="line">      user[<span class="string">&quot;username&quot;</span>] = value[<span class="string">&quot;username&quot;</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ScaffoldMessenger.of(context)</span><br><span class="line">        .showSnackBar(<span class="comment">//不能直接在Scaffold里使用</span></span><br><span class="line">            SnackBar(</span><br><span class="line">      content: Text(<span class="string">&#x27;用户名或密码错误！&#x27;</span>),</span><br><span class="line">      action: SnackBarAction(</span><br><span class="line">        label: <span class="string">&quot;关闭&quot;</span>,</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          <span class="comment">//print(&#x27;撤回&#x27;);</span></span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="以键值对的形式向缓存中存入数据"><a href="#以键值对的形式向缓存中存入数据" class="headerlink" title="以键值对的形式向缓存中存入数据"></a>以键值对的形式向缓存中存入数据</h2><ul><li><p>需要用到<strong>shared_preferences</strong>这个包，<strong>支持int, double, bool, string与 stringList</strong>类型的数据存储</p></li><li><p>异步获取实例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> initCacheInstance() <span class="keyword">async</span> &#123;</span><br><span class="line">  cache = <span class="keyword">await</span> SharedPreferences.getInstance();<span class="comment">//使用await会阻塞该方法后面的代码，保证了异步数据可以到达</span></span><br><span class="line">  <span class="keyword">if</span> (cache.containsKey(<span class="string">&quot;id&quot;</span>) &amp;&amp; cache.containsKey(<span class="string">&quot;username&quot;</span>)) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      user[<span class="string">&quot;id&quot;</span>] = cache.getString(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">      user[<span class="string">&quot;username&quot;</span>] = cache.getString(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>存入数据，存别的类型的数据的话方法名以此类推：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cache.setString(<span class="string">&quot;id&quot;</span>, value[<span class="string">&quot;id&quot;</span>]);</span><br><span class="line">cache.setString(<span class="string">&quot;username&quot;</span>, value[<span class="string">&quot;username&quot;</span>]);</span><br></pre></td></tr></table></figure></li><li><p>取出数据：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user[<span class="string">&quot;id&quot;</span>] = value.getString(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">user[<span class="string">&quot;username&quot;</span>] = value.getString(<span class="string">&quot;username&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="路由返回时刷新ui界面"><a href="#路由返回时刷新ui界面" class="headerlink" title="路由返回时刷新ui界面"></a>路由返回时刷新ui界面</h2><ul><li><p>只需要<strong>在路由跳转后面的.then方法中setState()即可</strong>。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Navigator.pushNamed(context, <span class="string">&quot;/user&quot;</span>).then((value) &#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.containsKey(<span class="string">&quot;id&quot;</span>) &amp;&amp; cache.containsKey(<span class="string">&quot;username&quot;</span>)) &#123;</span><br><span class="line">      user[<span class="string">&quot;id&quot;</span>] = cache.getString(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">      user[<span class="string">&quot;username&quot;</span>] = cache.getString(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="做一个可以点击的title"><a href="#做一个可以点击的title" class="headerlink" title="做一个可以点击的title"></a>做一个可以点击的title</h2><ul><li><p>用InkWell实现：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: InkWell(</span><br><span class="line">  child: Text(<span class="string">&quot;山师问卷系统&quot;</span>),</span><br><span class="line">  onTap: () &#123;</span><br><span class="line">    tapNum++;</span><br><span class="line">    <span class="built_in">print</span>(tapNum);</span><br><span class="line">  &#125;,</span><br><span class="line">),</span><br></pre></td></tr></table></figure></li></ul><h1 id="Flutter打包项目"><a href="#Flutter打包项目" class="headerlink" title="Flutter打包项目"></a>Flutter打包项目</h1><ul><li>使用命令<strong>flutter build apk –no-sound-null-safety</strong>可以不开空安全来打包项目</li><li>在打包的时候往往会报一堆错，报的错基本跟着他说的内容改改就差不多能改好，其它改不好的就往这写写以后长个记性。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;Flutter避坑&quot;&gt;&lt;a href=&quot;#Flutter避坑&quot; class=&quot;headerlink&quot; title=&quot;Flutter避坑&quot;&gt;&lt;/a&gt;Flutter避坑&lt;/h</summary>
      
    
    
    
    
    <category term="flutter" scheme="https://konjacor.github.io/tags/flutter/"/>
    
    <category term="移动应用开发" scheme="https://konjacor.github.io/tags/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤舟</title>
  <icon>https://www.gravatar.com/avatar/e5611663fc514deb557f849c3a23baeb</icon>
  <subtitle>静静地漂泊在思绪的海洋中</subtitle>
  <link href="https://konjacor.github.io/atom.xml" rel="self"/>
  
  <link href="https://konjacor.github.io/"/>
  <updated>2023-02-01T08:21:42.464Z</updated>
  <id>https://konjacor.github.io/</id>
  
  <author>
    <name>Konjacer</name>
    <email>1175590069@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL</title>
    <link href="https://konjacor.github.io/2023/02/01/MySQL/"/>
    <id>https://konjacor.github.io/2023/02/01/MySQL/</id>
    <published>2023-02-01T06:31:52.000Z</published>
    <updated>2023-02-01T08:21:42.464Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><ul><li>索引是帮助MySQL高效获取数据的<strong>数据结构</strong></li><li>索引存储在文件系统中</li><li>索引的文件存储形式与存储引擎有关</li><li>索引文件的结构有多种：hash表、二叉树、B树、B+树</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;h2 id=&quot;索引是什么&quot;&gt;&lt;a href=&quot;#索</summary>
      
    
    
    
    
    <category term="关系型数据库" scheme="https://konjacor.github.io/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://konjacor.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>综合知识整理</title>
    <link href="https://konjacor.github.io/2023/01/20/%E7%BB%BC%E5%90%88%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://konjacor.github.io/2023/01/20/%E7%BB%BC%E5%90%88%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</id>
    <published>2023-01-20T03:24:03.000Z</published>
    <updated>2023-03-06T09:49:04.143Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Java-语言有哪些特点"><a href="#Java-语言有哪些特点" class="headerlink" title="Java 语言有哪些特点?"></a>Java 语言有哪些特点?</h2><ol><li>简单易学；</li><li>面向对象（封装，继承，多态）；</li><li>平台无关性（ Java 虚拟机实现平台无关性）；</li><li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li><li>可靠性；</li><li>安全性；</li><li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li><li>编译与解释并存；</li></ol><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ul><li>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</li><li><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</li><li>OS运行在硬件之上，JVM运行在OS之上。</li></ul><h2 id="JDK和JRE"><a href="#JDK和JRE" class="headerlink" title="JDK和JRE"></a>JDK和JRE</h2><ol><li>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</li><li>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</li><li>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</li></ol><h2 id="什么是字节码？采用字节码的好处是什么？"><a href="#什么是字节码？采用字节码的好处是什么？" class="headerlink" title="什么是字节码？采用字节码的好处是什么？"></a>什么是字节码？采用字节码的好处是什么？</h2><ul><li><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），<strong>它不面向任何特定的处理器，只面向虚拟机（也就是说字节码是跑在虚拟机上的）</strong>。Java 语言通过字节码的方式，<strong>在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点</strong>。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，<strong>由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行</strong>。</p></li><li><p>Java 程序从源代码到运行的过程如下图所示：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230218183516012.png" alt="image-20230218183516012"></p></li><li><p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 <strong>JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢</strong>。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。<strong>当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用</strong>。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p></li><li><p>JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。</p></li></ul><h2 id="为什么不全部使用AOT呢？"><a href="#为什么不全部使用AOT呢？" class="headerlink" title="为什么不全部使用AOT呢？"></a>为什么不全部使用AOT呢？</h2><ul><li>长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，<strong>CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了</strong>。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</li></ul><h2 id="为什么说Java语言“编译与解释并存”？"><a href="#为什么说Java语言“编译与解释并存”？" class="headerlink" title="为什么说Java语言“编译与解释并存”？"></a>为什么说Java语言“编译与解释并存”？</h2><ul><li>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</li></ul><h2 id="Oracle-JDK和OpenJDK"><a href="#Oracle-JDK和OpenJDK" class="headerlink" title="Oracle JDK和OpenJDK"></a>Oracle JDK和OpenJDK</h2><ul><li>OpenJDK开源；Oracle JDK闭源，11之后，个人使用免费，但是商用收费。</li><li>Oracle JDK 比 OpenJDK 更稳定</li><li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能</li></ul><h2 id="Java和C-的区别？"><a href="#Java和C-的区别？" class="headerlink" title="Java和C++的区别？"></a>Java和C++的区别？</h2><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全。</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h2 id="Java中的三种移位运算符"><a href="#Java中的三种移位运算符" class="headerlink" title="Java中的三种移位运算符"></a>Java中的三种移位运算符</h2><ul><li><code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。</li><li><code>&gt;&gt;</code> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。</li><li><code>&gt;&gt;&gt;</code> :无符号右移，忽略符号位，空位都以 0 补齐。</li><li>由于 <code>double</code>，<code>float</code> 在二进制中的表现比较特殊，因此不能来进行移位操作。</li><li>移位操作符实际上支持的类型只有<code>int</code>和<code>long</code>，编译器在对<code>short</code>、<code>byte</code>、<code>char</code>类型进行移位前，都会将其转换为<code>int</code>类型再操作。</li><li>如果移位的位数超过数值所占有的位数会怎样？</li><li>当 int 类型左移&#x2F;右移位数大于等于 32 位操作时，会先求余（%）后再进行左移&#x2F;右移操作。也就是说左移&#x2F;右移 32 位相当于不进行移位操作（32%32&#x3D;0），左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位（42%32&#x3D;10）。当 long 类型进行左移&#x2F;右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。</li></ul><h2 id="成员变量和局部变量的区别？"><a href="#成员变量和局部变量的区别？" class="headerlink" title="成员变量和局部变量的区别？"></a>成员变量和局部变量的区别？</h2><ul><li><strong>语法形式</strong> ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li><li><strong>存储方式</strong> ：从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li><strong>生存时间</strong> ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li><li><strong>默认值</strong> ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul><h2 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h2><ol><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ol><h2 id="重载和重写的区别？"><a href="#重载和重写的区别？" class="headerlink" title="重载和重写的区别？"></a>重载和重写的区别？</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul><li>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</li></ul><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><ul><li><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p></li><li><p><strong>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类</strong>。</p></li><li><p><strong>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明（此时两个重名的static方法没有任何关系）</strong>。</p></li><li><p>构造方法无法被重写</p></li><li><p><strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230218190352463.png" alt="image-20230218190352463"></p></li><li><p>方法的重写要遵循“<strong>两同两小一大</strong>”：</p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul></li></ul><h2 id="可变长参数遇到方法重载怎么办？会优先匹配固定参数还是可变参数的方法呢？"><a href="#可变长参数遇到方法重载怎么办？会优先匹配固定参数还是可变参数的方法呢？" class="headerlink" title="可变长参数遇到方法重载怎么办？会优先匹配固定参数还是可变参数的方法呢？"></a>可变长参数遇到方法重载怎么办？会优先匹配固定参数还是可变参数的方法呢？</h2><ul><li>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</li><li>另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 <code>class</code>文件就可以看出来了。</li></ul><h2 id="Java中的基本数据类型"><a href="#Java中的基本数据类型" class="headerlink" title="Java中的基本数据类型"></a>Java中的基本数据类型</h2><ul><li><p>6 种数字类型：</p><ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li><p>1 种字符类型：<code>char</code></p></li><li><p>1 种布尔型：<code>boolean</code></p></li><li><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230218190858669.png" alt="image-20230218190858669"></p></li><li><p>对于 <code>boolean</code>，官方文档未明确定义，它<strong>依赖于 JVM 厂商的具体实现</strong>。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p></li><li><p>另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。<strong>这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一</strong>。</p></li><li><p>注意：</p><ol><li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li><li>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code></li></ol></li></ul><h2 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h2><ol><li>成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li>包装类型可用于泛型，而基本类型不可以。</li><li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道<strong>几乎所有对象实例都存在于堆中</strong>。</li><li>相比于对象类型， 基本数据类型占用的空间非常小。</li></ol><ul><li>注意 ： <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</li></ul><h2 id="所有的对象实例都存在堆中吗？"><a href="#所有的对象实例都存在堆中吗？" class="headerlink" title="所有的对象实例都存在堆中吗？"></a>所有的对象实例都存在堆中吗？</h2><ul><li>不是，是几乎所有对象实例都存在堆中，<strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，<strong>如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</strong>。</li><li><strong>标量替换</strong>：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是<strong>将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样随着方法调用结束，栈帧也会销毁。有效的减少了堆中创建对象及gc的次数</strong></li></ul><h2 id="包装类型的缓存机制了解么？"><a href="#包装类型的缓存机制了解么？" class="headerlink" title="包装类型的缓存机制了解么？"></a>包装类型的缓存机制了解么？</h2><ul><li><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p></li><li><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p></li><li><p>如果<strong>超出对应范围仍然会去创建新的对象</strong>，缓存的范围区间的大小只是在性能和资源之间的权衡。</p></li><li><p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p></li><li><p>Integer缓存源码（自动装箱用的就是valueOf方法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<span class="comment">//如果范围在缓存中，直接返回缓存的数据</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);<span class="comment">//否则新建对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230218193854172.png" alt="image-20230218193854172"></p></li></ul><h2 id="自动装箱与拆箱了解吗？原理是什么？"><a href="#自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="自动装箱与拆箱了解吗？原理是什么？"></a>自动装箱与拆箱了解吗？原理是什么？</h2><ul><li>从字节码中，我们发现<strong>装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法</strong>。</li><li>因此：<ul><li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li><li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li></ul></li><li>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></li></ul><h2 id="为什么浮点数运算的时候会有精度丢失的风险？"><a href="#为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="为什么浮点数运算的时候会有精度丢失的风险？"></a>为什么浮点数运算的时候会有精度丢失的风险？</h2><ul><li><p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且<strong>计算机在表示一个数字时，宽度是有限的</strong>，<strong>无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示</strong>。</p></li><li><p>比如十进制的0.2要存放在计算机中，那肯定要转换成2进制来存储，而转成的二进制可能是无限长的，所以必须截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span></span><br><span class="line"><span class="comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span> <span class="comment">//第一位二进制小数，取整数部分0，余下的参与下次运算</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> -&gt; <span class="number">0</span> <span class="comment">//第二位二进制小数，取整数部分0，余下的参与下次运算</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> -&gt; <span class="number">1</span> <span class="comment">//第三位二进制小数，取整数部分1，余下的参与下次运算</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> -&gt; <span class="number">1</span> <span class="comment">//第四位二进制小数，取整数部分1，余下的参与下次运算</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span>（发生循环）<span class="comment">//第五位二进制小数，取整数部分0，余下的参与下次运算，在这里发生循环，也就意味着0.2转换成的二进制将会是无限循环的，所以必须截断</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何解决浮点数运算的精度丢失问题？"><a href="#如何解决浮点数运算的精度丢失问题？" class="headerlink" title="如何解决浮点数运算的精度丢失问题？"></a>如何解决浮点数运算的精度丢失问题？</h2><ul><li><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</li><li>BigDecimal中提供各种各样的方法来实现BigDecimal对象之间的运算，所以运算的时候要使用其中的方法。</li></ul><h2 id="超过long整型的数据应该如何表示？"><a href="#超过long整型的数据应该如何表示？" class="headerlink" title="超过long整型的数据应该如何表示？"></a>超过long整型的数据应该如何表示？</h2><ul><li>在 Java 中，64 位 long 整型是最大的整数类型。超过了可以用<code>BigInteger</code> ，其内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。和BigDecimal一样，其中提供了各种供对象间进行运算的方法。</li><li>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</li></ul><h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><ul><li>两者的主要区别在于解决问题的方式不同：<ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul></li><li>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</li></ul><h2 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>创建一个对象用什么运算符?对象实体与对象引用有何不同?</h2><ul><li>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（就是指针，指向对象实例的位置）。</li><li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li></ul><h2 id="对象相等和引用相等的区别？"><a href="#对象相等和引用相等的区别？" class="headerlink" title="对象相等和引用相等的区别？"></a>对象相等和引用相等的区别？</h2><ul><li>对象的相等一般比较的是内存中存放的内容是否相等。</li><li>引用相等一般比较的是他们指向的内存地址是否相等。</li></ul><h2 id="类的构造方法的作用是什么"><a href="#类的构造方法的作用是什么" class="headerlink" title="类的构造方法的作用是什么?"></a>类的构造方法的作用是什么?</h2><ul><li>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</li></ul><h2 id="如果一个类没有声明构造方法，该程序能正确执行吗？"><a href="#如果一个类没有声明构造方法，该程序能正确执行吗？" class="headerlink" title="如果一个类没有声明构造方法，该程序能正确执行吗？"></a>如果一个类没有声明构造方法，该程序能正确执行吗？</h2><ul><li>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</li></ul><h2 id="构造方法有哪些特点？是否可被-override"><a href="#构造方法有哪些特点？是否可被-override" class="headerlink" title="构造方法有哪些特点？是否可被 override?"></a>构造方法有哪些特点？是否可被 override?</h2><ul><li>构造方法特点如下：<ol><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ol></li><li>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</li></ul><h2 id="面向对象四大特征"><a href="#面向对象四大特征" class="headerlink" title="面向对象四大特征"></a>面向对象四大特征</h2><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><ul><li>就是指一种思想，我们可以将客观存在的一切事物都抽象成java类，其中属性表示事物的状态信息，方法表示事物可以有的行为。</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li>封装是指<strong>把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性</strong>。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。<strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率</strong>。</li><li>关于继承如下 3 点请记住：<ol><li>子类拥有父类对象所有的属性和方法（<strong>包括私有属性和私有方法</strong>），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ol></li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</li><li>多态的特点：<ol><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ol></li></ul><h2 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h2><ul><li>共同点：<ol><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ol></li><li>区别：<ol><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ol></li></ul><h2 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h2><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li><li><strong>引用拷贝</strong>：引用拷贝就是两个不同的引用指向同一个对象。</li></ul><h2 id="Object类的常见方法有哪些？"><a href="#Object类的常见方法有哪些？" class="headerlink" title="Object类的常见方法有哪些？"></a>Object类的常见方法有哪些？</h2><ul><li><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作，第一次回收触发这个方法，然后会将对象放到一个队列中，此时对象的内存并没有被真正释放；第二次回收的时候会判断队列中的对象是否通过finalize方法重新建立起了引用，如果有，那就不回收了，如果没有，直接回收掉，这次是真回收，会释放内存空间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="x3D-x3D-和equals-的区别"><a href="#x3D-x3D-和equals-的区别" class="headerlink" title="&#x3D;&#x3D;和equals()的区别"></a>&#x3D;&#x3D;和equals()的区别</h2><ul><li><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：<ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li></ul></li><li>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</li><li><strong><code>equals()</code></strong> <strong>不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等（这个相等的定义是自己定义的）</strong>。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</li><li><code>equals()</code> 方法存在两种使用情况：<ol><li><strong>类没有重写 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ol></li></ul><h2 id="hashCode-有什么用？"><a href="#hashCode-有什么用？" class="headerlink" title="hashCode()有什么用？"></a>hashCode()有什么用？</h2><ul><li><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</li><li><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</li><li>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></li><li>可以<strong>优化对象比较大小时的速度</strong>，通过先比较hashcode，如果hashcode不同，那么这两个对象一定是不同的，如果hashcode相同，再通过equals()方法来进一步比较确定两者是否相同。</li></ul><h2 id="为什么要有-hashCode？"><a href="#为什么要有-hashCode？" class="headerlink" title="为什么要有 hashCode？"></a>为什么要有 hashCode？</h2><ul><li><p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 <code>hashCode</code>？</p></li><li><p>下面这段内容摘自我的 Java 启蒙书《Head First Java》:</p><blockquote><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p></blockquote><p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p></li><li><p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p></li><li><p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p></li><li><p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p></li><li><p>总结下来就是 ：</p><ol><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ol></li></ul><h2 id="为什么重写equals-时必须重写hashCode-方法？"><a href="#为什么重写equals-时必须重写hashCode-方法？" class="headerlink" title="为什么重写equals()时必须重写hashCode()方法？"></a>为什么重写equals()时必须重写hashCode()方法？</h2><ul><li>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li><li>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</li><li><strong>思考</strong> ：重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</li><li><strong>总结</strong> ：<ul><li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li><li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li></ul></li></ul><h2 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h2><h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h3><ul><li><p><code>String</code> 是不可变的（后面会详细分析原因）。</p></li><li><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">      <span class="type">char</span>[] value;</span><br><span class="line">      <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">return</span> appendNull();</span><br><span class="line">          <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">          ensureCapacityInternal(count + len);</span><br><span class="line">          str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">          count += len;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">### 线程安全性</span><br><span class="line"></span><br><span class="line">- `String` 中的对象是不可变的，也就可以理解为常量，线程安全。`AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。**`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的**。</span><br><span class="line"></span><br><span class="line">### 性能</span><br><span class="line"></span><br><span class="line">- 每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。**`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用**。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 <span class="number">10</span>%~<span class="number">15</span>% 左右的性能提升，但却要冒多线程不安全的风险。</span><br><span class="line"></span><br><span class="line">### 对于三者使用的总结</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 操作少量的数据: 适用 `String`</span><br><span class="line"><span class="number">2.</span> 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`</span><br><span class="line"><span class="number">3.</span> 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`</span><br><span class="line"></span><br><span class="line">## String为什么是不可变的？</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 保存字符串的字符数组（jdk1<span class="number">.9</span>之后是字节数组）被 `<span class="keyword">final</span>` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。</span><br><span class="line"><span class="number">2.</span> `String` 类被 `<span class="keyword">final</span>` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。</span><br><span class="line"></span><br><span class="line">## String不可变的好处？</span><br><span class="line"></span><br><span class="line">### 便于实现String常量池</span><br><span class="line"></span><br><span class="line">- 在程序编写过程中往往会大量用到String常量，如果每次都为新的String常量申请内存空间的话会对空间造成很大的浪费，所以我们需要字符串常量池来对String常量做一个优化，把之前用过的String保存下来，以后如果再用的话可以直接拿。</span><br><span class="line">- 从上面我们知道了我们需要一个字符串常量池来对使用String做优化，而只有当字符串是不可变的，字符串池才有可能实现。**字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变**。</span><br><span class="line"></span><br><span class="line">### 可以很方便地作为Map的key</span><br><span class="line"></span><br><span class="line">- 以String作为HashMap的key，String的不可变性保证了其hash值的不可变性，防止出现key值发生变化导致key对象的hash值发生变化，之后再用key的那个对象在map中找对应的value就找不到了（因为hash值变了，找的位置就不对了）。</span><br><span class="line"></span><br><span class="line">### 避免网络安全问题</span><br><span class="line"></span><br><span class="line">- 如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。</span><br><span class="line"></span><br><span class="line">### 使多线程安全</span><br><span class="line"></span><br><span class="line">- 因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</span><br><span class="line"></span><br><span class="line">### 避免本地安全性问题</span><br><span class="line"></span><br><span class="line">- 类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。</span><br><span class="line"></span><br><span class="line">### 加快字符串处理速度</span><br><span class="line"></span><br><span class="line">- 因为字符串是不可变的，所以在它创建的时候hashcode就被缓存在对象头中了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</span><br><span class="line"></span><br><span class="line">## Java9为何要将String的底层实现由<span class="type">char</span>[]改成了<span class="type">byte</span>[]？</span><br><span class="line"></span><br><span class="line">- 新版的 String 其实支持两个编码方案： Latin-<span class="number">1</span> 和 UTF-<span class="number">16</span>。JDK 官方就说了绝大部分字符串对象只包含 Latin-<span class="number">1</span> 可表示的字符。如果字符串中包含的汉字没有超过 Latin-<span class="number">1</span> 可表示范围内的字符，那就会使用 Latin-<span class="number">1</span> 作为编码方案。Latin-<span class="number">1</span> 编码方案下，`<span class="type">byte</span>` 占一个字节(<span class="number">8</span> 位)，`<span class="type">char</span>` 占用 <span class="number">2</span> 个字节（<span class="number">16</span>），`<span class="type">byte</span>` 相较 `<span class="type">char</span>` 节省一半的内存空间。</span><br><span class="line">- 如果字符串中包含的汉字超过 Latin-<span class="number">1</span> 可表示范围内的字符，`<span class="type">byte</span>` 和 `<span class="type">char</span>` 所占用的空间是一样的。</span><br><span class="line"></span><br><span class="line">## 字符串拼接用“+”还是StringBuilder？</span><br><span class="line"></span><br><span class="line">- Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</span><br><span class="line">- 通过编译后形成的字节码文件的内容可以看出，**字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 **。</span><br><span class="line">- 不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：**编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象**。</span><br><span class="line">- 所以**推荐在循环中拼接字符串时应该事先在循环外面声明好StringBuilder然后在循环中使用StringBuilder的append()方法**。</span><br><span class="line"></span><br><span class="line">## 字符串常量池的作用了解吗？</span><br><span class="line"></span><br><span class="line">- **字符串常量池（jdk1<span class="number">.7</span>之前在方法区的常量池中，jdk1<span class="number">.7</span>的时候字符串常量池被从常量池中单独拎出来放到了堆中；jdk1<span class="number">.8</span>的时候原本在方法区中的每个类特有的静态域也被放到了堆中，具体存放在堆中类在加载阶段生成的class对象的尾部）** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，**主要目的是为了避免字符串的重复创建**。</span><br><span class="line"></span><br><span class="line">## <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);这句话创建了几个字符串对象？</span><br><span class="line"></span><br><span class="line">- 会创建 <span class="number">1</span> 或 <span class="number">2</span> 个字符串对象。</span><br><span class="line">- 如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中（看这说法应该默认是jdk1<span class="number">.7</span>之后的版本）创建 <span class="number">2</span> 个字符串对象“abc”；反之则只会创建<span class="number">1</span>个。</span><br><span class="line"></span><br><span class="line">## intern方法有什么作用？</span><br><span class="line"></span><br><span class="line">- `String.intern()` 是一个 <span class="keyword">native</span>（本地）方法，**其作用是将指定的字符串对象的引用保存在字符串常量池中**，可以简单分为两种情况：</span><br><span class="line">  <span class="number">1.</span> 如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</span><br><span class="line">  <span class="number">2.</span> 如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</span><br><span class="line"></span><br><span class="line">## String 类型的引用和字面量做“+”运算时发生了什么？</span><br><span class="line"></span><br><span class="line">- 先来看字符串不加 `<span class="keyword">final</span>` 关键字拼接的情况（JDK1<span class="number">.8</span>）：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">  System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">  System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">  System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li><li><p><strong>对于编译期可以确定值的字符串，也就是字面量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串字面量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p></li><li><p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。<strong>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中</strong>，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p></li><li><p>所以，对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p></li><li><p>不过要注意，<strong>并不是所有的常量&#x2F;变量都会进行折叠，只有编译器在程序编译期就可以确定值的常量&#x2F;变量才可以</strong>：</p><ul><li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串的字面量。</li><li><code>final</code> 修饰的基本数据类型和字符串引用</li><li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li></ul></li><li><p><strong>引用的值在程序编译期是无法确定的（因为值是地址，非final的地址程序不跑起来定不下来），编译器无法对其进行优化（除非引用是final的，final的引用的值在编译期是确定的）。</strong></p></li><li><p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。所以我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p></li><li><p>不过，<strong>字符串引用使用的都是被 <code>final</code> 关键字修饰的字符串引用时，可以让编译器把这个引用当做字面量来做优化处理，因为final引用的值在编译期就会被确定</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p></li><li><p>如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> getStr();</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 在堆上创建的新的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>总之就是一点，看编译时变量&#x2F;常量的值是否能被确定，如果能，那么编译器就会做常量折叠优化；反之则不做优化</strong>。</p></li></ul><h2 id="Java异常类层次结构图概览"><a href="#Java异常类层次结构图概览" class="headerlink" title="Java异常类层次结构图概览"></a>Java异常类层次结构图概览</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230220221230590.png" alt="image-20230220221230590"></p><h2 id="Exception和Error有什么区别？"><a href="#Exception和Error有什么区别？" class="headerlink" title="Exception和Error有什么区别？"></a>Exception和Error有什么区别？</h2><ul><li>在 Java 中，<strong>所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类</strong>。<code>Throwable</code> 类有两个重要的子类:<ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul></li></ul><h2 id="Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="Checked Exception 和 Unchecked Exception 有什么区别？"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h2><ul><li><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</li><li><strong>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常</strong>。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…</li><li><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</li><li><strong><code>RuntimeException</code> 及其子类都统称为非受检查异常</strong>，常见的有（建议记下来，日常开发中会经常用到）：<ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li><li>……</li></ul></li></ul><h2 id="Throwable类常用方法有哪些？"><a href="#Throwable类常用方法有哪些？" class="headerlink" title="Throwable类常用方法有哪些？"></a>Throwable类常用方法有哪些？</h2><ul><li><code>String getMessage()</code>: 返回异常发生时的简要描述</li><li><code>String toString()</code>: 返回异常发生时的详细信息</li><li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li><li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h2 id="try-catch-finally如何使用？"><a href="#try-catch-finally如何使用？" class="headerlink" title="try-catch-finally如何使用？"></a>try-catch-finally如何使用？</h2><ul><li><code>try</code>块 ： 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><code>catch</code>块 ： 用于处理 try 捕获到的异常。</li><li><code>finally</code> 块 ： 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到</li><li><code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li><li><strong>注意：尽量不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</li></ul><h2 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h2><ul><li><p>不一定的！在某些情况下，finally 中的代码不会被执行。就比如说 <strong>finally 之前虚拟机被终止运行</strong>的话，finally 中的代码就不会被执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 终止当前正在运行的Java虚拟机</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//Try to do something</span></span><br><span class="line"><span class="comment">//Catch Exception -&gt; RuntimeException</span></span><br></pre></td></tr></table></figure></li><li><p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p><ol><li><strong>程序所在的线程死亡</strong>。</li><li><strong>关闭 CPU</strong>。</li></ol></li></ul><h2 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h2><ul><li><p><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</p></li><li><p><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</p></li><li><p>《Effective Java》中明确指出：</p><blockquote><p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p></blockquote></li><li><p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p></li><li><p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">       <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">      <span class="type">int</span> b;</span><br><span class="line">      <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">          bout.write(b);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">## 异常使用有哪些需要注意的地方？</span><br><span class="line"></span><br><span class="line">- **不要把异常定义为静态变量**，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 <span class="keyword">new</span> 一个异常对象抛出。</span><br><span class="line">- 抛出的异常信息一定**要有意义**。</span><br><span class="line">- 建议**抛出更加具体的异常**比如字符串转换为数字格式错误的时候应该抛出`NumberFormatException`而不是其父类`IllegalArgumentException`。</span><br><span class="line">- **使用日志打印异常之后就不要再抛出异常了**（两者不要同时存在一段代码逻辑中）。</span><br><span class="line">- ......</span><br><span class="line"></span><br><span class="line">## 什么是泛型？有什么作用？</span><br><span class="line"></span><br><span class="line">- **Java 泛型（Generics）** 是 JDK <span class="number">5</span> 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</span><br><span class="line">- 编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 `ArrayList&lt;Person&gt; persons = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;()` 这行代码就指明了该 `ArrayList` 对象只能传入 `Person` 对象，如果传入其他类型的对象就会报错。</span><br><span class="line">- 并且，原生 `List` 返回类型是 `Object` ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</span><br><span class="line">- 说白了**使用泛型其实就是在编译期编译器帮我们保证泛型中泛型参数的类型正确**，如果不使用泛型，我们需要自己来做这些事情，由于泛型只在编译期体现，在运行时泛型的类型参数会被擦除，泛型参数的类型会转换成上界的类型，所以我感觉泛型也是个语法糖。</span><br><span class="line"></span><br><span class="line">## 泛型的使用方式有哪几种？</span><br><span class="line"></span><br><span class="line">- 泛型一般有三种使用方式:**泛型类**、**泛型接口**、**泛型方法**。</span><br><span class="line"></span><br><span class="line">### 泛型类</span><br><span class="line"></span><br><span class="line">- 代码示例：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line">  <span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">private</span> T key;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.key = key;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> key;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如何实例化泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><ul><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，不指定具体类型参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，指定具体类型参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">         System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure></li><li><p>注意: <code>public static &lt;E&gt; void printArray( E[] inputArray )</code> 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以<strong>静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code></strong></p></li></ul><h2 id="项目中哪里用到了泛型？"><a href="#项目中哪里用到了泛型？" class="headerlink" title="项目中哪里用到了泛型？"></a>项目中哪里用到了泛型？</h2><ul><li>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</li><li>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型</li><li>构建集合工具类（参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法）。</li><li>……</li></ul><h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><ul><li>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它<strong>赋予了我们在运行时分析类以及执行类中方法的能力</strong>。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</li></ul><h2 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点?"></a>反射的优缺点?</h2><ul><li>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</li><li>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li></ul><h2 id="反射的应用场景？"><a href="#反射的应用场景？" class="headerlink" title="反射的应用场景？"></a>反射的应用场景？</h2><ul><li>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring&#x2F;Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</li><li><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></li><li>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。为什么使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？这些都是因为<strong>可以基于反射分析类，然后获取到类&#x2F;属性&#x2F;方法&#x2F;方法的参数上的注解。获取到注解之后，就可以做进一步的处理</strong>，所以说注解其实就是一个标识，通过反射分析注解这个标识来进行相应的处理。</li></ul><h2 id="什么是注解？"><a href="#什么是注解？" class="headerlink" title="什么是注解？"></a>什么是注解？</h2><ul><li><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，<strong>可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用</strong>。</p></li><li><p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>JDK提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p></li></ul><h2 id="注解的解析方法有哪几种？"><a href="#注解的解析方法有哪几种？" class="headerlink" title="注解的解析方法有哪几种？"></a>注解的解析方法有哪几种？</h2><ul><li>注解只有被解析之后才会生效，常见的解析方法有两种：<ol><li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li></ol></li></ul><h2 id="什么是SPI？"><a href="#什么是SPI？" class="headerlink" title="什么是SPI？"></a>什么是SPI？</h2><ul><li>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：<strong>专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口</strong>。</li><li>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</li><li>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</li></ul><h2 id="SPI和API有什么区别？"><a href="#SPI和API有什么区别？" class="headerlink" title="SPI和API有什么区别？"></a>SPI和API有什么区别？</h2><h2 id="SPI的优缺点？"><a href="#SPI的优缺点？" class="headerlink" title="SPI的优缺点？"></a>SPI的优缺点？</h2><ul><li>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：<ol><li>需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</li><li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li></ol></li></ul><h2 id="什么是序列化？什么是反序列化？"><a href="#什么是序列化？什么是反序列化？" class="headerlink" title="什么是序列化？什么是反序列化？"></a>什么是序列化？什么是反序列化？</h2><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="说一下synchronized锁升级的机制？"><a href="#说一下synchronized锁升级的机制？" class="headerlink" title="说一下synchronized锁升级的机制？"></a>说一下synchronized锁升级的机制？</h2><ul><li>首先在JDK1.6之前，synchronized锁是一个重量级锁，其依赖于操作系统的mutex lock命令，而这个命令呢，是内核态的命令，所以跑在用户态的进程需要将自己切换成内核态之后再去进行系统调用，这样做会有很大的性能损耗，特别是在争抢锁的线程较少的情况下，所以在JDK1.6之后，设计师们引入了偏向锁和轻量级锁来实现synchronized的锁升级机制。</li><li>当只有一个线程来拿锁的时候，synchronized是一个偏向锁的机制，<strong>偏向锁会把提供监视器的对象的对象头中记录下当前线程的id</strong>，当下次这个线程来拿锁的时候，可以直接获取到，这样实际上就是对单线程条件下的优化。</li><li>当之后多个线程来的时候，synchronized会升级成<strong>用CAS+自旋实现的轻量级锁</strong>，所有没有获取到锁的线程会进行自旋尝试获取到锁，这样的操作不会阻塞线程，但是如果线程较多的情况下，线程为了获取到锁进行的自旋次数也会变多，这样的自旋是很耗费cpu的性能的。</li><li>如果自旋次数过多还没能获取到锁，synchronized会升级成重量级锁，<strong>重量级锁就是之前说过的依赖于操作系统的mutex lock命令，在JVM层面上是依赖于monitorenter和monitorexit命令来获取对象的同步监视器monitor</strong>，这俩命令一个指向同步代码段的开头，一个指向结尾，当线程想要获取锁的时候，要先检查monitor的计数器是否是0，如果是0说明可以获取，让计数器++，如果不是0，那么线程阻塞等待。</li></ul><h2 id="为什么ConcurrentHashMap的key和value不能为空？"><a href="#为什么ConcurrentHashMap的key和value不能为空？" class="headerlink" title="为什么ConcurrentHashMap的key和value不能为空？"></a>为什么ConcurrentHashMap的key和value不能为空？</h2><ul><li>这是为了<strong>避免在多线程的情况下产生歧义</strong>，因为在多线程的条件下，如果我们尝试去获取ConcurrentHashMap的key或者value返回了null，那么我们是不能确定到底是key或者value不存在还是本身那个值就是null，如果在单线程下，我们可以通过containsKey这样的方法来求证，但是在多线程下，使用containsKey方法的时候，另外一个线程可以将键值对插入到了那个位置，这就导致containsKey可能返回的值不确定，也就无法求证到底是那两种情况的哪种情况，这样的问题实际上是一个线程同步问题，而ConcurrentHashMap又是线程安全的，所以ConcurrentHashMap不允许出现这样的问题。</li></ul><h2 id="为什么ThreadLocalMap的key是弱引用？"><a href="#为什么ThreadLocalMap的key是弱引用？" class="headerlink" title="为什么ThreadLocalMap的key是弱引用？"></a>为什么ThreadLocalMap的key是弱引用？</h2><ul><li>我们都知道ThreadLocalMap的key是ThreadLocal的弱引用，为什么要这样设计呢？实际上这是<strong>为了防止内存泄漏</strong>而设计的。</li><li>想象一个场景，我们在使用ThreadLocal的时候，我们new了一个ThreadLocal对象，然后用一个强引用指向了它，同时这个ThreadLocal也被Thread中的ThreadLocalMap的key指向了，如果key是强引用，那么当我们不想用这个ThreadLocal从而将我们自己创建的那个强引用改变指向之后，由于还有强引用指向那个ThreadLocal，所以它的空间是永远不会被gc的，在极端情况下就会出现内存泄漏，所以我们将key设置成ThreadLocal的弱引用，这样在ThreadLocal不存在外界的强引用的时候，在下一次gc中会被回收，减少出现内存泄漏问题的概率。</li></ul><h2 id="为什么ThreadLocalMap的value不是弱引用？"><a href="#为什么ThreadLocalMap的value不是弱引用？" class="headerlink" title="为什么ThreadLocalMap的value不是弱引用？"></a>为什么ThreadLocalMap的value不是弱引用？</h2><ul><li>因为<strong>大多数情况下外界不对value有强引用</strong>，我们归根结底还是要通过ThreadLocal这个key从ThreadLocalMap得到value的，这个可以想一下我们平时使用ThreadLocal的场景，我们是通过ThreadLocal这个key来去找value，所以value通常在外界没有强引用，所以如果value是弱引用的话，很容易就被gc掉了，这就导致我们使用ThreadLocal的get方法的时候返回值是null，这显然不是我们期望的结果。</li></ul><h1 id="JVM-1"><a href="#JVM-1" class="headerlink" title="JVM"></a>JVM</h1><h2 id="java对象在堆中的结构"><a href="#java对象在堆中的结构" class="headerlink" title="java对象在堆中的结构"></a>java对象在堆中的结构</h2><ul><li>主要是分为三部分：<strong>对象头、实例数据、对齐填充</strong></li></ul><h3 id="对象头（header）"><a href="#对象头（header）" class="headerlink" title="对象头（header）"></a>对象头（header）</h3><ul><li>分为两大块，第一块是<strong>占8个字节的markword，其中存放着锁信息、hashcode、GC信息</strong>，第二块是<strong>占4个字节（压缩前是8个字节，默认压缩）的类型指针（class pointer），这个没啥好说的，就是存放的是这个对象的类的元数据（在方法区中）的地址</strong>。</li><li>也就是说一般情况下对象头占12个字节。</li><li>平时所说的拿到了对象的锁，实际上从底层来看就是修改了对象头中的markword中的锁信息</li><li>在调用一次hashcode方法之后，这个对象的hashcode就会被记录到对象头的markword中，下次使用到的时候可以直接拿</li><li>对象头的markword中的GC信息记录的是这个对象的GC分代年龄</li></ul><h3 id="实例数据（instance-data）"><a href="#实例数据（instance-data）" class="headerlink" title="实例数据（instance data）"></a>实例数据（instance data）</h3><ul><li>这一部分<strong>存放着对象的所有实例属性</strong>。</li></ul><h3 id="对齐填充（padding）"><a href="#对齐填充（padding）" class="headerlink" title="对齐填充（padding）"></a>对齐填充（padding）</h3><ul><li>所有对象的大小（以字节为单位）都是8的倍数，这是为了契合64位处理器的位宽，这也是64位处理器能一次处理的数据大小（也就是一个字长的大小），所以对于那些前两个部分加起来不是8的倍数的对象，我们要<strong>补齐最后一段，从而让对象的大小是8的倍数</strong>，这一部分仅作补齐，没有其他含义。</li></ul><h2 id="对象如何定位"><a href="#对象如何定位" class="headerlink" title="对象如何定位"></a>对象如何定位</h2><ul><li>当用一个引用指向一个对象的时候，这个引用是如何找到那个对象的呢？</li></ul><h3 id="通过指针直接定位"><a href="#通过指针直接定位" class="headerlink" title="通过指针直接定位"></a>通过指针直接定位</h3><ul><li>这种方式也是hotspot虚拟机使用的方式，<strong>引用中存放着的是对象的地址</strong>，通过引用可以直接访问到对象。</li><li>好处就是<strong>访问效率高</strong>，坏处就是GC的时候对象会移动，而引用的值也要随之而改变，<strong>GC效率相较间接定位的方式偏低</strong>。</li></ul><h3 id="通过句柄间接定位"><a href="#通过句柄间接定位" class="headerlink" title="通过句柄间接定位"></a>通过句柄间接定位</h3><ul><li>这种方式，<strong>引用中存放的是一个句柄的地址</strong>，而这个<strong>句柄中又有两个直接指针分别指向对象和它的类的元数据</strong>，这种方式相当于通过句柄间接访问对象。</li><li>句柄通常存放在句柄池中，而<strong>句柄池通常是在堆中</strong>。</li><li>这种方式的好处在于，在进行GC的时候，内存中的对象的位置通常会发生改变（），而使用这种间接定位的方式，由于引用指向的是句柄，而句柄的位置不变，所以引用的值不需要改变，由于引用的值控制着很多GC的参数，所以它不变的话<strong>可以提高GC的效率</strong>。坏处就在于需要两次才能定位对象，<strong>定位的效率相较直接定位方式偏低</strong>。</li></ul><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="谈谈你对IO多路复用的理解？"><a href="#谈谈你对IO多路复用的理解？" class="headerlink" title="谈谈你对IO多路复用的理解？"></a>谈谈你对IO多路复用的理解？</h2><ul><li>IO多路复用是一种同步的IO模型，利用IO多路复用模型，我们可以使用一个或多个线程处理多个TCP连接而无需创建和维护过多的线程，IO多路复用有三种实现模型，分别是select模型、poll模型、epoll模型。</li><li></li></ul><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring中Bean的Scope是Singleton的时候Bean是单例模式吗？"><a href="#Spring中Bean的Scope是Singleton的时候Bean是单例模式吗？" class="headerlink" title="Spring中Bean的Scope是Singleton的时候Bean是单例模式吗？"></a>Spring中Bean的Scope是Singleton的时候Bean是单例模式吗？</h2><ul><li>是，但是这里的单例模式的作用范围非常小，只是作用在相同名字的范围，而并非我们通常说的单例模式一样是作用在同一类型上的，也就是说，<strong>平时我们说的单例模式是指一个类的对象只能有一个，而Spring中Bean的Singleton是指相同名字的对象只能有一个</strong>，也就是说如果我们新建一个Bean也是同一个类的对象，但是名字不同，这俩对象是不同的，如果说是我们平时说的那种单例模式的话，这俩对象就应该是相同的。</li></ul><h2 id="Spring中Bean的生命周期？"><a href="#Spring中Bean的生命周期？" class="headerlink" title="Spring中Bean的生命周期？"></a>Spring中Bean的生命周期？</h2><ul><li><strong>推断构造器</strong>：对于Spring来说，想要创建一个Bean的实例，首先就要推断用那个类的哪个构造器，如果其中只有一个构造器，那么Spring就会用唯一的哪个构造器；如果其中有多个构造方法，那么Spring会尝试去找无参构造器，如果找到了就用，如果没找到，Spring就会不知道使用哪个构造器，只能报错。同时我们也<strong>可以在我们想要使用的构造器上加上@Autowired注解来手动指定我们想用的构造器</strong>。</li><li><strong>实例化</strong>：Spring会使用上一步选中的构造器来实例化对应的Bean。</li><li>—————————————————–以上是Bean的实例化，以下是Bean的初始化———————————————————-</li><li><strong>填充属性</strong>：对Bean中使用了依赖注入注解的属性注入依赖。</li><li><strong>处理Aware回调</strong>：如果Bean的类实现了类似于BeanFactoryAware这样的接口，那么Spring会在这一步调用Bean中重写的那些接口中的方法，相当于是Spring把其内部的一些东西暴露给开发者来进行使用。</li><li><strong>初始化前，处理@PostConstruct注解</strong>：如果Bean中有方法上面有@PostConstruct注解，那么Spring会在这一步调用被那个注解修饰的方法。</li><li><strong>初始化，处理InitializingBean接口</strong>：如果Bean的类实现了InitializingBean接口，那么类中就要重写afterPropertiesSet方法，那个方法就是在这一步被Spring调用。当然也可以在xml文件中指定这一步要调用的方法。这一步可以做一些属性校验。</li><li><strong>初始化后，进行AOP</strong>：通过织入切面得到代理对象，此时Bean初始化完成，这个代理对象就是后面我们要使用的Bean。如果没有要织入的切面，那就直接使用Bean对象。</li></ul><h2 id="Spring-AOP是如何实现的？它和AspectJ有什么区别？"><a href="#Spring-AOP是如何实现的？它和AspectJ有什么区别？" class="headerlink" title="Spring AOP是如何实现的？它和AspectJ有什么区别？"></a>Spring AOP是如何实现的？它和AspectJ有什么区别？</h2><ul><li><strong>Spring AOP是使用了动态代理技术</strong>，如果Bean的类没有实现接口，那么使用的是<strong>Cglib动态代理</strong>，它用的是ASM字节码增强技术，这个技术会在解释运行字节码文件的时候动态对字节码进行改变（这也是为什么不使用AOT的原因），不需要被代理的类实现接口，因为其原理是生成一个被代理类的子类作为代理类，所以如果被代理类是final的就不能使用Cglib动态代理了；如果Bean的类实现了接口，那么使用的是<strong>JDK动态代理</strong>来生成被实现接口的代理对象。</li><li><strong>AspectJ是增强的静态代理</strong>，在<strong>对java文件进行编译的时候，会把切面织入到切入点中，也就是说编译形成的字节码文件本身就带着通知的逻辑</strong>，这就是作用在编译期的静态代理，使用AspectJ<strong>需要使用针对AspectJ的特殊编译器来编译文件</strong>。增强体现在相对于普通的静态代理，它不要求被代理类实现接口。</li><li><strong>Spring AOP沿用了AspectJ的部分注解</strong>，比如@Before、@After、@Around等，但是它们的底层原理是截然不同的。</li></ul><h2 id="Spring中的事务是如何实现的？"><a href="#Spring中的事务是如何实现的？" class="headerlink" title="Spring中的事务是如何实现的？"></a>Spring中的事务是如何实现的？</h2><h2 id="Spring事务什么时候失效？"><a href="#Spring事务什么时候失效？" class="headerlink" title="Spring事务什么时候失效？"></a>Spring事务什么时候失效？</h2><ul><li>由于Spring事务是使用Spring AOP实现的，而Spring AOP的原理又是动态代理，如果使用的是Cglib动态代理，那么生成的代理类是被代理类的子类，而对原方法的增强是通过代理类重写被代理类的方法来实现的，这也就意味着<strong>被代理类中的private方法和final方法是无法被代理的</strong>，因为生成的代理类中压根无法重写目标方法来对其进行增强。</li><li>如果<strong>在事务方法中手动调用本类中的其他方法</strong>，事务也会失效，因为这样做相当于通过this来调用本类的方法，而this是当前类的实例而非代理对象，所以调用的方法是没有事务特性的。</li><li>如果<strong>对象未注册到IOC容器中</strong>，事务注解也会失效，因为无法生成代理Bean</li><li><strong>错误的事务传播特性</strong>也会导致事务失效</li><li><strong>内部处理了异常没有往外抛或者手动抛了除指定外的其他异常</strong>，spring的事务也会失效</li></ul><h2 id="Spring是如何解决循环依赖的？"><a href="#Spring是如何解决循环依赖的？" class="headerlink" title="Spring是如何解决循环依赖的？"></a>Spring是如何解决循环依赖的？</h2><ul><li>多个Bean中相互持有对方的引用，就会产生循环依赖问题，循环依赖会导致Bean在依赖注入的时候造成死循环，有三种基本的形态，第一种是两个Bean之间互相依赖，第二种是三个以上的Bean之间互相依赖，第三种是一个Bean自己依赖自己。</li><li>Spring设计了三级缓存去解决循环依赖的问题，<strong>一级缓存存放已经初始化完成的Bean，二级缓存存放刚实例化完成的Bean，三级缓存存放对应Bean的工厂</strong></li><li>当获取一个Bean的时候，Spring会先从一级缓存去找，然后再从二级缓存去找，如果都没有找到，说明当前要获取的这个Bean还没有实例化，于是Spring会先对这个Bean进行实例化操作（注意只是实例化操作，初始化操作没有做，这也就意味着这个Bean中的属性还没有被注入依赖），然后Spring会判断这个Bean是否存在循环依赖问题，如果不存在，那么直接执行下面的内容直到Bean初始化完之后放到一级缓存中，如果存在，那么Spring会先把当前这个刚实例化完的Bean放入到二级缓存中，然后去尝试创建它依赖的那个Bean，那个Bean依赖着之前那个Bean，但是由于之前那个Bean的半成品已经进二级缓存了，所以这个Bean就能顺利走完初始化步骤，然后进入一级缓存，这时又回到了之前那个Bean的初始化步骤，从一级缓存中拿到依赖的那个Bean往下走，初始化完之后也进入一级缓存并从二级缓存中删掉它的引用。</li><li>上面说的情况是两个Bean不存在创建代理对象步骤的时候，如果需要创建代理对象，那么就不能用上面的方法解决循环依赖问题了，因为创建代理对象是在初始化后做的，而它们互相依赖的都是它们的代理对象，前面把实例化后的半成品放到二级缓存中会让后面的Bean引用前面的Bean本身而不是它的代理，这种情况就需要前面的Bean在实例化完之后把自己的一个工厂放到三级缓存中，当后面的Bean想要注入依赖的时候需要从三级缓存中用对应的工厂来得到前面的Bean，这个<strong>工厂实际上会执行AOP步骤中的提前创建代理对象的方法，也就是会提前创建好代理对象，把提前创建好的代理对象放到二级缓存中</strong>，然后后面的Bean就可以使用了。所以这样做就解决了Spring循环依赖的问题。</li></ul><h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><h2 id="叙述一下Spring-Boot自动装配机制的原理？"><a href="#叙述一下Spring-Boot自动装配机制的原理？" class="headerlink" title="叙述一下Spring Boot自动装配机制的原理？"></a>叙述一下Spring Boot自动装配机制的原理？</h2><ul><li>自动装配简单来说就是<strong>自动去把第三方组件的Bean装载到IOC容器中</strong>，不需要开发人员再去写bean相关配置，要想开启自动装配，我们只需要在启动类上加上@SpringBootApplication注解就可以实现自动装配了，但是这个注解是个复合注解，实际上自动装配是<strong>通过使用@EnableAutoConfiguration注解来进行开启</strong>的。</li><li>自动装配的实现主要依靠三个核心的关键技术：<ol><li>引入Starter启动依赖组件的时候，这个组件中必须包含一个带有**@Configuration注解的配置类<strong>，在这个配置类中我们需要使用</strong>@Bean注解来声明需要装配到IOC容器里面的Bean对象**。</li><li>这个配置类是放在第三方的jar包中的，然后通过Spring Boot中<strong>约定大于配置</strong>的理念，去把这个<strong>配置类的全路径放在classpath:&#x2F;META-INF&#x2F;spring.factories文件中</strong>，这样spring就可以知道这个配置类在第三方jar包中的位置，这个步骤主要是用到了spring中<strong>SpringFactoriesLoader</strong>来完成的。</li><li>Spring Boot在拿到所有第三方jar包里面声明的配置类之后，再通过spring提供的<strong>ImportSelector接口</strong>来实现对这些配置类的<strong>动态加载</strong>从而去完成动态装配的动作。</li></ol></li><li>在我看来，SpringBoot是约定优于配置这一理念下的一个产物，所以在很多地方都能看到这样的思想，它的出现可以<strong>让开发人员更多地聚焦再业务代码的编写上，而不需要去关心和业务无关的配置</strong>。</li><li>@EnableXxxxxx注解的实现实际上也是帮我们去自动完成相关Bean的注入而不需要我们去手动配置需要的Bean。</li></ul><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI-七层模型是什么？每一层的作用是什么？"><a href="#OSI-七层模型是什么？每一层的作用是什么？" class="headerlink" title="OSI 七层模型是什么？每一层的作用是什么？"></a>OSI 七层模型是什么？每一层的作用是什么？</h2><ul><li>应用层：为计算机用户提供服务</li><li>表示层：数据处理（编解码、加密解密、压缩解压缩）</li><li>会话层：管理（建立、维护、重连）应用程序之间的会话</li><li>传输层：为两台主机进程之间的通信提供的通用的数据传输服务</li><li>网络层：路由和寻址（决定数据在网络上的游走路径）</li><li>数据链路层：对数据进行封装成帧、透明传输、差错校验（CRC循环冗余校验）</li><li>物理层：确定如何表示比特（比如高电平表示1，低电平表示0），确定比特如何传输（通过光缆、同轴电缆等），透明地传输比特流数据</li></ul><h2 id="TCP-x2F-IP-四层模型是什么？每一层的作用是什么？"><a href="#TCP-x2F-IP-四层模型是什么？每一层的作用是什么？" class="headerlink" title="TCP&#x2F;IP 四层模型是什么？每一层的作用是什么？"></a>TCP&#x2F;IP 四层模型是什么？每一层的作用是什么？</h2><h2 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h2><ul><li>HTTP传输的数据是明文，很容易出现安全问题，而HTTPS传输的数据是密文，它结合了<strong>SSL&#x2F;TLS和TCP协议</strong>，对通信数据进行了加密。</li><li>对于SSL&#x2F;TLS协议来说，为了安全起见，应该使用非对称加密机制来保证数据的安全，也就是说发送方使用公钥进行加密，接收方使用私钥进行解密。</li><li>但是由于非对称加密体制需要的计算量较大，所以这样做数据传输效率会比较低，所以<strong>实际上SSL&#x2F;TLS协议是使用对称加密机制来保证数据安全的</strong>，也就是说通信双方都通过同一个公钥进行加密和解密，这样做数据的安全性实际上就是依赖于公钥的保密程度，因为加密和解密算法通常是公开的。</li><li>但是采用这种对称的加密方案的话，公钥的传输又是一个问题，因为接收方如果想要解析数据，就需要发送方发送的公钥，当发送方发送公钥的时候，如果敌手截取了发送方发送的公钥，那么敌手可以伪造一个公钥给接收方发过去，这样接收方之后发送消息都会通过这个伪造的公钥进行加密，这样敌手获取这个数据之后通过自己的私钥进行解密，就能获得明文了，而发送方和接收方对于这个敌手一无所知。</li><li>所以我们引入了<strong>第三方可信的证书颁发机构CA</strong>，如果发送方想要给接收方发送公钥，就要先向CA申请一个证书，CA会把包括要发送的<strong>公钥</strong>在内的数据做成<strong>证书</strong>，然后使用<strong>报文摘要算法</strong>对证书进行计算得到<strong>散列码</strong>，同时CA使用自己的<strong>私钥</strong>对得到的散列码进行<strong>加密</strong>，这样生成的数据就是CA对这个证书的<strong>数字签名</strong>，这个数字签名可以用来判断证书是否有效。</li><li>CA做完上面的操作之后把证书+签名交给发送方，发送方把这些数据发送给接收方，接收方收到之后会使用CA的<strong>公钥</strong>来对数字签名进行<strong>解密</strong>，并对证书数据进行相同的<strong>报文摘要算法</strong>，将计算结果和解密后的数字签名<strong>进行比较</strong>，如果相同，说明证书有效，如果不相同，说明证书无效。</li><li>当引入CA之后，如果敌手截获了CA的证书+签名，那么敌手也没有什么可以做的，敌手如果篡改证书数据而不改签名的话，接收方就会发现证书无效而不予使用，如果敌手想要篡改证书数据又篡改签名的话，由于不知道CA的私钥，所以无法对生成的散列码进行加密，这种情况同样也会被接收端验证出来证书无效。</li><li>总的来说<strong>SSL&#x2F;TLS是通过对称加密数据和通过证书发送公钥的方式来实现数据的安全传输的</strong>。</li></ul><h2 id="HTTP1-0、1-1、2-0、3-0之间的区别？"><a href="#HTTP1-0、1-1、2-0、3-0之间的区别？" class="headerlink" title="HTTP1.0、1.1、2.0、3.0之间的区别？"></a>HTTP1.0、1.1、2.0、3.0之间的区别？</h2><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h2><ol><li>操作系统是管理计算机硬件与软件资源的程序，是计算机的基石。</li><li></li></ol><h2 id="多级反馈队列调度算法了解吗？"><a href="#多级反馈队列调度算法了解吗？" class="headerlink" title="多级反馈队列调度算法了解吗？"></a>多级反馈队列调度算法了解吗？</h2><ul><li>多级反馈队列调度算法实际上是一种<strong>进程调度算法</strong>，它很好地<strong>融合了先来先服务、短作业优先、优先级、时间片轮转这几种进程调度算法的优势</strong>，这种进程调度算法<strong>使得优先级高的进程能快速得到响应的同时又保证了短作业能快速完成</strong>，这也是Unix系统中使用的进程调度算法。</li><li>其工作原理主要就是<strong>划分了多个优先级队列</strong>，每个队列存放不同优先级的进程，然后<strong>每个队列都有属于自己的时间片长度</strong>，<strong>优先级越高的队列时间片的长度越小</strong>（这样其实就是保证了高优先级作业能快速得到响应但是不一定会被处理完，而由于不用等待前面的作业处理完后再处理后面的作业，所以低优先级的短作业会很快被处理完）。</li><li>进行进程调度时会<strong>先从优先级高的队列开始</strong>，用<strong>先来先服务</strong>的方式去<strong>使用队列对应的时间片</strong>来让进程运行，如果在<strong>一个时间片内</strong>运行完毕，那个进程就可以直接退出系统了，如果在一个时间片内没有运行完毕，那么这个进程将会<strong>进入下一个队列的队尾中</strong>，以此类推，直到进程进入最后一个队列的队尾，该算法<strong>对最后一个队列的进程采用的时间片轮转的调度方法</strong>。</li><li>只有在<strong>处理完一个队列之后才会处理下一个队列</strong>，但是如果在处理优先级较低的队列时有优先级较高的进程进入了优先级较高的队列，那么处理机会将当前处理的进程放在当前队列的队尾，然后<strong>立即去处理刚来的较高优先级的进程</strong>。</li></ul><h2 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h2><ul><li>我认为虚拟内存是操作系统<strong>对于物理内存的抽象和封装</strong>，也就是说操作系统通过抽象和封装物理内存来<strong>给进程提供一个逻辑上连续且完整的地址空间</strong>，而这些所谓连续且完整的内存空间<strong>可能在物理层面是离散的</strong>，而且<strong>可能有部分是使用的磁盘上的空间</strong>，这样的做法使得<strong>计算机好像为用户提供了比实际内存大得多的内存空间</strong>，这实际上就是虚拟内存的概念。</li><li>这样做的好处主要有三个：<ol><li>首先就是我们在编写大型应用程序的时候，我们面向的地址空间是操作系统给我们提供的虚拟内存空间，这个空间总是<strong>连续且完整</strong>的，这<strong>给我们进行软件开发带来了极大的便利</strong>。</li><li>其次就是<strong>防止出现地址冲突的问题</strong>，如果操作系统直接将物理地址暴露给进程，那么进程可能会有意或无意地触碰到那些已经在使用地内存空间，这样可能会造成别的进程乃至操作系统的崩溃，但是如果进程面向的是虚拟内存空间就不会出现这种情况，因为虚拟地址会通过操作系统的调控再转换为物理地址，操作系统不会让这种情况发生。</li><li>再者就是使用虚拟内存<strong>消除了计算机同时运行多个程序带来的安全问题</strong>，如果操作系统将物理内存暴露，那么不同的人在编写应用程序的时候可能使用了相同的物理内存，这样不同的程序在同一个计算机上运行的时候就会出现问题，使用虚拟内存就不会出现这样的问题，因为操作系统会动态调控。</li></ol></li><li>基于<strong>局部性原理</strong>，在程序装入时，可以<strong>将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行</strong>。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。<strong>在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序</strong>。另一方面，<strong>操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息</strong>。这样，计算机好像为用户提供了一个比实际内存大得多的存储器——<strong>虚拟内存</strong>。</li><li>我觉得虚拟内存同样是一种<strong>时间换空间</strong>的策略：你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。</li></ul><h2 id="虚拟内存技术的实现？"><a href="#虚拟内存技术的实现？" class="headerlink" title="虚拟内存技术的实现？"></a>虚拟内存技术的实现？</h2><ul><li>虚拟内存技术的实现需要<strong>建立在离散分配的内存管理方式的基础上</strong>，虚拟内存的实现有以下三种方式：<ol><li><strong>请求分页存储管理</strong> ：<strong>建立在分页管理之上</strong>，为了支持虚拟存储器功能而<strong>增加了请求调页功能和页面置换功能</strong>。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，<strong>在作业开始运行之前，仅装入当前要执行的部分段即可运行</strong>。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法<strong>将要用的页面调入到主存</strong>，同时操作系统也可以<strong>将暂时不用的页面置换到外存</strong>中。</li><li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，<strong>增加了请求调段功能、分段置换功能</strong>。请求分段储存管理方式就如同请求分页储存管理方式一样，<strong>在作业开始运行之前，仅装入当前要执行的部分段即可运行</strong>；在执行过程中，可<strong>使用请求调入中断动态装入要访问但又不在内存的程序段</strong>；当内存空间已满，而又需要装入新的段时，<strong>根据置换功能适当调出某个段，以便腾出空间而装入新的段</strong>。</li><li><strong>请求段页式存储管理</strong></li></ol></li><li>这里多说一下，很多人容易搞混请求分页与分页存储管理，两者有何不同呢？<ul><li>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</li><li>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</li></ul></li><li>不管是上面那种实现方式，我们一般都需要：<ol><li><strong>一定容量的内存和外存</strong>：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li><li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li><li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li></ol></li></ul><h2 id="常见的页面置换算法有哪些？"><a href="#常见的页面置换算法有哪些？" class="headerlink" title="常见的页面置换算法有哪些？"></a>常见的页面置换算法有哪些？</h2><ul><li><strong>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断</strong> 。<strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</li><li>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。<strong>用来选择淘汰哪一页的规则叫做页面置换算法</strong>，我们可以把页面置换算法看成是淘汰页面的规则，页面置换算法主要有以下几种：<ol><li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法<strong>所选择的被淘汰页面将是以后永不使用的</strong>，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而<strong>该算法无法实现</strong>。一般作为衡量其他置换算法的方法。</li><li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即<strong>选择在内存中驻留时间最久的页面进行淘汰</strong>。</li><li><strong>LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU 算法赋予每个页面一个访问字段，用来<strong>记录一个页面自上次被访问以来所经历的时间 T</strong>，当须淘汰一个页面时，<strong>选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰</strong>。</li><li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法<strong>选择在之前时期使用最少的页面作为淘汰页</strong>。</li></ol></li></ul><h1 id="数据库理论"><a href="#数据库理论" class="headerlink" title="数据库理论"></a>数据库理论</h1><h2 id="一些数据库术语"><a href="#一些数据库术语" class="headerlink" title="一些数据库术语"></a>一些数据库术语</h2><ul><li><strong>关系</strong>：一个关系对应一张表</li><li><strong>元组</strong>：表中的一行</li><li><strong>属性</strong>：表中的一列</li><li><strong>码</strong>：也称码键，是表中的某个可以唯一标识一个元组的属性</li><li><strong>候选码</strong>：若关系中的一个属性或属性组的值能够唯一地标识一个元组，且他的真子集不能唯一的标识一个元组，则称这个属性或属性组做候选码。</li><li><strong>主码</strong>：从候选码里面任意挑出一个候选码作为主码。</li><li><strong>主属性</strong>：包含在候选码中的属性。</li><li><strong>非主属性</strong>：不包含在候选码中的属性。</li><li>全码：若关系中只有一个候选码,且这个候选码中包含全部属性,则该候选码为全码。</li><li>超码：能表示出所有属性的集合。候选码是最小的超码。</li><li>域：是一组具有相同数据类型的值的集合</li><li>分量：元组中的一个属性</li></ul><h2 id="数据库关系的完整性有哪三种？"><a href="#数据库关系的完整性有哪三种？" class="headerlink" title="数据库关系的完整性有哪三种？"></a>数据库关系的完整性有哪三种？</h2><ol><li>实体完整性：主码唯一且为空。</li><li>参照完整性：外码要么为空，要么对应另一个表的主码。外码指的是别的表的属性，一般用来关联两个表。</li><li>用户定义完整性：用户自己定义的关系要完整，不能有关键属性的遗漏。</li></ol><h2 id="怎么将ER图转换为关系模式？"><a href="#怎么将ER图转换为关系模式？" class="headerlink" title="怎么将ER图转换为关系模式？"></a>怎么将ER图转换为关系模式？</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514141426012.png" alt="image-20220514141426012"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514141438620.png" alt="image-20220514141438620"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514141501633.png" alt="就是将关系的属性和两边的主键组合成一个新的关系模式"></p><h2 id="如何对sql进行代数优化？"><a href="#如何对sql进行代数优化？" class="headerlink" title="如何对sql进行代数优化？"></a>如何对sql进行代数优化？</h2><ol><li>选择运算尽量先做</li><li>把投影运算和选择运算同时执行</li><li>把投影同它前后的双目运算符连接起来</li></ol><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="什么是快照读？什么是当前读？"><a href="#什么是快照读？什么是当前读？" class="headerlink" title="什么是快照读？什么是当前读？"></a>什么是快照读？什么是当前读？</h2><ul><li>快照读和当前读是读取数据的不同方式，这两种方式<strong>都能保证一定的事务隔离性</strong>，但是它们的<strong>底层实现不同</strong>。</li><li><strong>当前读</strong>又叫锁定读，顾名思义是用<strong>锁</strong>实现的，读到的是<strong>最新的数据</strong>；<strong>快照读</strong>又叫非锁定读，是使用<strong>MVCC</strong>技术实现的，读到的<strong>不一定是最新的数据</strong>。</li><li>快照读（非锁定读）举例：select * from table</li><li>当前读（锁定读）举例：select * from table <strong>lock in share mode</strong>、select * from table <strong>for update</strong>、insert操作、update操作、delete操作</li></ul><h2 id="介绍一下MVCC？"><a href="#介绍一下MVCC？" class="headerlink" title="介绍一下MVCC？"></a>介绍一下MVCC？</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>MVCC是<strong>多版本并发控制</strong>的意思，InnoDB中使用这个技术和锁技术一起保证事务的隔离性，这个技术主要是能<strong>让事务在不使用锁的前提下保证其隔离性</strong>，由于没有使用到锁，所以<strong>使用MVCC时的并发性能是比较高的</strong>，这也是InnoDB<strong>快照读</strong>的实现原理。</li><li>在<strong>RC</strong>的事务隔离级别下MVCC可以<strong>防止出现脏读</strong>，在<strong>RR</strong>的事务隔离级别下MVCC可以<strong>防止出现脏读、不可重复读和部分幻读</strong>，如果想要解决全部的幻读问题需要搭配<strong>临键锁</strong>来实现。</li></ul><h3 id="技术依赖"><a href="#技术依赖" class="headerlink" title="技术依赖"></a>技术依赖</h3><ul><li><p>InnoDB对MVCC的实现主要依赖于<strong>记录的隐藏字段、Read View和undo log</strong></p></li><li><p>先说一下隐藏字段，起主要作用的主要就是仨：</p><ol><li><strong>DB_TRX_ID</strong>：表示最后一次插入、删除或更新该行的事务 id。</li><li><strong>DB_ROLL_PTR</strong>：指向undo log中的之前这个记录的版本，如果该行无历史版本，则这个字段为空</li><li>DB_ROW_ID：记录的唯一id，如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引</li></ol></li><li><p>再说一下Read View，生成它的时机在不同的隔离级别中也是不同的，在<strong>RC隔离级别中，在事务中的每个select语句执行之前都会生成一个Read View</strong>；而在<strong>RR隔离级别中，在事务中只有第一个select语句执行之前会生成Read View</strong>，剩下的select语句都使用之前生成的Read View。那么这个Read View中有什么作用呢？我觉得可以把它看成一个<strong>事务状态快照</strong>，在生成它的时候得到当前时刻各事务的状态，然后<strong>根据这些信息和DB_TRX_ID来判断undo log中哪些版本是可见的</strong>。那么Read View中有些什么值呢？起主要作用的有四个字段：</p><ol><li><strong>m_low_limit_id</strong>：<strong>目前出现过的最大的事务 ID+1</strong>，即下一个将被分配的事务 ID。<strong>大于等于这个 ID 的数据版本均不可见</strong></li><li><strong>m_up_limit_id</strong>：<strong>活跃事务列表 m_ids中最小的事务 ID</strong>，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。<strong>小于这个 ID 的数据版本均可见</strong>。</li><li><strong>m_ids</strong>：<strong>Read View创建时其他未提交的活跃事务 ID 列表</strong>。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<strong>m_ids 不包括当前事务自己和已提交的事务（正在内存中）</strong></li><li><strong>m_creator_trx_id</strong>：<strong>创建该 Read View的事务 ID</strong></li></ol><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230306173026267.png" alt="image-20230306173026267"></p></li><li><p>最后说一下undo log，这个日志中<strong>保存着各记录的历史版本</strong>，<strong>各历史版本之间通过记录中的隐藏字段DB_ROLL_PTR来链接</strong>。</p></li></ul><h3 id="如何使用Read-View和DB-TRX-ID字段来判断记录的可见性"><a href="#如何使用Read-View和DB-TRX-ID字段来判断记录的可见性" class="headerlink" title="如何使用Read View和DB_TRX_ID字段来判断记录的可见性"></a>如何使用Read View和DB_TRX_ID字段来判断记录的可见性</h3><ol><li>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的</li><li>如果 DB_TRX_ID &gt;&#x3D; m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5</li><li>m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</li><li>如果 m_up_limit_id &lt;&#x3D; DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的<strong>二分查找</strong>，因为是有序的）<ul><li>如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5</li><li>在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见</li></ul></li><li>在该记录行的 DB_ROLL_PTR 指针所指向的 <code>undo log</code> 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空</li></ol><ul><li>总之就是先判断DB_TRX_ID是否大于最大id，如果是，那就顺着版本链在undo log中找符合条件的历史版本，如果不是，再判断DB_TRX_ID是否小于最小id，如果是，那就直接将该记录加入结果中，如果不是，再去m_ids中找是否有当前DB_TRX_ID的值，如果没有，那就直接将该记录加入到结果中，如果有，就顺着版本链在undo log中找符合条件的历史版本。</li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>在事务中进行更新、删除、插入记录的时候，undo log会<strong>把最新的记录状态记录下来</strong>，让隐藏字段DB_TRX_ID字段的值等于操作的事务ID，然后让隐藏字段DB_ROLL_PTR指向之前的那个记录版本。</li><li>在事务中进行快照读的时候，如果是RC隔离级别，那么在读之前会创建一个新的Read View；如果是RR隔离级别，那么在读之前会判断Read View是否已经生成，如果已经生成则使用已有的Read View，如果没有生成就创建一个新的Read View。然后每当读到一条记录的时候，都会<strong>通过DB_TRX_ID和Read View来判断记录的可见性（上面提到了具体步骤）</strong>，如果可见，就加入到结果中，如果不可见，就从undo log中找历史版本加入到结果中，如果没有满足条件的历史版本，那就跳过当前记录。</li></ul><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>—————————————————————————–Redis基础————————————————————————————–</p><h2 id="对于Redis，你的理解是什么？"><a href="#对于Redis，你的理解是什么？" class="headerlink" title="对于Redis，你的理解是什么？"></a>对于Redis，你的理解是什么？</h2><ul><li>Redis是一个<strong>基于内存</strong>实现的<strong>Key-Value数据结构</strong>的<strong>NoSQL数据库</strong>，由于数据是存储在内存之中，所以数据的IO效率是非常高的，当然Redis还提供了一些持久化策略来避免内存数据丢失的问题。NoSQL实际上就是非关系型数据库，这类数据库主要是考虑数据的扩展性、性能和大数据量的存储，弥补了关系型数据库的短板。通常用在分布式系统中做缓存中间件，同时对于企业级应用来说，Redis还提供了主从复制+哨兵+集群的方式来实现高可用，同时通过哈希槽的机制来实现了数据的分片，进一步提升了系统整体的性能和可扩展性。</li></ul><h2 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h2><ul><li>Redis是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 <strong>Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据</strong>。</li><li>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap）。并且，Redis 还支持事务 、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</li><li>Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。</li></ul><h2 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h2><ul><li>Redis 内部做了非常多的性能优化，比较重要的主要有下面 3 点：<ol><li>Redis <strong>基于内存</strong>，内存的访问速度是磁盘的上千倍；</li><li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是<strong>单线程事件循环和 IO 多路复用</strong>（Redis 线程模式后面会详细介绍到）；</li><li>Redis <strong>内置了多种优化过后的数据结构实现</strong>，性能非常高。</li></ol></li></ul><h2 id="Redis和Memcached的区别和共同点"><a href="#Redis和Memcached的区别和共同点" class="headerlink" title="Redis和Memcached的区别和共同点"></a>Redis和Memcached的区别和共同点</h2><ul><li>现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据。</li></ul><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k&#x2F;v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k&#x2F;v 数据类型。</li><li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li><li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li><li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li><li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li><li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型（仅IO和执行命令是单线程，其实Redis服务端本身是多线程的）。</strong> （Redis 6.0 引入了多线程 IO ）</li><li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li><li><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li></ol><h2 id="为什么要用Redis-x2F-为什么要用缓存？"><a href="#为什么要用Redis-x2F-为什么要用缓存？" class="headerlink" title="为什么要用Redis&#x2F;为什么要用缓存？"></a>为什么要用Redis&#x2F;为什么要用缓存？</h2><ul><li>主要是从<strong>高性能</strong>和<strong>高并发</strong>两点来分析。</li></ul><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><ul><li>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，<strong>如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中</strong>。</li><li>这样有什么好处呢？ 那就是<strong>保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快</strong>。</li></ul><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><ul><li>一般像 MySQL 这类的数据库的 QPS（服务器每秒可以执行的查询次数） 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。</li><li>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑<strong>把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发</strong>。</li></ul><h2 id="Redis除了做缓存之外，还能做什么？"><a href="#Redis除了做缓存之外，还能做什么？" class="headerlink" title="Redis除了做缓存之外，还能做什么？"></a>Redis除了做缓存之外，还能做什么？</h2><ul><li><strong>分布式锁</strong> ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。</li><li><strong>限流</strong> ：一般是通过 Redis + Lua 脚本的方式来实现限流。</li><li><strong>消息队列</strong> ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li><li><strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li><li>……</li></ul><h2 id="Redis可以做消息队列吗？"><a href="#Redis可以做消息队列吗？" class="headerlink" title="Redis可以做消息队列吗？"></a>Redis可以做消息队列吗？</h2><ul><li>Redis 5.0 新增加的一个数据结构 <code>Stream</code> 可以用来做消息队列，<code>Stream</code> 支持：<ol><li>发布 &#x2F; 订阅模式</li><li>按照消费者组进行消费</li><li>消息持久化（ RDB 和 AOF）</li></ol></li><li>不过，和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议是不使用 Redis 来做消息队列的，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</li></ul><h2 id="如何基于Redis实现分布式锁？"><a href="#如何基于Redis实现分布式锁？" class="headerlink" title="如何基于Redis实现分布式锁？"></a>如何基于Redis实现分布式锁？</h2><p>—————————————————————————–Redis数据结构——————————————————————————-</p><h2 id="Redis常用的数据结构有哪些？"><a href="#Redis常用的数据结构有哪些？" class="headerlink" title="Redis常用的数据结构有哪些？"></a>Redis常用的数据结构有哪些？</h2><ul><li><strong>5 种基础数据结构</strong> ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li><li><strong>3 种特殊数据结构</strong> ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li><li>赶不上（GBS）临淄（LZ）黄昏时（HHS）</li></ul><h2 id="String-的应用场景有哪些？"><a href="#String-的应用场景有哪些？" class="headerlink" title="String 的应用场景有哪些？"></a>String 的应用场景有哪些？</h2><ul><li>常规数据（比如 session、token、、序列化后的对象）的缓存；</li><li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li><li>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li><li>……</li></ul><h2 id="存储对象数据使用String还是Hash更好？"><a href="#存储对象数据使用String还是Hash更好？" class="headerlink" title="存储对象数据使用String还是Hash更好？"></a>存储对象数据使用String还是Hash更好？</h2><ul><li><strong>String 存储的是序列化后的对象数据，存放的是整个对象</strong>。<strong>Hash 是对对象的每个字段单独存储</strong>，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。<strong>如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合</strong>。</li><li><strong>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半</strong>。并且，存储具有多层嵌套的对象时也方便很多。<strong>如果系统对性能和资源消耗非常敏感的话，String 就非常适合</strong>。</li><li>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</li></ul><h2 id="String的底层实现是什么？"><a href="#String的底层实现是什么？" class="headerlink" title="String的底层实现是什么？"></a>String的底层实现是什么？</h2><ul><li><p>Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 <code>\0</code> 结尾的字符数组），而是<strong>自己编写了 SDS（Simple Dynamic String，简单动态字符串） 来作为底层实现</strong>。</p></li><li><p>SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。</p></li><li><p>Redis7.0 的 SDS 的部分源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。<strong>Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用</strong>：</p><table><thead><tr><th>类型</th><th>字节</th><th>位</th></tr></thead><tbody><tr><td>sdshdr5</td><td>&lt; 1</td><td>&lt;8</td></tr><tr><td>sdshdr8</td><td>1</td><td>8</td></tr><tr><td>sdshdr16</td><td>2</td><td>16</td></tr><tr><td>sdshdr32</td><td>4</td><td>32</td></tr><tr><td>sdshdr64</td><td>8</td><td>64</td></tr></tbody></table></li><li><p>对于后四种实现都包含了下面这 4 个属性：</p><ol><li><code>len</code> ：字符串的长度也就是已经使用的字节数</li><li><code>alloc</code>：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小</li><li><code>buf[]</code> ：实际存储字符串的数组</li><li><code>flags</code> ：低三位保存类型标志</li></ol></li><li><p>SDS 相比于 C 语言中的字符串有如下提升：</p><ol><li><strong>可以避免缓冲区溢出</strong> ：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li><li><strong>获取字符串长度的复杂度较低</strong> ： C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li><li><strong>减少内存分配次数</strong> ： 为了避免修改（增加&#x2F;减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li><li><strong>二进制安全</strong> ：C 语言中的字符串以空字符 <code>\0</code> 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</li></ol></li><li><p>多提一嘴，很多文章里 SDS 的定义是下面这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，<code>len</code> 和 <code>free</code> 的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。</p></li></ul><h2 id="购物车信息用String还是Hash存储更好呢？"><a href="#购物车信息用String还是Hash存储更好呢？" class="headerlink" title="购物车信息用String还是Hash存储更好呢？"></a>购物车信息用String还是Hash存储更好呢？</h2><ul><li><p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p><ul><li><p>用户 id 为 key</p></li><li><p>商品 id 为 field，商品数量为 value</p></li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223155104792.png" alt="image-20230223155104792"></p></li><li><p>那用户购物车信息的维护具体应该怎么操作呢？</p><ul><li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li><li>查询购物车信息就是遍历对应的 Hash；</li><li>更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li><li>删除商品就是删除 Hash 中对应的 field；</li><li>清空购物车直接删除对应的 key 即可。</li></ul></li><li><p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。</p></li></ul><h2 id="使用Redis实现一个排行榜怎么做？"><a href="#使用Redis实现一个排行榜怎么做？" class="headerlink" title="使用Redis实现一个排行榜怎么做？"></a>使用Redis实现一个排行榜怎么做？</h2><ul><li>Redis 中有一个叫做 <strong><code>sorted set</code> 的数据结构经常被用在各种排行榜的场景</strong>，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li><li>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li></ul><h2 id="使用Set实现抽奖系统需要用到什么命令？"><a href="#使用Set实现抽奖系统需要用到什么命令？" class="headerlink" title="使用Set实现抽奖系统需要用到什么命令？"></a>使用Set实现抽奖系统需要用到什么命令？</h2><ul><li><code>SPOP key count</code> ： 随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li><li><code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li></ul><h2 id="使用Bitmap统计活跃用户怎么做？"><a href="#使用Bitmap统计活跃用户怎么做？" class="headerlink" title="使用Bitmap统计活跃用户怎么做？"></a>使用Bitmap统计活跃用户怎么做？</h2><ul><li><p>使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</p></li><li><p>初始化数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SETBIT 20210308 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">SETBIT 20210308 2 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">SETBIT 20210309 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></li><li><p>统计 20210308~20210309 总活跃用户数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITOP and desk1 20210308 20210309</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; BITCOUNT desk1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></li><li><p>统计 20210308~20210309 在线活跃用户数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITOP or desk2 20210308 20210309</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; BITCOUNT desk2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用HyperLogLog统计页面UV怎么做？"><a href="#使用HyperLogLog统计页面UV怎么做？" class="headerlink" title="使用HyperLogLog统计页面UV怎么做？"></a>使用HyperLogLog统计页面UV怎么做？</h2><ol><li><p>将访问指定页面的每个用户ID添加到HyperLogLog中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFADD PAGE_1:UV USER1 USER2 ...... USERn</span><br></pre></td></tr></table></figure></li><li><p>统计指定页面的UV。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT PAGE_1:UV</span><br></pre></td></tr></table></figure></li></ol><p>—————————————————————————–Redis线程模型——————————————————————————-</p><h2 id="Redis单线程模型了解吗？"><a href="#Redis单线程模型了解吗？" class="headerlink" title="Redis单线程模型了解吗？"></a>Redis单线程模型了解吗？</h2><ul><li><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于<strong>文件事件处理器（file event handler）是单线程方式运行的</strong>，所以我们一般都说 Redis 是单线程模型。</li></ul><blockquote><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。</p><ul><li>文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I&#x2F;O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p></blockquote><ul><li><p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p></li><li><p>这样的好处非常明显： <strong>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p></li><li><p>文件事件处理器（file event handler）主要是包含 4 个部分：</p><ol><li>多个 socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ol><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223160742563.png" alt="image-20230223160742563"></p></li></ul><h2 id="Redis6-0之前为什么不使用多线程？"><a href="#Redis6-0之前为什么不使用多线程？" class="headerlink" title="Redis6.0之前为什么不使用多线程？"></a>Redis6.0之前为什么不使用多线程？</h2><ul><li>虽然说 Redis 是单线程模型，但是，实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></li><li>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。</li><li>为此，Redis 4.0 之后新增了<code>UNLINK</code>（可以看作是 <code>DEL</code> 的异步版本）、<code>FLUSHALL ASYNC</code>（清空所有数据库的所有 key，不仅仅是当前 <code>SELECT</code> 的数据库）、<code>FLUSHDB ASYNC</code>（清空当前 <code>SELECT</code> 数据库中的所有 key）等异步命令。大体上来说，Redis 6.0 之前主要还是单线程处理。</li><li><strong>那 Redis6.0 之前为什么不使用多线程？</strong> 我觉得主要原因有 3 点：<ol><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ol></li></ul><h2 id="Redis6-0之后为什么引入了多线程"><a href="#Redis6-0之后为什么引入了多线程" class="headerlink" title="Redis6.0之后为什么引入了多线程"></a>Redis6.0之后为什么引入了多线程</h2><ul><li><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p></li><li><p>虽然，Redis6.0 引入了多线程，但是 <strong>Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行</strong>。因此，你也不需要担心线程安全问题。</p></li><li><p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置IO线程数 &gt; 1，需要修改 redis 配置文件 <code>redis.conf</code> ：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads 4 <span class="comment">#设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></span><br></pre></td></tr></table></figure></li><li><p>另外：</p><ul><li>io-threads的个数一旦设置，不能通过config动态设置</li><li>当设置ssl后，io-threads将不工作</li></ul></li><li><p>开启多线程后，默认只会使用多线程进行IO写入writes，即发送数据给客户端，如果需要开启多线程IO读取reads，同样需要修改 redis 配置文件 <code>redis.conf</code> :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads-do-reads <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></li><li><p>但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启</p></li></ul><p>—————————————————————————–Redis内存管理——————————————————————————-</p><h2 id="Redis给缓存数据设置过期时间有什么用？"><a href="#Redis给缓存数据设置过期时间有什么用？" class="headerlink" title="Redis给缓存数据设置过期时间有什么用？"></a>Redis给缓存数据设置过期时间有什么用？</h2><ul><li><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p></li><li><p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire key 60 <span class="comment"># 数据在 60s 后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value <span class="comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key <span class="comment"># 查看数据还有多久过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 56</span><br></pre></td></tr></table></figure></li><li><p>注意：<strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p></li><li><p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong>很多时候，我们的<strong>业务场景就是需要某个数据只在某一时间段内存在</strong>，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p></li></ul><h2 id="Redis是如何判断数据是否过期的呢？"><a href="#Redis是如何判断数据是否过期的呢？" class="headerlink" title="Redis是如何判断数据是否过期的呢？"></a>Redis是如何判断数据是否过期的呢？</h2><ul><li><p>Redis 通过一个叫做<strong>过期字典（可以看作是 hash 表）来保存数据过期的时间</strong>。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223164436724.png" alt="image-20230223164436724"></p></li><li><p>过期字典是存储在 redisDb 这个结构里的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    dict *dict;     <span class="comment">//数据库键空间,保存着数据库中所有键值对</span></span><br><span class="line">    dict *expires   <span class="comment">// 过期字典,保存着键的过期时间</span></span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure></li></ul><h2 id="过期的数据的删除策略了解吗？"><a href="#过期的数据的删除策略了解吗？" class="headerlink" title="过期的数据的删除策略了解吗？"></a>过期的数据的删除策略了解吗？</h2><ul><li>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</li><li>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：<ol><li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol></li><li>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 。</li><li>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</li><li>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></li></ul><h2 id="Redis内存淘汰机制了解吗？"><a href="#Redis内存淘汰机制了解吗？" class="headerlink" title="Redis内存淘汰机制了解吗？"></a>Redis内存淘汰机制了解吗？</h2><ul><li>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</li><li>Redis 提供 6 种数据淘汰策略：<ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol></li><li>4.0 版本后增加以下两种：<ol start="7"><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li><li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ol></li></ul><p>—————————————————————————–Redis持久化机制——————————————————————————-</p><h2 id="怎么保证Redis挂掉之后再重启数据可以进行恢复？"><a href="#怎么保证Redis挂掉之后再重启数据可以进行恢复？" class="headerlink" title="怎么保证Redis挂掉之后再重启数据可以进行恢复？"></a>怎么保证Redis挂掉之后再重启数据可以进行恢复？</h2><ul><li>很多时候我们需要<strong>持久化数据也就是将内存中的数据写入到硬盘里面</strong>，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</li><li>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</li></ul><h2 id="什么是RDB持久化？"><a href="#什么是RDB持久化？" class="headerlink" title="什么是RDB持久化？"></a>什么是RDB持久化？</h2><ul><li><p>Redis 可以<strong>通过创建快照来获得存储在内存里面的数据在某个时间点上的副本</strong>。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p></li><li><p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           <span class="comment">#在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。</span></span><br><span class="line"></span><br><span class="line">save 300 10          <span class="comment">#在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。</span></span><br><span class="line"></span><br><span class="line">save 60 10000        <span class="comment">#在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="RDB创建快照时会阻塞主线程吗？"><a href="#RDB创建快照时会阻塞主线程吗？" class="headerlink" title="RDB创建快照时会阻塞主线程吗？"></a>RDB创建快照时会阻塞主线程吗？</h2><ul><li><p><strong>默认是子线程执行创建快照的动作，不会阻塞主线程</strong>。</p></li><li><p>Redis 提供了两个命令来生成 RDB 快照文件：</p><ul><li><code>save</code> : 主线程执行，会阻塞主线程；</li><li><code>bgsave</code> : 子线程执行，不会阻塞主线程，默认选项。</li></ul></li></ul><h2 id="什么是AOF持久化？"><a href="#什么是AOF持久化？" class="headerlink" title="什么是AOF持久化？"></a>什么是AOF持久化？</h2><ul><li><p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。<strong>默认情况下 Redis 没有开启 AOF（append only file）方式的持久化</strong>，可以通过 appendonly 参数开启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></li><li><p><strong>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件</strong>。</p></li><li><p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p></li><li><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    <span class="comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span></span><br><span class="line">appendfsync everysec  <span class="comment">#每秒钟同步一次，显式地将多个写命令同步到硬盘</span></span><br><span class="line">appendfsync no        <span class="comment">#让操作系统决定何时进行同步</span></span><br></pre></td></tr></table></figure></li><li><p><strong>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响</strong>。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p></li></ul><h2 id="AOF日志是如何实现的？"><a href="#AOF日志是如何实现的？" class="headerlink" title="AOF日志是如何实现的？"></a>AOF日志是如何实现的？</h2><ul><li><p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223170909801.png" alt="image-20230223170909801"></p></li><li><p><strong>为什么是在执行完命令之后记录日志呢？</strong></p><ol><li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li><li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li></ol></li><li><p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p><ol><li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li><li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li></ol></li></ul><h2 id="AOF重写了解吗？"><a href="#AOF重写了解吗？" class="headerlink" title="AOF重写了解吗？"></a>AOF重写了解吗？</h2><ul><li>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，<strong>新旧两个文件所保存的数据库状态是相同的，但是新的AOF文件不会包含任何浪费空间的冗余命令，通常体积会较旧AOF文件小很多</strong>。</li><li>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</li><li>在执行 <code>BGREWRITEAOF</code> 命令时，<strong>Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作</strong>。</li><li>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，<strong>重写期间到达的所有写入命令都会写入磁盘两次</strong>。</li></ul><h2 id="如何选择RDB和AOF？"><a href="#如何选择RDB和AOF？" class="headerlink" title="如何选择RDB和AOF？"></a>如何选择RDB和AOF？</h2><ul><li>建议两者都开，不建议只开AOF。如果对数据不敏感可以只开RDB。如果只是做缓存，可以都不开。</li></ul><h3 id="RDB比AOF优秀的地方"><a href="#RDB比AOF优秀的地方" class="headerlink" title="RDB比AOF优秀的地方"></a>RDB比AOF优秀的地方</h3><ol><li><strong>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会必 RDB 文件大很多</strong>。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li><li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，<strong>与 AOF 相比，恢复大数据集的时候，RDB 速度更快</strong>。</li></ol><h3 id="AOF比RDB优秀的地方"><a href="#AOF比RDB优秀的地方" class="headerlink" title="AOF比RDB优秀的地方"></a>AOF比RDB优秀的地方</h3><ol><li><strong>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据</strong>。生成 RDB 文件的过程是比繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li><li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以<strong>存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题</strong>。</li><li><strong>AOF 以一种易于理解和解析的格式包含所有操作的日志，也就是可读性强</strong>。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li></ol><h2 id="Redis-4-0-对于持久化机制做了什么优化？"><a href="#Redis-4-0-对于持久化机制做了什么优化？" class="headerlink" title="Redis 4.0 对于持久化机制做了什么优化？"></a>Redis 4.0 对于持久化机制做了什么优化？</h2><ul><li>由于 RDB 和 AOF 各有优势，于是，<strong>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）</strong>。</li><li><strong>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据</strong>。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，<strong>可读性较差</strong>。</li></ul><p>—————————————————————————–Redis事务———————————————————————————–</p><h2 id="如何使用Redis事务？"><a href="#如何使用Redis事务？" class="headerlink" title="如何使用Redis事务？"></a>如何使用Redis事务？</h2><ul><li><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET PROJECT</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;JavaGuide&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>MULTI</code>命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了<code>EXEC</code>命令后，再执行所有的命令</strong>。</p></li><li><p>这个过程是这样的：</p><ol><li>开始事务（<code>MULTI</code>）；</li><li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；</li><li>执行事务(<code>EXEC</code>)。</li></ol></li><li><p>你也可以<strong>通过<code>DISCARD</code>命令取消一个事务，它会清空事务队列中保存的所有命令</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET PROJECT</span><br><span class="line">QUEUED</span><br><span class="line">&gt; DISCARD</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li><p>你可以<strong>通过 <code>WATCH</code> 命令监听指定的 Key，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的 Key 被 其他客户端&#x2F;Session 修改的话，整个事务都不会被执行</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端 1</span></span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;RustGuide&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; WATCH PROJECT</span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端 2</span></span><br><span class="line"><span class="comment"># 在客户端 1 执行 EXEC 命令提交事务之前修改 PROJECT 的值</span></span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;GoGuide&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端 1</span></span><br><span class="line"><span class="comment"># 修改失败，因为 PROJECT 的值被客户端2修改了</span></span><br><span class="line">&gt; EXEC</span><br><span class="line">(nil)</span><br><span class="line">&gt; GET PROJECT</span><br><span class="line"><span class="string">&quot;GoGuide&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>不过，<strong>如果 WATCH与事务在同一个 Session 里，并且被WATCH监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的</strong>。</p></li><li><p>事务内部修改 WATCH 监视的 Key：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; WATCH PROJECT</span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide1&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide2&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide3&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">127.0.0.1:6379&gt; GET PROJECT</span><br><span class="line"><span class="string">&quot;JavaGuide3&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>事务外部修改 WATCH 监视的Key：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; WATCH PROJECT</span><br><span class="line">OK</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide2&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; GET USER</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Redis支持原子性吗？"><a href="#Redis支持原子性吗？" class="headerlink" title="Redis支持原子性吗？"></a>Redis支持原子性吗？</h2><ul><li>Redis 的事务和我们平时理解的关系型数据库的事务不同。</li><li><strong>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行</strong>。并且，<strong>Redis 是不支持回滚（roll back）操作</strong>的。因此，<strong>Redis 事务其实是不满足原子性的（而且不满足持久性）</strong>。</li><li>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得<strong>没必要支持回滚，这样更简单便捷并且性能更好</strong>。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</li><li>你可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></li><li><strong>除了不满足原子性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为（使用lua脚本优化）</strong>。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。因此，<strong>Redis 事务是不建议在日常开发中使用的</strong>。</li></ul><h2 id="如何解决Redis事务的缺陷？"><a href="#如何解决Redis事务的缺陷？" class="headerlink" title="如何解决Redis事务的缺陷？"></a>如何解决Redis事务的缺陷？</h2><ul><li>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们<strong>可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销</strong>。</li><li>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</li><li><strong>如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的</strong>。因此，<strong>严格来说，通过 Lua 脚本来批量执行 Redis 命令也是不满足原子性的</strong>。</li><li>另外，Redis 7.0 新增了Redis functions特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。</li><li>总之<strong>Lua脚本解决的是redis事务中的命令无法送至redis服务端批量执行的问题，并没有完全解决redis事务不具备原子性的特点</strong>。</li></ul><p>—————————————————————————–Redis性能优化———————————————————————————–</p><h2 id="什么是bigkey？"><a href="#什么是bigkey？" class="headerlink" title="什么是bigkey？"></a>什么是bigkey？</h2><ul><li>简单来说，<strong>如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey</strong>。具体多大才算大呢？有一个不是特别精确的参考标准：<strong>string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）</strong>。</li></ul><h2 id="bigkey有什么危害？"><a href="#bigkey有什么危害？" class="headerlink" title="bigkey有什么危害？"></a>bigkey有什么危害？</h2><ul><li>除了会消耗更多的内存空间，bigkey 对性能也会有比较大的影响。</li><li>因此，我们应该尽量避免写入 bigkey！</li></ul><h2 id="如何发现bigkey？"><a href="#如何发现bigkey？" class="headerlink" title="如何发现bigkey？"></a>如何发现bigkey？</h2><ol><li><p><strong>使用 Redis 自带的 <code>--bigkeys</code> 参数来查找</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-cli -p 6379 --bigkeys</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Scanning the entire keyspace to find biggest keys as well as</span></span><br><span class="line"><span class="comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span></span><br><span class="line"><span class="comment"># per 100 SCAN commands (not usually needed).</span></span><br><span class="line"></span><br><span class="line">[00.00%] Biggest string found so far <span class="string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> with 4437 bytes</span><br><span class="line">[00.00%] Biggest list   found so far <span class="string">&#x27;&quot;my-list&quot;&#x27;</span> with 17 items</span><br><span class="line"></span><br><span class="line">-------- summary -------</span><br><span class="line"></span><br><span class="line">Sampled 5 keys <span class="keyword">in</span> the keyspace!</span><br><span class="line">Total key length <span class="keyword">in</span> bytes is 264 (avg len 52.80)</span><br><span class="line"></span><br><span class="line">Biggest   list found <span class="string">&#x27;&quot;my-list&quot;&#x27;</span> has 17 items</span><br><span class="line">Biggest string found <span class="string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> has 4437 bytes</span><br><span class="line"></span><br><span class="line">1 lists with 17 items (20.00% of keys, avg size 17.00)</span><br><span class="line">0 hashs with 0 fields (00.00% of keys, avg size 0.00)</span><br><span class="line">4 strings with 4831 bytes (80.00% of keys, avg size 1207.75)</span><br><span class="line">0 streams with 0 entries (00.00% of keys, avg size 0.00)</span><br><span class="line">0 sets with 0 members (00.00% of keys, avg size 0.00)</span><br><span class="line">0 zsets with 0 members (00.00% of keys, avg size 0.00</span><br></pre></td></tr></table></figure><p>从这个命令的运行结果，我们可以看出：<strong>这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响</strong>。并且，这种方式<strong>只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）</strong>。</p></li><li><p><strong>通过软件分析RDB文件</strong>来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p></li></ol><h2 id="大量key集中过期的问题"><a href="#大量key集中过期的问题" class="headerlink" title="大量key集中过期的问题"></a>大量key集中过期的问题</h2><ul><li>我在上面提到过：对于过期 key，Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 策略。</li><li><strong>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成</strong>，因为这个这个<strong>定期任务线程是在 Redis 主线程中执行的</strong>。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</li><li>如何解决呢？下面是两种常见的方法：<ol><li>给 key <strong>设置随机过期时间</strong>。</li><li>开启 <strong>lazy-free（惰性删除&#x2F;延迟释放） <strong>。lazy-free 特性是 Redis 4.0 开始引入的，指的是</strong>让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程</strong>。</li></ol></li><li>建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</li></ul><p>—————————————————————————–Redis生产问题———————————————————————————–</p><h2 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h2><ul><li><p>缓存穿透说简单点就是<strong>大量请求的 key 是不合理的，根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223190624286.png" alt="image-20230223190624286"></p></li><li><p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p></li></ul><h2 id="如何解决缓存穿透问题？"><a href="#如何解决缓存穿透问题？" class="headerlink" title="如何解决缓存穿透问题？"></a>如何解决缓存穿透问题？</h2><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><h3 id="缓存无效key"><a href="#缓存无效key" class="headerlink" title="缓存无效key"></a>缓存无效key</h3><ul><li><p><strong>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间</strong>，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，<strong>如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key</strong>。很明显，<strong>这种方案并不能从根本上解决此问题</strong>。如果非要用这种方式来解决穿透问题的话，<strong>尽量将无效的 key 的过期时间设置短一点比如 1 分钟</strong>。</p></li><li><p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p></li><li><p>如果用 Java 代码展示的话，差不多是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObjectInclNullById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheValue</span> <span class="operator">=</span> cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">storageValue</span> <span class="operator">=</span> storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用布隆过滤器"><a href="#使用布隆过滤器" class="headerlink" title="使用布隆过滤器"></a>使用布隆过滤器</h3><ul><li><p>布隆过滤器是一个非常神奇的数据结构，通过它我们<strong>可以非常方便地判断一个给定数据是否存在于海量数据中</strong>。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p></li><li><p>具体是这样做的：<strong>把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程</strong>。</p></li><li><p>加入布隆过滤器之后的缓存处理流程图如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223191446498.png" alt="image-20230223191446498"></p></li><li><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判（哈希碰撞）。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p></li><li><p>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</p></li><li><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（<strong>一般会有多个哈希函数，有几个哈希函数得到几个哈希值</strong>）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol></li><li><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol></li><li><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p></li></ul><h2 id="什么是缓存击穿？"><a href="#什么是缓存击穿？" class="headerlink" title="什么是缓存击穿？"></a>什么是缓存击穿？</h2><ul><li><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223192036582.png" alt="image-20230223192036582"></p></li><li><p>举个例子 ：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p></li></ul><h2 id="如何解决缓存击穿问题？"><a href="#如何解决缓存击穿问题？" class="headerlink" title="如何解决缓存击穿问题？"></a>如何解决缓存击穿问题？</h2><ol><li>设置热点数据<strong>永不过期或者过期时间比较长</strong>。</li><li>针对热点数据<strong>提前预热</strong>，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li><li>请求数据库写数据到缓存之前，先<strong>获取互斥锁</strong>，保证只有一个请求会落到数据库上，减少数据库的压力。</li></ol><h2 id="缓存穿透和缓存击穿有什么区别？"><a href="#缓存穿透和缓存击穿有什么区别？" class="headerlink" title="缓存穿透和缓存击穿有什么区别？"></a>缓存穿透和缓存击穿有什么区别？</h2><ol><li>缓存穿透中，请求的 key <strong>既不存在于缓存中，也不存在于数据库中</strong>。</li><li>缓存击穿中，请求的 key 对应的是<strong>热点数据</strong> ，该数据<strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</li></ol><h2 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h2><ul><li><p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上:</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223192507611.png" alt="image-20230223192507611"></p></li><li><p>举个例子 ：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p></li></ul><h2 id="如何解决缓存雪崩问题？"><a href="#如何解决缓存雪崩问题？" class="headerlink" title="如何解决缓存雪崩问题？"></a>如何解决缓存雪崩问题？</h2><h3 id="针对Redis服务不可用的情况"><a href="#针对Redis服务不可用的情况" class="headerlink" title="针对Redis服务不可用的情况"></a>针对Redis服务不可用的情况</h3><ol><li>采用 Redis <strong>集群</strong>，避免单机出现问题整个缓存服务都没办法使用。</li><li><strong>限流</strong>，避免同时处理大量的请求。</li></ol><h3 id="针对热点缓存失效的情况"><a href="#针对热点缓存失效的情况" class="headerlink" title="针对热点缓存失效的情况"></a>针对热点缓存失效的情况</h3><ol><li>设置不同的失效时间比如<strong>随机设置缓存的失效时间</strong>。</li><li>缓存永不失效（不太推荐，实用性太差）。</li><li>设置<strong>二级缓存</strong>。</li></ol><h2 id="缓存雪崩和缓存击穿有什么区别？"><a href="#缓存雪崩和缓存击穿有什么区别？" class="headerlink" title="缓存雪崩和缓存击穿有什么区别？"></a>缓存雪崩和缓存击穿有什么区别？</h2><ul><li>缓存雪崩和缓存击穿比较像，但<strong>缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong>。</li></ul><h2 id="如何保证缓存和数据库数据的一致性？"><a href="#如何保证缓存和数据库数据的一致性？" class="headerlink" title="如何保证缓存和数据库数据的一致性？"></a>如何保证缓存和数据库数据的一致性？</h2><ul><li>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</li><li>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache （还有另外一种方案好像是更新db后再更新cache）。</li><li>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：<ol><li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加 cache 更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li></ol></li></ul><p>—————————————————————————Redis集群———————————————————————————–</p><h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>主机数据更新后根据配置和策略， 自动同步到备机的<strong>master&#x2F;slaver机制</strong>，<strong>Master以写为主，Slave以读为主</strong>。</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>读写分离，性能扩展</strong></li><li><strong>容灾快速恢复</strong></li></ul><h3 id="如何配置"><a href="#如何配置" class="headerlink" title="如何配置"></a>如何配置</h3><ul><li>默认所有redis实例都是主机，可以使用<code>slaveof &lt;ip&gt; &lt;port&gt;</code>命令来指定该主机为从机并指定好其归属的主机，从机下面也能配置从机，使用命令设置的话重启后会失效，可以配置在配置文件中永久生效。</li><li>使用<code>slaveof no one</code>将从机变为主机。</li><li>配置好后，主机上可以写数据，从机上只能读数据，如果在从机上写数据会报错。</li><li>主机挂了之后重启即可；从机挂了之后如果没有在配置文件中配置其主从关系，那么就需要重新使用命令来建立从属关系。</li></ul><h3 id="复制延时问题"><a href="#复制延时问题" class="headerlink" title="复制延时问题"></a>复制延时问题</h3><ul><li>由于<strong>所有的写操作都是先在Master上操作，然后同步更新到Slave上</strong>，所以<strong>从Master同步到Slave机器有一定的延迟</strong>，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><p><strong>Slave启动成功连接到master后会发送一个sync命令</strong>。</p></li><li><p>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，<strong>master将传送整个数据文件到slave,以完成一次完全同步</strong>。</p></li><li><p><strong>全量复制</strong>：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p></li><li><p><strong>增量复制</strong>：Master继续将新的所有收集到的修改命令依次传给slave,完成同步。</p></li><li><p>但是<strong>只要是重新连接master,一次完全同步（全量复制)将被自动执行</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101757180.png" alt="image-20221015101757180"></p></li></ul><h2 id="常用的三种主从结构"><a href="#常用的三种主从结构" class="headerlink" title="常用的三种主从结构"></a>常用的三种主从结构</h2><h3 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015100717323.png" alt="image-20221015100717323"></p><h3 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h3><ul><li><p>上一个Slave可以是下一个slave的Master，<strong>Slave同样可以接收其他slaves的连接和同步请求</strong>，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</p></li><li><p>用 slaveof  &lt;ip&gt; &lt;port&gt;进行配置</p><p>中途变更转向:会清除之前的数据，重新建立拷贝最新的</p><p>风险是一旦某个slave宕机，后面的slave都没法备份</p><p>主机挂了，从机还是从机，无法写数据了</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101147373.png" alt="image-20221015101147373"></p></li></ul><h3 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h3><ul><li><strong>当一个master宕机后，后面的slave可以立刻升为master</strong>，其后面的slave不用做任何修改。</li><li>用<strong>slaveof no one</strong>将从机变为主机。</li></ul><h2 id="哨兵模式（sentinel）"><a href="#哨兵模式（sentinel）" class="headerlink" title="哨兵模式（sentinel）"></a>哨兵模式（sentinel）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li><p>这是<strong>反客为主的自动版</strong>，哨兵能够<strong>后台监控主机是否故障</strong>，如果故障了<strong>根据投票数自动将从库转换为主库</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101935319.png" alt="image-20221015101935319"></p></li></ul><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><ul><li>这个需要额外配置一个哨兵，先<strong>在配置文件目录下新建sentinel.conf文件</strong>。</li><li>然后在sentinel.conf中填写内容：<strong>sentinel monitor mymaster 127.0.0.1 6379 1</strong>，其中<strong>mymaster为监控对象起的服务器名称</strong>， <strong>1为至少有多少个哨兵同意迁移的数量</strong>。</li><li>最后在redis的安装目录下执行<strong>redis-sentinel  &#x2F;myredis&#x2F;sentinel.conf</strong>来启动哨兵</li></ul><h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><ul><li><p>优先级在redis.conf中默认：slave-priority 100，<strong>值越小优先级越高</strong></p></li><li><p><strong>偏移量是指获得原主机数据最全的</strong></p></li><li><p>每个redis实例启动后都会<strong>随机生成一个40位的runid</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015103154028.png" alt="image-20221015103154028"></p></li></ul><h2 id="什么是redis集群？"><a href="#什么是redis集群？" class="headerlink" title="什么是redis集群？"></a>什么是redis集群？</h2><ul><li>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，<strong>将整个数据库分布存储在这N个节点中，每个节点存储总数据的1&#x2F;N</strong>。</li><li>Redis 集群<strong>通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求</strong>。</li><li>上面的主从结构可以是集群的一部分。</li></ul><h2 id="redis集群如何分配节点？"><a href="#redis集群如何分配节点？" class="headerlink" title="redis集群如何分配节点？"></a>redis集群如何分配节点？</h2><ul><li><strong>一个集群至少要有三个主节点</strong>。</li><li>选项 <strong>–cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点</strong>。</li><li>分配原则<strong>尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上</strong>。</li></ul><h2 id="什么是Slots？"><a href="#什么是Slots？" class="headerlink" title="什么是Slots？"></a>什么是Slots？</h2><ul><li><p>就是用来分布式存储数据的结构。</p></li><li><p>一个 Redis 集群包含 16384 个插槽（hash slot）， <strong>数据库中的每个键都属于这 16384 个插槽的其中一个</strong>，<strong>一个插槽中可以有多个键，但一个键只对应一个插槽</strong>。</p></li><li><p><strong>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽</strong>， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p></li><li><p><strong>集群中的每个节点负责处理一部分插槽</strong>。 举个例子， 如果一个集群可以有主节点， 其中：</p><p>节点 A 负责处理 0 号至 5460 号插槽。</p><p>节点 B 负责处理 5461 号至 10922 号插槽。</p><p>节点 C 负责处理 10923 号至 16383 号插槽。</p></li></ul><h2 id="redis集群的故障恢复"><a href="#redis集群的故障恢复" class="headerlink" title="redis集群的故障恢复"></a>redis集群的故障恢复</h2><ul><li><p>如果主节点下线？从节点能否自动升为主节点？答：能，注意：<strong>15秒超时</strong></p></li><li><p>主节点恢复后，主从关系会如何？答：主节点回来会变成从机。</p></li><li><p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p><p><strong>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉。</strong></p><p><strong>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</strong></p><p>redis.conf中的参数  cluster-require-full-coverage</p></li></ul><h2 id="redis集群的好处？"><a href="#redis集群的好处？" class="headerlink" title="redis集群的好处？"></a>redis集群的好处？</h2><ul><li><strong>实现扩容</strong></li><li><strong>分摊压力</strong></li><li><strong>无中心配置相对简单</strong></li></ul><h2 id="redis集群的不足？"><a href="#redis集群的不足？" class="headerlink" title="redis集群的不足？"></a>redis集群的不足？</h2><ul><li><strong>多键操作是不被支持的</strong>，因为多个键所在的slot可能不同。</li><li><strong>多键的Redis事务是不被支持的，lua脚本不被支持</strong>。</li><li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而<strong>代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大</strong>。</li></ul><p>————————————————————–Redis三种常用的缓存读写策略———————————————————————-</p><h2 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h2><ul><li><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></li><li>Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。</li><li>下面我们来看一下这个策略模式下的缓存读写步骤。</li></ul><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><ul><li><p>先更新db，然后直接删除cache：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223205824427.png" alt="image-20230223205824427"></p></li></ul><h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><ul><li><p>从 cache 中读取数据，读取到就直接返回；cache 中读取不到的话，就从 db 中读取数据返回。最后再把数据放到 cache 中：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223205919248.png" alt="image-20230223205919248"></p></li></ul><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><p>比如说面试官很可能会追问：“<strong>在写数据的过程中，可以先删除 cache ，后更新 db 么？</strong>”</p><p><strong>答案：</strong> 那肯定是不行的！因为这样可能会造成 <strong>数据库（db）和缓存（Cache）数据不一致</strong>的问题。</p><p>举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。这个过程可以简单描述为：请求 1 先把 cache 中的 A 数据删除 -&gt; 请求 2 从 db 中读取数据-&gt;请求 1 再把 db 中的 A 数据更新</p></li><li><p>当你这样回答上面的问题之后，面试官可能会紧接着就追问：“<strong>在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？</strong>”</p><p><strong>答案：</strong> 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。</p><p>举例：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。这个过程可以简单描述为：请求 1 从 db 读数据 A-&gt; 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） -&gt; 请求 1 将数据 A 写入 cache</p></li></ul><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ol><li><strong>首次请求数据一定不在 cache 的问题</strong>。解决办法：<ul><li>可以将热点数据可以提前放入 cache 中。</li></ul></li><li><strong>写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率。</strong>解决办法：<ul><li>数据库和缓存数据强一致场景 ：更新 db 的时候同样更新 cache，不过我们需要加一个锁&#x2F;分布式锁来保证更新 cache 的时候不存在线程安全问题。</li><li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li></ul></li></ol><h2 id="Read-x2F-Write-Through-Pattern（读写穿透模式）"><a href="#Read-x2F-Write-Through-Pattern（读写穿透模式）" class="headerlink" title="Read&#x2F;Write Through Pattern（读写穿透模式）"></a>Read&#x2F;Write Through Pattern（读写穿透模式）</h2><ul><li>Read&#x2F;Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</li><li>这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入 db 的功能。</li></ul><h3 id="写（Write-Through）"><a href="#写（Write-Through）" class="headerlink" title="写（Write Through）"></a>写（Write Through）</h3><ul><li><p>先查 cache，cache 中不存在，直接更新 db；cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223211749415.png" alt="image-20230223211749415"></p></li></ul><h3 id="读（Read-Through）"><a href="#读（Read-Through）" class="headerlink" title="读（Read Through）"></a>读（Read Through）</h3><ul><li><p>从 cache 中读取数据，读取到就直接返回 ；读取不到的话，先从 db 加载，写入到 cache 后返回响应：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223211840069.png" alt="image-20230223211840069"></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 <strong>Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache</strong>，而 <strong>Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的</strong>。</li><li>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不在 cache 的问题，对于热点数据可以提前放入缓存中。</li></ul><h2 id="Write-Behind-Pattern（异步缓存写入模式）"><a href="#Write-Behind-Pattern（异步缓存写入模式）" class="headerlink" title="Write Behind Pattern（异步缓存写入模式）"></a>Write Behind Pattern（异步缓存写入模式）</h2><ul><li>Write Behind Pattern 和 Read&#x2F;Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。</li><li>但是，两个又有很大的不同：<strong>Read&#x2F;Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</strong></li><li>很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。</li><li>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。</li><li>Write Behind Pattern 下 db 的写性能非常高，非常<strong>适合一些数据经常变化又对数据一致性要求没那么高的场景</strong>，比如浏览量、点赞量。</li></ul><p>————————————————————————Redis基本数据结构详解—————————————————————————</p><h2 id="Redis基本数据结构的底层数据结构是什么？"><a href="#Redis基本数据结构的底层数据结构是什么？" class="headerlink" title="Redis基本数据结构的底层数据结构是什么？"></a>Redis基本数据结构的底层数据结构是什么？</h2><ul><li><p>Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p></li><li><p>这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、HashTable（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。</p></li><li><p>Redis 基本数据结构的底层数据结构实现如下：</p><table><thead><tr><th>String</th><th>List</th><th>Hash</th><th>Set</th><th>Zset</th></tr></thead><tbody><tr><td>SDS（简单动态字符串）</td><td>LinkedList（双向链表）&#x2F;ZipList（压缩列表）&#x2F;QuickList（快速列表）</td><td>HashTable（哈希表）、ZipList（压缩列表）</td><td>ZipList（压缩列表）、Intset（整数集合）</td><td>ZipList（压缩列表）、SkipList（跳跃表）</td></tr></tbody></table></li><li><p>Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。</p></li></ul><h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>String 是 Redis 中最简单同时也是最常用的一个数据结构。</p></li><li><p>String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220142410.png" alt="image-20230223220142410"></p></li><li><p>虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（Simple Dynamic String，<strong>SDS</strong>）。相比于 C 的原生字符串，<strong>Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出</strong>。</p></li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220438634.png" alt="image-20230223220438634"></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>需要<strong>存储常规数据</strong>的场景：<ul><li>举例 ：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。</li><li>相关命令 ： <code>SET</code>、<code>GET</code>。</li></ul></li><li>需要<strong>计数</strong>的场景：<ul><li>举例 ：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li><li>相关命令 ：<code>SET</code>、<code>GET</code>、 <code>INCR</code>、<code>DECR</code> 。</li></ul></li><li><strong>分布式锁</strong>：<ul><li>利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁（存在一些缺陷，<strong>通常不建议这样实现分布式锁</strong>）。</li></ul></li></ul><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>Redis 中的 List 其实就是链表数据结构的实现。</p></li><li><p>许多高级编程语言都内置了链表的实现比如 Java 中的 <code>LinkedList</code>，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 List 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220254844.png" alt="image-20230223220254844"></p></li></ul><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220502834.png" alt="image-20230223220502834"></p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>信息流展示</strong>：<ul><li>举例 ：最新文章、最新动态。</li><li>相关命令 ： <code>LPUSH</code>、<code>LRANGE</code>。</li></ul></li><li><strong>消息队列</strong>：<ul><li>Redis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。</li><li>相对来说，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</li></ul></li></ul><h2 id="Hash（哈希表）"><a href="#Hash（哈希表）" class="headerlink" title="Hash（哈希表）"></a>Hash（哈希表）</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</p></li><li><p>Hash 类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220743151.png" alt="image-20230223220743151"></p></li></ul><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220809369.png" alt="image-20230223220809369"></p><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>对象数据存储场景</strong>：<ul><li>举例 ：用户信息、商品信息、文章信息、购物车信息。</li><li>相关命令 ：<code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）。</li></ul></li></ul><h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>Redis 中的 Set 类型是一种<strong>无序集合，集合中的元素没有先后顺序但都唯一</strong>，有点类似于 Java 中的 <code>HashSet</code> 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p></li><li><p>你可以基于 Set 轻易实现交集、并集、差集的操作，比如你<strong>可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223222643653.png" alt="image-20230223222643653"></p></li></ul><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223222716378.png" alt="image-20230223222716378"></p><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>需要存放的数据不能重复的场景</strong>：<ul><li>举例：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</li><li>相关命令：<code>SCARD</code>（获取集合数量） 。</li></ul></li><li><strong>需要获取多个数据源交集、并集和差集的场景</strong>：<ul><li>举例 ：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集） 、订阅号推荐（差集+交集） 等场景。</li><li>相关命令：<code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）。</li></ul></li><li><strong>需要随机获取数据源中的元素的场景</strong>：<ul><li>举例 ：抽奖系统、随机。</li><li>相关命令：<code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）。</li></ul></li><li><strong>可以用于解决接口幂等性的问题</strong>：<ul><li>给调用接口要执行的操作一个uuid存到redis的set中，然后如果这次没有调用完又来了一次调用，那么这次调用的时候就能通过set中的uuid来判断是否是同一个请求，如果是，就拒绝这次请求，这样就实现了接口的幂等性。</li></ul></li></ul><h2 id="Sorted-Set（有序集合）"><a href="#Sorted-Set（有序集合）" class="headerlink" title="Sorted Set（有序集合）"></a>Sorted Set（有序集合）</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>Sorted Set 类似于 Set，但和 Set 相比，<strong>Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表</strong>。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223223030914.png" alt="image-20230223223030914"></p></li></ul><h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223223054604.png" alt="image-20230223223054604"></p><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong>：<ul><li>举例 ：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li><li>相关命令 ：<code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li></ul></li><li><strong>需要存储的数据有优先级或者重要程度的场景</strong>：<ul><li>举例 ：优先级任务队列。</li><li>相关命令 ：<code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li></ul></li></ul><p>————————————————————————Redis特殊数据结构详解—————————————————————————</p><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, <strong>只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身</strong> 。我们知道 8 个 bit 可以组成一个 byte，所以 <strong>Bitmap 本身会极大的节省储存空间</strong>。</p></li><li><p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223223400243.png" alt="image-20230223223400243"></p></li></ul><h3 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223223428295.png" alt="image-20230223223428295"></p><h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>需要保存状态信息（0&#x2F;1 即可表示）的场景</strong>：<ul><li>举例 ：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li><li>相关命令 ：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>。</li></ul></li></ul><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><ul><li>HyperLogLog 是一种有名的<strong>基数计数概率算法</strong> ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。</li><li>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素。这是真的厉害，这就是数学的魅力么！并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：<ul><li><strong>稀疏矩阵</strong> ：计数较少的时候，占用空间很小。</li><li><strong>稠密矩阵</strong> ：计数达到某个阈值的时候，占用 12k 的空间。</li></ul></li><li>基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code>0.81%</code> 。）。</li></ul><h3 id="常用命令-6"><a href="#常用命令-6" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223224557133.png" alt="image-20230223224557133"></p><h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>数量量巨大（百万、千万级别以上）的计数场景</strong>：<ul><li>举例 ：热门网站每日&#x2F;每周&#x2F;每月访问 ip 数统计、热门帖子 uv 统计、</li><li>相关命令 ：<code>PFADD</code>、<code>PFCOUNT</code> 。</li></ul></li></ul><h2 id="Geospatial-index"><a href="#Geospatial-index" class="headerlink" title="Geospatial index"></a>Geospatial index</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>Geospatial index（地理空间索引，简称 GEO） 主要<strong>用于存储地理位置信息</strong>，<strong>基于 Sorted Set 实现</strong>，GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。通过 GEO 我们可以轻松<strong>实现两个位置距离的计算、获取指定位置附近的元素</strong>等功能。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223224817449.png" alt="image-20230223224817449"></p></li></ul><h3 id="常用命令-7"><a href="#常用命令-7" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223224838093.png" alt="image-20230223224838093"></p><h3 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>需要管理使用地理空间数据的场景</strong>：<ul><li>举例：附近的人。</li><li>相关命令: <code>GEOADD</code>、<code>GEORADIUS</code>、<code>GEORADIUSBYMEMBER</code> 。</li></ul></li></ul><p>————————————————————————Redis内存碎片详解—————————————————————————</p><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h2><ul><li>我们可以把消息队列看作是<strong>一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可</strong>。由于队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。</li><li>参与消息传递的双方称为生产者和消费者，<strong>生产者负责发送消息，消费者负责处理消息</strong>。</li><li>我们知道操作系统中的进程通信的一种很重要的方式就是消息队列。我们这里提到的消息队列稍微有点区别，更多指的是各个服务以及系统内部各个组件&#x2F;模块之前的通信，属于一种中间件。</li><li>随着分布式和微服务系统的发展，消息队列在系统设计中有了更大的发挥空间，<strong>使用消息队列可以降低系统耦合性、实现任务异步、有效地进行流量削峰</strong>，是分布式和微服务系统中重要的组件之一。</li></ul><h2 id="消息队列有什么用？"><a href="#消息队列有什么用？" class="headerlink" title="消息队列有什么用？"></a>消息队列有什么用？</h2><ul><li>通常来说，使用消息队列能为我们的系统带来下面三点好处：<ol><li><strong>通过异步处理提高系统性能（减少响应所需时间）。</strong></li><li><strong>削峰&#x2F;限流</strong></li><li><strong>降低系统耦合性。</strong></li></ol></li><li>如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的简历上涉及到消息队列这方面的内容，这个时候推荐你结合你自己的项目来回答。</li></ul><h3 id="通过异步处理提高系统性能（减少响应所需时间）"><a href="#通过异步处理提高系统性能（减少响应所需时间）" class="headerlink" title="通过异步处理提高系统性能（减少响应所需时间）"></a>通过异步处理提高系统性能（减少响应所需时间）</h3><ul><li><strong>将用户的请求数据存储到消息队列之后就立即返回结果。随后，系统再对消息进行消费</strong>。</li><li>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，<strong>使用消息队列进行异步处理之后，需要适当修改业务流程进行配合</strong>，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</li></ul><h3 id="削峰-x2F-限流"><a href="#削峰-x2F-限流" class="headerlink" title="削峰&#x2F;限流"></a>削峰&#x2F;限流</h3><ul><li><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。</strong></li></ul><h3 id="降低系统耦合度"><a href="#降低系统耦合度" class="headerlink" title="降低系统耦合度"></a>降低系统耦合度</h3><ul><li>使用消息队列还可以<strong>降低系统耦合度</strong>。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。</li><li>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。</li><li><strong>消息队列使用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</li><li>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</li><li>另外，为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</li><li><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了 5 种消息模型。</li></ul><h2 id="使用消息队列产生的问题？"><a href="#使用消息队列产生的问题？" class="headerlink" title="使用消息队列产生的问题？"></a>使用消息队列产生的问题？</h2><ul><li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li><li><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li></ul><h2 id="AMQP是什么？"><a href="#AMQP是什么？" class="headerlink" title="AMQP是什么？"></a>AMQP是什么？</h2><ul><li>AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制。</li><li><strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></li></ul><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="相关名词介绍"><a href="#相关名词介绍" class="headerlink" title="相关名词介绍"></a>相关名词介绍</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029093829448.png" alt="image-20221029093829448"></p><ul><li><strong>Broker（代理）</strong>：<strong>接收和分发消息的应用</strong>，RabbitMQ Server 就是 Message Broker。</li><li><strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP（协议）的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。<strong>当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</strong>。</li><li><strong>Connection</strong>：<strong>publisher／consumer 和 broker 之间的 TCP 连接</strong>。</li><li><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。<strong>Channel 是在 connection 内部建立的逻辑连接</strong>，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的Connection极大减少了操作系统建立TCP connection的开销</strong>。</li><li><strong>Exchange</strong>：message 到达 broker 的第一站，<strong>根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去</strong>。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</li><li><strong>Queue</strong>：<strong>消息最终被送到这里等待 consumer 取走</strong>。</li><li><strong>Binding</strong>：<strong>exchange 和 queue 之间的虚拟连接</strong>，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</li></ul><h2 id="RabbitMQ是什么？"><a href="#RabbitMQ是什么？" class="headerlink" title="RabbitMQ是什么？"></a>RabbitMQ是什么？</h2><ul><li>RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</li><li>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个Broker构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。</li><li>PS:也可能直接问什么是消息队列？<strong>消息队列就是一个使用队列来通信的组件</strong>。</li></ul><h2 id="RabbitMQ的特点？"><a href="#RabbitMQ的特点？" class="headerlink" title="RabbitMQ的特点？"></a>RabbitMQ的特点？</h2><ul><li><strong>可靠性</strong>: RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。</li><li><strong>灵活的路由</strong> : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个 交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。</li><li><strong>扩展性</strong>: 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。</li><li><strong>高可用性</strong> : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。</li><li><strong>多种协议</strong>: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息 中间件协议。</li><li><strong>多语言客户端</strong> :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。</li><li><strong>管理界面</strong> : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。</li><li><strong>插件机制</strong> : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。</li></ul><h2 id="AMQP是什么？-1"><a href="#AMQP是什么？-1" class="headerlink" title="AMQP是什么？"></a>AMQP是什么？</h2><ul><li>AMQP的全称为：Advanced Message Queuing Protocol（高级消息队列协议）</li><li>RabbitMQ 就是 AMQP 协议的 <code>Erlang</code> 的实现(当然 RabbitMQ 还支持 <code>STOMP2</code>、 <code>MQTT3</code> 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定 。</li><li>RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相应的概念。目前 RabbitMQ 最新版本默认支持的是 AMQP 0-9-1。</li></ul><h3 id="AMQP协议的三层结构"><a href="#AMQP协议的三层结构" class="headerlink" title="AMQP协议的三层结构"></a>AMQP协议的三层结构</h3><ol><li><strong>Module Layer</strong>:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。</li><li><strong>Session Layer</strong>:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。</li><li><strong>TransportLayer</strong>:最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。</li></ol><h3 id="AMQP模型的三大组件"><a href="#AMQP模型的三大组件" class="headerlink" title="AMQP模型的三大组件"></a>AMQP模型的三大组件</h3><ol><li><strong>交换器 (Exchange)</strong> ：消息代理服务器中用于把消息路由到队列的组件。</li><li><strong>队列 (Queue)</strong> ：用来存储消息的数据结构，位于硬盘或内存中。</li><li><strong>绑定 (Binding)</strong> ：一套规则，告知交换器消息应该将消息投递给哪个队列。</li></ol><h2 id="说说生产者Producer和消费者Consumer？"><a href="#说说生产者Producer和消费者Consumer？" class="headerlink" title="说说生产者Producer和消费者Consumer？"></a>说说生产者Producer和消费者Consumer？</h2><ul><li><strong>生产者</strong> :<ul><li>消息生产者，就是投递消息的一方。</li><li>消息一般包含两个部分：消息体（<code>payload</code>)和标签(<code>Label</code>)。</li></ul></li><li><strong>消费者</strong> ：<ul><li>消费消息，也就是接收消息的一方。</li><li>消费者连接到 RabbitMQ 服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。</li></ul></li></ul><h2 id="说说-Broker-服务节点、Queue-队列、Exchange-交换器？"><a href="#说说-Broker-服务节点、Queue-队列、Exchange-交换器？" class="headerlink" title="说说 Broker 服务节点、Queue 队列、Exchange 交换器？"></a>说说 Broker 服务节点、Queue 队列、Exchange 交换器？</h2><ul><li><strong>Broker</strong> ：可以看做 RabbitMQ 的服务节点。一般请下一个 Broker 可以看做一个 RabbitMQ 服务器。</li><li><strong>Queue</strong> : RabbitMQ 的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时<strong>队列中的消息会被平摊（轮询）给多个消费者进行处理</strong>。</li><li><strong>Exchange</strong> : 生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。</li></ul><h2 id="什么是死信队列？"><a href="#什么是死信队列？" class="headerlink" title="什么是死信队列？"></a>什么是死信队列？</h2><ul><li><strong>DLX，全称为 <code>Dead-Letter-Exchange</code>，死信交换器</strong>，死信邮箱。当消息在一个队列中变成死信 (<code>dead message</code>) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，<strong>绑定 DLX 的队列就称之为死信队列</strong>。</li></ul><h2 id="死信是如何导致的？"><a href="#死信是如何导致的？" class="headerlink" title="死信是如何导致的？"></a>死信是如何导致的？</h2><ol><li>消息被拒（<code>Basic.Reject /Basic.Nack</code>) 且 <code>requeue = false</code>。</li><li>消息 TTL 过期。</li><li>队列满了，无法再添加。</li></ol><h2 id="什么是延迟队列？"><a href="#什么是延迟队列？" class="headerlink" title="什么是延迟队列？"></a>什么是延迟队列？</h2><ul><li>延迟队列指的是存储对应的延迟消息，消息被发送以后，并不想让消费者立刻拿到消息，而是<strong>等待特定时间后，消费者才能拿到这个消息进行消费</strong>。</li></ul><h2 id="RabbitMQ怎么实现延迟队列？"><a href="#RabbitMQ怎么实现延迟队列？" class="headerlink" title="RabbitMQ怎么实现延迟队列？"></a>RabbitMQ怎么实现延迟队列？</h2><ul><li>RabbitMQ本身是没有延迟队列的，要实现延迟消息，一般有两种方式：<ol><li>通过RabbitMQ本身队列的特性来实现，需要使用RabbitMQ的死信交换机（Exchange）和消息的存活时间TTL（Time To Live）。</li><li>在RabbitMQ 3.5.7及以上的版本提供了一个插件（rabbitmq-delayed-message-exchange）来实现延迟队列功能。同时，插件依赖Erlang&#x2F;OPT 18.0及以上。</li></ol></li><li>也就是说，AMQP 协议以及RabbitMQ本身没有直接支持延迟队列的功能，但是可以通过TTL和DLX模拟出延迟队列的功能。</li></ul><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ul><li><p>先来个架构图，需要<strong>手动给队列配置它的死信队列</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117110145349.png" alt="image-20221117110145349"></p></li><li><p>具体是怎么实现呢？首先我们可以<strong>给队列或者发的消息设置TTL，阻塞掉那个队列的所有消费者，这样消息就能在队列中自然过期，然后被送到死信交换机中，然后被路由到死信队列中，真正的消费者是消费死信队列中的消息，这样就达到了延时队列的效果</strong>。</p></li><li><p>关于消息和队列TTL的几个问题：首先就是如果一个消息设置了TTL，它所去的队列也设置了TTL，那么<strong>较小的那个值会被使用</strong>。然后就是如果<strong>设置了队列的TTL，那么一旦消息过期，消息会立刻被丢弃</strong>；如果<strong>只是设置了消息的TTL，那么即使消息过期也不一定会被马上丢弃，因为消息会等它被消费到的时候判断是否过期</strong>，过期就丢弃，不过期就消费。</p></li></ul><h2 id="什么是优先级队列？"><a href="#什么是优先级队列？" class="headerlink" title="什么是优先级队列？"></a>什么是优先级队列？</h2><ul><li>RabbitMQ 自 V3.5.0 有优先级队列实现，优先级高的队列会先被消费。</li><li>可以通过<code>x-max-priority</code>参数来实现优先级队列。不过，当消费速度大于生产速度且 Broker 没有堆积的情况下，优先级显得没有意义。</li></ul><h2 id="RabbitMQ有哪些工作模式？"><a href="#RabbitMQ有哪些工作模式？" class="headerlink" title="RabbitMQ有哪些工作模式？"></a>RabbitMQ有哪些工作模式？</h2><ul><li><p><strong>简单模式</strong>：一个生产者，一个消费者，中间通过一个队列直接连接。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230224114922728.png" alt="image-20230224114922728"></p></li><li><p><strong>work 工作模式</strong>：就是<strong>有多个消费者消费队列里的消息，队列里的消息只能被一个消费者消费，这样多部署几个消费者，就可以缓解压力</strong>，比如过年的时候抢票，抢票成功后会给你发短信，这个时候就可以把发短信的任务放入队列里，然后有多个发短信的服务来处理队列里的任务。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230224114937419.png" alt="image-20230224114937419"></p></li><li><p><strong>pub&#x2F;sub 发布订阅模式</strong>：用到一个Exchange交换机角色来帮助我们把消息发给所有订阅我们的消费者。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230224115119733.png" alt="image-20230224115119733"></p></li><li><p><strong>Routing 路由模式</strong>：路由模式就是交换机并不是给所有订阅他的队列发送消息了，而是<strong>根据路由键来确定应该给哪个队列发送消息，队列和交换机绑定的时候需要通过路由键，而生产者发送消息的时候也需要指定路由键</strong>，这样就可以确定给哪个队列发送消息了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230224115144791.png" alt="image-20230224115144791"></p></li><li><p><strong>Topic 主题模式</strong>：主题模式就相当于模糊匹配，假如我想给姓张的发送消息，那么我就可以通过主题模式给所有姓张的发送消息。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230224115222685.png" alt="image-20230224115222685"></p></li></ul><h2 id="RabbitMQ消息怎么传输？"><a href="#RabbitMQ消息怎么传输？" class="headerlink" title="RabbitMQ消息怎么传输？"></a>RabbitMQ消息怎么传输？</h2><ul><li>由于 TCP 链接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈，所以 <strong>RabbitMQ 使用信道的方式来传输数据</strong>。信道（Channel）是生产者、消费者与 RabbitMQ 通信的渠道，<strong>信道是建立在 TCP 链接上的虚拟链接，且每条 TCP 链接上的信道数量没有限制</strong>。就是说 RabbitMQ 在一条 TCP 链接上建立成百上千个信道来达到多个线程处理，<strong>这个 TCP 被多个线程共享，每个信道在 RabbitMQ 都有唯一的 ID，保证了信道私有性，每个信道对应一个线程使用</strong>。</li></ul><h2 id="如何保证消息的可靠性？"><a href="#如何保证消息的可靠性？" class="headerlink" title="如何保证消息的可靠性？"></a>如何保证消息的可靠性？</h2><ul><li>可能出现这几种问题：消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。</li><li>生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：<strong>事务机制和 Confirm 机制是互斥的，两者不能共存</strong>，会导致 RabbitMQ 报错。</li><li>RabbitMQ 自身：持久化、集群、普通模式、镜像模式。</li><li>RabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制。</li></ul><h2 id="如何保证RabbitMQ消息的顺序性？"><a href="#如何保证RabbitMQ消息的顺序性？" class="headerlink" title="如何保证RabbitMQ消息的顺序性？"></a>如何保证RabbitMQ消息的顺序性？</h2><ul><li>拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是**多一些 queue (消息队列)**而已，确实是麻烦点；</li><li>或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 <strong>consumer(消费者)内部用内存队列做排队</strong>，然后分发给底层不同的 worker 来处理。</li></ul><h2 id="如何保证RabbitMQ的高可用？"><a href="#如何保证RabbitMQ的高可用？" class="headerlink" title="如何保证RabbitMQ的高可用？"></a>如何保证RabbitMQ的高可用？</h2><ul><li>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：<strong>单机模式、普通集群模式、镜像集群模式</strong>。</li></ul><h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><ul><li>Demo 级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。</li></ul><h3 id="普通集群模式"><a href="#普通集群模式" class="headerlink" title="普通集群模式"></a>普通集群模式</h3><ul><li>意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你<strong>创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据</strong>（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。</li><li>你消费的时候，实际上<strong>如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来</strong>。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</li></ul><h3 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h3><ul><li>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，<strong>在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思</strong>。然后每次你写消息到 queue 的时候，都会<strong>自动把消息同步到多个实例的 queue 上</strong>。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</li><li>这样的<strong>好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据</strong>。<strong>坏处在于，性能开销太大，消息需要同步到所有机器上，导致网络带宽压力和消耗很重</strong>！镜像集群下，每个节点都存放着所有 queue 的完整数据。</li></ul><h2 id="如何解决消息挤压问题？"><a href="#如何解决消息挤压问题？" class="headerlink" title="如何解决消息挤压问题？"></a>如何解决消息挤压问题？</h2><ul><li><strong>临时紧急扩容</strong>。先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</li></ul><h2 id="如何解决消息队列的延时以及过期失效问题？"><a href="#如何解决消息队列的延时以及过期失效问题？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？"></a>如何解决消息队列的延时以及过期失效问题？</h2><ul><li>RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是<strong>批量重导</strong>，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，<strong>将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来</strong>。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;Java基础&quot;&gt;&lt;a href=&quot;#Java基础&quot; class=&quot;headerlink&quot; title=&quot;Java基础&quot;&gt;&lt;/a&gt;Java基础&lt;/h1&gt;&lt;h2 id=&quot;Ja</summary>
      
    
    
    
    
    <category term="综合知识" scheme="https://konjacor.github.io/tags/%E7%BB%BC%E5%90%88%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>贾岛项目开发日志</title>
    <link href="https://konjacor.github.io/2022/12/22/%E8%B4%BE%E5%B2%9B%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <id>https://konjacor.github.io/2022/12/22/%E8%B4%BE%E5%B2%9B%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</id>
    <published>2022-12-22T14:24:37.000Z</published>
    <updated>2023-03-06T11:15:53.327Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>本项目基于尚硅谷的谷粒商城项目，主要是做的时候我想根据自己所学的东西对谷粒商城进行一定程度的改造，有点属于自己的特色，做这个项目的过程也是我巩固之前所学知识的一个机会，所以趁这个机会，把开发日志写一下，积累一下实战经验。</li></ul><h1 id="2022-x2F-12-x2F-23"><a href="#2022-x2F-12-x2F-23" class="headerlink" title="2022&#x2F;12&#x2F;23"></a>2022&#x2F;12&#x2F;23</h1><h2 id="为什么使用微服务的架构风格"><a href="#为什么使用微服务的架构风格" class="headerlink" title="为什么使用微服务的架构风格"></a>为什么使用微服务的架构风格</h2><ul><li>微服务的架构风格，实际上就是将一个单独的应用程序拆分成了多个小服务，每个小服务运行在自己的的进程中，并且它们之间使用轻量级的通信机制，通常是HTTP API，这些服务是围绕着应用的业务能力来构建的，并且可以独立部署，这些服务可以使用不同的编程语言编写、可以使用不同的数据存储技术，并且所有服务之间保持着最低限度的集中式管理。简而言之：<strong>微服务架构拒绝大型单体应用，基于业务边界进行服务微化拆分，各个服务独立部署运行</strong>。</li><li>使用微服务的架构风格使得项目获得了很好的可扩展性，再需要添加新功能的时候只需要把精力集中在开发新服务上即可，不用把精力花费在之前的代码上，这就是使用微服务解耦带来的好处之一，除此之外使用微服务的架构风格遇到错误和故障可以将其隔离以防止这些错误蔓延到别的服务模块，微服务带来的好处还有很多，但是同时它也给运维人员、开发人员等提出了新的挑战，比如：我该如何做到高可用呢？我该如何在分布式的事务中保证数据的一致性？服务被调用的时候中间的某个服务出现了错误，我该怎么办？我该怎么才能找到错误的服务？对于这些服务我该使用什么样的部署方案？我该如何对流量进行监控和限制？等等诸如此类的问题。</li></ul><h2 id="集群、分布式和节点"><a href="#集群、分布式和节点" class="headerlink" title="集群、分布式和节点"></a>集群、分布式和节点</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223142832425.png" alt="image-20221223142832425"></p><h2 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223143038851.png" alt="image-20221223143038851"></p><ul><li>使用HTTP+JSON的方式来进行远程调用的好处在于他们提供的天然的跨平台性，JSON可以在任何平台上被编码或是解码，而对于大多数编程语言来说，他们都有对应的发送HTTP请求的方法。</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223143343097.png" alt="image-20221223143343097"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223143418977.png" alt="image-20221223143418977"></p><ul><li>不要让某台机器太忙或者太闲</li></ul><h2 id="服务注册-x2F-发现中心"><a href="#服务注册-x2F-发现中心" class="headerlink" title="服务注册&#x2F;发现中心"></a>服务注册&#x2F;发现中心</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223143510152.png" alt="image-20221223143510152"></p><ul><li>将服务的消费者和服务的生产者解耦，引入中间件进行服务的管理。</li></ul><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223143814126.png" alt="image-20221223143814126"></p><ul><li>将配置和服务解耦，引入中间件集中管理微服务的配置信息。</li></ul><h2 id="服务熔断和服务降级"><a href="#服务熔断和服务降级" class="headerlink" title="服务熔断和服务降级"></a>服务熔断和服务降级</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223144306392.png" alt="image-20221223144306392"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223144331911.png" alt="image-20221223144331911"></p><ul><li>熔断器有半开机制，在熔断器打开后的一个时间窗口后，熔断器开始变成半开状态，尝试将流量放行，如果要是放行的流量返回了正常的结果，那么熔断器就会尝试关闭。</li><li>服务降级可以看作是服务熔断后的一种处理方式。</li></ul><h2 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223144626739.png" alt="image-20221223144626739"></p><ul><li>拦截所有打过来的请求，先做断言，断言成功之后，做过滤，最后再进行路由。</li></ul><h2 id="完整服务架构图"><a href="#完整服务架构图" class="headerlink" title="完整服务架构图"></a>完整服务架构图</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223145200445.png" alt="image-20221223145200445"></p><h2 id="微服务划分图"><a href="#微服务划分图" class="headerlink" title="微服务划分图"></a>微服务划分图</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223145837732.png" alt="image-20221223145837732"></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223153607206.png" alt="image-20221223153607206"></p><ul><li>虚拟化的容器，里面通过镜像装好了各种软件，镜像可以从Docker的hub上获取，软件可以在Docker中运行，因为软件的运行时环境都被打包到镜像中了，通过镜像安装后，软件就具备了在docker中运行的能力，各软件的运行环境相互隔离，一个出问题不会影响另外一个。</li><li>用这个技术安装软件非常方便，省去了在linux上安装软件的一系列繁琐的步骤。</li></ul><h2 id="租了个腾讯云服务器"><a href="#租了个腾讯云服务器" class="headerlink" title="租了个腾讯云服务器"></a>租了个腾讯云服务器</h2><ul><li>用来做后面的部署工作啥的，centos7.6系统，自带了个docker，4核8g，100gSSD。</li></ul><h2 id="使用docker安装mysql-5-7"><a href="#使用docker安装mysql-5-7" class="headerlink" title="使用docker安装mysql 5.7"></a>使用docker安装mysql 5.7</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><ul><li><p>有了云服务器和docker之后，安装这些软件就变得非常容易了，只需要在云服务器上运行**<code>sudo docker pull mysql:5.7</code><strong>就能下载了，下载别的软件的时候这个命令的格式基本不变，不过要注意的是，</strong>如果要指定下载软件镜像的版本，应该在镜像名称的后面加个冒号然后指定版本，如果不加冒号则默认下载最新版**：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223163407228.png" alt="image-20221223163407228"></p></li></ul><h3 id="查看已经下载的镜像"><a href="#查看已经下载的镜像" class="headerlink" title="查看已经下载的镜像"></a>查看已经下载的镜像</h3><ul><li><p>然后可以通过**<code>sudo docker images</code><strong>命令来</strong>查看已经下载的所有镜像**：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223163502237.png" alt="image-20221223163502237"></p></li></ul><h3 id="创建实例并启动"><a href="#创建实例并启动" class="headerlink" title="创建实例并启动"></a>创建实例并启动</h3><ul><li><p>使用如下的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223173136099.png" alt="image-20221223173136099"></p><p><strong>最后产生的是该实例的id</strong>。</p></li><li><p>参数说明：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223164759780.png" alt="image-20221223164759780"></p></li><li><p>从这里也能看出来<strong>docker中的部分冒号一般充当映射的作用，冒号前面的是运行docker的宿主机的内容，冒号后面的是docker这个虚拟容器中的内容</strong>，明白了这个看很多docker命令就了然许多了。</p></li><li><p>所谓<strong>目录挂载-v</strong>就是<strong>将一个目录挂载到另一个目录下，这样在访问被挂载到的目录的时候就相当于访问到了挂载目录，实际上是用软连接（快捷方式）实现的</strong>，这样就省得每次想要修改实例内部的文件的时候都要进实例中修改了,<strong>在挂载目录之前为了防止出现权限不够的问题，最好是先用命令<code>sudo chmod -R 777 目录路径</code>来提升相关目录的权限</strong>。</p></li><li><p>关于<strong>端口映射-p</strong>，由于<strong>mysql是跑在docker里面的3306端口上的</strong>，从外面无法访问，所以我们<strong>需要将docker里的3306端口和其宿主机的3306端口进行一个映射，这样外面在访问宿主机的3306端口的时候就能访问到docker的3306端口了</strong>。</p></li><li><p>至于<strong>设置实例名称–name</strong>，实例名称之后可以当作实例的唯一标识，那一串实例id也可以当作实例的唯一标识，但是用实例名称作为标识方便多了不是吗？</p></li><li><p><strong>-d就是从后台启动</strong>，后面要写<strong>镜像名:版本号</strong></p></li></ul><h3 id="查看某个实例的日志"><a href="#查看某个实例的日志" class="headerlink" title="查看某个实例的日志"></a>查看某个实例的日志</h3><ul><li><p>使用命令**<code>docker logs 实例名或实例id</code>**来查看某个实例的日志：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223205722266.png" alt="image-20221223205722266"></p></li></ul><h3 id="查看docker中正在运行的软件"><a href="#查看docker中正在运行的软件" class="headerlink" title="查看docker中正在运行的软件"></a>查看docker中正在运行的软件</h3><ul><li><p>使用**<code>docker ps -a</code><strong>命令来</strong>查看当前docker中所有状态的软件，包括正在运行的和已经终止的<strong>；使用</strong><code>docker ps</code><strong>命令来</strong>查看当前docker中正在运行的软件**：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223173216375.png" alt="image-20221223173216375"></p></li></ul><h3 id="停止docker实例"><a href="#停止docker实例" class="headerlink" title="停止docker实例"></a>停止docker实例</h3><ul><li><p>使用**<code>docker stop 实例名或实例id</code><strong>来</strong>将一个实例从正在运行状态变成已经终止的状态<strong>，注意</strong>停止docker实例的运行并不代表着删除docker实例**，停止docker实例运行后还可以通过启动docker实例来让其恢复运行，而删除docker实例后就这个实例就永远不能启动了，要想跑实例就必须再创建一个实例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223191435300.png" alt="image-20221223191435300"></p></li></ul><h3 id="启动docker实例"><a href="#启动docker实例" class="headerlink" title="启动docker实例"></a>启动docker实例</h3><ul><li><p>使用**<code>docker start 实例名或实例id</code>**来将一个状态是终止状态的实例启动：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223191618624.png" alt="image-20221223191618624"></p></li></ul><h3 id="重启docker实例"><a href="#重启docker实例" class="headerlink" title="重启docker实例"></a>重启docker实例</h3><ul><li>使用**<code>docker restart 实例名或实例id</code>**来将一个状态是运行状态的实例重新启动。</li></ul><h3 id="删除docker容器"><a href="#删除docker容器" class="headerlink" title="删除docker容器"></a>删除docker容器</h3><ul><li>有的实例已经没有在运行了，但是其容器还存在绑定着一些资源，我们想将其移除，可以使用**<code>docker rm 实例ID或实例名</code>**来将其删除。</li></ul><h3 id="删除docker本地镜像"><a href="#删除docker本地镜像" class="headerlink" title="删除docker本地镜像"></a>删除docker本地镜像</h3><ul><li>首先可以通过**<code>docker images</code><strong>来查看本地镜像名称及id，然后可以通过</strong><code>docker rmi 镜像名或镜像id</code>**来删除本地镜像。</li></ul><h3 id="进入docker正在运行的实例内部"><a href="#进入docker正在运行的实例内部" class="headerlink" title="进入docker正在运行的实例内部"></a>进入docker正在运行的实例内部</h3><ul><li>由于<strong>docker实例有一个软件完整的运行环境，所以它本质上拥有一个完整的linux目录结构（以linux系统下的docker来说</strong>），我们可以通过**<code>docker exec -it 实例名或实例id /bin/bash</code>**进入到这个实例的内部的操作台，然后就可以对实例的内部进行操作了，操作就和linux一样，毕竟是个linux环境。</li><li>也可以修改最后一部分以运行实例内部中的其他东西。</li><li>通过**<code>exit</code>**命令从实例内部的操作台中退出到外面。</li></ul><h3 id="让对应的容器开机自启动实例"><a href="#让对应的容器开机自启动实例" class="headerlink" title="让对应的容器开机自启动实例"></a>让对应的容器开机自启动实例</h3><ul><li>使用命令**<code>sudo docker update 容器id或容器名 --restart=always</code>**来配置开机自启动。</li></ul><h3 id="创建mysql的配置文件"><a href="#创建mysql的配置文件" class="headerlink" title="创建mysql的配置文件"></a>创建mysql的配置文件</h3><ul><li><p>在刚才挂载的宿主机上的目录下新建配置文件my.cnf(用**<code>touch 文件名</code><strong>或者</strong><code>vim/vi 文件名</code>**都行)填入以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">init_connect=&#x27;SET collation_connection = utf8_unicode_ci&#x27;</span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure></li><li><p>重启mysql实例，如果想要验证是否真的产生了配置文件可以进入实例内部的对应目录下查看。</p></li></ul><h3 id="查看各实例占用资源的情况"><a href="#查看各实例占用资源的情况" class="headerlink" title="查看各实例占用资源的情况"></a>查看各实例占用资源的情况</h3><ul><li>可以使用<code>docker stats</code>命令来进行查看。</li></ul><h3 id="将docker容器中的内容复制到指定位置"><a href="#将docker容器中的内容复制到指定位置" class="headerlink" title="将docker容器中的内容复制到指定位置"></a>将docker容器中的内容复制到指定位置</h3><ul><li>使用命令**<code>docker container cp 容器名:容器内部目录 目标目录</code>**来实现。</li></ul><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><ul><li>SSH（Secure Shell） 是较可靠，<strong>专为远程登录会话和其他网络服务提供安全性的协议</strong>，利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题，这是因为SSH相较于其他的传输协议来说对数据进行了加密处理。</li><li>我们<strong>通常使用实现SSH协议的软件来实现远程数据传输、远程连接等操作</strong>，这个连接操作<strong>可以使用基于密钥的安全验证</strong>的，<strong>也可以使用基于口令的安全验证</strong>。</li></ul><h2 id="在本地使用Navicat通过SSH协议连接到服务器上的mysql数据库"><a href="#在本地使用Navicat通过SSH协议连接到服务器上的mysql数据库" class="headerlink" title="在本地使用Navicat通过SSH协议连接到服务器上的mysql数据库"></a>在本地使用Navicat通过SSH协议连接到服务器上的mysql数据库</h2><ul><li>出于安全考虑，我们不使用基于口令的安全验证方式，实际上腾讯云服务器上ssh协议的配置文件中也是默认将这种方式关闭的，我们使用基于密钥的安全验证。</li></ul><h3 id="创建密钥"><a href="#创建密钥" class="headerlink" title="创建密钥"></a>创建密钥</h3><ul><li>SSH协议通常使用基于密钥的安全验证方式，所以我们要先在腾讯云控制台上新建一个密钥，公钥会显示在控制台，而密钥会下载到本地。</li></ul><h3 id="将密钥绑定到服务器实例上"><a href="#将密钥绑定到服务器实例上" class="headerlink" title="将密钥绑定到服务器实例上"></a>将密钥绑定到服务器实例上</h3><ul><li>就是把刚才创建的SSH公钥绑定到服务器上，这样别的主机就可以使用那个SSH公钥对应的私钥来向服务器发起SSH连接。</li></ul><h3 id="新建连接"><a href="#新建连接" class="headerlink" title="新建连接"></a>新建连接</h3><ul><li>在navicat上新建一个连接，名字随便取，然后数据库的密码填服务器上数据库的密码。</li><li>然后配置SSH，勾选使用SSH通道，填写服务器ip，填写用户名，验证方法选公钥，然后私钥选择刚才下载下来的那个文件，通行短语就是每次连接的时候需要输入的口令，自己随便设置一个就行，建议勾选保存通行短语，这样就不用每次连接都输入通行短语了，测试连接，发现可以连通，点击确认即可。</li></ul><h2 id="使用docker安装redis"><a href="#使用docker安装redis" class="headerlink" title="使用docker安装redis"></a>使用docker安装redis</h2><ul><li><p>前面基本和mysql的安装类似，pull的是最新版的</p></li><li><p>在外面预先创建好redis的配置文件，因为实例中redis一开始可能没有redis.conf，进行挂载目录的时候宿主机的redis.conf可能会被错误的识别为一个目录，所以要在指定位置先创建好redis.conf防止发生歧义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/redis/conf</span><br><span class="line">touch /mydata/redis/conf/redis.conf</span><br></pre></td></tr></table></figure></li><li><p>创建实例并启动的命令，最后一句是表示让redis-server按照对应路径下的配置文件进行启动，要预先在外面对应位置创建好redis.conf文件，注意这个redis.conf文件存在的目录在不同版本的redis中有区别，具体按安装的redis版本为准：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis \</span><br><span class="line">-v /mydata/redis/data:/data \</span><br><span class="line">-v /mydata/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf \</span><br><span class="line">-d redis /usr/local/bin/redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure></li><li><p>使用**<code>docker exec -it redis redis-cli</code>**可以打开redis实例中的redis-cli</p></li><li><p>在redis的配置文件中添加<strong>appendonly yes</strong>，配置让redis使用aof的方式持久化数据</p></li><li><p>可以在本地<strong>使用Redis Desktop Manager来远程访问redis</strong>，也是用SSH连接，和前面的Navicat类似，这里就不赘述了，但是注意这个软件用到了服务器上的6379端口，所以要先把6379端口开放之后才能连接上。</p></li></ul><h2 id="在IDEA中搭建各种模块"><a href="#在IDEA中搭建各种模块" class="headerlink" title="在IDEA中搭建各种模块"></a>在IDEA中搭建各种模块</h2><ul><li><p>先clone下来刚建好的仓库，再创建各个模块</p></li><li><p>每个模块使用springboot的初始化工具进行初始化，每个一开始都配上web和openfeign的环境</p></li></ul><h1 id="2022-x2F-12-x2F-24"><a href="#2022-x2F-12-x2F-24" class="headerlink" title="2022&#x2F;12&#x2F;24"></a>2022&#x2F;12&#x2F;24</h1><h2 id="设置项目的-gitignore文件"><a href="#设置项目的-gitignore文件" class="headerlink" title="设置项目的.gitignore文件"></a>设置项目的.gitignore文件</h2><ul><li><p>两个星号**指所有子目录及其递归结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">target/</span><br><span class="line">pom.xml.tag</span><br><span class="line">pom.xml.releaseBackup</span><br><span class="line">pom.xml.versionsBackup</span><br><span class="line">pom.xml.next</span><br><span class="line">release.properties</span><br><span class="line">dependency-reduced-pom.xml</span><br><span class="line">buildNumber.properties</span><br><span class="line">.mvn/timing.properties</span><br><span class="line"># https://github.com/takari/maven-wrapper#usage-without-binary-jar</span><br><span class="line">.mvn/wrapper/maven-wrapper.jar</span><br><span class="line"></span><br><span class="line">**/mvnw</span><br><span class="line">**/mvnw.cmd</span><br><span class="line">**/.mvn</span><br><span class="line">**/target/</span><br><span class="line">.idea</span><br><span class="line">**/.gitignore</span><br></pre></td></tr></table></figure></li></ul><h2 id="IDEA中Project-Structure中的Facets配置"><a href="#IDEA中Project-Structure中的Facets配置" class="headerlink" title="IDEA中Project Structure中的Facets配置"></a>IDEA中Project Structure中的Facets配置</h2><ul><li><p>这个配置实际上就是在告诉IDEA怎么去处理你的对应模块，比如说我给一个模块设置了一个spring的Facets，那么IDEA就知道使用对待spring模块的方式来对待我的这个模块，每个模块可以配置多个Facets，并且每个Facets可以进行相应的配置从而来让IDEA帮我们配置关于这个模块的一些东西：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221224154946122.png" alt="image-20221224154946122"></p></li></ul><h2 id="PowerDesigner"><a href="#PowerDesigner" class="headerlink" title="PowerDesigner"></a>PowerDesigner</h2><ul><li>这个软件是用来设计数据库的</li><li>所有表无论关系多么复杂都不应该建立外键，外键关联非常消耗数据库的性能</li><li>可以用这个软件针对设计出来的数据库导出sql文件（Database-generate database选项）</li></ul><h2 id="启动报错：java-程序包org-aspectj-lang不存在"><a href="#启动报错：java-程序包org-aspectj-lang不存在" class="headerlink" title="启动报错：java: 程序包org.aspectj.lang不存在"></a>启动报错：java: 程序包org.aspectj.lang不存在</h2><ul><li>可能是springboot版本的问题，改个版本试下</li></ul><h2 id="前端项目下载依赖"><a href="#前端项目下载依赖" class="headerlink" title="前端项目下载依赖"></a>前端项目下载依赖</h2><ul><li>可以通过**<code>npm install</code>**命令来下载一个前端项目所需要的依赖文件。</li></ul><h2 id="前端项目运行"><a href="#前端项目运行" class="headerlink" title="前端项目运行"></a>前端项目运行</h2><ul><li>使用**<code>npm run dev</code>**来运行前端项目</li></ul><h2 id="查看windows系统的端口占用"><a href="#查看windows系统的端口占用" class="headerlink" title="查看windows系统的端口占用"></a>查看windows系统的端口占用</h2><ul><li>使用**<code>netstat -ano</code>**命令查看所有端口的占用情况，再根据详细信息中的PID从任务管理器中找到对应的应用。</li></ul><h2 id="关于子模块的依赖问题"><a href="#关于子模块的依赖问题" class="headerlink" title="关于子模块的依赖问题"></a>关于子模块的依赖问题</h2><ul><li>一般来说子模块用到的依赖应该在父模块声明方便管理，然后子模块再声明一次。</li><li>其实也可以将子模块都用得到的依赖放到common模块中，然后子模块引入common模块，省的在子模块中再声明一次了就。</li></ul><h2 id="关于maven的版本问题"><a href="#关于maven的版本问题" class="headerlink" title="关于maven的版本问题"></a>关于maven的版本问题</h2><ul><li>用IDEA的话maven尽量用3.6.3的版本吧，这个版本的maven对各个版本的IDEA都挺兼容的，我感觉我从远程下载不下来jar包是因为我maven版本太高了的原因，我现在是3.8.6，我去试试低版本。</li><li>好像也不太行，总之还是尽量用第二梯队的吧，啥东西也是别无脑上最新版。</li></ul><h1 id="2022-x2F-12-x2F-27"><a href="#2022-x2F-12-x2F-27" class="headerlink" title="2022&#x2F;12&#x2F;27"></a>2022&#x2F;12&#x2F;27</h1><h2 id="关于有些jar包无法从远程仓库下载"><a href="#关于有些jar包无法从远程仓库下载" class="headerlink" title="关于有些jar包无法从远程仓库下载"></a>关于有些jar包无法从远程仓库下载</h2><ul><li><p>首先排除一下网络问题</p></li><li><p>然后可能是你这个jar包在你配置的那个仓库中没有，你需要重新配置一个有那个jar包的仓库的镜像，至于怎么知道这个jar包在哪个仓库中有，可以从中央仓库中搜索，然后点下面这几个标签之一就能查看标签对应的仓库地址了：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221227202945652.png" alt="image-20221227202945652"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221227203005023.png" alt="image-20221227203005023"></p></li><li><p>如果还是不能解决的话，也可以手动下载然后根据gav地址配置到本地的maven仓库中。</p></li><li><p>最后就是记得使用解决方案之后clean一下maven，不然可能还是爆红。</p></li></ul><h1 id="2022-x2F-12-x2F-28"><a href="#2022-x2F-12-x2F-28" class="headerlink" title="2022&#x2F;12&#x2F;28"></a>2022&#x2F;12&#x2F;28</h1><h2 id="关于mybatis-plus的代码生成器的依赖"><a href="#关于mybatis-plus的代码生成器的依赖" class="headerlink" title="关于mybatis-plus的代码生成器的依赖"></a>关于mybatis-plus的代码生成器的依赖</h2><ul><li><p>搞了半天终于搞定了mybatis-plus代码生成器的依赖，依赖列表如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mybatis-plus.version</span>&gt;</span>3.1.2<span class="tag">&lt;/<span class="name">mybatis-plus.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mybatis-plus-generator.version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">mybatis-plus-generator.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mysql-connector-java.version</span>&gt;</span>8.0.17<span class="tag">&lt;/<span class="name">mysql-connector-java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.1.13<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">velocity-engine-core.version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">velocity-engine-core.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--mybatis-plus 持久层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis-plus代码生成器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus-generator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 代码生成器依赖的某个工具类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-lang3.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql数据库驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql-connector-java.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--阿里druid连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.velocity/velocity-engine-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;velocity-engine-core.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="关于数据库表的一些设计规范"><a href="#关于数据库表的一些设计规范" class="headerlink" title="关于数据库表的一些设计规范"></a>关于数据库表的一些设计规范</h2><ul><li>根据《阿里巴巴开发手册》中提到的，<strong>每张表应该都有id、gmt_create（记录创建时间）、gmt_modified（记录修改时间）字段</strong>，说明：其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1（或者用varchar 19存，每次使用雪花算法自动生成19位uuid）。gmt_create、gmt_modified 的类型均为 date_time 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</li><li>还可以<strong>创建is_deleted字段来标识当前记录是否被逻辑删除</strong>，开发的时候可以配置逻辑删除插件来对这个字段实现自动化操作，并且<strong>应该让被逻辑删除的记录无法被查到</strong>。</li></ul><h2 id="关于spring-boot-maven-plugin"><a href="#关于spring-boot-maven-plugin" class="headerlink" title="关于spring-boot-maven-plugin"></a>关于spring-boot-maven-plugin</h2><ul><li>这个插件如果要是配置到pom文件中，那么在maven进行构建的时候就会去找这个pom文件管辖范围下的程序入口main，所以如果父工程没有程序入口main，就不要引入这个插件，不然在执行maven的生命周期时会报错。</li></ul><h2 id="maven执行install的时候报单元测试错误"><a href="#maven执行install的时候报单元测试错误" class="headerlink" title="maven执行install的时候报单元测试错误"></a>maven执行install的时候报单元测试错误</h2><ul><li><p>可以在下面这个地方设置成跳过单元测试的模式，设置完成后再执行就好了：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221228183630929.png" alt="image-20221228183630929"></p></li></ul><h2 id="IDEA有时包明明存在但是运行程序时总是报找不到某个包"><a href="#IDEA有时包明明存在但是运行程序时总是报找不到某个包" class="headerlink" title="IDEA有时包明明存在但是运行程序时总是报找不到某个包"></a>IDEA有时包明明存在但是运行程序时总是报找不到某个包</h2><ul><li><p>首先尝试刷新Maven，有的时候IDE会抽风导致很多包明明存在但却没有被加载。</p></li><li><p>再者有可能是IDEA的bug，可以在下面这个地方将IDE的构建&#x2F;运行操作委托给maven，不过设置了这个之后不保证以后不会出什么问题，所以解决问题之后能改回来就尽量改回来吧：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221228184212604.png" alt="image-20221228184212604"></p></li></ul><h1 id="2022-x2F-12-x2F-29"><a href="#2022-x2F-12-x2F-29" class="headerlink" title="2022&#x2F;12&#x2F;29"></a>2022&#x2F;12&#x2F;29</h1><h2 id="记录一种奇怪的依赖引入方式"><a href="#记录一种奇怪的依赖引入方式" class="headerlink" title="记录一种奇怪的依赖引入方式"></a>记录一种奇怪的依赖引入方式</h2><ul><li><p>在处理依赖的时候发现了一种比较奇怪的依赖引入方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个结构的依赖我翻了翻之前的博客，没发现有相关的解释，值为pom的type标签和值为import的scope标签也从来没见过，上网搜了搜，基本可以将这个东西理解成一个比较方便引入的整体，需要引入的时候直接往pom里一粘，具体的解释目前还不得而知。（如果原pom本来就有dependencyManagement标签怎么办？如果要是父pom中引入了这种格式的依赖，那子pom应该以怎样的格式引入这样的依赖？type标签和scope标签的值到底是什么含义？）</p></li></ul><h2 id="关于nacos-2-x版本无法访问的问题"><a href="#关于nacos-2-x版本无法访问的问题" class="headerlink" title="关于nacos 2.x版本无法访问的问题"></a>关于nacos 2.x版本无法访问的问题</h2><ul><li><p>在服务器的docker上安装了nacos-server的2.0.2版本，但是在本地启动springboot的服务却报错无法连接到nacos-server，但是在本地的浏览器上访问服务器的8848端口下的nacos目录是可以访问的，就奇了怪了，后来搜索了一下才知道，原来<strong>2.x版本的nacos-server还用到了9848（8848+1000）和9849（8848+1001）两个端口，这两个端口号不是固定的是通过主服务端口加上一个固定的偏移量得来的</strong>，所以在docker启动镜像的时候要用多个-p命令同时指定三个端口的映射：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221229172729337.png" alt="image-20221229172729337"></p></li></ul><h2 id="关于在nacos配置中心上做配置"><a href="#关于在nacos配置中心上做配置" class="headerlink" title="关于在nacos配置中心上做配置"></a>关于在nacos配置中心上做配置</h2><ul><li><p>配置中心的命名空间可以用来隔离不同的服务，也可以用来隔离不同的开发环境，也可以自定义隔离规则，在命名空间下还有组可以进行环境隔离，要想指定特定的命名空间和组，需要在bootstrap配置文件中进行相关配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置命名空间,填的是命名空间的id</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.namespace</span>=<span class="string">coupon</span></span><br><span class="line"><span class="comment">#配置组，填的是组名</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.group</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure></li><li><p>如果一个配置文件中的内容过多的话，可以将一个配置文件拆成多个配置文件，每一个配置文件各司其职，不过这样的方式需要最后在本地的bootstrap配置文件中进行配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置配置中心上自定义名称的配置文件，可以把很长的配置文件拆分开放到配置中心上，然后在这里配置读取</span></span><br><span class="line"><span class="comment">#中心上的配置文件名称</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[0].data-id</span>=<span class="string">datasource.yaml</span></span><br><span class="line"><span class="comment">#设置组</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[0].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="comment">#开启刷新以保证服务可以事实获取到最新的改动</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[0].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[1].data-id</span>=<span class="string">mybatis.yaml</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[1].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[1].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[2].data-id</span>=<span class="string">other.yaml</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[2].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[2].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="2022-x2F-12-x2F-30"><a href="#2022-x2F-12-x2F-30" class="headerlink" title="2022&#x2F;12&#x2F;30"></a>2022&#x2F;12&#x2F;30</h1><h2 id="如何排除不想加载的包"><a href="#如何排除不想加载的包" class="headerlink" title="如何排除不想加载的包"></a>如何排除不想加载的包</h2><ol><li><p>可以在pom文件中使用exclusions-exclusion标签来对指定jar包进行排除</p></li><li><p>也可以在@SpringBootApplication注解中设置exclude参数，实参应该是某个AutoConfiguration的class对象，比如想要排除数据源相关的包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="2023-x2F-1-x2F-1"><a href="#2023-x2F-1-x2F-1" class="headerlink" title="2023&#x2F;1&#x2F;1"></a>2023&#x2F;1&#x2F;1</h1><h2 id="关于使用mybatis-plus查不出数据的问题"><a href="#关于使用mybatis-plus查不出数据的问题" class="headerlink" title="关于使用mybatis-plus查不出数据的问题"></a>关于使用mybatis-plus查不出数据的问题</h2><ul><li>首先检查@TableId注解，看看数据库的id和实体类的id是否一致</li><li>也有可能是@TableLogic注解导致的，因为注解上@TableLogic注解后默认这个字段不能为空，此时要是数据库中的数据这个字段为空，那就查不出来。</li><li>总而言之大部分是实体类和数据库表的字段参数不一致造成的。</li></ul><h2 id="在实体类中添加数据库表中不存在的字段"><a href="#在实体类中添加数据库表中不存在的字段" class="headerlink" title="在实体类中添加数据库表中不存在的字段"></a>在实体类中添加数据库表中不存在的字段</h2><ul><li>需要加上**<code>@TableField(exist = false)</code>**注解。</li><li>不过更规范的做法应该是再写一个VO类，然后使用bean拷贝。</li></ul><h2 id="在VScode中添加vue代码模板"><a href="#在VScode中添加vue代码模板" class="headerlink" title="在VScode中添加vue代码模板"></a>在VScode中添加vue代码模板</h2><ul><li><p>首先点击<strong>文件-首选项-配置用户代码片段</strong>，然后点击<strong>新建全局代码片段文件</strong>，然后<strong>将模板复制进去或者自己写一个模板</strong>，其中<strong>prefix属性就是你输入prefix属性对应的值会提示产生这个代码片段</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Print to console&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;&lt;!-- $1 --&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;template&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;div class=&#x27;$2&#x27;&gt;$5&lt;/div&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;/template&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;script&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//这里可以导入其他文件（比如：组件，工具js，第三方插件js，json文件，图片文件等等）&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//例如：import 《组件名称》 from &#x27;《组件路径》&#x27;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;export default &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//import引入的组件需要注入到对象中才能使用&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;components: &#123;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;data() &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//这里存放数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;return &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//监听属性 类似于data概念&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;computed: &#123;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//监控data中的数据变化&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;watch: &#123;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//方法集合&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;methods: &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//生命周期 - 创建完成（可以访问当前this实例）&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;created() &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//生命周期 - 挂载完成（可以访问DOM元素）&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;mounted() &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;beforeCreate() &#123;&#125;, //生命周期 - 创建之前&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;beforeMount() &#123;&#125;, //生命周期 - 挂载之前&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;beforeUpdate() &#123;&#125;, //生命周期 - 更新之前&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;updated() &#123;&#125;, //生命周期 - 更新之后&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;beforeDestroy() &#123;&#125;, //生命周期 - 销毁之前&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;destroyed() &#123;&#125;, //生命周期 - 销毁完成&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;activated() &#123;&#125;, //如果页面有keep-alive缓存功能，这个函数会触发&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;/script&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;style scoped&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;/style&gt;&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;生成vue模板&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http-get请求&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;httpget&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;this.\\$http(&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;url: this.\\$http.adornUrl(&#x27;&#x27;),&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;method: &#x27;get&#x27;,&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;params: this.\\$http.adornParams(&#123;&#125;)&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;&#125;).then((&#123; data &#125;) =&gt; &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;&#125;)&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;httpGET请求&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http-post请求&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;httppost&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;this.\\$http(&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;url: this.\\$http.adornUrl(&#x27;&#x27;),&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;method: &#x27;post&#x27;,&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;data: this.\\$http.adornData(data, false)&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;&#125;).then((&#123; data &#125;) =&gt; &#123; &#125;);&quot;</span> </span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;httpPOST请求&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="2023-x2F-1-x2F-2"><a href="#2023-x2F-1-x2F-2" class="headerlink" title="2023&#x2F;1&#x2F;2"></a>2023&#x2F;1&#x2F;2</h1><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><ul><li><p>由于某些软件的CORS（Cross-Origin Resource Sharing 跨域资源共享）policy的设置，使得我们在跨域访问资源的时候会出现禁止跨域访问资源的问题，<strong>协议、域名、端口其中有一个不同都会产生跨域</strong>，详细解释：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS%E3%80%82">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS。</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230102142732589.png" alt="image-20230102142732589"></p></li><li><p>对于这样的跨域问题我们可以从两个方向着手解决：</p><ol><li><p>其一是使用nginx将项目部署为同一域</p></li><li><p>其二是在跨域访问的响应资源的http报文header中写明当次请求允许跨域，可以在网关中配置跨域过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CorsWebFilter <span class="title function_">corsWebFilter</span><span class="params">()</span>&#123;<span class="comment">//配置跨域过滤器，让资源允许被跨域访问</span></span><br><span class="line">    <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">    <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line"></span><br><span class="line">    corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);<span class="comment">//允许所有带有头部的资源被跨域访问</span></span><br><span class="line">    corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);<span class="comment">//允许资源被所有访问方式跨域访问</span></span><br><span class="line">    corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);<span class="comment">//允许资源被所有域名跨域访问</span></span><br><span class="line">    corsConfiguration.setAllowCredentials(<span class="literal">true</span>);<span class="comment">//允许cookie资源跨域访问</span></span><br><span class="line"></span><br><span class="line">    source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,corsConfiguration);<span class="comment">//对于任意资源路径进行跨域配置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完上面这些之后，资源在返回的时候就会经过过滤器，在资源的响应header上加上我们配置的字段，浏览器看到之后自然就会将该资源放行。</p></li></ol></li></ul><h2 id="如何初始化并启动一个前端项目"><a href="#如何初始化并启动一个前端项目" class="headerlink" title="如何初始化并启动一个前端项目"></a>如何初始化并启动一个前端项目</h2><ol><li>使用<strong>npm init</strong>命令初始化项目目录</li><li>使用<strong>npm install</strong>命令安装package.json文件中写的依赖</li><li>使用<strong>npm run dev</strong>命令启动项目</li></ol><h1 id="2023-x2F-1-x2F-3"><a href="#2023-x2F-1-x2F-3" class="headerlink" title="2023&#x2F;1&#x2F;3"></a>2023&#x2F;1&#x2F;3</h1><h2 id="项目中如何进行文件存储"><a href="#项目中如何进行文件存储" class="headerlink" title="项目中如何进行文件存储"></a>项目中如何进行文件存储</h2><ul><li><p>如果项目需要我们进行文件存储，我们应该怎么办？</p></li><li><p>首先我们能想到的是在后端创建一个目录，专门用来存放前端传过来的文件，但是这样有个问题，就是后端在部署为集群的时候，前端对于后端的访问肯定是负载均衡的，所以前端不一定将文件存放到哪个集群节点中，访问的时候也不一定访问哪个集群节点，并不能保证文件一定会被读取到。</p></li><li><p>再者我们可以创建一个专门的文件服务器来对文件进行存储，直接将文件传给文件服务器，这样可以保证存储的文件可以被读取到，但是我们自己搭建的文件服务器难免会出现一些问题，而且我们还要拿出专门的时间去对其进行维护。所以我们可以使用云存储功能，去购买别人公司的云存储功能，我们只需要将我们的程序和公司的接口对接就能实现云存储的功能了，而且公司里有专业的运维人员来维护，我们只要掏钱就行了。</p></li><li><p>那么我们应该采取什么样的策略来实现文件存储呢？是前端将文件传给后端，然后后端再交给云服务器吗？这样可以实现，但是这样做后端的压力过大，仅仅是处理文件上传请求就已经占用了后端太多的资源，所以我们<strong>可以利用用户端的资源来上传文件，后端要做的只是返回一个签名，前端带着这个签名申请将文件上传到云服务器，如果签名被云服务器承认，那么文件就可以从前端直接上传到云服务器上，很明显这样做大大减少了后端的压力</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230103165550800.png" alt="image-20230103165550800"></p></li><li><p>springcloud alibaba整合了阿里的OSS服务的SDK并对其进行了封装，我们如果想要使用它的功能，只需要<strong>导入springcloud alibaba的依赖、oss的starter依赖，然后在配置文件中进行身份验证的配置和endpoint的配置，然后在controller中注入OSSClient对象，使用OSSClient对象就可以实现各种操作了</strong>。整合的时候oss的starter依赖尽量和springcloud alibaba的依赖版本相同，不然可能会出现依赖冲突，出现依赖冲突后需要手动exclusion一些包。</p></li><li><p>前端收到签名后，按照阿里云的文档构造请求体，然后直接给bucket对应的url发post请求即可，文档：<a href="https://help.aliyun.com/document_detail/31926.html">https://help.aliyun.com/document_detail/31926.html</a></p></li><li><p>上传文件的时候可以使用UUID+原始文件名组成上传文件名来防止出现命名冲突。</p></li><li><p>dir目录可以设置成格式化的年月日，这样每天上传的文件都会放到一个对应当天日期的目录中方便管理。</p></li><li><p>记得在阿里云oss控制台那边配置CORS policy，不然会有跨域问题。</p></li></ul><h1 id="2023-x2F-1-x2F-4"><a href="#2023-x2F-1-x2F-4" class="headerlink" title="2023&#x2F;1&#x2F;4"></a>2023&#x2F;1&#x2F;4</h1><h2 id="后端数据校验"><a href="#后端数据校验" class="headerlink" title="后端数据校验"></a>后端数据校验</h2><h3 id="为什么后端要进行数据校验"><a href="#为什么后端要进行数据校验" class="headerlink" title="为什么后端要进行数据校验"></a>为什么后端要进行数据校验</h3><ul><li>虽然前端有进行数据校验，但是如果一些不法分子不通过前端向后端发送数据，比如使用postman等工具，也就绕过了前端的数据校验，所以后端必须再进行一次数据校验以保证系统的安全。</li></ul><h3 id="关于JSR"><a href="#关于JSR" class="headerlink" title="关于JSR"></a>关于JSR</h3><ul><li>JSR是Java Specification Requests的缩写，意思是<strong>Java 规范提案</strong>。是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。</li></ul><h3 id="关于JSR-303"><a href="#关于JSR-303" class="headerlink" title="关于JSR-303"></a>关于JSR-303</h3><p>JSR-303 是JAVA EE 6 中的一项子规范，叫做<strong>Bean Validation</strong>，是用来校验数据的规范，Hibernate Validator 是 Bean Validation 的参考实现 . Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。</p><h3 id="基本数据校验"><a href="#基本数据校验" class="headerlink" title="基本数据校验"></a>基本数据校验</h3><ul><li><p>主要是使用JSR-303标准，这套标准规定了java中对各种数据进行校验的标准，各公司对于这套标准的实现提供了多种多样的注解，通过<strong>给实体类属性上面添加对应的校验注解、自定义message提示消息</strong>并且<strong>给想要校验的参数注解上@Valid</strong>来实现对实参数据的校验，实参校验不通过会响应包含自定义message提示消息在内的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(value = &quot;品牌名&quot;)</span></span><br><span class="line"><span class="meta">@NotBlank(message = &quot;品牌名不能为空&quot;)</span><span class="comment">//数据校验，该字段不能为空，并且至少有一个非空字符</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> PmsBrand entity)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pmsBrandService.save(entity)?Result.ok():Result.error();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果<strong>想要获取校验的结果，可以在被@Valid注解修饰的参数后面紧跟着写一个BindingResult类型的参数，这个参数封装了它前面参数的校验结果</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> PmsBrand entity, BindingResult bindingResult)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取所有元素校验的错误结果</span></span><br><span class="line">        bindingResult.getFieldErrors().forEach(item-&gt;&#123;</span><br><span class="line">            <span class="comment">//获取到错误信息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> item.getDefaultMessage();</span><br><span class="line">            <span class="comment">//获取错误的属性的名字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> item.getField();</span><br><span class="line">            map.put(field,message);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> Result.error().code(<span class="number">400</span>).message(<span class="string">&quot;提交的数据不合法&quot;</span>).data(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pmsBrandService.save(entity)?Result.ok():Result.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果想要<strong>自定义数据校验的规则，可以使用@Pattern注解，其中的regexp属性支持正则表达式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(value = &quot;检索首字母&quot;)</span></span><br><span class="line"><span class="meta">@NotEmpty</span></span><br><span class="line"><span class="meta">@Pattern(regexp = &quot;/^[a-zA-Z]$/&quot;,message = &quot;检索首字母必须是一个字母&quot;)</span><span class="comment">//自定义的数据校验，可以写正则表达式</span></span><br><span class="line"><span class="keyword">private</span> String firstLetter;</span><br></pre></td></tr></table></figure></li><li><p>依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-validator.version</span>&gt;</span>6.0.16.Final<span class="tag">&lt;/<span class="name">hibernate-validator.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--JSR303规范的数据校验实现--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate-validator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="分组数据校验"><a href="#分组数据校验" class="headerlink" title="分组数据校验"></a>分组数据校验</h3><ul><li><p>适用于多场景下的复杂校验</p></li><li><p>上面的校验方式有点问题，那就是<strong>如果我们想要在不同的业务场景下用不同的校验规则，那怎么办呢？</strong>就比如说在我save数据的时候我想要上面那套校验规则，但是现在我想设置一套update数据的校验规则，那该怎么办呢？基于这种情况，我们可以使用分组的数据校验。</p></li><li><p>首先我们<strong>创建一些空接口来标识不同的场景，也就是表示不同的分组</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.valid;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 19:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AddGroup</span> &#123;<span class="comment">//校验数据时的对应增加数据的情况的分组，只是一个标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.valid;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 19:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UpdateGroup</span> &#123;<span class="comment">//校验数据时的对应更新数据的情况的分组，只是一个标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后我们<strong>根据需要给实体类属性上的数据校验注解的groups属性赋值，表示这个数据校验注解在什么分组下生效</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(value = &quot;品牌id&quot;)</span></span><br><span class="line"><span class="meta">@TableId(value = &quot;brand_id&quot;, type = IdType.ASSIGN_ID)</span></span><br><span class="line"><span class="meta">@NotNull(message = &quot;修改必须指定品牌id&quot;,groups = UpdateGroup.class)</span></span><br><span class="line"><span class="meta">@Null(message = &quot;新增不能指定品牌id&quot;,groups = AddGroup.class)</span></span><br><span class="line"><span class="keyword">private</span> String brandId;</span><br></pre></td></tr></table></figure></li><li><p>最后我们<strong>在controller的参数中使用<code>@Validated(&#123;分组接口1.class,...&#125;)</code>注解来表示对被修饰的数据是以什么分组来进行校验，只有对应分组的数据校验注解会在这次数据校验中生效</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@Validated(&#123;AddGroup.class&#125;)</span> <span class="meta">@RequestBody</span> PmsBrand entity)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pmsBrandService.save(entity)?Result.ok():Result.error();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果属性上的<strong>数据校验注解没有指定groups，那么在参数中指定以某个分组进行数据校验的时候，没有指定groups的数据校验注解就无效</strong>。</p></li></ul><h3 id="自定义数据校验"><a href="#自定义数据校验" class="headerlink" title="自定义数据校验"></a>自定义数据校验</h3><ul><li><p>有时提供的数据校验注解无法很好的完成任务，这个时候我们就需要自定义数据校验逻辑来满足我们的需求。</p></li><li><p>首先我们需要<strong>编写一个自定义的校验注解，包括自定义的错误信息配置文件</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.valid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.TYPE_USE;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 20:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span><span class="comment">//与生成java文档相关，被这个元注解修饰的注解可以被很好地显示在文档中</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123; &#125;)</span><span class="comment">//该校验注解使用哪些校验器进行校验，可以绑定多个校验器以适配不同的场景</span></span><br><span class="line"><span class="meta">@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span><span class="comment">//该注解可以标识在哪些位置</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span><span class="comment">//让该注解在运行时能被获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListValue &#123;<span class="comment">//用来校验数据是否是指定的数据集中的数据</span></span><br><span class="line">    <span class="comment">//注解的属性就是在写注解的时候可以在小括号中指定的那些属性</span></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;com.konjacer.mallisland.common.valid.ListValue.message&#125;&quot;</span>;<span class="comment">//错误信息去哪取，默认是从classpath下的ValidationMessages.properties配置文件中取，我们可以自己写一个这样的配置文件放在classpath下，让它从我们自己的配置文件中取对应的值</span></span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//分组数据校验功能，若指定了分组，则该注解只对指定分组的数据校验生效</span></span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//和负载相关</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] vals() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//指定校验数据可以是哪些数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ValidationMessages.properties</span></span><br><span class="line"><span class="attr">com.konjacer.mallisland.common.valid.ListValue.message</span>=<span class="string">必须提交指定的值</span></span><br></pre></td></tr></table></figure></li><li><p>然后我们需要<strong>编写一个自定义的校验器</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.valid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 20:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListValueConstraintValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;ListValue,Integer&gt; &#123;<span class="comment">//实现接口的第一个类型参数是用在哪个注解上，第二个是处理什么类型的数据</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//用来判断数据在不在给定的数据中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ListValue constraintAnnotation)</span> &#123;<span class="comment">//初始化方法</span></span><br><span class="line">        <span class="comment">//ConstraintValidator.super.initialize(constraintAnnotation);</span></span><br><span class="line">        <span class="type">int</span>[] vals = constraintAnnotation.vals();<span class="comment">//获取在使用注解时传入的数据，是从ListValue注解中拿到的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> val : vals)&#123;</span><br><span class="line">            set.add(val);<span class="comment">//把给定的数据给set</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 需要校验的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context context in which the constraint is evaluated</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否校验成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(Integer value, ConstraintValidatorContext context)</span> &#123;<span class="comment">//判断是否校验成功</span></span><br><span class="line">        <span class="keyword">return</span> set.contains(value);<span class="comment">//判断被修饰的属性的值在不在给定的数据中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后我们应该<strong>关联自定义的校验器和自定义的校验注解</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.valid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.TYPE_USE;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 20:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span><span class="comment">//与生成java文档相关，被这个元注解修饰的注解可以被很好地显示在文档中</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123;ListValueConstraintValidator.class&#125;)</span><span class="comment">//该校验注解使用哪些校验器进行校验，可以绑定多个校验器以适配不同的场景</span></span><br><span class="line"><span class="meta">@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span><span class="comment">//该注解可以标识在哪些位置</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span><span class="comment">//让该注解在运行时能被获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListValue &#123;<span class="comment">//用来校验数据是否是指定的数据集中的数据</span></span><br><span class="line">    <span class="comment">//注解的属性就是在写注解的时候可以在小括号中指定的那些属性</span></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;com.konjacer.mallisland.common.valid.ListValue.message&#125;&quot;</span>;<span class="comment">//错误信息去哪取，默认是从classpath下的ValidationMessages.properties配置文件中取，我们可以自己写一个这样的配置文件放在classpath下，让它从我们自己的配置文件中取对应的值</span></span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//分组数据校验功能，若指定了分组，则该注解只对指定分组的数据校验生效</span></span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//和负载相关</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] vals() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//指定校验数据可以是哪些数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="NotBlank、-NotNull、-NotEmpty、-NonNull四者之间的区别"><a href="#NotBlank、-NotNull、-NotEmpty、-NonNull四者之间的区别" class="headerlink" title="@NotBlank、@NotNull、@NotEmpty、@NonNull四者之间的区别"></a>@NotBlank、@NotNull、@NotEmpty、@NonNull四者之间的区别</h3><p>1.@NotNull：<strong>一般用在基本类型上</strong>，不能为null，但可以为空字符串</p><p>2.@NotEmpty：<strong>一般用在集合类上</strong>，不能为null，并且长度必须大于0</p><p>3.@NotBlank：<strong>只能作用在String上</strong>，不能为null，而且调用trim()后（去掉头尾空格），长度必须大于0</p><p>4.@NonNull：<strong>在方法或构造函数的参数上使用，</strong>生成一个空值检查语句</p><h3 id="Validated注解和-Valid注解的区别"><a href="#Validated注解和-Valid注解的区别" class="headerlink" title="@Validated注解和@Valid注解的区别"></a>@Validated注解和@Valid注解的区别</h3><h2 id="项目中的系统状态码使用规范"><a href="#项目中的系统状态码使用规范" class="headerlink" title="项目中的系统状态码使用规范"></a>项目中的系统状态码使用规范</h2><ul><li>状态码应该是一个<strong>5位的数字</strong></li><li>状态码的<strong>前两位表示业务场景或者对应的模块，最后三位表示状态类型</strong>，比如：01200可以定义为向01场景的请求成功。</li><li>应该<strong>将状态码定义为枚举类型</strong>，<strong>在封装统一返回类型的对象时，不要使用数字、字符串等的字面量，应该使用状态码枚举类中定义过的对象</strong>。</li></ul><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><ul><li><p>让各个方法来处理异常未免有点太过于繁琐，所以可以设置一个异常处理中心，<strong>所有的异常均由这个异常处理中心进行处理</strong>，实际上也是一个解耦的思想，将异常处理和具体业务方法解耦，在这个异常处理中心中可以<strong>写方法和具体的异常进行绑定，这样每当对应的异常被抛出，异常中心对应的方法就会将对应的异常处理掉</strong>。</p></li><li><p>除了设置相对精确的异常和方法的映射外，<strong>对于没有方法与之对应的异常，我们应该写一个方法对他们进行兜底处理</strong>，如果没有匹配到任何一个异常处理方法，那就使用兜底的方法。</p></li><li><p>结合上面写的数据校验的处理，我们认为<strong>将数据校验的处理放到controller中是非常繁琐的，所以我们可以考虑将其迁移到异常处理中心中做统一的处理</strong>，<strong>由于数据校验失败的时候会抛异常，所以我们只要针对对应的异常绑定对应的处理方法就行了</strong>，这样我们在controller中就可以只关注于处理业务请求，而无需分心在处理数据校验失败的情况了。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.mallisland.commonutils.Result;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.mallisland.commonutils.ResultCode;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindingResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ValidationException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 17:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &quot;com.konjacer.mallisland.product.controller&quot;)</span><span class="comment">//注册为异常处理中心并且返回的数据转换为json，参数配置的是异常处理中心生效范围</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallislandExceptionHandler</span> &#123;<span class="comment">//统一处理所有的异常</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span><span class="comment">//指定处理什么异常</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">VaildExceptionHandler</span><span class="params">(MethodArgumentNotValidException exception)</span>&#123;<span class="comment">//指定的异常被抛出时这个方法就会处理它</span></span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> exception.getBindingResult();<span class="comment">//获取参数校验结果</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取所有元素校验的错误结果</span></span><br><span class="line">        bindingResult.getFieldErrors().forEach(item-&gt;&#123;</span><br><span class="line">            <span class="comment">//获取到错误信息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> item.getDefaultMessage();</span><br><span class="line">            <span class="comment">//获取错误的属性的名字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> item.getField();</span><br><span class="line">            map.put(field,message);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> Result.error()</span><br><span class="line">                .code(ResultCode.VALID_ERROR.getCode())</span><br><span class="line">                .message(ResultCode.VALID_ERROR.getMessage())</span><br><span class="line">                .data(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Throwable.class)</span><span class="comment">//如过没有找到对应的异常处理方法就兜底处理</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">ExceptionHandler</span><span class="params">(Throwable throwable)</span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;错误：&quot;</span>,throwable);<span class="comment">//日志输出具体的异常信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.error()</span><br><span class="line">                .code(ResultCode.UNKNOW_ERROR.getCode())</span><br><span class="line">                .message(ResultCode.UNKNOW_ERROR.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置实体类字段自动填充后没有效果"><a href="#配置实体类字段自动填充后没有效果" class="headerlink" title="配置实体类字段自动填充后没有效果"></a>配置实体类字段自动填充后没有效果</h2><ul><li><p>自动填充的相关注解有：**<code>@TableField(fill = FieldFill.INSERT)</code>、<code>@TableField(fill = FieldFill.UPDATE)</code>、<code>@TableField(fill = FieldFill.INSERT_UPDATE)</code>、<code>@TableField(fill = FieldFill.DEFAULT)</code><strong>，他们分别代表：</strong>插入时填充、更新时填充、插入和更新时填充、默认不填充**。</p></li><li><p>除了写注解之外，还需要进行配置，<strong>需要新建一个实现MetaObjectHandler接口的类，然后在其中配置自动填充的规则，并将该类注册到IOC容器中</strong>，然后自动填充的注解才能生效。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-03 15:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;<span class="comment">//配置被插入时自动填充的注解修饰的属性自动填充的值</span></span><br><span class="line">        <span class="comment">//用属性名称而不是字段名称</span></span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;gmtCreate&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;gmtModified&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;isDeleted&quot;</span>,<span class="number">0</span>,metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;<span class="comment">//配置被更新时自动填充的注解修饰的属性自动填充的值</span></span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;gmtModified&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2023-x2F-1-x2F-5"><a href="#2023-x2F-1-x2F-5" class="headerlink" title="2023&#x2F;1&#x2F;5"></a>2023&#x2F;1&#x2F;5</h1><h2 id="SPU和SKU"><a href="#SPU和SKU" class="headerlink" title="SPU和SKU"></a>SPU和SKU</h2><h3 id="SPU（Standard-Product-Unit-标准化产品单元）"><a href="#SPU（Standard-Product-Unit-标准化产品单元）" class="headerlink" title="SPU（Standard Product Unit 标准化产品单元）"></a>SPU（Standard Product Unit 标准化产品单元）</h3><ul><li>是商品信息聚合的最小单位，是一组可复用、易于检索的标准化信息的集合，该集合描述了一个产品的特性。</li><li>比如红米Note9 pro 1亿像素摄像头 钛合金外壳 产自于中国…这些信息就是SPU，是一个产品的<strong>基本属性（规格参数）</strong>，因为任何一个红米Note9 pro手机都拥有以上特性，我们用这些信息聚合成了一个产品。</li><li>可以通过SPU的属性值来对具体产品进行搜索。</li></ul><h3 id="SKU（Stock-Keeping-Unit-最小库存单元）"><a href="#SKU（Stock-Keeping-Unit-最小库存单元）" class="headerlink" title="SKU（Stock Keeping Unit 最小库存单元）"></a>SKU（Stock Keeping Unit 最小库存单元）</h3><ul><li>上面SPU还有一些没有提到的特性，比如手机的颜色、内存等，这些属性都不是产品固定的，而是可以选择的，也叫<strong>销售属性</strong>，比如我可以选择内存是8g，颜色是蓝色，这些属性一旦被具体确定下来，那么这个具体的产品就是一个SKU，可以直接通过这些属性的值定位到库存中的具体存货。</li></ul><h2 id="JsonInclude注解"><a href="#JsonInclude注解" class="headerlink" title="@JsonInclude注解"></a>@JsonInclude注解</h2><ul><li>可以用在实体类的属性上，来标识这个实体类属性在什么条件下才可以被转换为json数据，比如**<code>@JsonInclude(JsonInclude.Include.NON_EMPTY)</code><strong>就标识</strong>当被其修饰的属性不为空的时候，那个属性才会被转换成json数据的一部分，如果为空，那么最后返回的json数据中就不包含这个字段**。</li><li>还有其他参数，可以看源码。</li></ul><h1 id="2023-x2F-1-x2F-6"><a href="#2023-x2F-1-x2F-6" class="headerlink" title="2023&#x2F;1&#x2F;6"></a>2023&#x2F;1&#x2F;6</h1><h2 id="EnableTransactionManagement"><a href="#EnableTransactionManagement" class="headerlink" title="@EnableTransactionManagement"></a>@EnableTransactionManagement</h2><ul><li>可以在配置类中写上这个注解，表示<strong>开启事务功能</strong>，<strong>之后可以通过在访问数据库的方法上添加<code>@Transactional</code>注解来标识该方法是事务方法，可以对里面操作数据库的部分新建一个事务来进行处理</strong>。</li><li>如果只添加@Transactional注解无法生效，需要用@EnableTransactionManagement注解开启事务功能才能生效。</li><li>大部分功能都是需要先用注解开启，然后使用相应注解才生效的。</li></ul><h2 id="数据库表的冗余存储"><a href="#数据库表的冗余存储" class="headerlink" title="数据库表的冗余存储"></a>数据库表的冗余存储</h2><ul><li>在进行数据存储的时候，<strong>为了避免多次单表查询带来的性能问题，我们可以将一些常用字段冗余存储到某一张表中，但是这样做必须保证增删改的时候，要保证数据的一致性</strong>，不能表里的数据都删了，冗余字段还有那个被删的数据，这样是不对的，所以对关联表进行增删改的时候要注意将数据同步到别的表的冗余字段中。</li></ul><h2 id="不要使用多表联查"><a href="#不要使用多表联查" class="headerlink" title="不要使用多表联查"></a>不要使用多表联查</h2><ul><li>使用笛卡尔积的多表联查对于效率来说是毁灭性打击。</li></ul><h2 id="target目录下没有mapper的xml文件"><a href="#target目录下没有mapper的xml文件" class="headerlink" title="target目录下没有mapper的xml文件"></a>target目录下没有mapper的xml文件</h2><ul><li><p>这个问题我找了好几个小时才解决，解决的过程中我对服务的运行又有了新的认识。</p></li><li><p>问题出现在我在启动服务之后测试自己写的sql语句，在调用mapper的时候它报错，大意就是没有找到和mapper绑定的xml文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.ibatis.binding.BindingException: Invalid bound statement (not found) ......</span><br></pre></td></tr></table></figure></li><li><p>然后因为项目运行的时候，环境实际上是和开发环境的目录不一样嘛，<strong>服务运行的时候是用的target输出目录下的目录结构</strong>，然后我就去target下找，找到mapper目录后一看，xml文件一个都没导入进来，那运行的时候找不到xml文件也就不难理解了。</p></li><li><p>我这开发时目录结构好像和主流的方案不太一样，我这个mapper的xml文件没有放到resources目录下，我这用代码生成器生成的，xml文件全在mapper目录下放着，如果要是xml文件在resouces目录下，根据maven的默认build策略，这些xml文件应该会被build在运行时环境的classes目录下（我也不确定，之后验证一下回来改）。但是我这xml文件在java路径下放着，<strong>根据maven的默认build策略，maven只会把java路径下的所有java文件给build，别的文件不会被build，所以xml文件全没被build</strong>。</p></li><li><p>那么怎么样才能让xml文件被build呢？主要是<strong>需要在服务对应的pom文件中的build标签中写明在build的时候需要额外添加一些什么文件，maven在build项目的时候默认只会把java目录下的java文件给build，所以我们应该显式告诉它java目录下的xml文件也需要被build</strong>，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果不配置resource，mapper.xml文件不会被加载到target，就会报找不到的错误。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置打包规则，告诉maven在java目录下还要额外build什么文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果有了上面的配置，原本默认的将resource中的文件打包操作就会被覆盖掉，所以需要手动指定--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--打包规则，打包时将resource文件夹下的配置文件排除，注意只有打包的时候使用，平时要注释掉--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- &lt;excludes&gt;--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--      &lt;exclude&gt;**/*.properties&lt;/exclude&gt;--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--      &lt;exclude&gt;**/*.yml&lt;/exclude&gt;--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--      &lt;exclude&gt;**/*.yaml&lt;/exclude&gt;--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- &lt;/excludes&gt;--&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>这样xml文件就被build到classes文件中了，位置和开发时的位置相同，但是，重新启动服务之后，测试接口，发现还是有问题，还是报同样的错误，所以我推断<strong>可能是mybatis-plus找xml文件位置的默认配置的问题，mp默认配置找xml文件的目录是<code>classpath*:/mapper/**/*.xml</code>，这意味着它会找所有包的classes目录下的mapper目录下的所有子目录下的xml文件，但是我这些xml文件不在这个路径下，所以应该将其改成<code>classpath:/**/mapper/**/*.xml</code>，因为mapper目录不直接在classes根目录下，所以classes目录和mapper目录之间应该用<code>**</code>来表示</strong>，改完之后就能正常运行了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置mybatis-plus的mapper的xml文件的位置，默认是classpath*:/mapper/**/*.xml，classpath后面的*代表除了自己的classpath，引入的jar包的classpath也会被检索</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/**/mapper/**/*.xml</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="java-Object的划分"><a href="#java-Object的划分" class="headerlink" title="java Object的划分"></a>java Object的划分</h2><h3 id="PO（persistent-object）持久对象"><a href="#PO（persistent-object）持久对象" class="headerlink" title="PO（persistent object）持久对象"></a>PO（persistent object）持久对象</h3><ul><li>PO就是<strong>对应数据库中某个表中的一条记录，多个记录可以用PO的集合</strong>，PO中应该不包含任何对数据库的操作。</li></ul><h3 id="DO（Domain-Object）领域对象"><a href="#DO（Domain-Object）领域对象" class="headerlink" title="DO（Domain Object）领域对象"></a>DO（Domain Object）领域对象</h3><ul><li>就是<strong>从现实世界中抽象出来的有形或者无形的业务实体</strong>。</li></ul><h3 id="TO（Transfer-Object）数据传输对象"><a href="#TO（Transfer-Object）数据传输对象" class="headerlink" title="TO（Transfer Object）数据传输对象"></a>TO（Transfer Object）数据传输对象</h3><ul><li><strong>不同的应用程序之间传输的对象</strong></li></ul><h3 id="DTO（Data-Transfer-Object）数据传输对象"><a href="#DTO（Data-Transfer-Object）数据传输对象" class="headerlink" title="DTO（Data Transfer Object）数据传输对象"></a>DTO（Data Transfer Object）数据传输对象</h3><ul><li>这个概念来源于J2EE的设计模式，原来的目的是为了EJB 的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，<strong>泛指用于展示层与服务层之间的数据传输的对象</strong>。</li></ul><h3 id="VO（Value-Object-x2F-View-Object）值对象-x2F-视图对象"><a href="#VO（Value-Object-x2F-View-Object）值对象-x2F-视图对象" class="headerlink" title="VO（Value  Object&#x2F;View Object）值对象&#x2F;视图对象"></a>VO（Value  Object&#x2F;View Object）值对象&#x2F;视图对象</h3><ul><li>通常用于业务层之间的数据传递，和 PO一样也是仅仅包含数据而已。但应是<strong>抽象出的业务对象，可以和表对应，也可以不</strong>，这根据业务的需要。用new关键字创建，由GC回收的。</li><li>或者叫View Object视图对象，vo的结构由具体的业务视图决定。</li><li>接收页面传递来的数据，封装成对象；将业务处理完成的对象，封装成页面要用的数据，都是VO。</li></ul><h3 id="BO（business-object）业务对象"><a href="#BO（business-object）业务对象" class="headerlink" title="BO（business object）业务对象"></a>BO（business object）业务对象</h3><ul><li>从业务模型的角度看，见 UML元件领域模型中的领域对象。封装业务逻辑的java对象，通过调用DAO方法，结合PO,VO进行业务操作。business object:业务对象，主要作用是<strong>把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象</strong>。比如一个简历，有教育经历、工作经历、社会关系等等。我们可以把教育经历对应一个 PO，工作经历对应一个PO，社会关系对应一个 PO。建立一个对应简历的 BO对象处理简历，每个BO包含这些PO。这样处理业务逻辑时，我们就可以针对BO去处理。</li></ul><h3 id="POJO（plain-ordinary-java-object）简单无规则java对象"><a href="#POJO（plain-ordinary-java-object）简单无规则java对象" class="headerlink" title="POJO（plain ordinary java object）简单无规则java对象"></a>POJO（plain ordinary java object）简单无规则java对象</h3><ul><li>传统意义的 java对象。就是说在一些Object&#x2F;Relation Mapping工具中，能够做到维护数据库表记录的 PO完全是一个符合Java Bean规范的纯 Java对象，没有增加别的属性和方法。我的理解就是最基本的 java Bean ，只有属性字段及setter和 getter方法。</li><li>POJO是 DO&#x2F;DTO&#x2F;BO&#x2F;VO 的统称。</li></ul><h3 id="DAO（data-access-object）数据访问对象"><a href="#DAO（data-access-object）数据访问对象" class="headerlink" title="DAO（data access object）数据访问对象"></a>DAO（data access object）数据访问对象</h3><ul><li>是一个 sun 的一个标准 J2EE设计模式，这个模式中有个接口就是DAO，它负责持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和PO 结合使用，DAO中包含了各种数据库的操作方法。通过它的方法，结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO，提供数据库的CRUD 操作。</li></ul><h2 id="复制VO的数据到Entity"><a href="#复制VO的数据到Entity" class="headerlink" title="复制VO的数据到Entity"></a>复制VO的数据到Entity</h2><ul><li>可以<strong>使用spring包中的BeanUtils工具类的copyProperties方法，可以将VO中的元素赋值给Entity，不过要注意，只有具有相同名称的属性才会被赋值，名字不相同或者不存在的属性都不会被赋值</strong>。</li></ul><h1 id="2023-x2F-1-x2F-7"><a href="#2023-x2F-1-x2F-7" class="headerlink" title="2023&#x2F;1&#x2F;7"></a>2023&#x2F;1&#x2F;7</h1><h2 id="使用符合场景的wrapper"><a href="#使用符合场景的wrapper" class="headerlink" title="使用符合场景的wrapper"></a>使用符合场景的wrapper</h2><ul><li>查询的时候用QueryWrapper，更新的时候用UpdateWrapper。</li></ul><h2 id="使用-RequestParam接收query参数"><a href="#使用-RequestParam接收query参数" class="headerlink" title="使用@RequestParam接收query参数"></a>使用@RequestParam接收query参数</h2><ul><li><p>可以指定或不指定value参数来接收单个对应的query参数，如果指定value，则将和value名称相同的query参数的值赋值给注解修饰的属性，如果不指定value，则将和被修饰的变量名称相同的query参数的值赋值给被修饰的属性。也可以指定require的值，如果为true说明这个属性不能接收不到参数，如果为false，说明这个属性允许接收不到参数，默认为true：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestParam(value = &quot;page&quot;,required = false)</span> Long current</span><br></pre></td></tr></table></figure></li><li><p>也可以直接修饰一个Map&lt;String,String&gt;类型的属性params，query参数会全部放到那里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestParam</span> Map&lt;String,String&gt; params</span><br></pre></td></tr></table></figure></li></ul><h2 id="Mapper中的selectCount方法"><a href="#Mapper中的selectCount方法" class="headerlink" title="Mapper中的selectCount方法"></a>Mapper中的selectCount方法</h2><ul><li>根据wrapper中的条件，统计符合条件的记录数量。</li></ul><h2 id="批量删除的动态sql"><a href="#批量删除的动态sql" class="headerlink" title="批量删除的动态sql"></a>批量删除的动态sql</h2><ul><li><p>可以用动态sql，遍历所有想要删除的数据的条件拼接在where后面，找到所有符合条件的数据一起删除：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;deleteBatchRelation&quot;</span>&gt;</span></span><br><span class="line">    UPDATE `pms_attr_attrgroup_relation` SET is_deleted=1 WHERE</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;entities&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">separator</span>=<span class="string">&quot; OR &quot;</span>&gt;</span></span><br><span class="line">        (attr_id=#&#123;item.attrId&#125; AND attr_group_id=#&#123;item.attrGroupId&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="每一层结构做了什么事"><a href="#每一层结构做了什么事" class="headerlink" title="每一层结构做了什么事"></a>每一层结构做了什么事</h2><ul><li>Controller用来处理请求，接收和校验数据</li><li>Service接收Controller传来的数据，进行业务逻辑的处理</li><li>Controller接收Service处理完的数据，封装与页面进行交互的VO</li></ul><h1 id="2023-x2F-1-x2F-8"><a href="#2023-x2F-1-x2F-8" class="headerlink" title="2023&#x2F;1&#x2F;8"></a>2023&#x2F;1&#x2F;8</h1><h2 id="基于OpenFeign的远程调用"><a href="#基于OpenFeign的远程调用" class="headerlink" title="基于OpenFeign的远程调用"></a>基于OpenFeign的远程调用</h2><ul><li><p>首先要使用Feign的远程调用功能要先<strong>在配置类中使用注解<code>@EnableFeignClients</code>开启这个功能，并指定远程调用接口的所在包目录，这一个注解的本质实际上是把指定位置的所有被@FeignClient注解修饰的bean注册到ioc容器中</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.konjacer.mallisland.product.feign&quot;)</span></span><br></pre></td></tr></table></figure></li><li><p>然后<strong>在对应的目录下创建接口，用对应的注解<code>@FeignClient</code>修饰这个接口，注解中的参数是被远程调用的服务在服务注册中心的服务名</strong>，这个远程调用可以过网关也可以不过网关，注意修改下面的uri就行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;mallisland-coupon&quot;)</span><span class="comment">//这是个声明式远程调用客户端，里面的方法远程调用了别的模块的方法，注解里面要指明想要调用的服务在服务注册中心里的名称</span></span><br></pre></td></tr></table></figure></li><li><p>然后<strong>在新建的接口中写远程调用的方法，用注解告知方法远程调用的路径，方法签名尽量和要调用的方法的签名相同</strong>，不过理论上<strong>在参数上用了<code>@RequestBody</code>注解的话，TO就会被转为json放到请求体中然后发送给远程服务，别的注解的效果类推</strong>，所以如果能保证接收方能接收发送方的json数据，那就没啥问题，不过方法签名还是尽量相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/coupon/sms-coupon/memberGetCoupons&quot;)</span><span class="comment">//地址要写全，就是通过这个地址来进行远程调用</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">memberGetCoupons</span><span class="params">(<span class="meta">@RequestBody</span> SpuBoundTo spuBoundTo)</span>;</span><br></pre></td></tr></table></figure></li><li><p>然后就可以<strong>在想用的地方注入对应的远程调用接口，然后通过注入的bean调用相应的方法来实现远程调用，不过一定要保证被调用的方法在服务注册中心中能找到</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">CouponFeignService couponFeignService;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SpuBoundTo</span> <span class="variable">spuBoundTo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpuBoundTo</span>();</span><br><span class="line">    couponFeignService.memberGetCoupons(spuBoundTo);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="在IDEA中同时启动多个服务"><a href="#在IDEA中同时启动多个服务" class="headerlink" title="在IDEA中同时启动多个服务"></a>在IDEA中同时启动多个服务</h2><ul><li><p>首先点击Edit Configurations：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230108173107813.png" alt="image-20230108173107813"></p></li><li><p>然后新建一个Compound：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230108173201032.png" alt="image-20230108173201032"></p></li><li><p>在新建的Compound中添加想要一起启动的服务，并且可以对他们的启动做自定义的配置：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230108173439649.png" alt="image-20230108173439649"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230108173502497.png" alt="image-20230108173502497"></p></li><li><p>之后启动对应的Compound就能同时启动多个服务了：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230108173552108.png" alt="image-20230108173552108"></p></li></ul><h2 id="配置json数据中日期数据的格式"><a href="#配置json数据中日期数据的格式" class="headerlink" title="配置json数据中日期数据的格式"></a>配置json数据中日期数据的格式</h2><ul><li><p>可以在springboot的配置文件中做以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#配置json数据中日期数据的格式</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="配置日志等级"><a href="#配置日志等级" class="headerlink" title="配置日志等级"></a>配置日志等级</h2><ul><li><p>可以在springboot的配置文件中做以下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#设置指定包下的日志级别</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    com.konjacer: info</span><br></pre></td></tr></table></figure></li></ul><h1 id="2023-x2F-1-x2F-10"><a href="#2023-x2F-1-x2F-10" class="headerlink" title="2023&#x2F;1&#x2F;10"></a>2023&#x2F;1&#x2F;10</h1><h2 id="linux中在命令上下载网络内容"><a href="#linux中在命令上下载网络内容" class="headerlink" title="linux中在命令上下载网络内容"></a>linux中在命令上下载网络内容</h2><ul><li>可以使用wget工具来进行下载，但是在使用wget之前需要使用**<code>sudo yum install wget</code>**安装wget</li><li>安装完之后通过**<code>wget &lt;url&gt;</code>**命令来从指定的url中下载文件</li></ul><h2 id="linux修改目录的权限"><a href="#linux修改目录的权限" class="headerlink" title="linux修改目录的权限"></a>linux修改目录的权限</h2><ul><li>可以使用**<code>sudo chmod -R 777 目录路径</code><strong>来将一个目录以及其中的所有子目录的文件改成最高权限777，</strong>-R是recursion递归的意思**，意思就是会递归地设置权限。</li></ul><h2 id="linux解压文件"><a href="#linux解压文件" class="headerlink" title="linux解压文件"></a>linux解压文件</h2><ul><li>可以使用unzip工具，没有可以用yum命令**<code>sudo yum install unzip</code>**下载一个。</li><li>通过**<code>unzip -d 目标目录 文件名</code>**命令来将指定文件解压到指定目录下。</li></ul><h1 id="2023-x2F-1-x2F-11"><a href="#2023-x2F-1-x2F-11" class="headerlink" title="2023&#x2F;1&#x2F;11"></a>2023&#x2F;1&#x2F;11</h1><h2 id="为什么有些包导入后里面的某些包和预期的不太一样"><a href="#为什么有些包导入后里面的某些包和预期的不太一样" class="headerlink" title="为什么有些包导入后里面的某些包和预期的不太一样"></a>为什么有些包导入后里面的某些包和预期的不太一样</h2><ul><li><p>可能是springboot项目的pom文件中对这些包有版本管理，导致这个版本传递到了后来的那些包中，要想修改，只需要<strong>先找到springboot的pom文件</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230111164504024.png" alt="image-20230111164504024"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230111164523772.png" alt="image-20230111164523772"></p></li><li><p>在springboot的pom文件中找到对应的那个包后<strong>将那个包的版本控制变量在当前项目的pom文件中进行重写即可</strong>。</p></li></ul><h2 id="ES中的nested类型"><a href="#ES中的nested类型" class="headerlink" title="ES中的nested类型"></a>ES中的nested类型</h2><ul><li>官方释义：这个nested类型是object一种数据类型，<strong>允许对象数组以相互独立的方式进行索引</strong></li><li>在设置一个索引（index）的映射（mapping）的时候，如果不将type设置成nested，那么这个属性在存放有结构的数据比如某种对象的时候，es在底层就会对这个对象进行扁平化处理，对象中相同的属性值会被一同放入到一个数组中进行维护，而查的时候也是基于那个维护的数组，这样做会产生很多问题。</li><li>所以为了防止有结构的属性被扁平化处理，在做映射的时候应该把存放非基本数据类型的数据的属性的type设置成nested。</li><li>在查询nested类型的数据的时候也不能和普通数据一样查询，要显示声明我要查的是nested类型的数据，详见官方文档。</li></ul><h2 id="ES的倒排索引"><a href="#ES的倒排索引" class="headerlink" title="ES的倒排索引"></a>ES的倒排索引</h2><ul><li>就是对一堆文本进行分词处理（把文本划分成词），然后记录每个分词在哪个文本中出现过，这样找的时候就能利用关键词来找到关键词出现过的文本了。（&#x2F;&#x2F;todo 至于分词怎么存。。。字典树？我暂时不清楚，之后清楚了再来改）</li></ul><h2 id="ES存储数据的结构"><a href="#ES存储数据的结构" class="headerlink" title="ES存储数据的结构"></a>ES存储数据的结构</h2><ul><li>最大的一层叫index也就是索引，再小一层叫type也就是类型（已经弃用，最好不要再用），再小一层叫doc也就是文档，每个文档就相当于mysql中的一个数据库中的一个表的一个记录，文档中还有各种各样的属性。</li></ul><h2 id="ES设置-x2F-修改索引的映射"><a href="#ES设置-x2F-修改索引的映射" class="headerlink" title="ES设置&#x2F;修改索引的映射"></a>ES设置&#x2F;修改索引的映射</h2><p>- </p><ul><li>索引的映射理论上来讲设置了之后是不能变的，所以如果想要修改索引的映射，方法就是重新创建一个索引，然后在新索引中设置想要的映射，然后做数据迁移，把之前索引的数据迁移到新索引中。</li></ul><h2 id="ES查询数据"><a href="#ES查询数据" class="headerlink" title="ES查询数据"></a>ES查询数据</h2><ul><li>通过DSL（结构化查询）语句来进行查询，es帮我们把功能都暴露成rest风格的接口了，所以如果我们想要查询ES中的数据，那么我们只需要写一个json格式的DSL来表明我们的需求，然后给ES服务发送相应的请求，那么ES就会回复给我们想要的数据。</li><li>具体DSL语句的写法可以参照官方文档。</li><li>一个复杂的DSL中可能同时存在：模糊匹配、过滤、排序、分页、高亮显示、聚合分析等要求，所以在学习的时候可以对准这几个部分来进行学习。</li></ul><h2 id="ES聚合分析"><a href="#ES聚合分析" class="headerlink" title="ES聚合分析"></a>ES聚合分析</h2><ul><li>对于聚合分析，实际上就是根据聚合条件来将查询到的数据进行逻辑分组，因为是逻辑分组，所以不同聚合之间肯定是可以有重复数据，聚合之中可以有子聚合，子聚合用的数据是父聚合的结果，要类比的话，就像mysql中的group by。</li></ul><h1 id="2023-x2F-1-x2F-12"><a href="#2023-x2F-1-x2F-12" class="headerlink" title="2023&#x2F;1&#x2F;12"></a>2023&#x2F;1&#x2F;12</h1><h2 id="统一返回类使用泛型处理的好处"><a href="#统一返回类使用泛型处理的好处" class="headerlink" title="统一返回类使用泛型处理的好处"></a>统一返回类使用泛型处理的好处</h2><ul><li>首先就是<strong>有更好的可读性</strong>，可以使开发人员一眼就能看出这个统一返回类中存放的是什么类型的数据。</li><li>再者就是<strong>方便数据的提取</strong>，如果要是统一返回类作为远程调用接口的返回值，那么我们拿到远程调用的结果后想要从统一返回类中将数据提取出来，如果不用泛型，那么为了提取其中的数据我们会进行一系列的显式类型转换操作，还有可能去判断类型的正确性，使用了泛型之后，这种的问题将不复存在，因为编译器自动帮你把这些活儿干了，如果我们将错误的数据放进去，编译都过不了，api的客户端拿到数据之后开箱即用，无需更多操作，提升了开发效率。</li></ul><h2 id="lambda表达式和stream流式编程中使用的外部变量必须为final"><a href="#lambda表达式和stream流式编程中使用的外部变量必须为final" class="headerlink" title="lambda表达式和stream流式编程中使用的外部变量必须为final"></a>lambda表达式和stream流式编程中使用的外部变量必须为final</h2><ul><li>经常会出现类似这样的错误：<code>Variable used in lambda expression should be final or effectively final</code>，这主要是因为在lambda表达式或者stream流式编程中使用了外部非final的变量，为什么会有这种规定呢？</li><li>这个具体原因我也不太清楚，不过大体上好像是为了保护数据的一致性而规定的。</li><li>所以以后在lambda表达式和stream流式编程中使用非final的外部变量的时候，要先在外面声明一个final的副本，然后在lambda表达式或stream流式编程中使用那个副本就可以了。</li></ul><h1 id="2023-x2F-1-x2F-13"><a href="#2023-x2F-1-x2F-13" class="headerlink" title="2023&#x2F;1&#x2F;13"></a>2023&#x2F;1&#x2F;13</h1><h2 id="SpringBoot整合ElasticSearch"><a href="#SpringBoot整合ElasticSearch" class="headerlink" title="SpringBoot整合ElasticSearch"></a>SpringBoot整合ElasticSearch</h2><ul><li><p>首先要引入依赖，依赖版本要和es的版本一致，如果出现写的版本一致，但是实际上引入的es版本不一致的情况，可以参照2023&#x2F;1&#x2F;11的”为什么有些包导入后里面的某些包和预期的不太一样“来在本地pom重写springboot的pom的properties中的对应包的version属性来解决：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">elasticsearch-rest-high-level-client.version</span>&gt;</span>7.4.2<span class="tag">&lt;/<span class="name">elasticsearch-rest-high-level-client.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--操作elasticsearch的java client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;elasticsearch-rest-high-level-client.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后在配置类中进行相关的配置，主要是<strong>构造Bean交给Spring和构造一个通用的设置项</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallislandElasticSearchConfig</span> &#123;<span class="comment">//elasticsearch的配置类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestOptions COMMON_OPTIONS;<span class="comment">//elasticsearch通用的设置项</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        RequestOptions.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> RequestOptions.DEFAULT.toBuilder();<span class="comment">//使用默认规则</span></span><br><span class="line"><span class="comment">//        builder.addHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + TOKEN);</span></span><br><span class="line"><span class="comment">//        builder.setHttpAsyncResponseConsumerFactory(</span></span><br><span class="line"><span class="comment">//                new HttpAsyncResponseConsumerFactory</span></span><br><span class="line"><span class="comment">//                        .HeapBufferedResponseConsumerFactory(30 * 1024 * 1024 * 1024));</span></span><br><span class="line">        COMMON_OPTIONS = builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">esRestClient</span><span class="params">()</span>&#123;<span class="comment">//创建Bean交给Spring</span></span><br><span class="line">        <span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;101.42.35.83&quot;</span>,<span class="number">9200</span>,<span class="string">&quot;http&quot;</span>)<span class="comment">//es的地址</span></span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后注入Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;<span class="comment">//用来操作es</span></span><br></pre></td></tr></table></figure></li><li><p>以一个批量保存为例，展示基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">productStatusUp</span><span class="params">(List&lt;SkuEsModel&gt; skuEsModels)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//给es中建立索引product,建立好映射关系</span></span><br><span class="line">    <span class="comment">//给es中保存这些数据</span></span><br><span class="line">    <span class="type">BulkRequest</span> <span class="variable">bulkRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">    skuEsModels.forEach(model-&gt;&#123;</span><br><span class="line">        <span class="comment">//构造保存请求并加入bulk请求中</span></span><br><span class="line">        <span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(EsConstant.IndexName.PRODUCT.getName());</span><br><span class="line">        indexRequest.id(model.getSkuId());<span class="comment">//设置id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> JSON.toJSONString(model);<span class="comment">//实体转json</span></span><br><span class="line">        indexRequest.source(source, XContentType.JSON);<span class="comment">//设置内容为json数据，记得设置内容类型（第二个参数）</span></span><br><span class="line">        bulkRequest.add(indexRequest);<span class="comment">//加入bulk批量操作中</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">BulkResponse</span> <span class="variable">bulkResponse</span> <span class="operator">=</span> restHighLevelClient.bulk(bulkRequest, MallislandElasticSearchConfig.COMMON_OPTIONS);<span class="comment">//bulk方法批量操作，记得第二个参数写配置在配置类中的通用设置</span></span><br><span class="line">    <span class="comment">//如果批量操作错误则处理错误</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> bulkResponse.hasFailures();<span class="comment">//是否有错误</span></span><br><span class="line">    List&lt;String&gt; collect = Arrays.stream(bulkResponse.getItems()).map(item-&gt; item.getId()).collect(Collectors.toList());</span><br><span class="line">    log.error(<span class="string">&quot;商品上架错误，上架错误的商品编号分别为：&#123;&#125;&quot;</span>,collect);</span><br><span class="line">    <span class="keyword">return</span> !b;<span class="comment">//取反返回更符合正常逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Feign的调用流程"><a href="#Feign的调用流程" class="headerlink" title="Feign的调用流程"></a>Feign的调用流程</h2><ol><li><p>构造请求数据，将对象转为json数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RequestTemplate</span> <span class="variable">template</span> <span class="operator">=</span> buildTemplateFromArgs.create(argv);</span><br></pre></td></tr></table></figure></li><li><p>发送请求进行执行，执行成功后会解码响应数据:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executeAndDecode(template);</span><br></pre></td></tr></table></figure></li><li><p>执行请求会有重试机制，在执行之前会new一个重试器，通过重试器的重试策略来决定是否重试，伪代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">   executeAndDecode(tempLate);</span><br><span class="line">       &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">               retryer.continueOrPropagate(e);</span><br><span class="line">           &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">               <span class="keyword">throw</span> ex;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">## 一个没有进行前后端分离的架构</span><br><span class="line"></span><br><span class="line">- 静态资源扔到nginx中，然后视图用模板引擎（模板引擎，这里特指用于Web开发的模板引擎，是**为了使用户界面与业务数据/内容分离而产生的**，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的文档。模板引擎的**基本机理就是替换/转换，将指定的标签转换为需要的业务数据，将指定的伪语句按照某种流程来变换输出**。）写好，**所有的静态资源去nginx中取**：</span><br><span class="line"></span><br><span class="line">  ![image-<span class="number">20230113193900265</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230113193900265.png)</span></span><br><span class="line"></span><br><span class="line">## 引入Thymeleaf模板引擎</span><br><span class="line"></span><br><span class="line">- 首先要引入依赖，版本最好和boot的版本一致：</span><br><span class="line"></span><br><span class="line">  ```xml</span><br><span class="line">  &lt;spring-boot-starter-thymeleaf.version&gt;<span class="number">2.3</span><span class="number">.4</span>.RELEASE&lt;/spring-boot-starter-thymeleaf.version&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!--thymeleaf模板引擎--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring-boot-starter-thymeleaf.version&#125;&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>在配置文件中关闭thymeleaf的缓存以在开发阶段保证其可见性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="comment">#关闭thymeleaf的缓存以在开发期间看到实时效果</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>SpringMVC的自动配置类WebMvcAutoConfiguration中默认约定静态资源都放在classpath的static&#x2F;public&#x2F;resources&#x2F;templates下，可以直接被访问到。</p></li><li><p>thymeleaf默认约定当controller方法返回string的时候，视图解析器会进行拼串处理，会定位资源到prefix+返回值+suffix，默认的prefix是“classpath:&#x2F;templates&#x2F;”，默认的suffix是“.html”，页面资源默认从templates中取。</p></li><li><p>为了保证项目结构的清晰，我们也约定，页面文件都放在templates下，然后页面用到的静态资源放到static下。</p></li><li><p>springboot约定，在访问项目的时候，如果有，会默认先找index.html页面来进行显示。</p></li><li><p>在开发时如果想要不重启服务器而实时更新页面，可以引入dev-tools使用热部署功能，修改完thymeleaf的页面后直接ctrl+shift+f9重新编译页面即可，如果是其他比如对配置的修改，还是手动重启下吧！不过开发后端的时候不建议开dev-tools，因为频繁的自动重启会使得开发效率低下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="2023-x2F-1-x2F-14"><a href="#2023-x2F-1-x2F-14" class="headerlink" title="2023&#x2F;1&#x2F;14"></a>2023&#x2F;1&#x2F;14</h1><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><ul><li><p><strong>正向代理服务器帮客户端去访问客户端想要访问的服务器，在收到结果之后再返回给客户端，也就是说正向代理服务器是在偏客户端这一边的</strong>。比如我想访问谷歌，但是我没办法直接访问到谷歌，所以我可以租一个正向代理服务器，每次我访问谷歌，我都会给那个正向代理服务器发送请求让那个正向代理服务器帮我去访问谷歌：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230114191838794.png" alt="image-20230114191838794"></p></li><li><p><strong>反向代理帮服务器接收客户端的请求，再把请求转发给对应的服务器，也就是反向代理服务器是在偏服务器这一边的</strong>。比如我要访问一个域名，这个域名可能是服务端的反向代理服务器的地址，是个公网ip，这样我就先访问到了服务端的反向代理服务器，然后反向代理服务器再帮我把我的请求转发给我真正想要访问的内网服务器，主打一个<strong>屏蔽内网服务器的信息和负载均衡地访问</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230114192302868.png" alt="image-20230114192302868"></p></li></ul><h2 id="nginx配置文件结构"><a href="#nginx配置文件结构" class="headerlink" title="nginx配置文件结构"></a>nginx配置文件结构</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230114200634788.png" alt="image-20230114200634788"></p><ul><li><p>查看nginx.conf文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到里面是没有server块的，这是因为其中使用到了include语句，server块在被include的文件中。</p></li><li><p>找到conf.d&#x2F;default.conf，也可以写别的扩展名为conf的文件，从上面的include语句中也能看出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  /var/log/nginx/log/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    proxy_pass   http://127.0.0.1;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    root           html;</span><br><span class="line">    #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    #    fastcgi_index  index.php;</span><br><span class="line">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">    #    include        fastcgi_params;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line">    # concurs with nginx&#x27;s one</span><br><span class="line">    #</span><br><span class="line">    #location ~ /\.ht &#123;</span><br><span class="line">    #    deny  all;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>server块中的server_name参数是干什么用的？每当我们从浏览器输入ip或者域名访问一个服务器的时候，http的请求报文中会携带一个host字段，这个字段就是记录着我们输入的ip或域名，而server_name会对请求报文中的host字段进行匹配，如果匹配成功，则会执行我们在下面指定的操作。</p></li></ul><h2 id="如何解决nginx转发的时候会丢掉原本请求报文的一些字段"><a href="#如何解决nginx转发的时候会丢掉原本请求报文的一些字段" class="headerlink" title="如何解决nginx转发的时候会丢掉原本请求报文的一些字段"></a>如何解决nginx转发的时候会丢掉原本请求报文的一些字段</h2><ul><li>nginx在对请求进行转发的时候会丢掉很多原本请求报文中存在的一些字段，比如host字段等，为了在nginx转发后获取这些字段，我们需要对nginx进行配置，可以在server块中的location块中使用<code>proxy_pass url</code>来设置满足条件的请求转发到哪里，通常配合和server同级的upstream块使用；使用<code>proxy_set_header Host $host;</code>来给转发的请求加头的Host字段，$host是取出当前请求的host字段的值。</li></ul><h2 id="使用nginx搭建域名访问环境"><a href="#使用nginx搭建域名访问环境" class="headerlink" title="使用nginx搭建域名访问环境"></a>使用nginx搭建域名访问环境</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230114205112366.png" alt="image-20230114205112366"></p><h2 id="通过JMeter压力测试来尝试对项目进行优化"><a href="#通过JMeter压力测试来尝试对项目进行优化" class="headerlink" title="通过JMeter压力测试来尝试对项目进行优化"></a>通过JMeter压力测试来尝试对项目进行优化</h2><ul><li><p>JMeter去apache官网下一个就行，选择编辑-添加-线程（用户）-线程组来添加一组测试，配置线程属性后，右键那个新建的测试可以选择添加一些取样器和监听器，运行就点上面那个运行按钮，清除记录就点那些带扫帚的按钮：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115154428987.png" alt="image-20230115154428987"></p></li><li><p>对页面压测的时候可以勾选下图中的那个选项，来把加载静态资源的时间也统计在里面：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115170421371.png" alt="image-20230115170421371"></p></li><li><p>影响项目性能的考虑点包括：数据库、应用程序、中间件、网络和操作系统等方面</p></li><li><p>在进行优化前应该先考虑自己的应用属于CPU密集型（大量计算）还是IO密集型（大量IO），我记得线程池线程数量的设置也受这两种类型的影响，<strong>CPU密集型的线程数应该设置为N（核心线程数）+1，IO密集型的线程数应该设置为2N（核心线程数）</strong>：</p><blockquote><p><strong>如果我们设置的线程池数量太小的话，如果同一时间有大量任务&#x2F;请求需要处理，可能会导致大量的请求&#x2F;任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务&#x2F;请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</strong></p><p><strong>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</strong></p><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I&#x2F;O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><hr><p>著作权归所有 原文链接：<a href="https://javaguide.cn/java/concurrent/java-thread-pool-summary.html">https://javaguide.cn/java/concurrent/java-thread-pool-summary.html</a></p></blockquote></li><li><p>对于CPU密集型应用的优化，我们可以尝试优化代码的逻辑和算法；对于IO密集型应用的优化，我们可以尝试优化代码逻辑，比如优化掉循环多次IO的代码。对于这两种应用有一种通用的优化方式，就是加强对应的硬件，CPU密集型就加强CPU、多CPU并发处理等，IO密集型就加强硬盘、内存，添加缓存等。</p></li><li><p>尝试让项目少进行Full GC（这里指old GC也就是只对老年代GC，有的时候Full GC还代指所有代的GC，这个就具体情况具体分析了），因为Full GC速度很慢</p></li></ul><h1 id="2023-x2F-1-x2F-15"><a href="#2023-x2F-1-x2F-15" class="headerlink" title="2023&#x2F;1&#x2F;15"></a>2023&#x2F;1&#x2F;15</h1><h2 id="在IDEA中给某个服务配置jvm参数"><a href="#在IDEA中给某个服务配置jvm参数" class="headerlink" title="在IDEA中给某个服务配置jvm参数"></a>在IDEA中给某个服务配置jvm参数</h2><ul><li><p>点击Edit Configurations：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115150549616.png" alt="image-20230115150549616"></p></li><li><p>在里面选择自己想要配置jvm参数的服务，在对应位置写上自己想要配置的参数即可：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115150702257.png" alt="image-20230115150702257"></p></li><li><p>配置堆的最大最小值时，分配的大小要接着命令的后面写，不要有空格，不要有冒号或等号，就是紧接着写，所以为啥要这样写呢，是有什么原因还是规定？</p></li></ul><h2 id="通过监视java进程以分析其各种指标从而做出优化"><a href="#通过监视java进程以分析其各种指标从而做出优化" class="headerlink" title="通过监视java进程以分析其各种指标从而做出优化"></a>通过监视java进程以分析其各种指标从而做出优化</h2><ul><li><p>可以使用jdk自带的工具<strong>jconsole和jvisualvm</strong>，推荐使用后者，后者是前者的加强版。</p></li><li><p>在配置了环境变量的情况下，在控制台直接输入jvisualvm来启动这个工具：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115153518894.png" alt="image-20230115153518894"></p></li><li><p>监视线程的部分如下图所示：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115153907989.png" alt="image-20230115153907989"></p><p>其中左下角的图例分别是：</p><p>运行：正在运行的线程</p><p>休眠：执行了sleep()方法的线程</p><p>等待：执行了wait()方法的线程，说明该线程正在等待其他线程的结果</p><p>驻留：线程池中空闲的线程</p><p>监视：被阻塞的线程，说明该线程正在等待别的线程释放锁以获得共享资源</p></li><li><p>如果还想让jvisualvm监视别的东西，比如gc，我们可以给jvisualvm安装插件，点击工具-插件，但是我们点击检查更新的时候可能会报无法连接的错误：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115154833965.png" alt="image-20230115154833965"></p><p>怎么解决呢？</p><p>首先我们去jvisualvm的插件官网：<a href="https://visualvm.github.io/pluginscenters.html%EF%BC%9A">https://visualvm.github.io/pluginscenters.html：</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115155229067.png" alt="image-20230115155229067"></p><p>查看我们装的jdk版本：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115155258812.png" alt="image-20230115155258812"></p><p>然后找到和我们的jdk版本匹配的url点进去，复制最上面的那个url：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115155428020.png" alt="image-20230115155428020"></p><p>然后回到jvisualvm的插件那里，点击设置-编辑，换上我们刚才复制的url后点确定：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115155540658.png" alt="image-20230115155540658"></p><p>然后就可以正常使用了。</p><p>选择自己想要安装的插件就可以了，这里主要是安装一下visual gc插件以监视gc的整个过程：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115155716557.png" alt="image-20230115155716557"></p><p>安装完后重启就能看到新的选项了：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115161309220.png" alt="image-20230115161309220"></p></li><li><p>从上图中也可以看到老年代Full GC（这里指old GC也就是只对老年代GC，有的时候Full GC还代指所有代的GC，这个就具体情况具体分析了）了3次花费的时间比新生代Eden区Minor GC了14次花费的时间还要长不少，这也印证了之前说的，老年代的GC效率很低，尽量少让老年代GC。</p></li></ul><h2 id="JVM分析与调优"><a href="#JVM分析与调优" class="headerlink" title="JVM分析与调优"></a>JVM分析与调优</h2><ul><li><p>在分析阶段，我们可以通过JMeter来对服务的各个环节来进行压测，最好是分成单独的压测和组合的压测，这样得到的结果可以汇总成一个表格，通过表格来判断我们应该从哪里着手进行优化：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115195332580.png" alt="image-20230115195332580"></p></li><li><p>中间件越多，性能损失越大，大多都损失在网络交互了，如果想要优化，可以先从中间件入手，优化中间件，提高中间件的吞吐量，再者可以从网络传输的部分入手，可以采用更好的网线、采用更高效的网络传输协议等</p></li><li><p>业务的优化可以考虑以下几个方面：DB（数据库）优化、静态资源访问优化、模板渲染速度优化（前后不分离的话）、业务逻辑优化（比如在循环中查表的问题）</p></li><li><p>对于数据库的优化，无非就是优化数据库查表的效率，<strong>数据量大的时候</strong>，对主键进行查询的时候效率比较高，那是因为主键有索引，对别的没有索引的字段进行查询的话，数据库会进行全表查询，在数据量比较大的时候这种查询的效率非常低，所以为了优化数据库的查询效率，我们可以<strong>考虑给查询得多的字段加上索引来加速查询</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115171845911.png" alt="image-20230115171845911"></p></li><li><p>有的时候通过jvisualvm可以看出来，整个服务的性能瓶颈出现在老年代的频繁GC，所以针对这个问题我们可以修改jvm的启动设置，手动给jvm设置内存：</p><ul><li>-Xmx用来设置堆的最大占用内存，例：<code>-Xmx100m</code></li><li>-Xms用来设置堆的最小占用内存，例：<code>-Xms100m</code></li><li>-Xmn用来设置堆中新生代的占用内存，JVM官方推荐新生代占整个堆的3&#x2F;8，其中Eden:S0:S1 &#x3D; 8:1:1，例：<code>-Xmn30m</code></li><li>未完待续……</li></ul></li></ul><h2 id="Nginx动静分离"><a href="#Nginx动静分离" class="headerlink" title="Nginx动静分离"></a>Nginx动静分离</h2><ul><li><p>为了对访问静态数据这一步进行优化，我们可以选择将静态资源全部放到nginx中，这样每当我们需要静态资源的时候，找nginx要就可以了，而不用发请求向后端要了，相当于把从nginx到后端的这段链路优化掉了，服务能腾出不少线程来专注为动态请求服务，能提升不少吞吐量：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115181112309.png" alt="image-20230115181112309"></p></li><li><p>所以以后可以将项目用到的所有静态资源全部放到nginx中，对静态资源的访问请求都应该由nginx直接返回。</p></li><li><p>首先把static下的文件全部放到服务器的nginx挂载的外部文件夹html中，这个文件夹是被nginx的保存静态资源的目录挂载的。</p></li><li><p>然后修改index.html中的访问静态资源的路径，都要在原路径前面加上一个&#x2F;static&#x2F;，这个&#x2F;static&#x2F;是准备在nginx中进行配置的，如果要是访问路径以&#x2F;static&#x2F;开头，那么nginx就要把请求转到指定的地方，所以这个&#x2F;static&#x2F;也可以自定义。</p></li><li><p>然后修改nginx的配置文件，主要就是加一个location做静态资源请求的转发映射：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以/static/开头的请求全部转到root下</span></span><br><span class="line">location /static/ &#123;</span><br><span class="line">    root   /usr/share/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>之后给ngxin发以&#x2F;static&#x2F;开头的静态资源请求，都会被nginx转发到nginx的静态资源目录中查找并返回对应的资源。</p></li></ul><h2 id="缓存的使用"><a href="#缓存的使用" class="headerlink" title="缓存的使用"></a>缓存的使用</h2><ul><li><p>当我们将大部分优化手段都做了一遍之后，如果还想提高系统的吞吐量，那么我们可以引入缓存，减少查数据库的次数。</p></li><li><p>哪些数据适合放入缓存？</p><ol><li><strong>即时性、数据一致性要求不高</strong>的</li><li><strong>访问量大且更新频率不高</strong>的数据（读多，写少）</li></ol></li><li><p>读缓存使用流程：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115224124283.png" alt="image-20230115224124283"></p></li><li><p>至于缓存的实现，可以是多种多样的，比如最简单的就是本地缓存，写个map装东西，在访问数据库之前先看看想要的数据在map中有没有，如果有就直接取，如果没有就查数据库，但是这样做会有很多问题，首先就是如果服务部署成一个集群，那么多个本地缓存的数据一致性难以保证，并且我们自己写的缓存很难有生产级别的缓存淘汰机制等，并且本地缓存和代码耦合度太高，后续难以维护，可读性也乏善可陈。</p></li><li><p>我们想要的缓存实现，应该是<strong>解耦的，稳定的，并且能在集群部署的情况下保证缓存之间的数据的一致性，并且应该有优秀的缓存淘汰算法可供我们进行选择</strong>。</p></li><li><p>综上所述，我们需要的应该是一个缓存中间件，所有服务更新缓存都是更新在中间件中，并且中间件还支持集群部署，这样就解决了缓存之间数据一致性的问题，中间件本身还是解耦的，并且还有多样的数据淘汰策略可供我们选择，缓存中间件有很多，redis挺好用，那就用redis。</p></li></ul><h1 id="2023-x2F-1-x2F-16"><a href="#2023-x2F-1-x2F-16" class="headerlink" title="2023&#x2F;1&#x2F;16"></a>2023&#x2F;1&#x2F;16</h1><h2 id="关于父项目管理子项目依赖的版本的问题"><a href="#关于父项目管理子项目依赖的版本的问题" class="headerlink" title="关于父项目管理子项目依赖的版本的问题"></a>关于父项目管理子项目依赖的版本的问题</h2><ul><li>如果父项目的dependency不写version，那么子项目是获取不到父项目的依赖版本的，即使是父项目的dependency的version能从它的父项目中得到，今天踩坑了&#x3D; &#x3D;。</li></ul><h2 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h2><ul><li><p>首先就是引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring-boot-starter-data-redis.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring-boot-starter-data-redis.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后就是在配置文件中进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment">#配置redis的主机地址和端口</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">111.111</span><span class="number">.111</span><span class="number">.111</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure></li><li><p>然后我们看看redis的AutoConfiguration类：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116151143755.png" alt="image-20230116151143755"></p><p>里面有两个注入到spring IOC容器中的bean，前者是和对象操作相关的，后者是和字符串操作相关的，我们<strong>使用缓存存放的数据一般都是json格式的数据</strong>，所以用后面的bean多一些。</p></li><li><p>使用StringRedisTemplate来操作redis，总的来说就是先获取对redis的某个数据结构的操作对象，然后再用那个获得的操作对象来执行一系列对于指定数据结构的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedis</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//获得对value的操作对象</span></span><br><span class="line">ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line"><span class="comment">//执行保存操作</span></span><br><span class="line">ops.set(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world_&quot;</span>+ UUID.randomUUID().toString());</span><br><span class="line"><span class="comment">//执行查询操作</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> ops.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;保存的key为hello的value是：&quot;</span>+hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以使用RedisDesktopManager软件来可视化地查看远端服务器上redis中存放的数据：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116154522095.png" alt="image-20230116154522095"></p></li><li><p>为了防止有人偷偷连上我们的redis做一些乱七八糟的操作，我们可以在redis的client中使用<code>config set requirepass 密码</code>设置密码，登录client的时候要使用<code>AUTH 密码</code>来进行登录，记得改一下RedisDesktopManager的客户端连接的设置，把那密码给写上，不然连不上；然后还要在项目的配置文件中设置一下spring.redis.password属性的值以让我们的项目也能成功连接上redis。</p></li><li><p>之后对于想要从数据库中查找符合存放在redis中要求的数据之前，要先检查一下缓存中有没有，如果有直接拿，如果没有再查数据库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTree</span><span class="params">()</span>&#123;<span class="comment">//给listWithTree方法加入缓存后的逻辑</span></span><br><span class="line">    <span class="comment">//给缓存中存放的是对象转成的json数据，拿出的也是json数据需要转成对象，有天然的跨平台性，这是序列化与反序列化的一种实现</span></span><br><span class="line">    <span class="comment">//尝试从redis中取想要的数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">catelogData</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;catelogData&quot;</span>);<span class="comment">//字面量按说应该抽成常量，这里只是为了方便</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(catelogData))&#123;<span class="comment">//如果redis中没有我们想要的数据，那么我们才从数据库中查,并将查到的结果加入缓存中</span></span><br><span class="line">        List&lt;PmsCategory&gt; result = listWithTreeFromDb();<span class="comment">//从数据库中查</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">store</span> <span class="operator">=</span> JSON.toJSONString(result);<span class="comment">//将结果转成json数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;catelogData&quot;</span>,store);<span class="comment">//将json数据存入redis</span></span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//返回从数据库中查到的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果redis中有我们想要的数据，那么我们可以反序列化之后直接使用</span></span><br><span class="line">    <span class="comment">//Json反序列化操作，注意第二个参数作为类型令牌的使用</span></span><br><span class="line">    List&lt;PmsCategory&gt; result = JSON.parseObject(catelogData,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;PmsCategory&gt;&gt;()&#123;&#125;);</span><br><span class="line">    log.info(<span class="string">&quot;是从redis中取的结果~&quot;</span>);</span><br><span class="line">    <span class="comment">//返回反序列化后的结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeFromDb</span><span class="params">()</span> &#123;<span class="comment">//原listWithTree方法</span></span><br><span class="line">    <span class="comment">//查出所有分类</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * baseMapper就相当于这个service对应的mapper，</span></span><br><span class="line"><span class="comment">     * 因为看上面继承了ServiceImpl，</span></span><br><span class="line"><span class="comment">     * 其中这个service对应的mapper被当作泛型的类型参数传进去了，</span></span><br><span class="line"><span class="comment">     * 而里面有个泛型参数类型的变量就是baseMapper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;PmsCategory&gt; data = baseMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//todo 组装成树形结构</span></span><br><span class="line">    <span class="comment">//找到所有的一级分类</span></span><br><span class="line">    List&lt;PmsCategory&gt; level1Menu = data.stream()</span><br><span class="line">            .filter(pmsCategory -&gt; pmsCategory.getParentCid().equals(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">            .map(menu -&gt; &#123;</span><br><span class="line">                menu.setChildren(getChildren(data,menu));</span><br><span class="line">                <span class="keyword">return</span> menu;</span><br><span class="line">            &#125;)</span><br><span class="line">            .sorted(Comparator.comparingInt(PmsCategory::getSort))<span class="comment">//Comparator封装了比较两个int变量的Comparator，直接传个方法引用告知其如何从元素中取得int变量即可</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> level1Menu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在对使用了缓存的方法进行压测的时候可能会出现的堆外内存溢出的问题：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116164117198.png" alt="image-20230116164117198"></p></li></ul><h2 id="高并发环境下缓存失效的问题"><a href="#高并发环境下缓存失效的问题" class="headerlink" title="高并发环境下缓存失效的问题"></a>高并发环境下缓存失效的问题</h2><h3 id="缓存穿透（大流量查一个不存在的数据）"><a href="#缓存穿透（大流量查一个不存在的数据）" class="headerlink" title="缓存穿透（大流量查一个不存在的数据）"></a>缓存穿透（大流量查一个不存在的数据）</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116165314128.png" alt="image-20230116165314128"></p><ul><li>就是查询一个不存在的数据，导致每次查询都要查数据库，缓存形同虚设，数据库的查询压力会增大，直至崩溃。所以针对数据库中不存在的结果，我们可以在查了数据库之后，<strong>把这个不存在的结果当作空值存在redis中并设置一定的过期时间</strong>，这样短时间内针对这个不存在的结果的查询，就会走缓存，数据库就不会有那么大的压力了。</li></ul><h3 id="缓存雪崩（流量高峰时缓存中的数据短时间内同时过期）"><a href="#缓存雪崩（流量高峰时缓存中的数据短时间内同时过期）" class="headerlink" title="缓存雪崩（流量高峰时缓存中的数据短时间内同时过期）"></a>缓存雪崩（流量高峰时缓存中的数据短时间内同时过期）</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116165905379.png" alt="image-20230116165905379"></p><h3 id="缓存击穿（热点数据在流量高峰期失效）"><a href="#缓存击穿（热点数据在流量高峰期失效）" class="headerlink" title="缓存击穿（热点数据在流量高峰期失效）"></a>缓存击穿（热点数据在流量高峰期失效）</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116170154726.png" alt="image-20230116170154726"></p><h2 id="分布式的情况下如何加锁"><a href="#分布式的情况下如何加锁" class="headerlink" title="分布式的情况下如何加锁"></a>分布式的情况下如何加锁</h2><ul><li><p>如果要是使用本地锁，使用this作为锁，那么作为单机应用来说是完全没有问题的，因为spring中的bean是单例的，可以保证每次的这个this是同一个对象。</p></li><li><p>但是如果要是分布式的情况下，不同的节点有不同的spring IOC容器，这样使用本地锁this无法将所有节点全部锁住，所以我们为了应对这个问题，可以使用分布式锁，不过这玩意儿性能比较低，其实仔细一想，如果分布式的情况下使用本地锁，无非也就是多放了几个请求进去嘛，无可厚非，所以这个分布式锁的使用情况就具体情况具体分析了，适用于那种大型分布式系统，那种集群节点很多的那种，如果能带来更高的性能就用，可以压测试试。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116171855477.png" alt="image-20230116171855477"></p></li><li><p>分布式锁基本原理，无非也就是把获取锁的这部分抽出来，怎么实现无所谓，关键是要和服务解耦：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116181622257.png" alt="image-20230116181622257"></p></li><li><p>我们可以使用redis的天然特性来去实现这个加锁操作，最简单的说就是每个线程到了redis，先set一个值，如果这个值没有设置，那么他设置了，他就可以进行下面的操作，如果要是值已经设置了，说明有线程已经到过了，那当前的线程就没有抢到锁，可以使用redis的命令setnx也就是指定的key没有值的情况下才进行set，不然就不进行set，这就是分布式锁的基本原理，类似于乐观锁：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116185358324.png" alt="image-20230116185358324"></p></li><li><p>上一个阶段中存在一个问题，如果出现问题导致redis锁没有释放，那么redis锁就一直不能被获取，就死锁了，也就是<strong>无法保证业务的原子性</strong>，针对这样的问题，我们可以给redis锁设置一个自动过期时间，一段时间过后，就算没有用程序将redis锁释放，过期时间到了锁就会被自动释放：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116190133025.png" alt="image-20230116190133025"></p></li><li><p>上个阶段中也有问题，万一在设置过期时间之前，突然断电了，那么过期时间没能设置，又死锁了，针对这种情况，我们可以把设置过期时间和获取锁的操作一起进行，让他们变成一个原子操作，这样就能解决这个问题：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116190717037.png" alt="image-20230116190717037"></p></li><li><p>上面这个阶段又有问题，问题出现在删除锁的情况下，万一一个持有锁的服务超时了，锁被自动释放掉了，然后别的线程拿到了锁，但是最后那个超时的服务又要执行删除锁的操作，这样就导致别人的锁被他删掉了，为了解决这个问题，我们给redis锁的值设置为uuid，这样每个人最后删除的时候总是尝试删除自己的锁：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116193241172.png" alt="image-20230116193241172"></p></li><li><p>上面这个阶段还是有问题，问题就在于我们无法保证最后获取锁的值并检查和释放锁这两个操作的原子性，这会导致什么后果呢，如果一个线程去redis查了自己的锁，在数据返回的时候，锁过期了，别的又加了锁，再之后这个数据到达本地，判断也通过了，就会执行释放锁的操作，又释放成别人的锁了。根据redis官方的说法，解决这个问题需要使用lua脚本以保证这些操作的一致性：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116193559497.png" alt="image-20230116193559497"></p></li><li><p>总结一下就是，使用redis做分布式锁，需要注意保证设置过期时间并加锁和检查是否是自己的锁并解锁的操作的原子性，还需要保证加锁的值是各线程特有的，前者是使用redis的语法保证原子性，后者是通过使用lua脚本保证原子性，以下是对之前代码的分布式锁实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTree</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listWithTreeByRedisLock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeByRedisLock</span><span class="params">()</span>&#123;<span class="comment">//用redis实现分布式锁，不过查出来的内容没放缓存呢还</span></span><br><span class="line">    <span class="comment">//分布式锁，去redis中set相同key的值，谁set成功了谁就拿到锁了，可以执行后面的内容，没拿到锁的进行睡眠并自旋，直到拿到锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();<span class="comment">//这是为了防止误删别人的锁，所以每个人设置锁的值都应该是唯一的，最后删除锁之前也要检查是不是自己的再删</span></span><br><span class="line">    <span class="comment">//尝试获取redis锁，使用的那个方法可以保证设置过期时间和设置值的操作是原子的，具体执行的语句应该是setnx Key Value EX 300 NX</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>,uuid,<span class="number">300</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;<span class="comment">//如果拿到了锁，就执行下面的操作</span></span><br><span class="line">        log.info(<span class="string">&quot;获取分布式锁成功&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> listWithTreeFromDb();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;<span class="comment">//在finally中解锁，保证锁会被解掉</span></span><br><span class="line">            <span class="comment">//保证了检查锁和解锁两个操作原子性的lua脚本</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">            <span class="comment">//删除锁,第一个参数是封装的脚本，泛型是返回值类型，redis删除成功返回1，删除不成功返回0，所以是个long，第二个参数是顺序的所有脚本中用到的key，第三个参数是顺序的所有脚本中用到的value</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">ifDeleted</span> <span class="operator">=</span> stringRedisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;Long&gt;(script,Long.class),Arrays.asList(<span class="string">&quot;lock&quot;</span>),uuid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果没有拿到锁，就睡眠并自旋</span></span><br><span class="line">        log.info(<span class="string">&quot;获取分布式锁失败，将在一定时间后重试&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;出现异常：&#123;&#125;&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listWithTreeByRedisLock();<span class="comment">//递归自旋，感觉不如提到前面做循环自旋，这个太占栈空间了。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeByLocalLock</span><span class="params">()</span>&#123;<span class="comment">//给listWithTree方法加入缓存后的逻辑,用的是本地锁</span></span><br><span class="line">    <span class="comment">//给缓存中存放的是对象转成的json数据，拿出的也是json数据需要转成对象，有天然的跨平台性，这是序列化与反序列化的一种实现</span></span><br><span class="line">    <span class="comment">//todo 空结果缓存：解决缓存穿透 随机过期时间：解决缓存雪崩 加锁：解决缓存击穿</span></span><br><span class="line">    <span class="comment">//尝试从redis中取想要的数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">catelogData</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;catelogData&quot;</span>);<span class="comment">//字面量按说应该抽成常量，这里只是为了方便</span></span><br><span class="line">    List&lt;PmsCategory&gt; result = <span class="literal">null</span>;<span class="comment">//最后要返回的结果</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(catelogData))&#123;<span class="comment">//如果redis中没有我们想要的数据，那么我们才从数据库中查,并将查到的结果加入缓存中</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;<span class="comment">//加本地锁以防止缓存穿透，把存入缓存的代码也放进来，防止缓存还没更新的时候下一个请求到了然后做出错误的判断</span></span><br><span class="line">            catelogData = stringRedisTemplate.opsForValue().get(<span class="string">&quot;catelogData&quot;</span>);<span class="comment">//再查一遍缓存用于双重校验</span></span><br><span class="line">            <span class="keyword">if</span>(!StringUtils.isEmpty(catelogData))&#123;<span class="comment">//双重校验，如果缓存中有数据了，就不用从数据库中查了</span></span><br><span class="line">                <span class="comment">//Json反序列化操作，注意第二个参数作为类型令牌的使用</span></span><br><span class="line">                result = JSON.parseObject(catelogData,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;PmsCategory&gt;&gt;()&#123;&#125;);</span><br><span class="line">                log.info(<span class="string">&quot;查redis~&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;查数据库~&quot;</span>);</span><br><span class="line">            result = listWithTreeFromDb();<span class="comment">//从数据库中查</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">store</span> <span class="operator">=</span> JSON.toJSONString(result);<span class="comment">//将结果转成json数据</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;catelogData&quot;</span>,store);<span class="comment">//将json数据存入redis</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//返回从数据库中查到的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果redis中有我们想要的数据，那么我们可以反序列化之后直接使用</span></span><br><span class="line">    <span class="comment">//Json反序列化操作，注意第二个参数作为类型令牌的使用</span></span><br><span class="line">    result = JSON.parseObject(catelogData,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;PmsCategory&gt;&gt;()&#123;&#125;);</span><br><span class="line">    log.info(<span class="string">&quot;查redis~&quot;</span>);</span><br><span class="line">    <span class="comment">//返回反序列化后的结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeFromDb</span><span class="params">()</span> &#123;<span class="comment">//原listWithTree方法</span></span><br><span class="line">    <span class="comment">//查出所有分类</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * baseMapper就相当于这个service对应的mapper，</span></span><br><span class="line"><span class="comment">     * 因为看上面继承了ServiceImpl，</span></span><br><span class="line"><span class="comment">     * 其中这个service对应的mapper被当作泛型的类型参数传进去了，</span></span><br><span class="line"><span class="comment">     * 而里面有个泛型参数类型的变量就是baseMapper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;PmsCategory&gt; data = baseMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//todo 组装成树形结构</span></span><br><span class="line">    <span class="comment">//找到所有的一级分类</span></span><br><span class="line">    List&lt;PmsCategory&gt; level1Menu = data.stream()</span><br><span class="line">            .filter(pmsCategory -&gt; pmsCategory.getParentCid().equals(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">            .map(menu -&gt; &#123;</span><br><span class="line">                menu.setChildren(getChildren(data,menu));</span><br><span class="line">                <span class="keyword">return</span> menu;</span><br><span class="line">            &#125;)</span><br><span class="line">            .sorted(Comparator.comparingInt(PmsCategory::getSort))<span class="comment">//Comparator封装了比较两个int变量的Comparator，直接传个方法引用告知其如何从元素中取得int变量即可</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> level1Menu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于原子加锁和解锁我们可以抽取成工具类，但是分布式锁有更专业的工具，下面会介绍到。</p></li></ul><h2 id="本地锁的时序问题"><a href="#本地锁的时序问题" class="headerlink" title="本地锁的时序问题"></a>本地锁的时序问题</h2><ul><li><p>本地锁的范围一定要考虑清楚，就拿上面写的那个查数据库的逻辑来说，如果要是将结果放入缓存的操作在锁外面，那么在一个线程释放锁之后，另一个线程进入代码块并判断缓存中有没有数据，由于数据还没来得及放入缓存，所以这个地方自然是返回false，那这个线程就又查了一遍数据库，所以锁的范围一定要考虑清楚，应该把放缓存的代码放到加锁的代码块中。</p></li><li><p>而且如果要是放入缓存的操作只是发一个网络请求就向下执行的话，我们还应该考虑网络延迟等因素的影响，所以最保险的做法我感觉是在最后用while循环判断缓存是否已经更新，如果更新了再释放锁。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116173314106.png" alt="image-20230116173314106"></p></li></ul><h2 id="对上面的代码进行加本地锁以防止缓存击穿"><a href="#对上面的代码进行加本地锁以防止缓存击穿" class="headerlink" title="对上面的代码进行加本地锁以防止缓存击穿"></a>对上面的代码进行加本地锁以防止缓存击穿</h2><ul><li><p>一定考虑清楚锁的范围，还有别忘了双重校验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTree</span><span class="params">()</span>&#123;<span class="comment">//给listWithTree方法加入缓存后的逻辑</span></span><br><span class="line">    <span class="comment">//给缓存中存放的是对象转成的json数据，拿出的也是json数据需要转成对象，有天然的跨平台性，这是序列化与反序列化的一种实现</span></span><br><span class="line">    <span class="comment">//todo 空结果缓存：解决缓存穿透 随机过期时间：解决缓存雪崩 加锁：解决缓存击穿</span></span><br><span class="line">    <span class="comment">//尝试从redis中取想要的数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">catelogData</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;catelogData&quot;</span>);<span class="comment">//字面量按说应该抽成常量，这里只是为了方便</span></span><br><span class="line">    List&lt;PmsCategory&gt; result = <span class="literal">null</span>;<span class="comment">//最后要返回的结果</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(catelogData))&#123;<span class="comment">//如果redis中没有我们想要的数据，那么我们才从数据库中查,并将查到的结果加入缓存中</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;<span class="comment">//加本地锁以防止缓存穿透，把存入缓存的代码也放进来，防止缓存还没更新的时候下一个请求到了然后做出错误的判断</span></span><br><span class="line">            catelogData = stringRedisTemplate.opsForValue().get(<span class="string">&quot;catelogData&quot;</span>);<span class="comment">//再查一遍缓存用于双重校验</span></span><br><span class="line">            <span class="keyword">if</span>(!StringUtils.isEmpty(catelogData))&#123;<span class="comment">//双重校验，如果缓存中有数据了，就不用从数据库中查了</span></span><br><span class="line">                <span class="comment">//Json反序列化操作，注意第二个参数作为类型令牌的使用</span></span><br><span class="line">                result = JSON.parseObject(catelogData,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;PmsCategory&gt;&gt;()&#123;&#125;);</span><br><span class="line">                log.info(<span class="string">&quot;查redis~&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;查数据库~&quot;</span>);</span><br><span class="line">            result = listWithTreeFromDb();<span class="comment">//从数据库中查</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">store</span> <span class="operator">=</span> JSON.toJSONString(result);<span class="comment">//将结果转成json数据</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;catelogData&quot;</span>,store);<span class="comment">//将json数据存入redis</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//返回从数据库中查到的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果redis中有我们想要的数据，那么我们可以反序列化之后直接使用</span></span><br><span class="line">    <span class="comment">//Json反序列化操作，注意第二个参数作为类型令牌的使用</span></span><br><span class="line">    result = JSON.parseObject(catelogData,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;PmsCategory&gt;&gt;()&#123;&#125;);</span><br><span class="line">    log.info(<span class="string">&quot;查redis~&quot;</span>);</span><br><span class="line">    <span class="comment">//返回反序列化后的结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeFromDb</span><span class="params">()</span> &#123;<span class="comment">//原listWithTree方法</span></span><br><span class="line">    <span class="comment">//查出所有分类</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * baseMapper就相当于这个service对应的mapper，</span></span><br><span class="line"><span class="comment">     * 因为看上面继承了ServiceImpl，</span></span><br><span class="line"><span class="comment">     * 其中这个service对应的mapper被当作泛型的类型参数传进去了，</span></span><br><span class="line"><span class="comment">     * 而里面有个泛型参数类型的变量就是baseMapper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;PmsCategory&gt; data = baseMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//todo 组装成树形结构</span></span><br><span class="line">    <span class="comment">//找到所有的一级分类</span></span><br><span class="line">    List&lt;PmsCategory&gt; level1Menu = data.stream()</span><br><span class="line">            .filter(pmsCategory -&gt; pmsCategory.getParentCid().equals(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">            .map(menu -&gt; &#123;</span><br><span class="line">                menu.setChildren(getChildren(data,menu));</span><br><span class="line">                <span class="keyword">return</span> menu;</span><br><span class="line">            &#125;)</span><br><span class="line">            .sorted(Comparator.comparingInt(PmsCategory::getSort))<span class="comment">//Comparator封装了比较两个int变量的Comparator，直接传个方法引用告知其如何从元素中取得int变量即可</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> level1Menu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>压力测试：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116175914279.png" alt="image-20230116175914279"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116175847264.png" alt="image-20230116175847264"></p><p>可以看到只查了一次数据库，所以这个锁在单机情况下是有作用的。</p></li></ul><h2 id="用IDEA模拟集群"><a href="#用IDEA模拟集群" class="headerlink" title="用IDEA模拟集群"></a>用IDEA模拟集群</h2><ul><li><p>可以在想要模拟集群的服务上右键，选择copy configuration，然后换个端口号，改改配置，多搞几个一起启动就行了：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116180519759.png" alt="image-20230116180519759"></p></li></ul><h1 id="2023-x2F-1-x2F-17"><a href="#2023-x2F-1-x2F-17" class="headerlink" title="2023&#x2F;1&#x2F;17"></a>2023&#x2F;1&#x2F;17</h1><h2 id="自旋锁（Spin-Lock）"><a href="#自旋锁（Spin-Lock）" class="headerlink" title="自旋锁（Spin Lock）"></a>自旋锁（Spin Lock）</h2><ul><li>就是没拿到锁的时候自己在那转，直到拿到锁，可以用循环或者递归实现。</li></ul><h2 id="可重入锁（Reentrant-Lock）"><a href="#可重入锁（Reentrant-Lock）" class="headerlink" title="可重入锁（Reentrant Lock）"></a>可重入锁（Reentrant Lock）</h2><ul><li><del>假设有两个方法分别是方法a和方法b，方法b在方法a中，他们都想加同一把锁，如果要是不可重入锁，那么在a拿到锁之后，b就会无限等待，就死锁了；如果是可重入锁，那么当a拿到锁后，它里面的方法b在某种情况下也可以拿到a锁，避免了死锁问题，所以为了避免死锁问题，我们的锁应该都尽量设计成可重入锁</del>。</li><li>可重入锁是指可以被已经获取该锁的线程重新获取，可以防止递归的时候出现死锁的情况。</li></ul><h2 id="公平锁（Fair-Lock）"><a href="#公平锁（Fair-Lock）" class="headerlink" title="公平锁（Fair Lock）"></a>公平锁（Fair Lock）</h2><ul><li>就是一个线程拿到锁之后，又有很多线程想要拿锁，在之前拿到锁的线程释放锁之后，那些后来的线程会按照一定的顺序来拿锁而非抢占，这就是公平锁。释放锁后进行抢占的那是非公平锁。</li></ul><h2 id="读写锁（ReadWrite-Lock）"><a href="#读写锁（ReadWrite-Lock）" class="headerlink" title="读写锁（ReadWrite Lock）"></a>读写锁（ReadWrite Lock）</h2><ul><li><p>如果一个线程拿着写锁在修改数据，而另一个线程想要拿读锁读取数据，那么它是拿不到的，只有当写锁被释放之后，它才能拿到读锁，这样就保证了读线程读到的都是最新的数据。</p></li><li><p>同样，如果一个线程拿着读锁在读取数据，而另一个线程想要拿写锁修改数据，那么它是拿不到的，只有当读锁被释放之后，它才能拿到写锁。</p></li><li><p>如果要是很多线程并发读取数据（写锁在释放状态），那么他们拿的是共享读锁，可以一起读，类似于无锁的状态。</p></li><li><p>如果要是很多线程并发修改数据（读锁在释放状态），那么他们要拿排他&#x2F;互斥写锁，不能一起写。</p></li><li><p>也就是<strong>共享读，排他&#x2F;独享&#x2F;互斥写</strong>，<strong>读写不兼容，读读兼容，写写不兼容</strong>。</p></li><li><p>读写锁总是成对出现，写锁控制着读锁，只要写锁没释放，读锁就要等待；读锁没释放，写锁也要等待。</p></li><li><p>这其实设计操作系统中读者和写者的问题，可以再去翻翻书。</p></li><li><p><strong>对于频繁读，偶尔写的业务场景，加读写锁对性能影响不大</strong>。</p></li><li><p>代码示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117154614171.png" alt="image-20230117154614171"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117154650048.png" alt="image-20230117154650048"></p></li></ul><h2 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h2><ul><li><p>信号量的值是个数字，每当一个线程拿到这个锁，信号量就减1，只要信号量不为0，来的线程就能拿到锁，当信号量减为0时，再想获得这个锁就要等待或者不拿锁了直接走掉。</p></li><li><p>可以用作分布式限流等操作中。</p></li><li><p>代码示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117154926261.png" alt="image-20230117154926261"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117154943639.png" alt="image-20230117154943639"></p></li></ul><h2 id="闭锁（CountDownLatch）"><a href="#闭锁（CountDownLatch）" class="headerlink" title="闭锁（CountDownLatch）"></a>闭锁（CountDownLatch）</h2><ul><li><p>有多个线程可以同时拿着闭锁，但是只有当所有的线程都释放闭锁之后，闭锁才会被释放。</p></li><li><p>应用场景：加载多个配置，需要加载完所有的配置才能走下一步。</p></li><li><p>代码示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117155137552.png" alt="image-20230117155137552"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117155150238.png" alt="image-20230117155150238"></p></li></ul><h2 id="最好把注入的对象名写成把他注册到spring-IOC容器中的那个方法的名字"><a href="#最好把注入的对象名写成把他注册到spring-IOC容器中的那个方法的名字" class="headerlink" title="最好把注入的对象名写成把他注册到spring IOC容器中的那个方法的名字"></a>最好把注入的对象名写成把他注册到spring IOC容器中的那个方法的名字</h2><ul><li>相当于那个组件的id，增强可读性</li></ul><h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><ul><li><p>这是一个封装了很多分布式操作的包，用它我们可以很轻松的实现分布式锁（包括上面写的那些锁，方法名字和上面写的那些锁的名字差不多）、分布式对象等高级操作。</p></li><li><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">redisson.version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">redisson.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--redisson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;redisson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>虽然它有starter，可以进行自动配置，但是我们还是手动配置一下以获取更深的理解，给它新建一个配置类进行配置，最后返回的是一个RedissonClient实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRedissonConfig</span> &#123;<span class="comment">//redisson的配置类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;shutdown&quot;)</span></span><br><span class="line">    RedissonClient <span class="title function_">redisson</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">//创建配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://101.42.35.83:6379&quot;</span>);</span><br><span class="line">        <span class="comment">//根据config创建RedissonClient实例</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>它的所有操作都是通过RedissonClient的实例来做的，所以以后用的时候，注入RedissonClient，然后用就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RedissonClient redisson;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/testRedisson&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">testRedisson</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">myLock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;myLock&quot;</span>);<span class="comment">//获取一把锁，参数是锁的名字，通过名字区分不同的锁，名字相同的就是同一把锁</span></span><br><span class="line">    myLock.lock();<span class="comment">//加锁,获取不到锁的线程会被阻塞</span></span><br><span class="line">    <span class="keyword">try</span>&#123;<span class="comment">//锁的ttl会利用看门狗自动续期，不用担心业务时间长锁会过期，默认ttl为30s，也不用担心程序挂掉之后不会解锁</span></span><br><span class="line">        System.out.println(<span class="string">&quot;加锁成功，执行业务...&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">//如果业务结束，那么看门狗不会再给锁的ttl续期</span></span><br><span class="line">        System.out.println(<span class="string">&quot;解锁...&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">        myLock.unlock();<span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(redisson);</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是正常的，没有获得锁的线程会阻塞，之前的线程放开锁后马上开始竞争锁：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116232306338.png" alt="image-20230116232306338"></p><p>在redis中能看到锁：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116232334579.png" alt="image-20230116232334579"></p></li><li><p>可以发现加锁后，一个任务运行的时候出现错误没能解锁之后，另外一个任务仍然能拿到锁，这是因为<strong>redisson在redis中加锁的时候设置了过期时间TTL，默认是30s，也就是一个看门狗时间</strong>，而这个TTL也没那么简单，TTL会被监视，<strong>如果业务还在运行中，那么这个TTL会在1&#x2F;3个看门狗时间也就是10s后自动续期到一个看门狗时间也就是30s，一直重复直到业务完成或宕掉；如果业务没有在运行了，TTL就不会做自动续期，最后TTL减到0锁被淘汰</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117143059296.png" alt="image-20230117143059296"></p></li><li><p>但是<strong>如果在使用锁的时候显式地指定了过期时间，那么看门狗机制会失效</strong>，虽然我也不知道它为啥这样设计…</p></li><li><p>不过<strong>自动续期TTL会造成性能的损失</strong>，所以之后在用的时候最好还是显式指定超时时间。</p></li><li><p>redisson中有上面写的那些锁的实现，名字和那些锁的名字差不多，<strong>带try的方法是尝试获取锁的时候不阻塞，不带try的方法是尝试获取锁的时候阻塞</strong>。</p></li><li><p>用redisson再改造一下昨天写的代码，看着简洁多了，不过<strong>在给锁命名的时候要注意锁的粒度问题</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeByRedissonLock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//新建分布式锁</span></span><br><span class="line">    <span class="comment">//起名的时候涉及锁的粒度越细，速度越快，粒度越大，速度越慢</span></span><br><span class="line">    <span class="comment">//可以按照具体的服务名以及缓存内容等给锁起名，保证锁的粒度合理</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">myLock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;product-listWithTree-lock&quot;</span>);</span><br><span class="line">    myLock.lock(<span class="number">30</span>,TimeUnit.SECONDS);<span class="comment">//上锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listWithTreeFromDb();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        myLock.unlock();<span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="缓存数据一致性问题"><a href="#缓存数据一致性问题" class="headerlink" title="缓存数据一致性问题"></a>缓存数据一致性问题</h2><ul><li>缓存里面的数据如何和数据库中的数据保持一致？</li></ul><h3 id="双写模式"><a href="#双写模式" class="headerlink" title="双写模式"></a>双写模式</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117161428127.png" alt="image-20230117161428127"></p><ul><li>就是写完数据库之后再改缓存，但是这样比较麻烦，而且在高并发的情况下缓存中可能出现脏数据，可以通过加锁解决；或者系统允许有一定的脏数据存在，因为脏数据一段时间过后会被淘汰，再查数据库更新的缓存就是最新的了。</li><li>但是这种方案是虽然读最新数据可能有延迟，但是整体是满足最终一致性的。</li></ul><h3 id="失效模式"><a href="#失效模式" class="headerlink" title="失效模式"></a>失效模式</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117162628865.png" alt="image-20230117162628865"></p><ul><li>就是写完数据库，把对应的缓存删掉，直到下一次有请求主动查数据库来更新缓存。</li><li>还是会有读脏数据的情况出现，具体情况就是左边那个图，可以通过加锁来解决。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>解决方案无非就是给<strong>缓存数据加上过期时间，保证并发读写的时候加读写锁</strong>，不过这样数据在缓存中更新会产生一定程度的延迟，所以说那些需要频繁写，并且对实时性要求很高的数据，就不要放缓存了，直接查数据库就行了。</p></li><li><p>永远记住，<strong>缓存只用来保证最终一致性</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117162901916.png" alt="image-20230117162901916"></p></li><li><p>不过完全解决缓存数据的一致性也可以使用阿里的Canal中间件，Canal会伪装成mysql的一个从服务器，可以通过订阅来监听mysql的变化，一旦mysql发生变化，Canal马上就会去更新缓存，这样我们就把更新缓存的操作和业务代码解耦了；同时Canal也可以做大数据分析，它可以同时订阅多个数据库中的表，每当订阅的表发生改变，Canal就动态分析计算出一个新的表，之后我们可以操作这个新的表来实现一些功能，比如用户智能推荐功能：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117163401840.png" alt="image-20230117163401840"></p></li><li><p>该项目最终决定采用<strong>失效模式+读写锁</strong>来保证缓存和数据库的数据一致性：</p><ul><li>缓存的所有数据都有过期时间，数据过期后下一次查询触发主动更新</li><li>读写数据的时候，加上分布式的读写锁，对于频繁读，偶尔写的场景，加读写锁对系统的性能影响不大。</li></ul></li></ul><h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><ul><li><p>为了简化我们使用缓存的操作，spring专门抽取了一个包来<strong>统一不同的缓存技术以供我们进行使用</strong>，这就是Spring Cache。</p></li><li><p>Spring Cache中主要定义了两个接口，<strong>Cache和CacheManager</strong>，<strong>CacheMannager根据使用的缓存实现不同有很多种实现，其中管理着相同缓存实现下各种各样的根据我们逻辑划分的缓存组件，不过它只是相当于用来定义缓存规则的，其中存放的缓存组件才是真正帮我们crud数据的</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117171457073.png" alt="image-20230117171457073"></p></li></ul><h3 id="整合Spring-Cache"><a href="#整合Spring-Cache" class="headerlink" title="整合Spring Cache"></a>整合Spring Cache</h3><ul><li><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring-boot-starter-cache.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring-boot-starter-cache.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--spring cache--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-starter-cache.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>查看其自动配置类CacheAutoConfiguration，发现它会导入RedisCacheConfiguration等配置类，并且自动配置好了redis的缓存管理器RedisCacheManager：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(CacheProperties.class)</span><span class="comment">//这里面配置的都是在配置文件中可以进行配置的东西</span></span><br><span class="line"><span class="comment">//----------------------------------------</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CacheConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">CacheType[] types = CacheType.values();</span><br><span class="line">String[] imports = <span class="keyword">new</span> <span class="title class_">String</span>[types.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">imports[i] = CacheConfigurations.getConfigurationClass(types[i]);<span class="comment">//在这里通过所有缓存的配置类得到了所有类型的缓存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> imports;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">getConfigurationClass</span><span class="params">(CacheType cacheType)</span> &#123;</span><br><span class="line">Class&lt;?&gt; configurationClass = MAPPINGS.get(cacheType);<span class="comment">//根据缓存类型做映射</span></span><br><span class="line">Assert.state(configurationClass != <span class="literal">null</span>, () -&gt; <span class="string">&quot;Unknown cache type &quot;</span> + cacheType);</span><br><span class="line"><span class="keyword">return</span> configurationClass.getName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;CacheType, Class&lt;?&gt;&gt; MAPPINGS;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">Map&lt;CacheType, Class&lt;?&gt;&gt; mappings = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(CacheType.class);</span><br><span class="line">mappings.put(CacheType.GENERIC, GenericCacheConfiguration.class);</span><br><span class="line">mappings.put(CacheType.EHCACHE, EhCacheCacheConfiguration.class);</span><br><span class="line">mappings.put(CacheType.HAZELCAST, HazelcastCacheConfiguration.class);</span><br><span class="line">mappings.put(CacheType.INFINISPAN, InfinispanCacheConfiguration.class);</span><br><span class="line">mappings.put(CacheType.JCACHE, JCacheCacheConfiguration.class);</span><br><span class="line">mappings.put(CacheType.COUCHBASE, CouchbaseCacheConfiguration.class);</span><br><span class="line">mappings.put(CacheType.REDIS, RedisCacheConfiguration.class);<span class="comment">//在这儿</span></span><br><span class="line">mappings.put(CacheType.CAFFEINE, CaffeineCacheConfiguration.class);</span><br><span class="line">mappings.put(CacheType.SIMPLE, SimpleCacheConfiguration.class);</span><br><span class="line">mappings.put(CacheType.NONE, NoOpCacheConfiguration.class);</span><br><span class="line">MAPPINGS = Collections.unmodifiableMap(mappings);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="meta">@Bean</span><span class="comment">//向容器中注册了RedisCacheManager</span></span><br><span class="line">RedisCacheManager <span class="title function_">cacheManager</span><span class="params">(CacheProperties cacheProperties, CacheManagerCustomizers cacheManagerCustomizers,</span></span><br><span class="line"><span class="params">ObjectProvider&lt;org.springframework.data.redis.cache.RedisCacheConfiguration&gt; redisCacheConfiguration,</span></span><br><span class="line"><span class="params">ObjectProvider&lt;RedisCacheManagerBuilderCustomizer&gt; redisCacheManagerBuilderCustomizers,</span></span><br><span class="line"><span class="params">RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line"><span class="type">RedisCacheManagerBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(</span><br><span class="line">determineConfiguration(cacheProperties, redisCacheConfiguration, resourceLoader.getClassLoader()));</span><br><span class="line">List&lt;String&gt; cacheNames = cacheProperties.getCacheNames();</span><br><span class="line"><span class="keyword">if</span> (!cacheNames.isEmpty()) &#123;</span><br><span class="line">builder.initialCacheNames(<span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(cacheNames));</span><br><span class="line">&#125;</span><br><span class="line">redisCacheManagerBuilderCustomizers.orderedStream().forEach((customizer) -&gt; customizer.customize(builder));</span><br><span class="line"><span class="keyword">return</span> cacheManagerCustomizers.customize(builder.build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中配置使用redis作为缓存：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure></li><li><p>在配置类上开启缓存功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span><span class="comment">//开启缓存功能</span></span><br></pre></td></tr></table></figure></li><li><p>然后就可以使用注解来实现功能了：</p><ol><li>@Cacheable：用在方法上，触发将方法返回的数据保存到缓存的操作</li><li>@CacheEvict：用在方法上，触发将方法返回的数据从缓存中删除的操作，可以用作失效模式</li><li>@CachePut：用在方法上，在不影响方法执行的情况下更新缓存为方法的返回值，可以用作双写模式</li><li>@Caching：用在方法上，组合以上多个操作</li><li>@CacheConfig：用在类上，在类的级别共享缓存的相同配置</li></ol></li><li><p>对昨天写的代码用这种方式加缓存，比之前的代码简洁了不是一点半点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般每一个需要缓存的数据我们都来指定要放到哪个名字的逻辑分区中，推荐按照业务类型分区</span></span><br><span class="line"><span class="meta">@Cacheable(&#123;&quot;product-category&quot;&#125;)</span><span class="comment">//代表当前方法的结果需要缓存，如果缓存中有，那么方法可以直接不用调用，然后去缓存中取数据；如果缓存中没有，会调用方法，最后把方法的结果放入缓存中。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTree</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listWithTreeFromDb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117183129988.png" alt="image-20230117183129988"></p></li></ul><h3 id="Cacheable注解"><a href="#Cacheable注解" class="headerlink" title="@Cacheable注解"></a>@Cacheable注解</h3><ul><li><p>@Cacheable的默认行为：</p><ol><li>如果缓存中存在数据，那么方法直接不执行，直接用缓存中的数据</li><li>缓存的key默认自动生成，缓存默认的名字是分区名::SimpleKey []</li><li>缓存的value，默认使用jdk的序列化机制，将序列化后的数据存到redis中</li><li>默认TTL为-1</li></ol></li><li><p>可以用注解中的key属性来指定生成的缓存的key，不过这个属性接收的是一个spEL表达式，这个表达式的语法可以去官方找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key属性的参数是一个spEL表达式，下面这个表达式的意思是取方法的名字作为参数</span></span><br><span class="line"><span class="meta">@Cacheable(value = &#123;&quot;product-category&quot;&#125;,key = &quot;#root.method.name&quot;)</span><span class="comment">//value参数指定的是分组，key参数指定的是向redis中存放的key的名字</span></span><br></pre></td></tr></table></figure></li><li><p>指定缓存数据的TTL，可以在配置文件中统一修改，但是这样做可能会引起缓存雪崩，怎样把定义缓存TTL的粒度降下去呢?</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="comment">#设置缓存类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="comment">#设置ttl为300000毫秒</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="number">300000</span></span><br></pre></td></tr></table></figure></li><li><p>将数据保存为json格式怎么搞，要实现这个比较麻烦，通过追踪源码可以得知，spring cache会加载默认的RedisCacheConfiguration，所以我们只需要重新写一个RedisCacheConfiguration加入到Spring IOC容器中覆盖掉之前的那个即可，不过我们自定义后，就不走自动配置那条路了，所以要把自动配置的内容再写一份到我们自定义的那个配置类中以让配置文件中的配置生效，为了方便拿到配置文件中的数据，我们还应该把相应的属性类和当前的配置类进行绑定，这是springboot的内容，我有点不太熟练：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span><span class="comment">//开启缓存功能</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(CacheProperties.class)</span><span class="comment">//为了用CacheProperties，这是springboot的内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCacheConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//参数会自动从容器中找</span></span><br><span class="line">    RedisCacheConfiguration <span class="title function_">redisCacheConfiguration</span><span class="params">(CacheProperties cacheProperties)</span>&#123;<span class="comment">//其实容器中有这个，但是我们这样做相当于把之前那个存在的重写了，看源码可以得知，由于走这儿了就不走自动配置了，所以在配置文件中的配置也要写到这里来</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig();<span class="comment">//新建一个RedisCacheConfiguration</span></span><br><span class="line">        config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>()));<span class="comment">//指定key的序列化方式为string</span></span><br><span class="line">        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">GenericFastJsonRedisSerializer</span>()));<span class="comment">//指定value的序列化方式为json</span></span><br><span class="line">        CacheProperties.<span class="type">Redis</span> <span class="variable">redisProperties</span> <span class="operator">=</span> cacheProperties.getRedis();<span class="comment">//得到redis的配置</span></span><br><span class="line">        <span class="comment">//将配置文件中的所有内容生效，以下大部分内容来自源码</span></span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getTimeToLive() != <span class="literal">null</span>) &#123;</span><br><span class="line">            config = config.entryTtl(redisProperties.getTimeToLive());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getKeyPrefix() != <span class="literal">null</span>) &#123;</span><br><span class="line">            config = config.prefixCacheNameWith(redisProperties.getKeyPrefix());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isCacheNullValues()) &#123;</span><br><span class="line">            config = config.disableCachingNullValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isUseKeyPrefix()) &#123;</span><br><span class="line">            config = config.disableKeyPrefix();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还有几个常用配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="comment">#设置缓存类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="comment">#设置ttl为300000毫秒</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="number">300000</span></span><br><span class="line">      <span class="comment">#设置缓存key的前缀，如果不设置则默认使用缓存组件的名字，可以设置开启或不开启</span></span><br><span class="line">  <span class="attr">key-prefix:</span> <span class="string">CACHE_</span></span><br><span class="line">  <span class="attr">use-key-prefix:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#是否缓存空值，开启可以避免缓存穿透</span></span><br><span class="line">  <span class="attr">cache-null-values:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="CacheEvict注解"><a href="#CacheEvict注解" class="headerlink" title="@CacheEvict注解"></a>@CacheEvict注解</h3><ul><li><p>可以<strong>用在更新&#x2F;删除数据的方法上，每次数据更新都会删掉它的缓存，直到下一次查库主动更新缓存，这样其实就是失效模式的实现</strong>。</p></li><li><p>删除单个key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(value = &quot;category&quot;,key = &quot;listWithTree&quot;)</span><span class="comment">//value指定分区，key指定要删除的key的名字</span></span><br></pre></td></tr></table></figure></li><li><p>如果有一些场景需要删除多个key（比如级联删除）怎么办？有两个方法：</p><ol><li><p>首先可以用之间介绍到的@Caching方法组合多个@CacheEvict注解来实现删除多个key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching(evict = &#123;</span></span><br><span class="line"><span class="meta">    @CacheEvict(value = &quot;category&quot;,key = &quot;listWithTree&quot;),</span></span><br><span class="line"><span class="meta">    @CacheEvict(value = &quot;category&quot;,key = &quot;listWithTree2&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p>然后就是可以在@CacheEvict注解中给allEntries属性设置为true，这样它就会把那个分区中的所有缓存都删掉，这个分区只是在spring中标识，其中存着那个key属于哪个分区，实际上redis中不存在什么分区什么的，所以才叫它逻辑分区嘛，所以以后我们尽量把数据分好区，这样删的时候也好删：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(value = &quot;category&quot;,allEntries = true)</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>推荐开启key的前缀，这样存的key在RedisDesktopManager中会以树形呈现，每一段之间用冒号隔开，比较方便查看。</p></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>解决<strong>缓存穿透</strong>问题：在配置文件中配置允许缓存空数据：<code>spring.cache.redis.cache-null-values=true</code></li><li>解决<strong>缓存击穿</strong>问题：<ol><li>自己写本地锁或者是用redisson的分布式锁</li><li>将@Cacheable注解的sync属性设置为true，不过其中给的实现是本地锁：<code>@Cacheable(value = &#123;&quot;product-category&quot;&#125;,key = &quot;#root.method.name&quot;,sync = true)</code></li></ol></li><li>解决<strong>缓存雪崩</strong>问题：给数据加上随机的过期时间，给数据加过期时间可以在配置文件中进行配置，时间的单位是毫秒：<code>spring.cache.redis.time-to-live=30000</code></li><li>解决<strong>缓存和数据库的一致性</strong>问题：<ol><li>读写加锁</li><li>引入Canal中间件，感知到MySQL的更新后去更新缓存</li><li>对于读少写多的数据，直接去数据库查就行了</li></ol></li><li>对于<strong>常规数据</strong>（读多写少，及时性、一致性要求不高的数据），可以使用Spring Cache，使用的时候对于写模式往往是只要有过期时间就足够了。</li><li>对于<strong>特殊数据</strong>，只能具体问题具体分析了，需要特殊的设计，可以结合前面的Redisson分布式锁以及JUC本地锁来实现。</li></ul><h1 id="2023-x2F-1-x2F-18"><a href="#2023-x2F-1-x2F-18" class="headerlink" title="2023&#x2F;1&#x2F;18"></a>2023&#x2F;1&#x2F;18</h1><h2 id="看到句名言"><a href="#看到句名言" class="headerlink" title="看到句名言"></a>看到句名言</h2><ul><li>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</li></ul><h1 id="2023-x2F-1-x2F-19"><a href="#2023-x2F-1-x2F-19" class="headerlink" title="2023&#x2F;1&#x2F;19"></a>2023&#x2F;1&#x2F;19</h1><h2 id="尝试提前给前端向后端传的数据约定好解析方式"><a href="#尝试提前给前端向后端传的数据约定好解析方式" class="headerlink" title="尝试提前给前端向后端传的数据约定好解析方式"></a>尝试提前给前端向后端传的数据约定好解析方式</h2><ul><li>有一些表示我们可以做一下提前的约定，然后后端按照约定去解析条件，比如我想要从前端用一个变量传递一个数字区间到后端，那么我们可以约定这个变量是string的，然后这个string中有两个数字，数字之间用一个下划线分开，那两个数字就是左右边界，那么后端就根据这个约定来解析这个条件后再去做一些操作。</li><li>总而言之就是，对于那些前端不好表达的条件，我们可以提前做个约定，约定一下这样的数据前端怎样表示，后端怎样解析，之后我们就可以按照这样的约定去实现对应的功能了。</li></ul><h2 id="如何完成一个ES的查询"><a href="#如何完成一个ES的查询" class="headerlink" title="如何完成一个ES的查询"></a>如何完成一个ES的查询</h2><ul><li>首先根据需求设计出<strong>DSL语句</strong>、<strong>设计VO类封装查询条件</strong></li><li>然后在java的service层方法中<strong>使用es提供的api（主要是一些builder）根据DSL语句和传过来的VO查询条件实例结合约定来构建查询</strong></li><li>最后就是<strong>执行，然后解析返回的结果</strong>，可以<strong>把解析的结果封装成一个返回结果的实体类</strong>，用于视图数据</li></ul><h2 id="尝试在VO中使用静态内部类"><a href="#尝试在VO中使用静态内部类" class="headerlink" title="尝试在VO中使用静态内部类"></a>尝试在VO中使用静态内部类</h2><ul><li>如果有些类型从逻辑上是属于这个vo，那么我们可以在这个vo中写静态内部类来表示这些类型，从逻辑上看比较合理，维护起来也方便。</li></ul><h1 id="2023-x2F-1-x2F-20"><a href="#2023-x2F-1-x2F-20" class="headerlink" title="2023&#x2F;1&#x2F;20"></a>2023&#x2F;1&#x2F;20</h1><h2 id="初始化线程的四种方式"><a href="#初始化线程的四种方式" class="headerlink" title="初始化线程的四种方式"></a>初始化线程的四种方式</h2><ol><li><p>继承Thread，重写run方法，然后new实例调用start方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread01</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;这里是main方法线程~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Thread01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用继承Thread类的方式来初始化线程~&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程启动,线程id为：&quot;</span>+<span class="built_in">this</span>.getId());</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;这里是&quot;</span>+<span class="built_in">this</span>.getId()+<span class="string">&quot;号线程~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Runnable接口，重写run方法，然后把它的实例当作参数传入Thread实例的构造器中，最后用Thread实例调用start方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable01</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;这里是main方法线程~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Runnable01</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用实现Runnable接口的方式来初始化线程~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Callable接口+FutureTask（可以拿到返回结果，可以处理异常）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable01</span>());<span class="comment">//也可以接收Runnable的实现类</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程返回结果是：&quot;</span>+futureTask.get());<span class="comment">//这个是等待线程执行完毕之后获取结果,当前线程会阻塞在这里</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;这里是main方法线程~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Callable01</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;<span class="comment">//Callable接口的泛型是线程返回值类型</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用实现Runnable接口的方式来初始化线程~&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程启动,线程id为：&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程池，每个系统中只有少数线程池，<strong>项目业务中所有的多线程异步任务都应该交给线程池执行</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;()</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        pool.execute(<span class="keyword">new</span> <span class="title class_">Runnable01</span>());</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;这里是main方法线程~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>第1、2种方式不能得到返回值，第3、4种方式可以得到返回值。</li><li>第1、2、3种方式都不能控制资源，第4种方式可以控制资源，性能稳定。</li><li>总之，以后业务中所有异步任务都用第4种方式处理，也就是使用线程池。</li></ul><h2 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h2><ul><li><strong>降低资源的消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>：因为线程池中的线程数没有超过线程池的最大线程数时，有的线程处于等待分配任务的状态，当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h2 id="线程池（ThreadPoolExecutor）详解"><a href="#线程池（ThreadPoolExecutor）详解" class="headerlink" title="线程池（ThreadPoolExecutor）详解"></a>线程池（ThreadPoolExecutor）详解</h2><ul><li>jdk给我们提供了比较简单的创建线程池的方法，那就是使用Executors类中的方法来创建一些预配置好的线程池，但是阿里巴巴开发手册中不推荐这样的创建方式，主要原因是里面的大部分方法创建的线程池都有OOM的风险，而且几乎不能让程序员能够更深入地理解线程池的各种参数。所以<strong>阿里巴巴开发手册中推荐使用原生创建线程池的方式ThreadPoolExecutor，所有的参数都由自己来进行设置，降低OOM的概率，并且还能加深对于线程池参数的理解</strong>，所以下面的内容都是在详解ThreadPoolExecutor。</li><li>值得注意的是，线程池的存在会阻塞住使用线程池的那个线程，所以程序会一直等待任务直至线程池销毁程序才会结束。</li></ul><h3 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h3><ol><li><strong>int corePoolSize</strong>：核心线程数，这些线程按需创建，也就是<strong>懒加载</strong>，一开始没有核心线程创建，直到有任务过来，核心线程被创建，但是任务结束后，核心线程即使空闲也不会销毁（除非设置了核心线程的存活时间），而是重新等待异步任务的到来。当线程池中new的线程数达到核心线程数之后，再有任务过来，任务就会被装到等待队列中，等待核心线程空闲，一旦核心线程有空闲，那么等待队列就会pop出一个任务使用空闲的核心线程来执行。</li><li><strong>int maximumPoolSize</strong>：最大线程数，在核心线程都忙碌且任务队列也满着的情况下，如果有任务再来，那么任务队列会pop一个任务，创建一个新的线程去执行它，并把刚来的任务放到任务队列中，刚才新创建的线程不属于核心线程，因为在创建它的时候核心线程已经满了，它也并非是永久存在的，因为第三个参数就是设置了核心线程外空闲线程的存活时间，一旦过了存活时间，这些多出来的<strong>空闲</strong>线程就会被自动销毁以达到控制资源的目的。<strong>最大线程数包括核心线程数</strong>，也就是说还能额外创建的线程数等于最大线程数-核心线程数</li><li><strong>long keepAliveTime</strong>：非核心<strong>空闲</strong>线程的存活时间，一旦非核心线程<strong>空闲的时间</strong>达到我们设置的值，那么那个非核心空闲线程就会被摧毁，这样可以达到控制资源的目的。换句话说，这是多余的空闲线程在终止前等待新任务的最长时间。</li><li><strong>TimeUnit unit</strong>：时间单位，就是上一个参数的时间单位（秒、毫秒、分啥的），这个没啥好说的</li><li><strong>BlockingQueue&lt;Runnable&gt; workQueue</strong>：阻塞队列，这个就是用来指定当核心线程数满且都在忙碌的情况下新来的任务应该装到的任务队列，一旦有线程空闲，那么队列中就会pop出一个任务来使用空闲线程执行。<strong>一定要指定队列大小</strong>，一些阻塞队列的默认容量是int的最大值，在任务数量很多的情况下可能会出现OOM。</li><li><strong>ThreadFactory threadFactory</strong>：线程的创建工厂，用于线程池创建新线程的时候，有默认实现（不填该参数或者用Executors.defaultThreadFactory()获得），如果想要自定义可以自己写一个。</li><li><strong>RejectedExecutionHandler handler</strong>：拒绝策略，就是指定当线程池和任务队列都满了的情况下，再来任务应该如何处理，有默认实现，默认是使用丢弃策略（不填该参数或者用new ThreadPoolExecutor.AbortPolicy()获得），就是线程池和任务队列都满了的情况下会直接丢弃后来的任务。还有直接调用任务的run方法（这样就是同步而非异步调用了，使用的线程是跑线程池的那个线程）的策略等。</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120164900396.png" alt="image-20230120164900396"></p><h2 id="CompletableFuture异步编排"><a href="#CompletableFuture异步编排" class="headerlink" title="CompletableFuture异步编排"></a>CompletableFuture异步编排</h2><ul><li>在我们执行异步任务的时候，可能出现一种情况，就是多个异步任务之间有一定的执行顺序，比如有两个异步任务A、B，异步任务B的执行依赖于异步任务A的返回值，那么这两个异步任务的执行就会有个先后顺序，我们需要对这些异步任务进行编排以让他们按照我们想要的顺序进行执行，那么我们怎么才能实现这种操作呢？可以使用CompletableFuture来做异步编排，这是JDK1.8之后新增的内容。</li><li>Future&lt;T&gt;接口：定义异步操作的结果，可以<strong>获取异步结果</strong>。</li><li>CompletableFuture就像js中的Promise一样，本质上都是封装了一个有逻辑的异步任务，然后通过链式编程有条不紊地编排任务并执行。</li><li>这个类中基本所有的api的返回值类型都是CompletableFuture，这就为我们<strong>链式编排异步任务</strong>提供了方便，<strong>其中的异步方法产生的效果都是针对这一整个异步任务链来说的</strong>，比如后面的allOf方法，并不是说所有异步任务都执行完后再执行当前线程，而是所有的异步任务都执行完后再执行返回的CompletableFuture之后的链上的操作，本质上它还是异步的，和当前线程没有关系。</li></ul><h3 id="创建异步对象"><a href="#创建异步对象" class="headerlink" title="创建异步对象"></a>创建异步对象</h3><ul><li><p>CompletableFuture提供了四个静态方法来创建一个异步操作：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120175236094.png" alt="image-20230120175236094"></p></li><li><p>可以从上面看到，<strong>runAsync方法是没有返回结果的，supplyAsync方法是有返回结果的</strong>。</p></li><li><p>传入的异步操作<strong>会用默认的线程池执行，但是也可以传入自定义的线程池，让异步任务用自定义的线程池执行</strong>。</p></li><li><p><strong>Runnable和Supplier都是函数式接口</strong>，所以这些方法都<strong>可以使用lambda表达式来作为参数</strong>。</p></li><li><p>runAsync方法使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程~&quot;</span>);</span><br><span class="line">        &#125;,pool);</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>supplyAsync方法使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面那些方法最后都会返回一个Completable类型的结果，我们可以使用这个返回值的方法来做异步编排，就类似于js中的Future中的then方法、error方法啥的</p></li></ul><h3 id="计算完成时的回调方法"><a href="#计算完成时的回调方法" class="headerlink" title="计算完成时的回调方法"></a>计算完成时的回调方法</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120185615279.png" alt="image-20230120185615279"></p><ul><li><p><strong>whenComplete</strong>可以处理正常和异常的<strong>计算结果</strong>，<strong>exceptionally</strong>处理<strong>异常情况</strong>，带async后缀的是指这个方法仍是交给线程池来异步执行，不带async后缀的就是使用当前线程同步执行。</p></li><li><p>非常非常非常像js的异步编程，whenComplete就类似js中Promise的then方法，exceptionally就类似js中Promise的error方法。</p></li><li><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">0</span>;</span><br><span class="line">        &#125;, pool).whenComplete((res,exception)-&gt;&#123;<span class="comment">//可以获取返回值和异常，但是无法修改返回数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;异步任务成功完成,结果是：&quot;</span>+res+<span class="string">&quot;异常是：&quot;</span>+exception);</span><br><span class="line">        &#125;).exceptionally(exception-&gt;<span class="number">10</span>);<span class="comment">//感知异常，可以修改返回数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="handle方法"><a href="#handle方法" class="headerlink" title="handle方法"></a>handle方法</h3><ul><li><p>可对结果做最后的处理，可以处理异常，可以改变返回值等，聚合了之前whenComplete和exceptionally方法的功能。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120190826146.png" alt="image-20230120190826146"></p></li><li><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">2</span>;</span><br><span class="line">        &#125;, pool).handle((res,err)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (res!=<span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程串行化方法"><a href="#线程串行化方法" class="headerlink" title="线程串行化方法"></a>线程串行化方法</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120192513872.png" alt="image-20230120192513872">、</p><ul><li><p>这些方法实际上就可以解决我们之前提出的那个问题，就是如何保证A、B两个异步方法的执行顺序。</p></li><li><p><strong>thenApply方法</strong>：当一个线程依赖另一个线程的返回结果时，获取上一个任务返回的结果，进行相应操作后，返回当前任务的返回值。带async的是异步执行。</p></li><li><p><strong>thenAccept方法</strong>：接收上一个任务的返回结果，并消费这个结果进行相应的操作，当前任务无返回结果。带async的是异步执行。</p></li><li><p><strong>thenRun方法</strong>：无法接收上一个任务的返回结果，上一个任务执行完成后，执行当前任务，当前任务无返回值。带async的是异步执行。</p></li><li><p>以上方法都在上一个任务执行结束后执行。</p></li><li><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程~&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;第一个方法执行~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">0</span>;</span><br><span class="line">        &#125;, pool).thenApply(res-&gt;&#123;<span class="comment">//拿到上一个任务的返回值，做操作，然后再返回，好像Stream的转换流...</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第二个方法执行~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        &#125;).exceptionally(err-&gt;<span class="string">&quot;10&quot;</span>);<span class="comment">//中间任何一个任务出现问题都会直接跳到这里来</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>之前的whenComplete和exceptionally方法都是针对整个异步方法链的，方法链中任何一个地方出现异常都会直接跳到最后的exceptionally方法。</p></li></ul><h3 id="两任务组合-都完成后执行第三个任务"><a href="#两任务组合-都完成后执行第三个任务" class="headerlink" title="两任务组合-都完成后执行第三个任务"></a>两任务组合-都完成后执行第三个任务</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120195142611.png" alt="image-20230120195142611"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120195207076.png" alt="image-20230120195207076"></p><ul><li><p><strong>thenCombine方法</strong>：组合两个异步任务，获取两个异步任务的返回结果，处理第三个任务，并返回第三个任务的返回结果。带async的是异步执行第三个任务。</p></li><li><p><strong>thenAcceptBoth方法</strong>：组合两个异步任务，获取两个异步任务的返回结果，处理第三个任务，第三个任务没有返回值。带async的是异步执行第三个任务。</p></li><li><p><strong>runAfterBoth方法</strong>：组合两个异步任务，不获取两个异步任务的返回结果，处理第三个任务，第三个任务没有返回值。带async的是异步执行第三个任务。</p></li><li><p><strong>任务三是在以上方法的参数中定义的</strong>。</p></li><li><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程1~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">2</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程2~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">5</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future03 = future01.thenCombineAsync(future02,(e1,e2)-&gt;e1+e2,pool).exceptionally(err-&gt;<span class="number">10</span>);<span class="comment">//任务1、2都结束后任务3才开始,这个方法任务3可以拿到任务1、2的返回值，并且任务3也能有返回值</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future03.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="两任务组合-一个任务完成后执行第三个任务"><a href="#两任务组合-一个任务完成后执行第三个任务" class="headerlink" title="两任务组合-一个任务完成后执行第三个任务"></a>两任务组合-一个任务完成后执行第三个任务</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120214254090.png" alt="image-20230120214254090"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120214317865.png" alt="image-20230120214317865"></p><ul><li><p><strong>applyToEither方法</strong>：两个任务中有一个任务完成后，获取它的返回值，处理第三个任务，并有新的返回值。带async的是异步执行第三个任务。</p></li><li><p><strong>acceptEither方法</strong>：两个任务中有一个任务完成后，获取它的返回值，处理第三个任务，没有新的返回值。带async的是异步执行第三个任务。</p></li><li><p><strong>runAfterEither方法</strong>：两个任务中有一个任务完成后，不获取它的返回值，处理第三个任务，没有新的返回值。带async的是异步执行第三个任务。</p></li><li><p><strong>任务一、二的返回值类型要相同</strong>，不然任务三都不知道怎么接收上一个任务的参数了。</p></li><li><p><strong>任务三是在以上方法的参数中定义的</strong>。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//睡上一觉模拟第一个任务执行较慢，看看任务3能否在任务2结束后顺利执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程1~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">2</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程2~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">5</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future03 = future01.applyToEitherAsync(future02,e-&gt;e,pool).exceptionally(err-&gt;<span class="number">10</span>);<span class="comment">//任务1、2的其中一个任务结束后任务3就会开始,这个方法任务3可以拿到先结束的那个任务的返回值，并且任务3也能有返回值</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future03.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="多任务组合"><a href="#多任务组合" class="headerlink" title="多任务组合"></a>多任务组合</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120220345334.png" alt="image-20230120220345334"></p><ul><li><p><strong>allOf方法</strong>：等待所有任务都完成后，再执行返回的CompletableFuture后面的操作，不能获取任务的返回值。</p></li><li><p><strong>anyOf方法</strong>：只要有一个任务完成，就执行返回的CompletableFuture后面的操作，可以获取第一个完成的任务的返回值。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//睡上一觉模拟第一个任务执行较慢，看看任务3能否在任务2结束后顺利执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程1~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">2</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程2~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">5</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future03 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程3~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Void&gt; future04 = CompletableFuture.allOf(future01, future02, future03);<span class="comment">//必须所有任务都执行完，才可以执行future04后面的操作</span></span><br><span class="line">        future04.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//睡上一觉模拟第一个任务执行较慢，看看任务3能否在任务2结束后顺利执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程1~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">2</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程2~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">5</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future03 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程3~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Object&gt; future04 = CompletableFuture.anyOf(future01, future02, future03);<span class="comment">//只要有一个任务执行完，那么就可以执行future04后面的操作了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最先执行完的那个任务的返回值是：&quot;</span>+future04.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用异步编排来获取一个网页的资源"><a href="#使用异步编排来获取一个网页的资源" class="headerlink" title="使用异步编排来获取一个网页的资源"></a>使用异步编排来获取一个网页的资源</h2><ul><li>如果获取网页资源的操作都是同步的，那么加载一个页面需要的时间是很长的，所以我们可以使用异步的方法来加载网页资源，这样网页资源加载完成的时间就只取决于所有异步操作中最慢的那个了，但是由于加载资源的异步操作可能有顺序上的要求，所以我们要对这些异步请求资源的方法来进行异步编排来保证最终结果的正确性。</li></ul><h1 id="2023-x2F-1-x2F-23"><a href="#2023-x2F-1-x2F-23" class="headerlink" title="2023&#x2F;1&#x2F;23"></a>2023&#x2F;1&#x2F;23</h1><h2 id="快速定位网页元素在代码中的位置"><a href="#快速定位网页元素在代码中的位置" class="headerlink" title="快速定位网页元素在代码中的位置"></a>快速定位网页元素在代码中的位置</h2><ul><li>页面跑起来之后打开浏览器的开发者工具（摁f12），然后点最左上角的按钮（审查元素），然后点击想要定位的元素，就能跳转到指定元素在代码中对应的位置了。</li></ul><h2 id="ToString注解"><a href="#ToString注解" class="headerlink" title="@ToString注解"></a>@ToString注解</h2><ul><li>是lombok中的一个注解，将该注解写在类上，可以自动生成该类的toString方法。</li></ul><h2 id="如何在MyBatis的xml文件中引用一个内部类"><a href="#如何在MyBatis的xml文件中引用一个内部类" class="headerlink" title="如何在MyBatis的xml文件中引用一个内部类"></a>如何在MyBatis的xml文件中引用一个内部类</h2><ul><li><p>MyBatis的xml文件的标签中的很多属性都要求给一个完全类路径的参数，别的类没啥问题，但是<strong>如果要是使用到内部类，那么在传参的时候最后一个分隔符不能用“.”，而应该用“$”</strong>，要不然就会报无法解析那个内部类的错误。</p></li><li><p>代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;SpuItemAttrGroupVo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.konjacer.mallisland.product.entity.vo.SkuItemVo$SpuItemAttrGroupVo&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="对于有嵌套属性的返回值使用MyBatis的自定义结果集封装"><a href="#对于有嵌套属性的返回值使用MyBatis的自定义结果集封装" class="headerlink" title="对于有嵌套属性的返回值使用MyBatis的自定义结果集封装"></a>对于有嵌套属性的返回值使用MyBatis的自定义结果集封装</h2><ul><li><p>对于写在xml文件中的sql语句的<strong>有嵌套属性的返回值</strong>，我们应该创建一个resultMap并在crud标签的<strong>resultMap属性</strong>指定成我们自定义的resultMap，这样做可以使得查出来的数据能够准确地映射到我们指定的位置，其中的嵌套属性中的数据我们需要手动和查出来的数据作映射，这样查出来的数据就可以映射到嵌套属性中了。如果不使用自定义的resultMap，那么mybatis不知道怎么把查出来的结果和返回值中的嵌套属性做映射，返回的结果就会出错。</p></li><li><p>代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--返回值中有嵌套属性的，要声明自定义的结果集来作为最后的返回值，不然mybatis不知道怎么把数据映射到嵌套属性中。注意内部类完全路径的写法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;SpuItemAttrGroupVo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.konjacer.mallisland.product.entity.vo.SkuItemVo$SpuItemAttrGroupVo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;groupName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;attr_group_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置其中的集合属性的映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;attrs&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.konjacer.mallisland.product.entity.vo.SkuItemVo$SpuBaseAttrVo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;attr_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;attrName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;attr_value&quot;</span> <span class="attr">property</span>=<span class="string">&quot;attrValue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--resultType声明的是返回的集合类型里面元素的类型--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--此处的联表查询只是为了熟悉操作，真正开发时尽量不要使用联表查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAttrGroupWithAttrsBySpuId&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">&quot;SpuItemAttrGroupVo&quot;</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">        pav.`spu_id`,ag.`attr_group_name`,ag.`attr_group_id`,</span><br><span class="line">        aar.`attr_id`,attr.`attr_id`,pav.`attr_value`</span><br><span class="line">    FROM `pms_attr_group` ag</span><br><span class="line">        LEFT JOIN `pms_attr_attrgroup_relation` aar ON aar.`attr_group_id` = ag.`attr_group_id`</span><br><span class="line">        LEFT JOIN `pms_attr` attr ON attr.`attr_id` = aar.`attr_id`</span><br><span class="line">        LEFT JOIN `pms_product_attr_value` pav ON pav.`attr_id` = attr.`attr_id`</span><br><span class="line">    WHERE ag.catelog_id = #&#123;catalogId&#125; AND pav.`spu_id` = #&#123;spuId&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="将对应的配置和实体类进行绑定"><a href="#将对应的配置和实体类进行绑定" class="headerlink" title="将对应的配置和实体类进行绑定"></a>将对应的配置和实体类进行绑定</h2><ul><li><p>先导入一个包以开启和配置相关的代码提示，不导入这个包也不影响后续的操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启springboot和配置相关的代码提示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>需要用到注解**<code>@ConfigurationProperties</code><strong>，该注解可以把配置文件中指定前缀的配置和被其修饰的类绑定，类中的</strong>非静态属性<strong>可以通过</strong>前缀和属性名**在配置文件中进行配置。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mallisland.thread&quot;)</span><span class="comment">//指定要绑定的前缀</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//注册到IOC容器中方便后续使用</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfigProperties</span> &#123;<span class="comment">//配置实体类</span></span><br><span class="line">    <span class="keyword">private</span> Integer coreSize;</span><br><span class="line">    <span class="keyword">private</span> Integer maxSize;</span><br><span class="line">    <span class="keyword">private</span> Integer keepAliveTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置线程池的相关属性，用的是自定义的配置实体类，使用前缀+属性名来对实体类中的属性进行配置</span></span><br><span class="line"><span class="attr">mallisland:</span></span><br><span class="line">  <span class="attr">thread:</span></span><br><span class="line">    <span class="attr">core-size:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">max-size:</span> <span class="number">200</span></span><br><span class="line">    <span class="attr">keep-alive-time:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></li><li><p>要想使用自定义的配置实体类，可以使用相应注解将其加入到ioc容器中。还有一点就是，<strong>被@Bean修饰的方法的参数可以自动注入，不需要任何额外的注解</strong>，使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">threadPool</span><span class="params">(ThreadPoolConfigProperties pool)</span>&#123;<span class="comment">//参数自动注入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            pool.getCoreSize(),</span><br><span class="line">            pool.getMaxSize(),</span><br><span class="line">            pool.getKeepAliveTime(),</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100000</span>),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">            );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>除了将自定义的配置实体类加入到ioc容器中外，还可以通过给<strong>配置类</strong>加上**<code>@EnableConfigurationProperties</code>**注解来开启对应的配置实体类，将指定的类注入到ioc容器中，使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ThreadPoolConfigProperties.class)</span><span class="comment">//开启使用指定的配置实体类，将指定的类注册进ioc容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">threadPool</span><span class="params">(ThreadPoolConfigProperties pool)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                pool.getCoreSize(),</span><br><span class="line">                pool.getMaxSize(),</span><br><span class="line">                pool.getKeepAliveTime(),</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100000</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="给模块添加一个线程池"><a href="#给模块添加一个线程池" class="headerlink" title="给模块添加一个线程池"></a>给模块添加一个线程池</h2><ul><li>可以<strong>在配置类中new一个线程池通过@Bean注解注册到ioc容器中</strong></li><li>然后线程池的参数应该是可在配置文件中配置的，所以我们要<strong>写一个配置实体类来表示我们允许配置的属性</strong></li><li>然后<strong>将配置实体类和对应前缀的配置绑定</strong>，这样以后我们就能通过在配置文件中配置的方式来改变配置实体类中的属性值了</li><li>然后我们<strong>将配置实体类注册到ioc容器中</strong>，之后就可以在创建线程池的方法中使用配置实体类的属性值作为线程池的参数了。</li></ul><h2 id="对业务逻辑进行异步编排优化示例"><a href="#对业务逻辑进行异步编排优化示例" class="headerlink" title="对业务逻辑进行异步编排优化示例"></a>对业务逻辑进行异步编排优化示例</h2><ul><li><p>其中第2、3、4个任务只依赖于第1个任务的返回值，第5个任务不依赖任何返回值，除了第1个任务外都没有返回值，所以先异步执行任务1、5（无先后顺序），然后得到1的返回值后再异步执行任务2、3、4（无先后顺序），最后通过<strong>使用allOf方法和get方法阻塞直到所有任务完成（真正起到阻塞当前线程的是get方法，allof方法只是阻塞了异步任务链）</strong>然后返回结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SkuItemVo <span class="title function_">item</span><span class="params">(String skuId)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">SkuItemVo</span> <span class="variable">skuItemVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkuItemVo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sku基本信息获取,查pms_sku_info</span></span><br><span class="line">    CompletableFuture&lt;PmsSkuInfo&gt; infoFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="type">PmsSkuInfo</span> <span class="variable">info</span> <span class="operator">=</span> getById(skuId);</span><br><span class="line">        skuItemVo.setInfo(info);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取spu的销售属性组合，依赖于第一个任务的返回值</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; saleAttrFuture = infoFuture.thenAcceptAsync((res) -&gt; &#123;</span><br><span class="line">        List&lt;SkuItemVo.SkuItemSaleAttrVo&gt; saleAttrVos = pmsSkuSaleAttrValueService.getSaleAttrsBySpuId(res.getSpuId());</span><br><span class="line">        skuItemVo.setSaleAttr(saleAttrVos);</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取spu的介绍,查pms_spu_info_desc，依赖于第一个任务的返回值</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; descFuture = infoFuture.thenAcceptAsync((res) -&gt; &#123;</span><br><span class="line">        <span class="type">PmsSpuInfoDesc</span> <span class="variable">spuInfoDescEntity</span> <span class="operator">=</span> pmsSpuInfoDescService.getById(res.getSpuId());</span><br><span class="line">        skuItemVo.setDesp(spuInfoDescEntity);</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取spu的规格参数信息，依赖于第一个任务的返回值</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; baseAttrFuture = infoFuture.thenAcceptAsync((res) -&gt; &#123;</span><br><span class="line">        List&lt;SkuItemVo.SpuItemAttrGroupVo&gt; attrGroupVos = pmsAttrGroupService.getAttrGroupWithAttrsBySpuId(res.getSpuId(), res.getCatalogId());</span><br><span class="line">        skuItemVo.setGroupAttrs(attrGroupVos);</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取sku的图片信息，查pms_sku_images</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; imageFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        List&lt;PmsSkuImages&gt; images = pmsSkuImagesService.getImagesBySkuId(skuId);</span><br><span class="line">        skuItemVo.setImages(images);</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞等待直到所有任务都完成，后面的get方法是必须的，不然没有阻塞当前线程的效果，会还没等任务都完成就返回了，因为这里的allOf方法是针对异步任务链来说的，本质上allOf还是异步任务</span></span><br><span class="line">    CompletableFuture</span><br><span class="line">            .allOf(infoFuture,saleAttrFuture,descFuture,baseAttrFuture,imageFuture)</span><br><span class="line">            .get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> skuItemVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2023-x2F-1-x2F-24"><a href="#2023-x2F-1-x2F-24" class="headerlink" title="2023&#x2F;1&#x2F;24"></a>2023&#x2F;1&#x2F;24</h1><h2 id="注册组件的时候一定使用准确的注解"><a href="#注册组件的时候一定使用准确的注解" class="headerlink" title="注册组件的时候一定使用准确的注解"></a>注册组件的时候一定使用准确的注解</h2><ul><li>就是某一层的组件往ioc容器里注册的时候就应该使用对应层的注册组件的注解，比如Controller层用@Controller注解，Service层用@Service注解，dao层用@Repository，普通的组件用@Component。</li><li>之前一直以为这四个注解完全相同，现在才直到<strong>这些组件或多或少都会有一点自己特化的功能（比如被@Controller 注解的bean会被spring-mvc框架所使用；被@Repository 注解的bean会被作为持久层操作（数据库）的bean来使用），有的时候用错可能会出问题，所以一定要保证使用的注解是对应层的注解</strong>。</li></ul><h2 id="使用SpringMVC的内容配置视图映射"><a href="#使用SpringMVC的内容配置视图映射" class="headerlink" title="使用SpringMVC的内容配置视图映射"></a>使用SpringMVC的内容配置视图映射</h2><ul><li><p>省的写页面跳转的Controller了，代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallislandWebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;<span class="comment">//配置视图映射</span></span><br><span class="line">        registry.addViewController(<span class="string">&quot;/login.html&quot;</span>).setViewName(<span class="string">&quot;login&quot;</span>);<span class="comment">//设置视图名称会结合themeleaf中的前后缀形成完整的跳转路径</span></span><br><span class="line">        registry.addViewController(<span class="string">&quot;/reg.html&quot;</span>).setViewName(<span class="string">&quot;reg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>值得注意的是这种映射方式只有get方式才能访问到，因为要进行转发，而转发的对象要求使用get方式进行访问。</p></li></ul><h2 id="整合阿里云短信服务（SMS）"><a href="#整合阿里云短信服务（SMS）" class="headerlink" title="整合阿里云短信服务（SMS）"></a>整合阿里云短信服务（SMS）</h2><ul><li><p>其实就是跟着官网的api文档来，然后一步步修修改改，核心代码抽一抽，解解耦，做做组件，映射一下组件的非静态属性到配置文件，指不定哪天官网又改了调用api的方式了，所以下面的内容仅供参考。</p></li><li><p>先<strong>在第三方服务的模块中整合阿里云短信服务并暴露接口</strong></p></li><li><p>首先根据官网的提示，先引入SMS服务用到的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--阿里云短信服务的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dysmsapi20170525<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后把官网给的示例代码改改做成一个ioc组件，把一些可配置的内容抽出去变成非静态属性，并将它们和配置文件中指定的前缀绑定，这样我们就可以在配置文件中配置这些内容了。<strong>本质上这个服务还是向阿里云的指定域名发送请求</strong>，请求参数可以自定义以实现不同的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.cloud.alicloud&quot;)</span><span class="comment">//和配置文件指定前缀的配置进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下五个变量做成可配置的，从配置文件中读取值赋值给属性是基于属性的set方法的，所以类上要加@Data注解</span></span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> <span class="string">&quot;dysmsapi.aliyuncs.com&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">templateCode</span> <span class="operator">=</span> <span class="string">&quot;SMS_154950909&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">signName</span> <span class="operator">=</span> <span class="string">&quot;阿里云短信测试&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用AK&amp;SK初始化账号Client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> com.aliyun.dysmsapi20170525.Client <span class="title function_">createClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        com.aliyun.teaopenapi.models.<span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.teaopenapi.models.Config()</span><br><span class="line">                <span class="comment">// 必填，您的 AccessKey ID</span></span><br><span class="line">                .setAccessKeyId(accessKey)</span><br><span class="line">                <span class="comment">// 必填，您的 AccessKey Secret</span></span><br><span class="line">                .setAccessKeySecret(secretKey);</span><br><span class="line">        <span class="comment">// 访问的域名</span></span><br><span class="line">        config.endpoint = endpoint;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.dysmsapi20170525.Client(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSmsCode</span><span class="params">(String phoneNum,String code)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//System.out.println(accessKey+&quot; &quot;+secretKey);</span></span><br><span class="line">        <span class="comment">// 工程代码泄露可能会导致AccessKey泄露，并威胁账号下所有资源的安全性。以下代码示例仅供参考，建议使用更安全的 STS 方式，更多鉴权访问方式请参见：https://help.aliyun.com/document_detail/378657.html</span></span><br><span class="line">        com.aliyun.dysmsapi20170525.<span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> createClient();</span><br><span class="line">        com.aliyun.dysmsapi20170525.models.<span class="type">SendSmsRequest</span> <span class="variable">sendSmsRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.dysmsapi20170525.models.SendSmsRequest();</span><br><span class="line">        <span class="comment">//设置请求参数</span></span><br><span class="line">        sendSmsRequest</span><br><span class="line">                .setPhoneNumbers(phoneNum)<span class="comment">//电话号码</span></span><br><span class="line">                .setSignName(signName)<span class="comment">//短信签名名称</span></span><br><span class="line">                .setTemplateCode(templateCode)<span class="comment">//短信模板Code</span></span><br><span class="line">                .setTemplateParam(<span class="string">&quot;&#123;\&quot;code\&quot;:\&quot;&quot;</span>+code+<span class="string">&quot;\&quot;&#125;&quot;</span>);<span class="comment">//短信模板变量对应的实际值</span></span><br><span class="line">        com.aliyun.teautil.models.<span class="type">RuntimeOptions</span> <span class="variable">runtime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.teautil.models.RuntimeOptions();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 复制代码运行请自行打印 API 的返回值</span></span><br><span class="line">            <span class="type">SendSmsResponse</span> <span class="variable">sendSmsResponse</span> <span class="operator">=</span> client.sendSmsWithOptions(sendSmsRequest, runtime);</span><br><span class="line">            System.out.println(sendSmsResponse.getStatusCode()+<span class="string">&quot; &quot;</span>+sendSmsResponse.getBody().getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TeaException error) &#123;</span><br><span class="line">            <span class="comment">// 如有需要，请打印 error</span></span><br><span class="line">            System.out.println(error);</span><br><span class="line">            com.aliyun.teautil.Common.assertAsString(error.message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception _error) &#123;</span><br><span class="line">            <span class="type">TeaException</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeaException</span>(_error.getMessage(), _error);</span><br><span class="line">            <span class="comment">// 如有需要，请打印 error</span></span><br><span class="line">            System.out.println(error);</span><br><span class="line">            com.aliyun.teautil.Common.assertAsString(error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面这个Component还能做优化，上面这样的写法虽然它整体是单例的，但是<strong>每次调用其中的方法时都会重新创建一个相同的client对象，这样就造成了性能的浪费，所以可以把重复创建的那个对象放到配置类中当成Bean注册给IOC容器，这样就能保证调用方法时不会重新创建对象（利用了Bean默认作用域是单例模式生成的性质）</strong>。</p></li><li><p>然后就是<strong>在第三方服务模块向外提供服务接口</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sms&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgController</span> &#123;<span class="comment">//阿里云短信服务的Controller</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SmsComponent smsComponent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供给别的服务进行调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phone 电话号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code 想发的验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/sendCode&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone,<span class="meta">@RequestParam(&quot;code&quot;)</span> String code)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//System.out.println(phone);</span></span><br><span class="line">        smsComponent.sendSmsCode(phone,code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后就是<strong>在认证中心使用服务接口向外提供短信发送的接口</strong>，要考虑的问题很多，比如说验证码要再次检查怎么办？验证码有效时间10分钟怎么搞？验证码60s内不能重复发送怎么搞？接口防刷怎么搞？可以通过引入redis解决部分问题，第一个问题可以解决，把验证码存到redis中，验证的时候直接拿就行；第二个问题也好解决，就是给放入缓存的数据加上ttl，到期就被淘汰，验证码也就失效了；第三个问题可以在存放验证码的时候，后缀带上个系统时间，然后每次发验证码的时候都检查当前时间是不是在缓存的时间的60s开外，如果不在，直接返回失败信息；最后一个问题之后再解决把：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ThirdFeignService thirdFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sms/sendCode&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone)</span>&#123;</span><br><span class="line">        <span class="comment">//todo 接口防刷</span></span><br><span class="line">        <span class="comment">//防止同一个手机号在60s内再发送验证码，我们可以给验证码带上系统时间的后缀，再想发的时候检查缓存中验证码的时间是否在60s之前。进来先检查这个</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisCode</span> <span class="operator">=</span> redisTemplate.opsForValue().get(AuthServerConstant.SmsConstant.SMS_CODE_CACHE_PREFIX.getValue()+phone);</span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(redisCode)) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">timeBefore</span> <span class="operator">=</span> Long.parseLong(redisCode.split(<span class="string">&quot;_&quot;</span>)[<span class="number">1</span>]);<span class="comment">//获取缓存中记录的上次添加验证码到缓存的时间</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() - timeBefore &lt; <span class="number">60000</span>) &#123;<span class="comment">//如果这次请求在上次请求的60s内，直接失败</span></span><br><span class="line">                <span class="keyword">return</span> Result</span><br><span class="line">                        .error()</span><br><span class="line">                        .code(ResultCode.SMS_CODE_EXCEPTION.getCode())</span><br><span class="line">                        .message(ResultCode.SMS_CODE_EXCEPTION.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取随机四位数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> String.valueOf((<span class="type">int</span>)(Math.random()*<span class="number">9000</span>+<span class="number">1000</span>));</span><br><span class="line">        <span class="comment">//为了验证码的再次校验，验证码暂时存到redis中,key是服务前缀+手机号防止撞key，value是验证码，要带上ttl，一般验证码不是都是几分钟就过期嘛</span></span><br><span class="line">        <span class="comment">//给验证码带上系统时间后缀，方便下次请求时检验请求是否是在60s之内发送的</span></span><br><span class="line">        redisTemplate.opsForValue().set(AuthServerConstant.SmsConstant.SMS_CODE_CACHE_PREFIX.getValue()+phone,code+<span class="string">&quot;_&quot;</span>+System.currentTimeMillis(),<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//远程调用发送验证码的方法</span></span><br><span class="line">        thirdFeignService.sendCode(phone,code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="给缓存到redis中的数据的key增加前缀"><a href="#给缓存到redis中的数据的key增加前缀" class="headerlink" title="给缓存到redis中的数据的key增加前缀"></a>给缓存到redis中的数据的key增加前缀</h2><ul><li>这个可以<strong>避免key的冲突</strong>，比如说我想缓存一个手机号的key，但是很多个服务都想要缓存这个key，那么我们在缓存的时候就产生了key的冲突，所以解决方法就是，每个服务有自己的缓存前缀（可以写成常量），无论是向redis中写还是查，都带着这个前缀来标识自己是哪个服务缓存的数据，这样在缓存或者查询的时候就不会产生key冲突了。</li></ul><h1 id="2023-x2F-1-x2F-25"><a href="#2023-x2F-1-x2F-25" class="headerlink" title="2023&#x2F;1&#x2F;25"></a>2023&#x2F;1&#x2F;25</h1><h2 id="MD5盐值加密"><a href="#MD5盐值加密" class="headerlink" title="MD5盐值加密"></a>MD5盐值加密</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><ul><li>即Message Digest Algorithm 5，是一种信息摘要算法</li><li><strong>压缩性</strong>：任意长度的数据，算出的MD5值的长度可以固定</li><li><strong>容易计算</strong>：从原数据计算出MD5值很容易</li><li><strong>抗修改性</strong>：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大的区别</li><li><strong>强抗碰撞性</strong>：想找到两个不同的数据使它们具有相同的MD5值，是非常困难的</li><li><strong>不可逆性</strong>：无法通过MD5值推算出原数据，网上那些所谓的MD5解析，是利用MD5值的抗修改性，从彩虹表（一个用于加密散列函数 逆运算的预先计算好的表 ）中查已经计算出的MD5的值对应的明文，遇到彩虹表中没有的MD5值，它就无法解析了。</li></ul><h3 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a>加盐</h3><ul><li>直接向数据库中存放MD5值就很安全吗？比裸奔是安全不少，但是还不够，因为<strong>黑客有可能拿着数据库中的MD5值去彩虹表中查，万一有些人设置的密码强度不够，那么很容易密码就会被破解出来</strong>。</li><li>所以不能单纯使用计算出的MD5值，我们可以<strong>通过生成随机数与明文数据进行组合后再计算MD5值（也就是给数据加盐），将最后计算出的结果作为存放在数据库中的数据</strong>。</li><li>而对于加的盐值，我们也得找地方存，<strong>可以存在数据库中，但是这样的话，黑客破解数据库后很容易就能取得盐值</strong>。也可以存到最后生成的MD5值中，spring家的<strong>BCryptPasswordEncoder</strong>类中的encode方法是<strong>将盐值存放到了最后生成的密文中</strong>，也就是说，通过特定的操作，可以从最后的密文中分离出盐值，这样做安全性就很高了，因为<strong>黑客并不知道怎么分离盐值，就算黑客得到了盐值，由于盐值是随机的，黑客无法利用已有的彩虹表，必须从头开始构建一个彩虹表来进行暴力破解，大大加大了黑客的破解成本</strong>。</li><li>在<strong>进行数据校验的时候我们需要组合盐值和用户输入数据之后再去计算MD5值进行校验</strong>。</li></ul><h2 id="用户注册后端实现"><a href="#用户注册后端实现" class="headerlink" title="用户注册后端实现"></a>用户注册后端实现</h2><ul><li><p>先在认证中心过了验证码的验证，然后远程调用会员模块的接口来将用户的数据存到数据库中。</p></li><li><p>细节还挺多的，首先就是<strong>后端校验数据，收集校验错误信息</strong>；然后就是<strong>从redis中拿验证码来和用户传过来的做对比校验，涉及验证码过期和验证码不匹配的情况，验证通过后要删除缓存（令牌机制）</strong>；然后就是<strong>远程调用用户模块来进行注册，可能成功也可能失败</strong>，用户注册的时候密码不能使用明文存储，使用spring家提供的<strong>BCryptPasswordEncoder</strong>类来做<strong>MD5盐值加密</strong>。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/regist&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">regist</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserRegistVo vo, BindingResult bindingResult)</span>&#123;</span><br><span class="line">    <span class="comment">//todo 重定向携带数据，利用session原理。将数据放到session中。只要跳到下一个页面取出这个数据后，session里面的数据就会删掉</span></span><br><span class="line">    <span class="comment">//todo 分布式下的session问题</span></span><br><span class="line">    <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">        <span class="comment">//收集所有错误信息，构造成一个map</span></span><br><span class="line">        Map&lt;String,String&gt; errors = bindingResult.getFieldErrors()</span><br><span class="line">                .stream()</span><br><span class="line">                .collect(Collectors.toMap(FieldError::getField,FieldError::getDefaultMessage));</span><br><span class="line">        <span class="keyword">return</span> Result.error().data(<span class="string">&quot;errors&quot;</span>,errors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> vo.getCode();</span><br><span class="line">    <span class="type">String</span> <span class="variable">redisResult</span> <span class="operator">=</span> redisTemplate.opsForValue().get(AuthServerConstant.SmsConstant.SMS_CODE_CACHE_PREFIX.getValue()+vo.getPhone());</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(redisResult))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error().message(<span class="string">&quot;验证码已过期&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!code.equals(redisResult.split(<span class="string">&quot;_&quot;</span>)[<span class="number">0</span>]))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error().message(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//验证码校验成功后删除验证码,令牌机制，只用一次</span></span><br><span class="line">    redisTemplate.delete(AuthServerConstant.SmsConstant.SMS_CODE_CACHE_PREFIX.getValue()+vo.getPhone());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用远程服务进行注册,可能成功也可能失败</span></span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> memberFeignService.regist(vo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>会员模块中保存用户数据的Service层方法，<strong>主要关注MD5盐值加密和自定义异常抛出</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UmsMemberLevelMapper umsMemberLevelMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">regist</span><span class="params">(MemberRegistVo vo)</span> <span class="keyword">throws</span> PhoneExistException,UsernameExistException&#123;</span><br><span class="line">    <span class="type">UmsMember</span> <span class="variable">member</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UmsMember</span>();</span><br><span class="line">    <span class="comment">//设置默认等级</span></span><br><span class="line">    <span class="comment">//UmsMemberLevel level = umsMemberLevelMapper.getDefaultLevel();</span></span><br><span class="line">    <span class="comment">//member.setLevelId(level.getId());</span></span><br><span class="line">    <span class="comment">//设置传过来的那些数据</span></span><br><span class="line">    <span class="comment">//检查用户名和手机号是否唯一</span></span><br><span class="line">    <span class="keyword">if</span>(checkPhoneUnique(vo.getPhone()))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PhoneExistException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(checkUsernameUnique(vo.getUsername()))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameExistException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    member.setUsername(vo.getUsername());</span><br><span class="line">    member.setMobile(vo.getPhone());</span><br><span class="line">    <span class="comment">//密码要进行加密存储,MD5加盐加密,spring家这个加盐算法就是能从最后的结果中解析出盐值来，但是怎么解析不知道，安全性就在这里体现</span></span><br><span class="line">    <span class="type">BCryptPasswordEncoder</span> <span class="variable">passwordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> passwordEncoder.encode(vo.getPassword());</span><br><span class="line">    member.setPassword(encode);</span><br><span class="line">    <span class="comment">//设置其他的默认信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> save(member);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPhoneUnique</span><span class="params">(String phone)</span>&#123;<span class="comment">//返回手机号是否存在，true就是已经存在，false就是不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.baseMapper.selectCount(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;UmsMember&gt;().eq(<span class="string">&quot;mobile&quot;</span>,phone))&gt;<span class="number">0</span>;<span class="comment">//查满足条件的记录的数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkUsernameUnique</span><span class="params">(String username)</span>&#123;<span class="comment">//返回用户名是否存在，true就是已经存在，false就是不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.baseMapper.selectCount(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;UmsMember&gt;().eq(<span class="string">&quot;username&quot;</span>,username))&gt;<span class="number">0</span>;<span class="comment">//查满足条件的记录的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>会员模块中保存用户数据的Controller层方法，<strong>主要关注针对不同异常使用相应的错误码返回</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/regist&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">regist</span><span class="params">(<span class="meta">@RequestBody</span> MemberRegistVo vo)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> umsMemberService.regist(vo)?Result.ok():Result.error();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (PhoneExistException e)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">return</span> Result</span><br><span class="line">                .error()</span><br><span class="line">                .code(ResultCode.PHONE_EXIST_EXCEPTION.getCode())</span><br><span class="line">                .message(ResultCode.PHONE_EXIST_EXCEPTION.getMessage());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (UsernameExistException e)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">return</span> Result</span><br><span class="line">                .error()</span><br><span class="line">                .code(ResultCode.USERNAME_EXIST_EXCEPTION.getCode())</span><br><span class="line">                .message(ResultCode.USERNAME_EXIST_EXCEPTION.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="通过使用自定义异常-Service层-和自定义错误码-Controller层-来处理程序出现的问题"><a href="#通过使用自定义异常-Service层-和自定义错误码-Controller层-来处理程序出现的问题" class="headerlink" title="通过使用自定义异常(Service层)和自定义错误码(Controller层)来处理程序出现的问题"></a>通过使用自定义异常(Service层)和自定义错误码(Controller层)来处理程序出现的问题</h2><ul><li><p>如果一个<strong>Service层的方法会发生很多问题，那么首先应该把这些问题对应的自定义异常抛出去，抛给Controller层</strong>；然后<strong>Controller针对不同的异常类型给统一返回对象设置对应异常类型的错误码</strong>。</p></li><li><p>这样做是因为<strong>Controller层是后端数据离开该模块的最后一层，应该使用统一返回对象来进行返回，从而可以让别的模块或者前端来解析使用，在这一层抛异常不合适</strong>。而<strong>Service层的数据是返回给Controller层的，它抛的异常Controller层也能接收到，所以可以向外抛异常</strong>。</p></li><li><p>这个用法在上一组业务代码中有体现。</p></li><li><p>自定义异常示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230125195746070.png" alt="image-20230125195746070"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFailedException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginFailedException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;用户账号或密码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置文件不起作用"><a href="#配置文件不起作用" class="headerlink" title="配置文件不起作用"></a>配置文件不起作用</h2><ul><li>可能是配置文件没有被build，检查配置文件是否被build进了classes目录，如果没有，应该在pom文件中显式声明将其加入要build的文件中。</li></ul><h2 id="开启mybatis-plus的日志打印"><a href="#开启mybatis-plus的日志打印" class="headerlink" title="开启mybatis-plus的日志打印"></a>开启mybatis-plus的日志打印</h2><ul><li><p>在配置文件中进行配置，打印的内容可以看到具体执行的sql语句：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置mybatis-plus的mapper位置，默认是classpath*:/mapper/**/*.xml，classpath后面的*代表除了自己的classpath，引入的jar包的classpath也会被检索</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/**/mapper/**/*.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#开启打印mybatis运行日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="用户登录后端实现"><a href="#用户登录后端实现" class="headerlink" title="用户登录后端实现"></a>用户登录后端实现</h2><ul><li><p>这个比较简单了就，主要就是注意使用<strong>BCryptPasswordEncoder</strong>类的match方法来验证密码，然后注意Service层和Controller层的<strong>抛接发问题处理模型（Service层抛异常，Controller层接异常，Controller层发错误码出去）</strong>。</p></li><li><p>先走认证中心，然后认证中心远程调用用户模块的登录方法。</p></li><li><p>认证中心的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> UserLoginVo vo)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> memberFeignService.login(vo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用户模块的Controller层方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> MemberLoginVo vo)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">UmsMember</span> <span class="variable">member</span> <span class="operator">=</span> umsMemberService.login(vo);</span><br><span class="line">        <span class="keyword">return</span> Result.ok().data(<span class="string">&quot;data&quot;</span>,member);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(LoginFailedException e)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">return</span> Result</span><br><span class="line">                .error()</span><br><span class="line">                .code(ResultCode.LOGIN_FAILED_EXCEPTION.getCode())</span><br><span class="line">                .message(ResultCode.LOGIN_FAILED_EXCEPTION.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用户模块的Service层方法（忘给数据的isDeleted属性加上自动填充注解导致好长时间都没有查出数据蚌）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UmsMember <span class="title function_">login</span><span class="params">(MemberLoginVo vo)</span> <span class="keyword">throws</span> LoginFailedException&#123;</span><br><span class="line">    <span class="comment">//System.out.println(vo.getLoginacct()+&quot; &quot;+vo.getPassword());</span></span><br><span class="line">    <span class="comment">//用户用username和phone登录都行</span></span><br><span class="line">    QueryWrapper&lt;UmsMember&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.eq(<span class="string">&quot;username&quot;</span>,vo.getLoginacct()).or().eq(<span class="string">&quot;mobile&quot;</span>,vo.getLoginacct());</span><br><span class="line">    <span class="comment">//System.out.println(wrapper.getSqlComment());</span></span><br><span class="line">    <span class="type">UmsMember</span> <span class="variable">member</span> <span class="operator">=</span> <span class="built_in">this</span>.baseMapper.selectOne(wrapper);</span><br><span class="line">    <span class="comment">//System.out.println(member);</span></span><br><span class="line">    <span class="comment">//用户不存在的情况处理一下</span></span><br><span class="line">    <span class="keyword">if</span>(member==<span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LoginFailedException</span>();</span><br><span class="line">    <span class="comment">//匹配密码，不匹配直接抛异常</span></span><br><span class="line">    <span class="type">BCryptPasswordEncoder</span> <span class="variable">passwordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    <span class="keyword">if</span>(!passwordEncoder.matches(vo.getPassword(),member.getPassword()))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LoginFailedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> member;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="社交登录"><a href="#社交登录" class="headerlink" title="社交登录"></a>社交登录</h2><ul><li>可以在登录界面提供第三方的登录，这样可以避免用户进行繁琐的注册流程，而且这些第三方平台使用的人一般也挺多，相当于变相利用第三方平台的大流量。</li><li>通过社交登录，就相当于我们利用用户在第三方平台上的一些信息，给这个用户自动注册了一个账号，注册的这个账号的一些信息是我们通过社交登录拿到的第三方平台上的这个用户的信息。</li></ul><h2 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h2><ul><li><p>OAuth（开放授权）：是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或者分享他们数据的所有内容。</p></li><li><p>OAuth2.0：与用户相关的OpenAPI（例如获取用户信息，动态同步，照片，日志，分享等），为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式地向用户征求授权。</p></li><li><p>官方版流程：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230125231614349.png" alt="image-20230125231614349"></p></li><li><p>比较准确的流程应该是：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230125231716917.png" alt="image-20230125231716917"></p><p>用户在输入完自己的第三方平台的登录信息之后，请求会发给第三方服务的服务器进行认证，认证通过之后会给用户想要登录的网站发送一个code，网站拿到这个code之后可以使用它向第三方服务器申请一个access_token，code一般只能用一次，网站拿到这个access_token之后，就可以拿着这个access_token去找qq存放用户开放信息的服务器请求用户开放数据来做相应的操作了，access_token一般可以使用多次，但有过期时间。</p></li></ul><h1 id="2023-x2F-1-x2F-26"><a href="#2023-x2F-1-x2F-26" class="headerlink" title="2023&#x2F;1&#x2F;26"></a>2023&#x2F;1&#x2F;26</h1><h2 id="使用第三方登录"><a href="#使用第三方登录" class="headerlink" title="使用第三方登录"></a>使用第三方登录</h2><ul><li>各第三方平台一般都会有他们对应的开放平台，其中提供很多开放的功能、api啥的 ，那想要用哪家的第三方登录功能就要去对应的开放平台去申请使用，申请完成之后，跟着开放平台上的文档一步步走就行了。</li></ul><h2 id="比较方便的封装了发送http请求的包"><a href="#比较方便的封装了发送http请求的包" class="headerlink" title="比较方便的封装了发送http请求的包"></a>比较方便的封装了发送http请求的包</h2><ul><li>可以用apache的HTTPUtils或者用restTemplate</li></ul><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><ul><li><p>时序图(Sequence Diagram)，又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。</p></li><li><p>也就是说可以用时序图来表示多个对象之间的交互关系</p></li><li><p>纵轴代表时间，横轴代表各种对象&#x2F;角色，对象下面的虚线是该对象的生命线，该对象的活动可以在生命线上用一个小矩形体现，这种小矩形叫控制焦点，对象之间发送同步消息用一条实线和实心箭头表示，发送异步消息用一条实线和一个大于号表示，返回消息用一条虚线和小于号表示，自关联的消息就是用箭头指向自己。</p></li><li><p>第三方登录的时序图示例：</p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126163007555.png" alt="image-20230126163007555"  /><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126162933956.png" alt="image-20230126162933956"></p></li><li><p>另一个时序图示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126151828420.png" alt="image-20230126151828420"></p></li></ul><h2 id="Session原理"><a href="#Session原理" class="headerlink" title="Session原理"></a>Session原理</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126164612737.png" alt="image-20230126164612737"></p><ul><li>由于<strong>http协议是无状态的，所以为了记录用户的状态使用户不必要每次都进行登录等重复操作，我们需要用到session技术</strong>，下面以登录场景举例，后台在处理用户的登录请求时，会<strong>将用户的状态存放在一个session中（可以想象session为一个map），所有session由一个sessionManager统一管理，之后服务器会命令浏览器保存一下这个用户的sessionId，浏览器就会保存，实际上这就是cookie，之后浏览器访问服务器都会带上它存储的cookie，cookie中有这个用户的sessionId等信息，服务器拿到之后就从sessionManager中找到对应的session，获取用户的状态从而将会话恢复到之前的状态</strong>。</li><li>就像是去银行卡办理业务一样，浏览器是客户，服务器是银行，客户进入银行存钱（session），银行发给客户一个银行卡（cookie）作为用户的凭证，这样每次用户来存钱银行都能正确处理。</li></ul><h2 id="Session共享问题"><a href="#Session共享问题" class="headerlink" title="Session共享问题"></a>Session共享问题</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126165443562.png" alt="image-20230126165443562"></p><ul><li>单机服务使用session没啥大问题，但是如果这个服务是个分布式的服务，问题就会出现，<strong>由于session是存放在受理用户对应操作的那个服务器上的，别的服务器没有用户的那个session，那么用户在使用别的服务器的服务的时候，那些服务器无法拿到用户的session</strong>。</li><li>比如用户在认证中心完成了登录，然后转到了主业务的服务器使用相应的服务，那么主业务的服务器是没有用户的session的，也就无法恢复用户的状态。再者如果用户都是使用的同一个服务，但是这个服务是集群部署，用户的请求经过负载均衡打在了同一服务的不同主机上，也没法保证提供服务的主机中有用户的session。这两个情景下的问题都是分布式下的session共享问题。</li></ul><h3 id="解决方案-session复制"><a href="#解决方案-session复制" class="headerlink" title="解决方案-session复制"></a>解决方案-session复制</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126170507748.png" alt="image-20230126170507748"></p><ul><li>这个优缺点都很明显，优点就是tomcat原生支持，配置起来简单；缺点就是session同步需要占用网络带宽、集群中节点数量太多的话单个节点会占用太多的空间来存储所有节点的session。</li><li>所以一般不用这种方法。</li></ul><h3 id="解决方案-客户端存储"><a href="#解决方案-客户端存储" class="headerlink" title="解决方案-客户端存储"></a>解决方案-客户端存储</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230127144611512.png" alt="image-20230127144611512"></p><ul><li>这种方法就是把session信息全都存到客户端的cookie中，不可能会用这种方法，安全性太低，而且cookie有长度限制，信息一多了就放不下了。</li></ul><h3 id="解决方案-hash一致性"><a href="#解决方案-hash一致性" class="headerlink" title="解决方案-hash一致性"></a>解决方案-hash一致性</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230127145021102.png" alt="image-20230127145021102"></p><ul><li>就是用户首次访问负载均衡服务器的时候，给用户的ip做一个hash，得到用户ip的hash值，然后再根据负载均衡给他分配服务器，以后只要还是这个ip过来访问，那么我们就给他转到和之前相同的服务器。</li><li>缺点就是服务器断电、服务器增减、用户ip改变等情况session会失效，不过这都是小概率事件。</li></ul><h3 id="解决方案-统一存储"><a href="#解决方案-统一存储" class="headerlink" title="解决方案-统一存储"></a>解决方案-统一存储</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230127145706059.png" alt="image-20230127145706059"></p><ul><li>来点儿名言：计算机中的问题没有什么是加一个中间层无法解决的。所以加一层装所有的session即可。不过就是增加了一次网络调用，读取速度比直接从内存中读取慢很多。</li></ul><h3 id="解决方案-子域session共享"><a href="#解决方案-子域session共享" class="headerlink" title="解决方案-子域session共享"></a>解决方案-子域session共享</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230127150420849.png" alt="image-20230127150420849"></p><ul><li>上面那个解决方案还有一些问题，就是当服务让浏览器存cookie的时候，默认的域名往往是子域名，这就导致浏览器只有访问对应的子域名的时候会带上cookie。</li><li>所以在上一个方案的基础上，我们应该在让浏览器存cookie的时候，手动声明域名为父域名以扩大cookie的作用域。</li></ul><h1 id="2023-x2F-1-x2F-27"><a href="#2023-x2F-1-x2F-27" class="headerlink" title="2023&#x2F;1&#x2F;27"></a>2023&#x2F;1&#x2F;27</h1><h2 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h2><ul><li>spring家给的session解决方案，不过现在前后端分离的项目好像不怎么用这种技术了，等我先研究研究现在的主流解决方案之后再回来搞这一块儿。&#x2F;&#x2F;todo</li><li>只要http协议还是无状态的协议，session技术就不会被淘汰。</li></ul><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><ul><li><p>Json Web Token（JWT）是为了网络应用环境间传递声明而执行的一种基于JSON的开发标准（RFC 7519），该token被设计为紧凑且安全的，特别适用于分布式站点的单点登陆（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p></li><li><p>总之，<strong>这个技术相当于把之前存在服务端的用户状态session转移到了用户端上</strong>，也就是说使用jwt生成的json对象中有用户的状态，我们把这个json对象叫做token，token存在客户端中，客户端想要从服务端申请数据的时候，就带上这个token，这样服务端就能从这个token中拆解出信息，从而对这个用户进行认证。这样<strong>服务端就不用保存任何session了，不用去考虑怎样解决分布式下的session共享问题了，将用户状态和服务端解耦，很明显对服务端的可扩展性是有提升的</strong>。</p></li><li><p>JWT的认证流程图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230216230348282.png" alt="image-20230216230348282"></p></li></ul><h3 id="session和jwt的区别"><a href="#session和jwt的区别" class="headerlink" title="session和jwt的区别"></a>session和jwt的区别</h3><ol><li>session 存储在服务端占用服务器资源，而 JWT 存储在客户端</li><li>session 存储在 Cookie 中，存在伪造跨站请求伪造攻击的风险</li><li>session 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用</li><li>存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性</li></ol><h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><ul><li>就是如果要是一个公司下面有很多个项目，那么我们期望实现一处登录，处处登录，比如一个公司有个商城项目，还有个在线视频网站项目，那么我们期望用户注册的时候，只需要注册这个公司的账号，然后就能登录这个公司旗下的所有项目，并且在其中一个项目登录了账号之后，再访问另外一个项目就不用重复登录了，这样的功能就是单点登录功能-一次登录可以访问多个应用。</li><li>这个要练习起来比较吃环境，不大好办，之后再搞吧。&#x2F;&#x2F;todo</li></ul><h1 id="2023-x2F-1-x2F-28"><a href="#2023-x2F-1-x2F-28" class="headerlink" title="2023&#x2F;1&#x2F;28"></a>2023&#x2F;1&#x2F;28</h1><h2 id="使用alt-insert来在IDEA中快速创建预制代码块"><a href="#使用alt-insert来在IDEA中快速创建预制代码块" class="headerlink" title="使用alt+insert来在IDEA中快速创建预制代码块"></a>使用alt+insert来在IDEA中快速创建预制代码块</h2><ul><li>这个快捷键还挺好用的，可以快速创建构造器、重写方法、实现方法等。</li></ul><h2 id="使用拦截器来判断用户的状态"><a href="#使用拦截器来判断用户的状态" class="headerlink" title="使用拦截器来判断用户的状态"></a>使用拦截器来判断用户的状态</h2><ul><li><p><strong>拦截器是spring mvc中的内容，它可以在Controller层的方法调用之前、调用之后、页面渲染之后执行相应的操作</strong>，所以如果我们想每次执行业务方法之前判断用户的状态，可以自定义一个拦截器。</p></li><li><p>拦截器可以单独放在一个包中，自定义的拦截器要实现spring提供的<strong>HandlerInterceptor</strong>接口，然后根据需求重写接口中的不同方法，返回true是放行请求，返回false是拦截请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;<span class="comment">//返回true是放行请求，返回false是拦截请求</span></span><br><span class="line">        <span class="keyword">return</span> HandlerInterceptor.<span class="built_in">super</span>.preHandle(request, response, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果想要让拦截器工作，还需要让他注册到ioc容器中让其生效并设置其可以拦截的请求，对于mvc相关的配置，我们可以新建一个实现了<strong>WebMvcConfigurer</strong>接口的配置类，然后在配置类中通过重写相应的方法来进行相关的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartWebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//将自定义的拦截器使用注册器注册到容器中并让其生效，指定其可以拦截的请求为所有请求</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">CartInterceptor</span>())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用ThreadLocal在同一个线程共享数据"><a href="#使用ThreadLocal在同一个线程共享数据" class="headerlink" title="使用ThreadLocal在同一个线程共享数据"></a>使用ThreadLocal在同一个线程共享数据</h2><ul><li><p>当有请求到达tomcat的时候，tomcat就会用一个线程来处理这个请求，从拦截器到controller到service到dao最后再返回来，这一串都在同一个线程，这样我们就可以使用JDK的ThreadLocal来在这一个线程中共享数据。</p></li><li><p>比如在拦截器中取得了一些数据，把这些数据做到ThreadLocal对象后，在进行后面的操作的时候就可以很容易地取出这些数据了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230128182826838.png" alt="image-20230128182826838"></p></li><li><p>使用ThreadLocal可以新建一个它的泛型，对外开放，再调用其set方法来维护一个对象，一个ThreadLocal只能维护一个对象，用的时候使用get方法取出ThreadLocal维护的对象。</p></li><li><p>使用ThreadLocal的好处就是可以实现线程隔离，<strong>每个线程都有一个属于自己的ThreadLocalMap&lt;ThreadLocal&lt;T&gt;,Object&gt;<strong>，这个类是ThreadLocal的内部类，</strong>ThreadLocalMap维护着当前线程的所有ThreadLocal对象对应的对象</strong>，这样<strong>每次使用ThreadLocal的get方法取出对象的时候，实际上是从本线程的ThreadLocalMap中取那个ThreadLocal对应的那个对象，这样就实现了线程之间的隔离</strong>，同理，<strong>使用ThreadLocal的set方法的时候也是在本线程的ThreadLocalMap中set进ThreadLocal和那个对象组成的键值对</strong>。</p></li><li><p>ThreadLocal的set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//得到当前线程的对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//得到线程对象的ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);<span class="comment">//向当前线程的ThreadLocalMap中存放当前ThreadLocal对应的对象</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ThreadLocal的get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//得到当前线程的对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//得到线程对象的ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);<span class="comment">//从当前线程的ThreadLocalMap中获得当前ThreadLocal对应的对象</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Docker安装RabbitMQ"><a href="#Docker安装RabbitMQ" class="headerlink" title="Docker安装RabbitMQ"></a>Docker安装RabbitMQ</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230128192259784.png" alt="image-20230128192259784"></p><ul><li>从15672端口进rabbitmq的可视化管理界面，用户名和密码默认都是guest</li><li>客户端使用高级消息队列协议（AMQP）来和rabbitmq进行交互的端口是5672端口</li><li>rabbitmq支持导出和导入配置文件，这让配置的迁移变得简单</li></ul><h1 id="2023-x2F-1-x2F-30"><a href="#2023-x2F-1-x2F-30" class="headerlink" title="2023&#x2F;1&#x2F;30"></a>2023&#x2F;1&#x2F;30</h1><h2 id="RabbitMQ的工作原理"><a href="#RabbitMQ的工作原理" class="headerlink" title="RabbitMQ的工作原理"></a>RabbitMQ的工作原理</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029093829448.png" alt="image-20221029093829448"></p><ul><li><strong>Broker（代理）</strong>：<strong>接收和分发消息的应用</strong>，RabbitMQ Server 就是 Message Broker。</li><li><strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP（协议）的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。<strong>当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</strong>。</li><li><strong>Connection</strong>：<strong>publisher／consumer 和 broker 之间的 TCP 连接</strong>。</li><li><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。<strong>Channel 是在 connection 内部建立的逻辑连接</strong>，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的Connection极大减少了操作系统建立TCP connection的开销</strong>。</li><li><strong>Exchange</strong>：message 到达 broker 的第一站，<strong>根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去</strong>。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</li><li><strong>Queue</strong>：<strong>消息最终被送到这里等待 consumer 取走</strong>。</li><li><strong>Binding</strong>：<strong>exchange 和 queue 之间的虚拟连接</strong>，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</li></ul><h2 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><ul><li><p>首先引入高级消息队列的场景启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring-boot-starter-amqp.version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">spring-boot-starter-amqp.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--高级消息队列的场景启动器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-starter-amqp.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引入场景启动器后RabbitAutoConfiguration就会自动生效，它会<strong>向容器中自动注册RabbitTemplate、AmqpAdmin、CachingConnectionFactory、RabbitMessagingTemplate对象</strong>，并且<strong>所有属性都可以通过前缀为“spring.rabbitmq”的配置项来在配置文件中进行配置</strong>。</p></li></ul><h3 id="进行配置"><a href="#进行配置" class="headerlink" title="进行配置"></a>进行配置</h3><ul><li><p>在配置文件中进行配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定rabbitmq的主机地址和连接端口</span></span><br><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">konjacer.com</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="comment">#配置virtual-host，这个和namespace的概念差不多，是用来做不同用户之间的隔离的</span></span><br><span class="line"><span class="attr">spring.rabbitmq.virtual-host</span>=<span class="string">/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="开启注解"><a href="#开启注解" class="headerlink" title="开启注解"></a>开启注解</h3><ul><li>使用**@EnableRabbit**来启动高级消息队列的功能</li></ul><h3 id="增删组件"><a href="#增删组件" class="headerlink" title="增删组件"></a>增删组件</h3><ul><li><p>对于<strong>RabbitMQ中的交换机、队列、Binding等组件的增删操作可以使用之前向容器中注册的AmqpAdmin对象来做</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">AmqpAdmin amqpAdmin;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAmqpAdmin</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//创建Exchange交换机</span></span><br><span class="line"><span class="type">DirectExchange</span> <span class="variable">directExchange</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;test-exchange&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">amqpAdmin.declareExchange(directExchange);</span><br><span class="line"><span class="comment">//创建Queue队列,exclusive如果是true那么只有一个连接可以连接到这个队列</span></span><br><span class="line"><span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;test-queue&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">amqpAdmin.declareQueue(queue);</span><br><span class="line"><span class="comment">//创建Binding绑定关系来绑定交换机和队列,将指定的交换机和目的地（可以是交换机也可以是队列,在第二个参数中声明）进行绑定，使用routingKey作为指定的路由键</span></span><br><span class="line"><span class="type">Binding</span> <span class="variable">binding</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Binding</span>(<span class="string">&quot;test-queue&quot;</span>, Binding.DestinationType.QUEUE,<span class="string">&quot;test-exchange&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">amqpAdmin.declareBinding(binding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><ul><li><p>如果想要<strong>进行收发消息的相关操作，我们可以使用之前注册到容器中的RabbitTemplate对象</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRabbitTemplate</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//发送消息,会使用到序列化机制将对象写出去,默认使用java的序列化机制,所以如果发送的消息是个对象，那么对象对应的类必须实现序列化接口Serializable</span></span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;test-exchange&quot;</span>,<span class="string">&quot;test&quot;</span>,msg);</span><br><span class="line"><span class="comment">//更改默认的序列化机制需要在ioc容器中添加另外一个消息转换器以覆盖默认的消息转换器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果想要更改默认的写出对象的序列化机制，可以<strong>在配置类中向ioc容器中添加一个新的json消息转换器以覆盖默认的转换器，这样以后就是将对象转换成json数据写出了</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;<span class="comment">//将json的消息转换器放到ioc容器中，这样以后在发送对象消息的时候，对象会被序列化成json数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><ul><li><p>主要是通过两个注解来实现消息的接收，首先就是**@RabbitListener<strong>注解，这个注解可以修饰方法和类，其中queue属性可以声明要监听的队列名称，如果要是修饰方法，那么被监听的队列中来了新消息后被修饰的方法会接收到新的消息；如果要是这个注解修饰类，那么被监听的队列中来了新消息之后，类中被</strong>@RabbitHandler**注解修饰的方法会根据消息类型和自己的形参类型来接收消息（如果类型相同就接收）。</p></li><li><p>一般都是用**@RabbitListener<strong>注解修饰类，然后用</strong>@RabbitHandler<strong>注解修饰类中的方法，这样可以</strong>细化接收消息方法的粒度，每个方法只接收符合自己实参类型的消息<strong>，注意</strong>方法中可以选择三个接收参数**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;test-queue&quot;&#125;)</span><span class="comment">//声明要监听的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OmsOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OmsOrderMapper, OmsOrder&gt; <span class="keyword">implements</span> <span class="title class_">OmsOrderService</span> &#123;</span><br><span class="line">    <span class="comment">//一个队列可以很多消费者来同时监听，只要消费者收到消息，队列就会删除消息，所以一个消息只会被一个消费者接收到，默认是轮询接收策略</span></span><br><span class="line">    <span class="comment">//只有当一个消息完全处理完（即方法运行结束），才可以接收下一个消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span><span class="comment">//声明该方法为消息处理方法，如果有消息到达类上注解中声明的要监听的队列，那么被@RabbitHandler注解修饰的方法会根据消息对象的类型和形参类型来选择接收（两者类型相同就接收）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">            Message msg,</span></span><br><span class="line"><span class="params">            OmsOrderService omsOrderService,</span></span><br><span class="line"><span class="params">            Channel channel</span></span><br><span class="line"><span class="params">    )</span>&#123;<span class="comment">//可选三个参数接收：原生消息类型Message封装了消息（消息头+消息体），除了消息本身还有很多其他信息，第二个参数写消息中的对象的类可以直接接收到消息对象，第三个参数可以获取到客户端和mq之间连接中的进行消息交互的channel</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span>+msg+<span class="string">&quot; &quot;</span>+<span class="string">&quot;接收到的消息内容对象：&quot;</span>+omsOrderService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个队列可以很多消费者来同时监听，只要消费者收到消息，队列就会删除消息，所以<strong>一个消息只会被一个消费者接收到</strong>，默认是轮询接收策略。</p></li><li><p><strong>只有当一个消息完全处理完（即方法运行结束），对应的方法才可以接收下一个消息</strong>。</p></li></ul><h2 id="RabbitMQ消息确认机制-可靠抵达"><a href="#RabbitMQ消息确认机制-可靠抵达" class="headerlink" title="RabbitMQ消息确认机制-可靠抵达"></a>RabbitMQ消息确认机制-可靠抵达</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230130173903685.png" alt="image-20230130173903685"></p><ul><li>为了保证消息的可靠抵达，我们可以在channel中使用事务机制，所有步骤都成功了之后整体才会成功，但是这样做性能下降很严重。我们还可以使用消息确认机制来实现消息的可靠抵达，这种方案性能损耗较小。</li></ul><h3 id="开启ConfirmCallback回调"><a href="#开启ConfirmCallback回调" class="headerlink" title="开启ConfirmCallback回调"></a>开启ConfirmCallback回调</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230130174647641.png" alt="image-20230130174647641"></p><ul><li><p>是<strong>生产者的消息成功到达Broker的回调方法</strong>，要想开启这个方法，可以<strong>在配置文件中进行相应的配置</strong>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启从生产者到Broker的消息成功到达回调，开启后消息成功从生产者到Broker后RabbitTemplate会调用对应的回调方法ConfirmCallback，所以如果我们想要定制这个回调方法，需要改一下RabbitTemplate中的参数然后再把它扔回ioc容器</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure></li><li><p>然后<strong>在配置文件中定制一下rabbitTemplate，给里面塞一个自定义的ConfirmCallback方法</strong>，这样之后消息从生产者到Broker之后，rabbitTemplate就会调用我们自定义的ConfirmCallback回调方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;<span class="comment">//将json的消息转换器放到ioc容器中，这样以后在发送对象消息的时候，对象会被序列化成json数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制rabbitTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span><span class="comment">//在MyRabbitConfig对象的构造器执行完之后再执行这个方法，为的是让RabbitTemplate先装载完毕？</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRabbitTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自定义消息从生产者到Broker的成功回调</span></span><br><span class="line"><span class="comment">         * 只要消息从生产者到Broker，ack就等于true</span></span><br><span class="line"><span class="comment">         * correlationData：当前消息的唯一关联数据（这个是消息的唯一id），发送的时候最好带上这个参数（要能唯一标识一个消息，可以是uuid），这样方便后面识别消息，也方便存数据库</span></span><br><span class="line"><span class="comment">         * ack：消息是否成功收到</span></span><br><span class="line"><span class="comment">         * cause：失败的原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(((correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;correlationData:&quot;</span>+correlationData+<span class="string">&quot;ack:&quot;</span>+ack+<span class="string">&quot;cause:&quot;</span>+cause);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="开启ReturnCallback回调"><a href="#开启ReturnCallback回调" class="headerlink" title="开启ReturnCallback回调"></a>开启ReturnCallback回调</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230130210051832.png" alt="image-20230130210051832"></p><ul><li><p>是<strong>消息未能从交换机传到队列中的回调方法</strong>，要想启用这个方法，可以在配置文件中进行设置，下面<strong>还设置开启了一个消息到达队列的回调方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#开启消息未能从交换机传到队列的回调方法</span><br><span class="line">spring.rabbitmq.publisher-returns=<span class="literal">true</span></span><br><span class="line">#只要抵达队列，优先以异步的方式回调ReturnConfirm方法</span><br><span class="line">spring.rabbitmq.template.mandatory=<span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>然后就是在RabbitTemplate中自定义上面开启的两个回调方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;<span class="comment">//将json的消息转换器放到ioc容器中，这样以后在发送对象消息的时候，对象会被序列化成json数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制rabbitTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span><span class="comment">//在MyRabbitConfig对象的构造器执行完之后再执行这个方法，为的是让RabbitTemplate先装载完毕？</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRabbitTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自定义消息从生产者到Broker的成功回调</span></span><br><span class="line"><span class="comment">         * 只要消息从生产者到Broker，ack就等于true</span></span><br><span class="line"><span class="comment">         * correlationData：当前消息的唯一关联数据（这个是消息的唯一id），发送的时候最好带上这个参数（要能唯一标识一个消息，可以是uuid），这样方便后面识别消息，也方便存数据库</span></span><br><span class="line"><span class="comment">         * ack：消息是否成功收到</span></span><br><span class="line"><span class="comment">         * cause：失败的原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(((correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;correlationData:&quot;</span>+correlationData+<span class="string">&quot;ack:&quot;</span>+ack+<span class="string">&quot;cause:&quot;</span>+cause);</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自定义消息未抵达队列的回调</span></span><br><span class="line"><span class="comment">         * message：投递失败的消息的详细信息</span></span><br><span class="line"><span class="comment">         * replyCode：回复的状态码</span></span><br><span class="line"><span class="comment">         * replyText：回复的文本内容</span></span><br><span class="line"><span class="comment">         * exchange：当时这个消息是从哪个交换机发出去的</span></span><br><span class="line"><span class="comment">         * routingKey：当时这个消息用的哪个路由键</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;失败的消息：&quot;</span>+message);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="开启ack消息确认机制"><a href="#开启ack消息确认机制" class="headerlink" title="开启ack消息确认机制"></a>开启ack消息确认机制</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230131161537978.png" alt="image-20230131161537978"></p><ul><li><p>是<strong>消息从队列到消费者的回调，有ack和nack&#x2F;reject三种回调，ack是逻辑上消息处理成功，nack&#x2F;reject是逻辑上消息处理失败</strong>，消费者客户端在不同的时间执行这两个回调时”处理成功&#x2F;失败“有不同的意义，需要具体情况具体分析，<strong>默认是自动确认的，只要消息被消费者接收到，那么即使消息没有被处理完（也就是接收消息的方法没有运行完）消费者客户端也会自动确认ack，服务端收到确认ack后就会移除对应的消息</strong>。</p></li><li><p>上面说的<strong>这种只要接收到消息就自动确认的机制是有很大问题的，会造成消息的丢失</strong>，比如消费者收到了很多消息，对于这些消息消费者都回复了ack，服务端收到ack后就把队列中的消息删除了，但是消费者在处理完一部分消息后宕机了，那么那些没有处理完的消息就丢失了，队列里也没了，因为服务端收到ack后就把对应的消息删掉了。</p></li><li><p>所以要解决上面说的那种问题，我们<strong>可以采用手动确认，也就是处理消息的方法结束之后，我们再手动向服务端发送ack</strong>，这样就能保证服务端接收到ack并删除对应消息的时候，消息已经再消费者客户端处理完毕了，<strong>解决了上面那种情况下消息丢失的问题</strong>。<strong>在手动确认模式下，只要我们没有调用ack，那么服务端中对应的消息就一直是unchecked状态，即使消费者宕机消息也不会丢失，而是会变成ready状态，当下一次有新的消费者连接到这个队列的时候，消息就会被重新发给消费者</strong>。要想采用手动确认，首先要在配置文件中进行相关的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#手动ack消息</span><br><span class="line">spring.rabbitmq.listener.simple.acknowledge-mode=manual</span><br></pre></td></tr></table></figure></li><li><p>然后就是在处理消息的方法中手动调用channel的一些有ack&#x2F;nack&#x2F;reject功能的方法来告知服务端消息的处理情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------ack消息处理完毕------------------------------------</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;test-queue&quot;&#125;)</span><span class="comment">//声明要监听的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OmsOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OmsOrderMapper, OmsOrder&gt; <span class="keyword">implements</span> <span class="title class_">OmsOrderService</span> &#123;</span><br><span class="line">    <span class="comment">//一个队列可以很多消费者来同时监听，只要消费者收到消息，队列就会删除消息，所以一个消息只会被一个消费者接收到，默认是轮询接收策略</span></span><br><span class="line">    <span class="comment">//只有当一个消息完全处理完（即方法运行结束），才可以接收下一个消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span><span class="comment">//声明该方法为消息处理方法，如果有消息到达类上注解中声明的要监听的队列，那么被@RabbitHandler注解修饰的方法会根据消息对象的类型和形参类型来选择接收（两者类型相同就接收）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">            Message msg,</span></span><br><span class="line"><span class="params">            OmsOrderService omsOrderService,</span></span><br><span class="line"><span class="params">            Channel channel</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> IOException &#123;<span class="comment">//可选三个参数接收：原生消息类型Message封装了消息（消息头+消息体），除了消息本身还有很多其他信息，第二个参数写消息中的对象的类可以直接接收到消息对象，第三个参数可以获取到客户端和mq之间连接中的进行消息交互的channel</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span>+msg+<span class="string">&quot; &quot;</span>+<span class="string">&quot;接收到的消息内容对象：&quot;</span>+omsOrderService);</span><br><span class="line">        <span class="comment">//手动确认ack表示消息已经处理完毕，服务端可以把对应的消息删掉了</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> msg.getMessageProperties().getDeliveryTag();<span class="comment">//获取消息在队列中的编号，用于ack</span></span><br><span class="line">        channel.basicAck(deliveryTag,<span class="literal">false</span>);<span class="comment">//第一个参数是消息在队列中的编号，用于服务端找到对应的消息，第二个参数为是否批量删除，false表示这个ack只ack对应的那一条消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------nack/reject拒收消息------------------------------------</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;test-queue&quot;&#125;)</span><span class="comment">//声明要监听的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OmsOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OmsOrderMapper, OmsOrder&gt; <span class="keyword">implements</span> <span class="title class_">OmsOrderService</span> &#123;</span><br><span class="line">    <span class="comment">//一个队列可以很多消费者来同时监听，只要消费者收到消息，队列就会删除消息，所以一个消息只会被一个消费者接收到，默认是轮询接收策略</span></span><br><span class="line">    <span class="comment">//只有当一个消息完全处理完（即方法运行结束），才可以接收下一个消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span><span class="comment">//声明该方法为消息处理方法，如果有消息到达类上注解中声明的要监听的队列，那么被@RabbitHandler注解修饰的方法会根据消息对象的类型和形参类型来选择接收（两者类型相同就接收）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">            Message msg,</span></span><br><span class="line"><span class="params">            OmsOrderService omsOrderService,</span></span><br><span class="line"><span class="params">            Channel channel</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> IOException &#123;<span class="comment">//可选三个参数接收：原生消息类型Message封装了消息（消息头+消息体），除了消息本身还有很多其他信息，第二个参数写消息中的对象的类可以直接接收到消息对象，第三个参数可以获取到客户端和mq之间连接中的进行消息交互的channel</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span>+msg+<span class="string">&quot; &quot;</span>+<span class="string">&quot;接收到的消息内容对象：&quot;</span>+omsOrderService);</span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> msg.getMessageProperties().getDeliveryTag();<span class="comment">//获取消息在队列中的编号，用于ack</span></span><br><span class="line">        <span class="comment">//手动调用nack/reject表示拒收消息,第一个参数是消息在队列中的编号，第二个参数为是否批量拒绝，第三个参数为是否将拒收的消息重新入队，如果是false，则直接删除掉对应的消息</span></span><br><span class="line">        channel.basicNack(deliveryTag,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2023-x2F-1-x2F-31"><a href="#2023-x2F-1-x2F-31" class="headerlink" title="2023&#x2F;1&#x2F;31"></a>2023&#x2F;1&#x2F;31</h1><h2 id="RabbitMQ延时队列实现定时任务"><a href="#RabbitMQ延时队列实现定时任务" class="headerlink" title="RabbitMQ延时队列实现定时任务"></a>RabbitMQ延时队列实现定时任务</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230131170636690.png" alt="image-20230131170636690"></p><h2 id="Feign远程调用丢失请求头的问题"><a href="#Feign远程调用丢失请求头的问题" class="headerlink" title="Feign远程调用丢失请求头的问题"></a>Feign远程调用丢失请求头的问题</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230131191229994.png" alt="image-20230131191229994"></p><ul><li><p>简而言之就是<strong>Feign在进行远程调用的时候会创建一个新的request，这个request中啥也没有，然后再根据远程调用方法的参数向request的请求体等地方塞数据</strong>，但是由于远程调用方法传的只是数据，所以Feign新建的request只能得到数据，无法得到别的东西，自然就无法得到服务收到的请求的请求头等信息。</p></li><li><p>所以我们应该在feign新建request完成之前，给request设置好它的请求头。通过feign运行过程的源码可以得知，在feign新建request完成之前会执行多个拦截器，所以我们可以<strong>编写一个feign中用到的拦截器，在拦截器中手动给feign构造的requestTemplate中加入当前收到的请求的请求头</strong>。那么如何给拦截器共享请求头呢？由于拦截器和收到请求的服务是在同一个线程中，所以当然<strong>可以使用ThreadLocal进行数据共享</strong>；<strong>也可以使用spring给我们封装的当前线程的请求数据，使用RequestContextHolder.getRequestAttributes()来获取</strong>，RequestContextHolder中维护了很多当前线程请求的上下文数据，这个底层就是用ThreadLocal实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallislandFeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;requestInterceptor&quot;)</span><span class="comment">//设置这个bean的标识符</span></span><br><span class="line">    <span class="keyword">public</span> RequestInterceptor <span class="title function_">requestInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> template -&gt; &#123;</span><br><span class="line">            <span class="comment">//通过RequestContextHolder拿到当前线程收到的请求</span></span><br><span class="line">            <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">            <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();<span class="comment">//获取请求</span></span><br><span class="line">            <span class="comment">//获得当前线程收到请求的cookie</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">cookie</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Cookie&quot;</span>);</span><br><span class="line">            <span class="comment">//把当前线程收到请求的cookie放到feign构造的requestTemplate中</span></span><br><span class="line">            template.header(<span class="string">&quot;Cookie&quot;</span>,cookie);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>所以解决后整个流程应该是这样的：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230131195252805.png" alt="image-20230131195252805"></p></li></ul><h2 id="异步情况下Feign丢失上下文的问题"><a href="#异步情况下Feign丢失上下文的问题" class="headerlink" title="异步情况下Feign丢失上下文的问题"></a>异步情况下Feign丢失上下文的问题</h2><ul><li><p>在上面加上拦截器的情况下，对Feign的远程调用方法进行异步调用的时候，Feign构造的request又出现了没有header的情况，这是什么问题呢？这是<strong>因为异步任务换了线程了，异步任务所在的线程无法获取到别的线程的ThreadLocal中的数据</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230131202603266.png" alt="image-20230131202603266"></p></li><li><p>解决方法很简单，<strong>只需要在CompletableFuture的方法参数中写的异步任务流程的lambda中手动添加上主线程的数据即可</strong>，可以在主线程使用RequestContextHolder的getRequestAttributes方法拿到数据，然后再在异步任务流程的lambda中使用使用RequestContextHolder的setRequestAttributes方法设置数据，RequestContextHolder底层是基于ThreadLocal实现的，所以不同线程有不同的RequestContextHolder。</p></li></ul><h1 id="2023-x2F-2-x2F-2"><a href="#2023-x2F-2-x2F-2" class="headerlink" title="2023&#x2F;2&#x2F;2"></a>2023&#x2F;2&#x2F;2</h1><h2 id="对数据库非主属性的唯一性约束"><a href="#对数据库非主属性的唯一性约束" class="headerlink" title="对数据库非主属性的唯一性约束"></a>对数据库非主属性的唯一性约束</h2><ul><li>可以给那个属性添加唯一索引，这样可以保证那个属性值的唯一性，但是唯一索引的效率可能偏低？</li></ul><h2 id="接口的幂等性"><a href="#接口的幂等性" class="headerlink" title="接口的幂等性"></a>接口的幂等性</h2><h3 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h3><ul><li>接口幂等性就是<strong>用户对于同一操作发起的一次请求或者多次请求的结果是一致的</strong>，不会因为多次点击而产生了副作用。</li></ul><h3 id="哪些情况下需要保证接口的幂等性"><a href="#哪些情况下需要保证接口的幂等性" class="headerlink" title="哪些情况下需要保证接口的幂等性"></a>哪些情况下需要保证接口的幂等性</h3><ol><li>用户多次点击同一个按钮（也就是用户多次调用同一个接口）</li><li>用户回退页面后再次进行提交</li><li>微服务之间进行互相调用，由于网络问题导致请求失败，feign触发重试机制</li><li>其他业务情况</li></ol><h3 id="什么情况下不需要保证接口的幂等性"><a href="#什么情况下不需要保证接口的幂等性" class="headerlink" title="什么情况下不需要保证接口的幂等性"></a>什么情况下不需要保证接口的幂等性</h3><ul><li>以SQL为例，有些操作是天然幂等的，比如crud一些固定的值、带主键的insert。</li><li>而有些SQL却不是幂等的，比如update一个值让其+1，或者是insert一个不带主键的元素（可以重复被insert）。</li></ul><h2 id="接口幂等性的解决方案"><a href="#接口幂等性的解决方案" class="headerlink" title="接口幂等性的解决方案"></a>接口幂等性的解决方案</h2><h3 id="token令牌机制"><a href="#token令牌机制" class="headerlink" title="token令牌机制"></a>token令牌机制</h3><ul><li>服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，<strong>服务器会把token保存在redis中</strong>。</li><li>然后调用业务接口请求的时候，把token携带到后端，<strong>token一般放在请求头部</strong>。</li><li>服务器判断token是否在redis中存在，如果存在表示这是第一次请求，删除token，继续执行业务。</li><li>如果判断token不存在redis中，就表示当前的操作是重复操作，直接返回重复标记给客户端，这样就保证了业务代码不被重复执行。</li></ul><h4 id="危险性"><a href="#危险性" class="headerlink" title="危险性"></a>危险性</h4><ol><li><p>先删除token还是后删除token？</p><ul><li>先删除可能导致第一次请求过来删除token后，业务没能处理完成，进行重试的时候，带的是之前的token，但是之前的token已经被删掉了，所以业务就无法被处理完成了。</li><li>后删除可能导致在处理的过程中，服务闪断，出现超时，token没能被删除，别人继续重试的时候，由于token还存在，所以服务又会被处理一次。</li><li>所以<strong>在使用token的时候，最好是设计成先删除token，如果业务调用失败，就重新获取新的token再次请求</strong>。</li></ul></li><li><p>token的获取、比较和删除操作的整体必须是原子性的</p><ul><li><p>这个问题比较好理解，如果这三个操作的整体不是原子性的，那么在高并发的情况下可能会产生业务的重复处理（一个时间段可能同时有很多线程拿到了那个token并进行比较）。</p></li><li><p>可以使用lua脚本完成这个操作：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[<span class="number">1</span>])==ARGV[<span class="number">1</span>] <span class="keyword">then</span> <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>]) <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="各种锁机制"><a href="#各种锁机制" class="headerlink" title="各种锁机制"></a>各种锁机制</h3><h4 id="数据库悲观锁"><a href="#数据库悲观锁" class="headerlink" title="数据库悲观锁"></a>数据库悲观锁</h4><ul><li>例：select * from xxxx where id &#x3D; 1 for update;</li><li>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，需要根据实际情况选用。另外要注意的是，id 字段一定是主键或者唯一索引，不然可能造成锁表的结果，处理起来会非常麻烦。</li></ul><h4 id="数据库乐观锁"><a href="#数据库乐观锁" class="headerlink" title="数据库乐观锁"></a>数据库乐观锁</h4><ul><li>这种方法适合用在更新的场景中，例：update t_goods set count &#x3D; count -1 , version &#x3D; version + 1 where good_id&#x3D;2 and version &#x3D; 1</li><li>根据 version 版本，也就是在操作库存前先获取当前商品的 version 版本号，然后操作的时候带上此 version 号。我们梳理下，我们第一次操作库存时，得到 version 为1，调用库存服务version 变成了 2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传入的 version 还是 1，再执行上面的 sql 语句时，就不会执行；因为version 已经变为 2 了，where 条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。乐观锁主要使用于处理读多写少的问题。</li></ul><h4 id="业务层分布式锁"><a href="#业务层分布式锁" class="headerlink" title="业务层分布式锁"></a>业务层分布式锁</h4><ul><li>如果多个机器可能在同一时间同时处理相同的数据，比如多台机器定时任务都拿到了相同数据处理，我们就可以加分布式锁，锁定此数据，处理完成后释放锁。获取到锁的必须先判断这个数据是否被处理过。</li></ul><h3 id="各种唯一约束"><a href="#各种唯一约束" class="headerlink" title="各种唯一约束"></a>各种唯一约束</h3><h4 id="数据库唯一约束"><a href="#数据库唯一约束" class="headerlink" title="数据库唯一约束"></a>数据库唯一约束</h4><ul><li>插入数据，应该按照唯一索引进行插入，比如订单号，相同的订单就不可能有两条记录插入。我们在数据库层面防止重复。</li><li>这个机制是利用了数据库的主键唯一约束的特性，解决了在 insert 场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。</li><li>如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。</li></ul><h4 id="用redis的set数据结构防重"><a href="#用redis的set数据结构防重" class="headerlink" title="用redis的set数据结构防重"></a>用redis的set数据结构防重</h4><ul><li>很多数据需要处理，只能被处理一次，比如我们可以计算数据的 MD5 将其放入redis 的set，每次处理数据，先看这个 MD5 是否已经存在，存在就不处理</li></ul><h3 id="防重表"><a href="#防重表" class="headerlink" title="防重表"></a>防重表</h3><ul><li>使用订单号 orderNo 做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。</li><li>之前的redis的set防重也是这个道理。</li></ul><h3 id="全局请求唯一id"><a href="#全局请求唯一id" class="headerlink" title="全局请求唯一id"></a>全局请求唯一id</h3><ul><li>调用接口时，生成一个唯一 id，redis 将数据保存到集合中（去重），存在即处理过。可以使用 nginx 设置每一个请求的唯一 id：<code>proxy_set_header X-Request-Id $request_id;</code></li></ul><h2 id="使用token令牌机制解决接口幂等性"><a href="#使用token令牌机制解决接口幂等性" class="headerlink" title="使用token令牌机制解决接口幂等性"></a>使用token令牌机制解决接口幂等性</h2><ul><li>在给需要用到幂等性接口的前端返回数据的时候生成一个token，给前端发一份，给redis中存一份。举例来说，给redis中存的时候，key可以用固定前缀+用户id，这样能保证一个用户在同一时间内只能完成一个订单。</li><li>在进行token验证的时候要注意两点，第一是<strong>要验证完token后要先删掉token再处理业务，这是为了防止业务重复处理</strong>；第二是<strong>要保证获取、比较、删除token这三步整体的原子性，这是为了防止在高并发的情况下导致的业务重复处理</strong>，保证三步完整性的lua脚本：**<code>if redis.call(&#39;get&#39;,KEYS[1])==ARGV[1] then return redis.call(&#39;del&#39;,KEYS[1]) else return 0 end</code>**，使用StringRedisTemplate中的execute方法来执行lua脚本，返回0说明token校验失败，返回1说明token校验成功。</li></ul><h2 id="Transactional本地事务"><a href="#Transactional本地事务" class="headerlink" title="@Transactional本地事务"></a>@Transactional本地事务</h2><ul><li><p>这个注解用于方法上，表明该方法对数据库的操作是一个事务，如果要是<strong>被这个注解修饰的方法中抛了异常，那么这个方法之前对数据库做的操作都会回滚（默认是对抛出的RuntimeException作出相应）</strong>。</p></li><li><p>可以<strong>通过这个注解的rollbackFor属性指定方法抛出哪些异常时数据库会回滚</strong>。</p></li><li><p><strong>本地事务只能控制当前服务对数据库操作的回滚，无法控制业务处理链上其他服务对数据库操作的回滚</strong>。</p></li><li><p>可以<strong>使用isolation属性来调整事务的隔离级别，MySQL的事务隔离级别默认是REPEATABLE-READ（可重复读）</strong>。</p></li><li><p>可以<strong>使用propagation属性来调整事务的传播行为，MySQL的事务传播行为默认是REQUIRED</strong>。</p></li><li><p>可以<strong>使用timeout属性来设置事务的超时时间，也就是这个事务如果要是在规定的时间内没有处理完的话，就会回滚数据库操作</strong>。</p></li><li><p>spring家的事务注解是通过生成代理对象来实现功能的，所以同一个对象内事务方法互调时，被调用的事务方法的注解是默认失效的，因为这样做相当于绕过了代理对象。所以在同一个对象内进行事务方法互调的时候，应该使用代理对象来进行事务方法的调用：</p><ol><li><p>首先引入aop的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring-boot-starter-aop.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring-boot-starter-aop.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--aop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-starter-aop.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后<strong>在配置类上用注解开启AspectJ动态代理的功能并对外暴露代理对象</strong>：**<code>@EnableAspectJAutoProxy</code>**，这样以后创建动态代理都是通过AspectJ来进行创建（即使没有实现接口，也能创建，这是它最大的特点），如果不加这个注解，那么动态代理会通过JDK来进行创建。</p></li><li><p>然后就是在同一个对象内事务方法互调的时候，调用事务方法的时候使用当前类的代理对象来进行调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是在OrderServiceImpl类的一个事务方法内部</span></span><br><span class="line"><span class="type">OrderServiceImpl</span> <span class="variable">orderService</span> <span class="operator">=</span> (OrderService)AopContext.currentProxy();<span class="comment">//获取当前类的代理对象</span></span><br><span class="line">orderService.method();<span class="comment">//调用本类中另一个事务方法</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h1 id="2023-x2F-2-x2F-3"><a href="#2023-x2F-2-x2F-3" class="headerlink" title="2023&#x2F;2&#x2F;3"></a>2023&#x2F;2&#x2F;3</h1><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><ul><li><p>CAP原则又称CAP定理，CAP分别代表分布式系统的三个可能拥有的特性：</p><ol><li><strong>一致性（Consistency）</strong>：这一特性是指在分布式系统中的所有数据备份，在同一时刻应该是同样的值。（等同于所有节点拥有同一份最新的数据副本）</li><li><strong>可用性（Availability）</strong>：这一特性是指在集群中一部分节点故障之后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li><li><strong>分区容错性（Partition tolerance）</strong>：大多数分布式系统都分布在多个子网络上，每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败，比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。分区容错性要求系统的部分节点或者网络出现故障之后仍能对外提供服务，也就是<strong>部分故障不影响整体使用</strong>。</li></ol></li><li><p>CAP原则指的是，在同一个分布式系统中，上面这三个特性最多只能同时实现两个，<strong>不可能三者兼顾</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230203193842541.png" alt="image-20230203193842541"></p></li><li><p><strong>一般来说，分区容错无法避免，因此可以认为CAP的P总是成立</strong>，除非是单机应用，没有任何网络通信。<strong>CAP定理告诉我们，在满足P的前提下，剩下的C和A无法同时做到</strong>。其实想想也很容易理解，如果一个集群中有三个节点，这三个节点之间互相连接，而突然1、2节点之间的通信链路故障了，造成2、3节点之间无法通信，由于分区容错性，部分故障不影响系统整体的使用，不妨假设在出故障之后，又有更新请求打过来，但是由于2、3节点无法通信，所以只有1、2节点对数据进行了更新，在这种情况下，如果要是说满足C也就是一致性的话，我们就只能访问1、2节点，无法访问3节点，这样就不满足A也就是可用性了；如果要是说满足A也就是可用性的话，我们可以访问1、2、3节点，但是只有1、2节点的数据是最新的，3节点的数据还是老数据，这样又不满足C也就是一致性了。所以剩下的C和A只能二选一，两者不可兼得，具体使用哪种方案还是得看具体情况。</p></li><li><p>在分布式系统中实现数据一致性的算法有raft算法、paxos算法等</p></li></ul><h2 id="raft算法"><a href="#raft算法" class="headerlink" title="raft算法"></a>raft算法</h2><ul><li>这是一种用来在分布式系统中实现数据一致性的算法，有个网站上有个动画解释地很通俗易懂：<a href="http://thesecretlivesofdata.com/raft/%E3%80%82">http://thesecretlivesofdata.com/raft/。</a></li><li>raft算法有两个关键点，一是领导选举，二是日志复制。</li><li><strong>这个算法只能用来解决分布式系统的一致性，不能解决可用性</strong>，因为如果发生分区错误，且各分区的节点数量是相同的，那么整个分布式系统永远都不会有Leader被选出，整个系统就变成了不可用状态，但是由于分区容错性，各节点还是可以访问的，只不过返回的都是系统不可用的状态。</li></ul><h3 id="领导选举（Leader-Election）"><a href="#领导选举（Leader-Election）" class="headerlink" title="领导选举（Leader Election）"></a>领导选举（Leader Election）</h3><ol><li>集群中的每个节点都有<strong>三种状态</strong>，第一种状态是Follower（随从），第二种状态是Candidate（候选人），第三种状态是Leader（领导）</li><li>一开始所有的节点都是Follower，然后所有的集群节点开始一个随机时间（一般在150ms到300ms）的自旋，自旋结束之后，如果它还没有收到来自Candidate的投票请求或者是Leader的心跳维持请求，那么当前这个节点就会变成Candidate。</li><li>成为Candidate的节点会向所有其他节点发出投票请求，它自己也会为自己投一票，当其它节点收到投票请求之后，它们会先重置自旋时间，如果它还没有投过票，那么它就会向Candidate进行回复，Candidate收到的回复数就是别的节点的投票数，加上自己给自己投的一票，如果总票数大于一半节点数（这也是一个系统只有一个Leader的原因），那么当前这个Candidate就会变成Leader。</li><li>之后所有对系统的修改请求都会先通过Leader，并且Leader会重复在一个小于最小自旋时间的时间段之后向所有的Follower发送心跳维持请求，当Follower接收到心跳维持请求之后，Follower会重置自己的自旋时间并向Leader回复心跳。</li><li>在这之后，如果Leader宕掉了，那么Follower就会收不到心跳维持请求，它的自旋时间就不会被重置，直到有一个Follower的自旋时间到了，它会再重复上面的过程变成新的Leader。</li><li>如果有两个节点同时变成Candidate怎么办？那这两个Candidate会同时向所有其他节点（包括另一个Candidate）发送投票请求，同时再给自己一个随机的自旋时间，如果其他节点投过票了就不能再投了（Candidate默认投自己一票），否则就会投给那个先到的请求的节点，得到票数之后如果有一个节点的票数大于一半的节点，那么它就会变成Leader，如果没有，那么等着它们的自旋时间结束之后再来一轮，重复这个过程直到选出Leader（正是因为只有票数大于一半的节点才会变成Leader，所以系统中才只会有一个Leader）。</li></ol><h3 id="日志复制（Log-Replication）"><a href="#日志复制（Log-Replication）" class="headerlink" title="日志复制（Log Replication）"></a>日志复制（Log Replication）</h3><ol><li>在进行过领导选举的过程之后，系统已经选出了一个Leader，之后所有对系统的修改请求都会先经过Leader，Leader会把修改要进行的操作记录到自己的日志中，注意此时这个<strong>日志的内容还未提交</strong>，因此系统中不会发生任何改变。</li><li>然后Leader<strong>通过心跳维持请求</strong>把自己的日志内容复制一份发给他的所有Follower，这些Follower也把这个日志的内容记录到自己的日志中。</li><li>每当Follower把日志写完了，就<strong>通过心跳</strong>回复Leader，当Leader接到一半以上节点的回复之后，就会把日志的修改进行提交，也就是说系统会真正发生改变。</li><li>然后Leader会向客户端回复表示系统已经完成了修改，<strong>在下一次发送心跳维持请求</strong>的时候Leader会通知其他的Follower也进行日志的提交，当所有Follower都提交完毕之后，整个系统的数据就保持了一致性。</li><li>如果之后整个集群发生分区错误被分割成了多个分区，那么各个分区都会通过领导选举算法选出一个领导，那么此时如何保证集群的一致性呢？只有拥有一半以上节点的分区（后称主分区）才会提交日志，别的分区只是进行了日志复制，当所有分区合并的时候，Leader就会只剩下主分区的Leader，然后Leader将自己的日志复制给所有的节点，那些次分区的日志会回滚并向客户端抛异常。&#x2F;&#x2F;todo 这个地方存疑，一些细节还不是很清楚。</li></ol><h2 id="大多数情况下在分布式系统中使用AP两个特性"><a href="#大多数情况下在分布式系统中使用AP两个特性" class="headerlink" title="大多数情况下在分布式系统中使用AP两个特性"></a>大多数情况下在分布式系统中使用AP两个特性</h2><ul><li>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到99.999…%（N个9），即<strong>保证分区容错性和可用性，舍弃一致性</strong>，但是有的服务也对一致性有一定的要求，所以有人提出了BASE理论。</li></ul><h2 id="强一致性、弱一致性、最终一致性"><a href="#强一致性、弱一致性、最终一致性" class="headerlink" title="强一致性、弱一致性、最终一致性"></a>强一致性、弱一致性、最终一致性</h2><ul><li>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是<strong>强一致性</strong>。如果能容忍后续的部分或者全部访问不到，则是<strong>弱一致性</strong>。如果经过一段时间后要求能访问到更新后的数据，则是<strong>最终一致性</strong>。</li></ul><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><ul><li><strong>基本可用（Basically Available）</strong>：基本可用是<strong>指分布式系统在出现故障的时候，允许损失部分可用性</strong>（例如响应时间、功能上的可用性）。需要注意的是，<strong>基本可用绝不等价于系统不可用</strong>。<ul><li><strong>响应时间上的损失</strong>：正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了 1~2 秒。</li><li><strong>功能上的损失</strong>：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ul></li><li><strong>软状态（ Soft State）</strong>：软状态是<strong>指允许系统存在中间状态，而该中间状态不会影响系统整体可用性</strong>。分布式存储中一般一份数据会有多个副本，<strong>允许不同副本同步的延时就是软状态的体现</strong>。mysql replication 的异步复制也是一种体现。</li><li><strong>最终一致性（ Eventual Consistency）</strong>：最终一致性是<strong>指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态</strong>。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</li></ul><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><ol><li>PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，<strong>事务的参数按照加入的事务为准</strong>，该设置是最常用的设置。</li><li>PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</li><li>PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li><li>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</li><li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。</li></ol><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><ul><li><p><strong>在分布式系统下，业务逻辑通常不是自己所在的模块单独完成的，而是通过很多模块之间远程调用组成一个业务处理链来完成一个业务</strong>，而这会造成很多的问题，分布式事务就是这样的处理业务的模式下的一个很普遍且严重的问题。</p></li><li><p>在一个业务处理链中，可能有一个或者多个模块出现问题，<strong>只要业务处理链上有一个模块出现问题，那么这个业务处理链对数据库做的所有操作都要回滚，分布式事务就是用来实现这个效果的</strong>，之前用过的@Transactional注解只能对被他修饰的那个方法起作用，无法对整个业务处理链起作用。</p></li><li><p><strong>产生分布式事务问题的最大原因就是网络问题</strong>，因为分布式的系统依赖于多个模块之间的网络通信，我们很难保证网络什么时候出问题什么时候不出问题。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230203154404398.png" alt="image-20230203154404398"></p></li></ul><h3 id="解决方案-对业务处理链上的所有节点方法加本地事务"><a href="#解决方案-对业务处理链上的所有节点方法加本地事务" class="headerlink" title="解决方案-对业务处理链上的所有节点方法加本地事务"></a>解决方案-对业务处理链上的所有节点方法加本地事务</h3><ul><li><strong>我们可以对业务处理链上的所有处理节点的方法都加上事务注解，但是这样做也会有问题，第一是操作比较繁琐，第二是远程服务调用完成后当前服务出现问题，那就只回滚了当前服务对数据库的操作，明显不对，第三是很难覆盖到所有出错的情况（远程服务假失败问题）</strong>，比如一个节点虽然没抛出异常，但是由于这个节点的超时，使得远程调用这个节点的上一个节点得到了节点失败的消息，从而触发它的数据库回滚操作，但是那个超时的节点的数据库却没有回滚，这样就造成了数据库中数据的不一致性，这可能是因为我们的疏忽，没有给他写超时的处理逻辑，但是这样的问题还有很多很多，想要做的面面俱到是比较困难的，所以这种方式不推荐使用。</li></ul><h3 id="柔性事务和刚性事务"><a href="#柔性事务和刚性事务" class="headerlink" title="柔性事务和刚性事务"></a>柔性事务和刚性事务</h3><ul><li><strong>刚性事务</strong>：遵循<strong>ACID原则</strong>，具有<strong>强一致性</strong>。</li><li><strong>柔性事务</strong>：遵循<strong>BASE理论</strong>，具有<strong>最终一致性</strong>。与刚性事务不同，柔性事务允许一定时间内不同节点的数据不一致，但要求这些节点的数据最终一致。</li></ul><h3 id="解决方案-刚性事务-2PC模式"><a href="#解决方案-刚性事务-2PC模式" class="headerlink" title="解决方案-刚性事务-2PC模式"></a>解决方案-刚性事务-2PC模式</h3><ul><li><p>这是<strong>数据库原生支持</strong>的2PC（2 phase commit <strong>二阶提交</strong>）模式，<strong>又叫做XA Transactions</strong>，该模式要求<strong>除了在模块本地有本地资源管理器来管理本地事务外，还有个统一的事务管理器来管理所有模块的事务</strong>，<strong>XA是一个两阶段提交协议</strong>，该协议分为以下两个阶段：</p><ol><li>第一阶段：事务协调器要求每个涉及到事务的数据库<strong>预提交（precommit）此操作，并反应是否可以提交</strong>。</li><li>第二阶段：事务协调器要求每个数据库<strong>提交数据，其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分内容</strong>。</li></ol><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230204174729136.png" alt="image-20230204174729136"></p></li><li><p>XA协议<strong>比较简单</strong>，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低。</p></li><li><p>但是XA协议的<strong>性能不理想</strong>，特别是在并发量很高的业务处理链路，XA无法满足高并发场景的需求。</p></li><li><p>XA 目前在商业数据库支持的比较理想，<strong>在mysql数据库中支持的不太理想</strong>，mysql 的XA 实现，没有记录 prepare 阶段日志，主备切换回导致主库与备库数据不一致。</p></li><li><p><strong>许多 nosql 也没有支持 XA</strong>，这让 XA 的应用场景变得非常狭隘。</p></li><li><p>也有 <strong>3PC，引入了超时机制（无论协调者还是参与者，在向对方发送请求后，若长时间未收到回应则做出相应处理）</strong></p></li></ul><h3 id="解决方案-柔性事务-TCC事务补偿型方案"><a href="#解决方案-柔性事务-TCC事务补偿型方案" class="headerlink" title="解决方案-柔性事务-TCC事务补偿型方案"></a>解决方案-柔性事务-TCC事务补偿型方案</h3><ul><li><p>TCC的三个字符实际上就是指Try、Confirm、Cancel方法，也就是说这种方案要求我们在写一个和数据库进行交互的逻辑的时候要写三个方法，这三个方法分别代表准备数据（try）、提交数据（confirm）、回滚数据（cancel）的逻辑，这样全局事务管理器就能通过调用事务的这些方法来统一管理所有事务的状态了，一开始的时候全局事务管理器让所有事务准备数据（调用对应事务的try方法），然后提交数据（调用对应事务的confirm方法），如果有任何一个事务出现问题，那么事务管理器会让所有的事务回滚数据（调用对应事务的cancel方法）：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230204181024543.png" alt="image-20230204181024543"></p></li><li><p>也是大体分成三个阶段：</p><ol><li>一阶段<strong>prepare行为</strong>：调用自定义的<strong>try方法</strong></li><li>二阶段<strong>commit行为</strong>：调用自定义的<strong>confirm方法</strong></li><li>三阶段<strong>rollback行为</strong>：调用自定义的<strong>cancel方法</strong></li></ol></li><li><p>从本质上看，就是<strong>我们自定义了事务的声明周期方法以供全局事务管理器进行调用</strong>，所谓的<strong>TCC模式，是指支持把自定义的分支事务纳入到全局事务的管理中</strong>。</p></li></ul><h3 id="解决方案-柔性事务-最大努力通知型方案"><a href="#解决方案-柔性事务-最大努力通知型方案" class="headerlink" title="解决方案-柔性事务-最大努力通知型方案"></a>解决方案-柔性事务-最大努力通知型方案</h3><ul><li>抽象地来说其实就是<strong>一个终端按照规律不停向别的终端发送消息，直到所有终端都回复表示自己已经收到了消息</strong>。</li><li>在分布式事务场景中具体来说就是，<strong>在事务失败的时候，对于已经完成的事务，事务管理器会按规律进行通知它们，直到所有已经完成的事务都返回表示自己已经收到，然后收到消息的已经完成的事务会进行回滚</strong>（&#x2F;&#x2F;todo 回滚是在发送收到之前还是之后？），不保证数据一定能通知成功，但会提供可查询操作接口进行核对。</li><li>这种方案<strong>主要用在与第三方系统通讯时，通常使用MQ进行实现</strong>，比如：调用微信或支付宝支付后的支付结果通知。这种方案也是结合 MQ 进行实现，例如：通过 MQ 发送 http 请求，设置最大通知次数。达到通知次数后即不再通知。</li><li>案例：银行通知、商户通知等（各大交易业务平台间的商户通知：多次通知、查询校对、对账文件），支付宝的支付成功异步回调</li></ul><h3 id="解决方案-柔性事务-可靠消息-最终一致性方案（异步确保型）"><a href="#解决方案-柔性事务-可靠消息-最终一致性方案（异步确保型）" class="headerlink" title="解决方案-柔性事务-可靠消息+最终一致性方案（异步确保型）"></a>解决方案-柔性事务-可靠消息+最终一致性方案（异步确保型）</h3><ul><li>和上面那个差不多，具体到分布式事务的场景就是<strong>在事务失败的时候异步发送消息有规律地通知已经完成的事务进行回滚</strong>(&#x2F;&#x2F;todo 不知道这个解释对不对)。异步的通知决定了这种方案是柔性的，同时异步的解决方案还能提高并发性能。</li><li>实现：业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。</li></ul><h1 id="2023-x2F-2-x2F-4"><a href="#2023-x2F-2-x2F-4" class="headerlink" title="2023&#x2F;2&#x2F;4"></a>2023&#x2F;2&#x2F;4</h1><h2 id="Seata解决分布式事务"><a href="#Seata解决分布式事务" class="headerlink" title="Seata解决分布式事务"></a>Seata解决分布式事务</h2><h3 id="Seata是什么"><a href="#Seata是什么" class="headerlink" title="Seata是什么"></a>Seata是什么</h3><ul><li>Seata是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata为用户<strong>提供了AT（Auto Transaction 自动事务）、TCC、SAGA和XA事务模式</strong>，为用户打造一站式的分布式解决方案。</li></ul><h3 id="Seata的工作原理"><a href="#Seata的工作原理" class="headerlink" title="Seata的工作原理"></a>Seata的工作原理</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230204193132779.png" alt="image-20230204193132779"></p><ul><li>调用其他事务的事务是<strong>全局事务</strong>，被调用的事务是<strong>分支事务</strong>。</li><li><strong>TC-事务协调者</strong>：维护全局和分支事务的状态，驱动全局事务提交或回滚。</li><li><strong>TM-事务管理器</strong>：定义全局事务的范围-开始全局事务、提交或回滚全局事务。</li><li><strong>RM-资源管理器</strong>：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li><li><strong>在开启全局事务的时候，TM会先向TC进行报告，然后TC就可以知道全局事务的实时状态且能控制TM了，然后在全局事务调用分支事务的时候，每当调用到一个分支事务，当前的分支事务都会将自己注册到TC中，这样TC也能知道分支事务的实时状态且能控制RM了，这样当某个事务失败后，TC会让所有已经完成的事务也回滚</strong>。</li></ul><h3 id="Seata怎么用"><a href="#Seata怎么用" class="headerlink" title="Seata怎么用"></a>Seata怎么用</h3><ul><li><p>首先如果要用Seata的<strong>AT模式</strong>应该<strong>对分布式事务用到的每一个微服务的数据库中创建undo_log表来记录快照以在回滚的时候补偿已经提交的事务</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 注意此处0.3.0+ 增加唯一索引 ux_undo_log</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure></li><li><p>然后<strong>下载事务协调器seata-server，这个东西实际上就是上面提到的TC-事务协调器</strong>：<a href="https://github.com/seata/seata/releases%EF%BC%8C%E8%BF%99%E4%B8%AA%E4%BA%8B%E5%8A%A1%E5%8D%8F%E8%B0%83%E5%99%A8(TC)%E5%AE%9E%E9%99%85%E4%B8%8A%E5%B0%B1%E6%98%AF%E4%B8%8A%E9%9D%A2%E8%AF%B4%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%8C%E9%80%9A%E8%BF%87%E5%AE%83%E6%9D%A5%E5%AF%B9%E5%90%84%E4%BA%8B%E5%8A%A1%E8%BF%9B%E8%A1%8C%E5%8D%8F%E8%B0%83%EF%BC%8C%E8%80%8C%E6%AF%8F%E4%B8%AA%E4%BA%8B%E5%8A%A1%E8%BF%98%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%8C**%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E5%B0%B1%E6%98%AF%E9%80%9A%E8%BF%87%E6%93%8D%E4%BD%9C%E4%BA%8B%E5%8A%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E6%9D%A5%E5%AF%B9%E6%89%80%E6%9C%89%E4%BA%8B%E5%8A%A1%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E7%9A%84**%E3%80%82">https://github.com/seata/seata/releases，这个事务协调器(TC)实际上就是上面说的解决方案中的全局事务管理器，通过它来对各事务进行协调，而每个事务还有自己的事务管理器，**全局事务管理器就是通过操作事务对应的本地事务管理器来对所有事务进行管理的**。</a></p></li><li><p>然后就是引入依赖，引入后<strong>要注意seata-all这个包的版本，这个包的版本决定着我们应该使用什么版本的seata-server</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后就是<strong>解压并启动下载好的seata-server</strong>，并<strong>按照自己的需求修改registry.conf注册中心配置和file.conf</strong></p></li><li></li><li><p>最后给分布式的全局事务上标注@GlobalTransactional注解，给分支事务上标注@Transactional注解，然后就能用了。</p></li></ul><h2 id="MQ解决分布式事务"><a href="#MQ解决分布式事务" class="headerlink" title="MQ解决分布式事务"></a>MQ解决分布式事务</h2><ul><li>seata默认用的是AT模式，分为两个阶段，一阶段是业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源；二阶段是异步化提交，如果出现问题，那么会通过一阶段的回滚日志进行反向补偿以达到回滚的目的（&#x2F;&#x2F;todo 还是不太清楚细节）。由于事务之间的隔离级别太高，所以这个模式不满足高并发的业务场景，所以<strong>考虑使用MQ来实现异步的最大努力通知型方案</strong>。</li></ul><h1 id="2023-x2F-2-x2F-6"><a href="#2023-x2F-2-x2F-6" class="headerlink" title="2023&#x2F;2&#x2F;6"></a>2023&#x2F;2&#x2F;6</h1><h2 id="项目开发中dev、test和prod是什么意思"><a href="#项目开发中dev、test和prod是什么意思" class="headerlink" title="项目开发中dev、test和prod是什么意思"></a>项目开发中dev、test和prod是什么意思</h2><ul><li><strong>开发环境（dev）</strong>：开发环境是程序猿们专门用于开发的服务器，配置可以比较随意，为了开发调试方便，一般打开全部错误报告。</li><li><strong>测试环境（test）</strong>：一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产机上。</li><li><strong>生产环境（prod）</strong>：是值<strong>正式提供对外服务</strong>的，一般会关掉错误报告，打开错误日志。</li><li>三个环境也可以说是系统开发的三个阶段：<strong>开发-&gt;测试-&gt;上线</strong>，其中<strong>生产环境也就是通常说的真实环境</strong>。</li></ul><h2 id="如何配置Bean的作用域"><a href="#如何配置Bean的作用域" class="headerlink" title="如何配置Bean的作用域"></a>如何配置Bean的作用域</h2><ul><li><p>Spring中Bean的作用域通常有下面几种：</p><ol><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ol></li><li><p>使用@Scope注解的方式设置Bean的作用域为原型模式，也就是每次用到的时候都创建一个新的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2023-x2F-2-x2F-8"><a href="#2023-x2F-2-x2F-8" class="headerlink" title="2023&#x2F;2&#x2F;8"></a>2023&#x2F;2&#x2F;8</h1><h2 id="ActiveProfiles注解"><a href="#ActiveProfiles注解" class="headerlink" title="@ActiveProfiles注解"></a>@ActiveProfiles注解</h2><ul><li><p>一般作用于测试类上， 用于<strong>声明生效的 Spring 配置文件</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = RANDOM_PORT)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;test&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TestBase</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2023-x2F-2-x2F-9"><a href="#2023-x2F-2-x2F-9" class="headerlink" title="2023&#x2F;2&#x2F;9"></a>2023&#x2F;2&#x2F;9</h1><h2 id="数据库被人黑了"><a href="#数据库被人黑了" class="headerlink" title="数据库被人黑了"></a>数据库被人黑了</h2><ul><li>谔谔，数据库竟然被人删了，也怪我密码设的太弱了，长个教训，以后可以从下面的这几个方面提高安全性：<ol><li>使用密码生成器生成强密码</li><li>开启mysql的binlog日志，数据库寄了可以通过这个日志来恢复数据</li><li>对外关闭数据库连接的端口，只能通过SSH来对数据库进行连接</li></ol></li></ul><h2 id="数据库无法远程连接"><a href="#数据库无法远程连接" class="headerlink" title="数据库无法远程连接"></a>数据库无法远程连接</h2><ul><li>报错：<code>Access denied for user &#39;root&#39;@&#39;xxx.xxx.xxx.xxx&#39; (using password: YES)</code></li><li>首先确保自己的密码输入正确</li><li>然后就是要打开mysql的远程授权，在mysql中使用命令：**<code>grant all privileges on *.* to root@&#39;%&#39; identified by &#39;root密码&#39;;</code><strong>然后再使用命令</strong><code>flush privileges;</code>**就能开启远程授权了。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;本项目基于尚硅谷的谷粒商城项目，主</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://konjacor.github.io/tags/SpringBoot/"/>
    
    <category term="SpringCloud" scheme="https://konjacor.github.io/tags/SpringCloud/"/>
    
    <category term="SpringMVC" scheme="https://konjacor.github.io/tags/SpringMVC/"/>
    
    <category term="商城" scheme="https://konjacor.github.io/tags/%E5%95%86%E5%9F%8E/"/>
    
    <category term="分布式" scheme="https://konjacor.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="微服务" scheme="https://konjacor.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="SpringCloudAlibaba" scheme="https://konjacor.github.io/tags/SpringCloudAlibaba/"/>
    
    <category term="Docker" scheme="https://konjacor.github.io/tags/Docker/"/>
    
    <category term="实战项目" scheme="https://konjacor.github.io/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="MyBatis" scheme="https://konjacor.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://konjacor.github.io/2022/12/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E9%87%8D%E7%82%B9(%E6%9A%82%E6%97%B6)/"/>
    <id>https://konjacor.github.io/2022/12/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E9%87%8D%E7%82%B9(%E6%9A%82%E6%97%B6)/</id>
    <published>2022-12-20T12:11:43.208Z</published>
    <updated>2022-12-20T12:11:43.208Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><input disabled="" type="checkbox"> </p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1软件危机介绍"><a href="#1软件危机介绍" class="headerlink" title="1软件危机介绍"></a>1软件危机介绍</h2><p>软件危机是指在计算机软件开发和维护过程中所遇到的一系列的严重问题。</p></li><li><p><input disabled="" type="checkbox"> </p><h2 id="2软件危机的典型表现（简单看一下）"><a href="#2软件危机的典型表现（简单看一下）" class="headerlink" title="2软件危机的典型表现（简单看一下）"></a>2软件危机的典型表现（简单看一下）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="3消除软件危机的途径（4条）（简答题）"><a href="#3消除软件危机的途径（4条）（简答题）" class="headerlink" title="3消除软件危机的途径（4条）（简答题）"></a>3消除软件危机的途径（4条）（简答题）</h2><p>①首先要对计算机软件有着正确的认识。</p><p>②要意识到软件开发不应该是某些个体劳动的神秘技术，而应该是组织良好、管理严密、各类人员协同配合、共同完成的项目工程。</p><p>③要坚持推广和使用在实践过程中总结出来的成功的技术和方法，并不断探索更好更高效的技术和方法。</p><p>④要开发和使用个好的软件工具。</p><p>总之，消除软件危机一方面要有相应的技术措施，也要有相应的组织管理措施。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="4软件工程的基本原理（7条）（简答）"><a href="#4软件工程的基本原理（7条）（简答）" class="headerlink" title="4软件工程的基本原理（7条）（简答）"></a>4软件工程的基本原理（7条）（简答）</h2><p>①使用分阶段的生命周期计划严格管理。</p><p>②要坚持进行阶段性评审。</p><p>③实行严格的产品控制。</p><p>④要使用现代程序设计技术。</p><p>⑤结果应能清楚地审查。</p><p>⑥开发小组的人员应该少而精。</p><p>⑦应该承认改进软件工程实践的重要性。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="5软件工程的方法学三要素（填空）以及目前使用的最广泛地两个软件工程方法学（填空）"><a href="#5软件工程的方法学三要素（填空）以及目前使用的最广泛地两个软件工程方法学（填空）" class="headerlink" title="5软件工程的方法学三要素（填空）以及目前使用的最广泛地两个软件工程方法学（填空）"></a>5软件工程的方法学三要素（填空）以及目前使用的最广泛地两个软件工程方法学（填空）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="6软件生命周期三个时期以及阶段"><a href="#6软件生命周期三个时期以及阶段" class="headerlink" title="6软件生命周期三个时期以及阶段"></a>6软件生命周期三个时期以及阶段</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="7几个软件过程的模型"><a href="#7几个软件过程的模型" class="headerlink" title="7几个软件过程的模型"></a>7几个软件过程的模型</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-研究可行性的三个方面（填空）"><a href="#1-研究可行性的三个方面（填空）" class="headerlink" title="1.研究可行性的三个方面（填空）"></a>1.研究可行性的三个方面（填空）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-数据字典的用途（三条）（简答）"><a href="#2-数据字典的用途（三条）（简答）" class="headerlink" title="2.数据字典的用途（三条）（简答）"></a>2.数据字典的用途（三条）（简答）</h2><p>①数据字典最重要的用途是作为分析阶段的工具。</p><p>②数据字典中每个数据元素的控制信息都是很有价值的。</p><p>③数据字典是开发数据库的第一步，也是很有价值的一步。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="3-成本估计的三个估算技术"><a href="#3-成本估计的三个估算技术" class="headerlink" title="3.成本估计的三个估算技术"></a>3.成本估计的三个估算技术</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-需求分析的三个模型即对应的图"><a href="#1-需求分析的三个模型即对应的图" class="headerlink" title="1.需求分析的三个模型即对应的图"></a>1.需求分析的三个模型即对应的图</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-E-R图的符号"><a href="#2-E-R图的符号" class="headerlink" title="2.E-R图的符号"></a>2.E-R图的符号</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="3-复印机的题"><a href="#3-复印机的题" class="headerlink" title="3.复印机的题"></a>3.复印机的题</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-形式化的三个常用的方法"><a href="#1-形式化的三个常用的方法" class="headerlink" title="1.形式化的三个常用的方法"></a>1.形式化的三个常用的方法</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="2-形式化优点（可能只考小结里的一个）"><a href="#2-形式化优点（可能只考小结里的一个）" class="headerlink" title="2.形式化优点（可能只考小结里的一个）"></a>2.形式化优点（可能只考小结里的一个）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-耦合是啥，划分"><a href="#1-耦合是啥，划分" class="headerlink" title="1.耦合是啥，划分"></a>1.耦合是啥，划分</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-内聚是啥，划分"><a href="#2-内聚是啥，划分" class="headerlink" title="2.内聚是啥，划分"></a>2.内聚是啥，划分</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="3-启发规则（7条）-（简答）"><a href="#3-启发规则（7条）-（简答）" class="headerlink" title="3.启发规则（7条）                 （简答）"></a>3.启发规则（7条）                 （简答）</h2><p>①改变软件结构提高模块的独立性。</p><p>②模块的规模应该适中</p><p>③深度、宽度、扇入和扇出都应该适当。</p><p>④模块的作用域应该在控制域之内。</p><p>⑤应该力争降低模块接口的复杂程度。</p><p>⑥设计单入口和单出口的模块。</p><p>⑦模块的功能应该可以预测。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="4-信息流的类型（填空）"><a href="#4-信息流的类型（填空）" class="headerlink" title="4.信息流的类型（填空）"></a>4.信息流的类型（填空）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-三种基本的控制结构（填空）"><a href="#1-三种基本的控制结构（填空）" class="headerlink" title="1.三种基本的控制结构（填空）"></a>1.三种基本的控制结构（填空）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-系统响应时间的两个重要属性（填空）"><a href="#2-系统响应时间的两个重要属性（填空）" class="headerlink" title="2.系统响应时间的两个重要属性（填空）"></a>2.系统响应时间的两个重要属性（填空）</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="3-过程设计工具"><a href="#3-过程设计工具" class="headerlink" title="3.过程设计工具"></a>3.过程设计工具</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="4-计算环形复杂度（需要三种方法P141P142题）"><a href="#4-计算环形复杂度（需要三种方法P141P142题）" class="headerlink" title="4.计算环形复杂度（需要三种方法P141P142题）"></a>4.计算环形复杂度（需要三种方法P141P142题）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-通常把编码和测试统称为实现（填空）"><a href="#1-通常把编码和测试统称为实现（填空）" class="headerlink" title="1.通常把编码和测试统称为实现（填空）"></a>1.通常把编码和测试统称为实现（填空）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-软件测试的步骤"><a href="#2-软件测试的步骤" class="headerlink" title="2.软件测试的步骤"></a>2.软件测试的步骤</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="3-代码审查分工（组长应该是啥样的（选择））"><a href="#3-代码审查分工（组长应该是啥样的（选择））" class="headerlink" title="3.代码审查分工（组长应该是啥样的（选择））"></a>3.代码审查分工（组长应该是啥样的（选择））</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="4-题P166-P168"><a href="#4-题P166-P168" class="headerlink" title="4.题P166~P168"></a>4.题P166~P168</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="5-黑盒技术的题（P173）"><a href="#5-黑盒技术的题（P173）" class="headerlink" title="5.黑盒技术的题（P173）"></a>5.黑盒技术的题（P173）</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="6-题P187"><a href="#6-题P187" class="headerlink" title="6.题P187"></a>6.题P187</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-四类维护活动（填空）"><a href="#1-四类维护活动（填空）" class="headerlink" title="1.四类维护活动（填空）"></a>1.四类维护活动（填空）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-面向对象的三种模型以及工具"><a href="#1-面向对象的三种模型以及工具" class="headerlink" title="1.面向对象的三种模型以及工具"></a>1.面向对象的三种模型以及工具</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-属性可见性（没有默认的可见性）"><a href="#2-属性可见性（没有默认的可见性）" class="headerlink" title="2.属性可见性（没有默认的可见性）"></a>2.属性可见性（没有默认的可见性）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1></li><li><p><input disabled="" type="checkbox"> </p><h2 id="无"><a href="#无" class="headerlink" title="无"></a>无</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-类构件的重用方式（填空）"><a href="#1-类构件的重用方式（填空）" class="headerlink" title="1.类构件的重用方式（填空）"></a>1.类构件的重用方式（填空）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h1></li><li><p><input disabled="" type="checkbox"> </p><h2 id="无-1"><a href="#无-1" class="headerlink" title="无"></a>无</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-代码行技术的优缺点-（简答）"><a href="#1-代码行技术的优缺点-（简答）" class="headerlink" title="1.代码行技术的优缺点                                   （简答）"></a>1.代码行技术的优缺点                                   （简答）</h2><p>（1）优点</p><p>①代码是所有的软件开发都要有的产品。</p><p>②很容易计算代码行数</p><p>（2）缺点</p><p>①源码知识软件配置的一部分，使用源码的规模来代表整体软件的规模似乎不是很合理。</p><p>②不同的语言实现同一个软件所用到的代码行数不同。</p><p>③代码行技术不适合用于非过程性的语言。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-工作量估算的三种模型（选择，混入一个别的）"><a href="#2-工作量估算的三种模型（选择，混入一个别的）" class="headerlink" title="2.工作量估算的三种模型（选择，混入一个别的）"></a>2.工作量估算的三种模型（选择，混入一个别的）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="3-民主制程序员组的优点（简答）"><a href="#3-民主制程序员组的优点（简答）" class="headerlink" title="3.民主制程序员组的优点（简答）"></a>3.民主制程序员组的优点（简答）</h2><p>①使组员们对发现程序错误抱有积极地态度，这种积极的态度有利于更快的发现程序中的错误，产生高质量的代码。</p><p>②组员们拥有充足民主，组内具有高度凝聚力，小组的学术氛围浓厚，有利于攻克技术难关。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="4-正式的技术复查包括-走查-和-审查（填空）"><a href="#4-正式的技术复查包括-走查-和-审查（填空）" class="headerlink" title="4.正式的技术复查包括  走查   和   审查（填空）"></a>4.正式的技术复查包括  走查   和   审查（填空）</h2></li></ul><p><img src="file:///D:\Softwares\QQ\Recv\2470152347\Image\Group2\7P~3\7P~38J{HQOM8VAVFBOVT1KN.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;/p&gt;
&lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h1&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;in</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://konjacor.github.io/2022/12/20/hello-world/"/>
    <id>https://konjacor.github.io/2022/12/20/hello-world/</id>
    <published>2022-12-20T12:11:43.202Z</published>
    <updated>2022-12-20T12:11:43.202Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>EffectiveJava读后整理</title>
    <link href="https://konjacor.github.io/2022/12/07/EffectiveJava%E8%AF%BB%E5%90%8E%E6%95%B4%E7%90%86/"/>
    <id>https://konjacor.github.io/2022/12/07/EffectiveJava%E8%AF%BB%E5%90%8E%E6%95%B4%E7%90%86/</id>
    <published>2022-12-07T08:23:35.000Z</published>
    <updated>2023-02-11T12:43:17.674Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul><li>这书也读了一段时间了，一直没时间整理，之后抽空整理一下吧，本身这本书就是通过一条条对读者Java编程的建议构成的，所以整理起来也比较容易。</li><li>我感觉这书里面表达的思想是很好的，但是就是中文翻译太烂了，经常翻译地让人摸不着头脑，但是里面的思想绝对是值得读者反复阅读揣摩的，我第一次读的时候水平有限，只能看懂一部分，等着自己的能力提升了再看几遍吧。</li><li>在这本书的引言中，作者写到了几个概念，完善了我之前对它们的理解：<strong>API是指类、接口、构造器、成员和序列化形式，程序员通过它们可以访问类、接口或者包</strong>、<strong>使用API编写程序的程序员被称为该API的用户，在类的实现中使用了API的类被称为该API的客户端</strong>、<strong>不严格地讲，一个包的导出API是由该包中的每个公有类或者接口中所有公有的或者受保护的成员和构造器组成</strong>。</li></ul><h1 id="第一条：用静态工厂方法代替构造器"><a href="#第一条：用静态工厂方法代替构造器" class="headerlink" title="第一条：用静态工厂方法代替构造器"></a>第一条：用静态工厂方法代替构造器</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>静态工厂方法可以有名称，相比于重载的构造器来说，明显多种静态工厂方法更能让该api的用户感觉体验更好，因为<strong>用户可以望文生义，看见静态工厂方法的名称就能知道这个方法返回的是哪一种对象</strong>，而如果使用重载的构造器，用户估计要区分半天，最后也不见得能用对。除此之外静态工厂方法在一些情况下还可以减小构造器的粒度，比如我们想要使用同样类型的一组参数创建不同种类的该类的对象，如果使用构造器的话，我们只能通过增加参数数量或者在构造器内部判断参数具体的值来判断应该如何初始化对象，因为参数数量和类型相同的构造器不构成重载；但是使用静态工厂方法的话，我们就可以将所有的情况区分开了，每个静态工厂方法虽然参数的数量和类型相同，但是它们生成的对象却不同，用户可以通过这些静态工厂对象的名字来区分它们。</li><li>使用静态工厂方法不必在每次调用它们的时候创建新对象，构造器一旦调用，对象也一定会随之创建，但是有的时候我们不希望创建对象，我们想用预先创建好的实例，这种情况下使用构造器的话就无法达成我们的目的了。<strong>对于不可变类来说使用静态工厂方法可以使用预先创建好的对象，或者把创建好的对象缓存起来重复利用，从而避免创建不必要的重复对象</strong>。</li><li>使用静态工厂方法代替构造器可以返回该类的任何子类的对象，</li><li>使用静态工厂方法所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值，</li><li>使用静态工厂方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在，</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>类如果不含公有的或者受保护的构造器，就不能被子类化，</li><li>程序员很难发现它们，因为它们不和构造器一样在API文档中被明确地标识出来，程序员要发现它们，大多数情况下是依赖API开发者和程序员之间的约定，</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>静态工厂方法和构造器各有优劣，但是多数情况下静态工厂方法都能代替构造器，所以<strong>在编写一个类的时候应该优先考虑静态工厂方法而不是公共的构造器</strong>。</li></ul><h1 id="第2条：构造器参数过多时要考虑使用构建器"><a href="#第2条：构造器参数过多时要考虑使用构建器" class="headerlink" title="第2条：构造器参数过多时要考虑使用构建器"></a>第2条：构造器参数过多时要考虑使用构建器</h1><ul><li>对于静态工厂方法和构造器来说，它们都不能很好地扩展大量的的可选参数。那么对于可选参数很多的类我们应该怎样编写呢？</li><li>程序员一向习惯采用重叠构造器模式，</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;这书也读了一段时间了，一直没时间整</summary>
      
    
    
    
    
    <category term="EffectiveJava" scheme="https://konjacor.github.io/tags/EffectiveJava/"/>
    
    <category term="读后整理" scheme="https://konjacor.github.io/tags/%E8%AF%BB%E5%90%8E%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JUC并发编程</title>
    <link href="https://konjacor.github.io/2022/12/07/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://konjacor.github.io/2022/12/07/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2022-12-07T08:22:54.000Z</published>
    <updated>2022-12-20T12:11:43.195Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
</summary>
      
    
    
    
    
    <category term="JUC工具类" scheme="https://konjacor.github.io/tags/JUC%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    <category term="并发编程" scheme="https://konjacor.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://konjacor.github.io/2022/12/07/JVM/"/>
    <id>https://konjacor.github.io/2022/12/07/JVM/</id>
    <published>2022-12-07T08:22:17.000Z</published>
    <updated>2022-12-20T12:11:43.196Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
</summary>
      
    
    
    
    
    <category term="JVM" scheme="https://konjacor.github.io/tags/JVM/"/>
    
    <category term="Java虚拟机" scheme="https://konjacor.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud</title>
    <link href="https://konjacor.github.io/2022/12/07/SpringCloud/"/>
    <id>https://konjacor.github.io/2022/12/07/SpringCloud/</id>
    <published>2022-12-07T08:15:34.000Z</published>
    <updated>2022-12-20T12:11:43.200Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><ul><li>尚硅谷SpringCloudAlibaba教程，第42章由于缺乏JUC并发编程的知识还没有听。</li><li>JMeter压力测试</li><li>gateway底层采用了webflux和reactor-netty这类异步非阻塞响应式框架，什么是异步非阻塞响应式？</li><li>IDEA中如果不想写太多重复的微服务，可以使用虚拟端口映射来复制一份，但是复制的一份是虚的，最终请求还是打到被复制的微服务上。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;ul&gt;
&lt;li&gt;尚硅谷SpringCloudAlibaba教程，第42章由于缺乏JUC并发编程的知识还没有听。&lt;/li&gt;
&lt;li&gt;JMeter压力测试&lt;/li&gt;
&lt;li&gt;gateway</summary>
      
    
    
    
    
    <category term="SpringCloud" scheme="https://konjacor.github.io/tags/SpringCloud/"/>
    
    <category term="Alibaba" scheme="https://konjacor.github.io/tags/Alibaba/"/>
    
  </entry>
  
  <entry>
    <title>Maven</title>
    <link href="https://konjacor.github.io/2022/11/01/Maven/"/>
    <id>https://konjacor.github.io/2022/11/01/Maven/</id>
    <published>2022-11-01T12:17:52.000Z</published>
    <updated>2022-12-20T12:11:43.198Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="为什么要学习Maven？"><a href="#为什么要学习Maven？" class="headerlink" title="为什么要学习Maven？"></a>为什么要学习Maven？</h1><h2 id="Maven作为依赖管理工具"><a href="#Maven作为依赖管理工具" class="headerlink" title="Maven作为依赖管理工具"></a>Maven作为依赖管理工具</h2><h3 id="jar包的规模越来越大"><a href="#jar包的规模越来越大" class="headerlink" title="jar包的规模越来越大"></a>jar包的规模越来越大</h3><ul><li><p>随着我们使用越来越多的框架，或者框架封装程度越来越高，<strong>项目中使用的jar包也越来越多</strong>。项目中，一个模块里面用到上百个jar包是非常正常的。</p></li><li><p>比如下面的例子，我们只用到SpringBoot、SpringCloud框架中的三个功能：</p><ol><li>Nacos 服务注册发现</li><li>Web 框架环境</li><li>图模板技术 Thymeleaf</li></ol><p>最终却导入了106个jar包……</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.security:spring-security-rsa:jar:1.0.9.RELEASE:compile</span><br><span class="line">com.netflix.ribbon: ribbon:jar:2.3.0:compile</span><br><span class="line">org.springframework.boot:spring-boot-starter-thymeleaf:jar:2.3.6.RELEASE:compile</span><br><span class="line">commons-configuration:commons-configuration:jar:1.8:compile</span><br><span class="line">org.apache.logging.log4j:log4j-api:jar:2.13.3:compile</span><br><span class="line">org.springframework:spring-beans:jar:5.2.11.RELEASE:compile</span><br><span class="line">org.springframework.cloud:spring-cloud-starter-netflix-ribbon:jar:2.2.6.RELEASE:compile</span><br><span class="line">org.apache.tomcat.embed:tomcat-embed-websocket:jar:9.0.39:compile</span><br><span class="line">com.alibaba.cloud:spring-cloud-alibaba-commons:jar:2.2.6.RELEASE:compile</span><br><span class="line">org.bouncycastle:bcprov-jdk15on:jar:1.64:compile</span><br><span class="line">org.springframework.security:spring-security-crypto:jar:5.3.5.RELEASE:compile</span><br><span class="line">org.apache.httpcomponents:httpasyncclient:jar:4.1.4:compile</span><br><span class="line">com.google.j2objc:j2objc-annotations:jar:1.3:compile</span><br><span class="line">com.fasterxml.jackson.core:jackson-databind:jar:2.11.3:compile</span><br><span class="line">io.reactivex:rxjava:jar:1.3.8:compile</span><br><span class="line">ch.qos.logback:logback-classic:jar:1.2.3:compile</span><br><span class="line">org.springframework:spring-web:jar:5.2.11.RELEASE:compile</span><br><span class="line">io.reactivex:rxnetty-servo:jar:0.4.9:runtime</span><br><span class="line">org.springframework:spring-core:jar:5.2.11.RELEASE:compile</span><br><span class="line">io.github.openfeign.form:feign-form-spring:jar:3.8.0:compile</span><br><span class="line">io.github.openfeign.form:feign-form:jar:3.8.0:compile</span><br><span class="line">com.netflix.ribbon:ribbon-loadbalancer:jar:2.3.0:compile</span><br><span class="line">org.apache.httpcomponents:httpcore:jar:4.4.13:compile</span><br><span class="line">org.thymeleaf.extras:thymeleaf-extras-java8time:jar:3.0.4.RELEASE:compile</span><br><span class="line">org.slf4j:jul-to-slf4j:jar:1.7.30:compile</span><br><span class="line">com.atguigu.demo:demo09-base-entity:jar:1.0-SNAPSHOT:compile</span><br><span class="line">org.yaml:snakeyaml:jar:1.26:compile</span><br><span class="line">org.springframework.boot:spring-boot-starter-logging:jar:2.3.6.RELEASE:compile</span><br><span class="line">io.reactivex:rxnetty-contexts:jar:0.4.9:runtime</span><br><span class="line">org.apache.httpcomponents:httpclient:jar:4.5.13:compile</span><br><span class="line">io.github.openfeign:feign-core:jar:10.10.1:compile</span><br><span class="line">org.springframework.boot:spring-boot-starter-aop:jar:2.3.6.RELEASE:compile</span><br><span class="line">org.hdrhistogram:HdrHistogram:jar:2.1.9:compile</span><br><span class="line">org.springframework:spring-context:jar:5.2.11.RELEASE:compile</span><br><span class="line">commons-lang:commons-lang:jar:2.6:compile</span><br><span class="line">io.prometheus:simpleclient:jar:0.5.0:compile</span><br><span class="line">ch.qos.logback:logback-core:jar:1.2.3:compile</span><br><span class="line">org.springframework:spring-webmvc:jar:5.2.11.RELEASE:compile</span><br><span class="line">com.sun.jersey:jersey-core:jar:1.19.1:runtime</span><br><span class="line">javax.ws.rs:jsr311-api:jar:1.1.1:runtime</span><br><span class="line">javax.inject:javax.inject:jar:1:runtime</span><br><span class="line">org.springframework.cloud:spring-cloud-openfeign-core:jar:2.2.6.RELEASE:compile</span><br><span class="line">com.netflix.ribbon:ribbon-core:jar:2.3.0:compile</span><br><span class="line">com.netflix.hystrix:hystrix-core:jar:1.5.18:compile</span><br><span class="line">com.netflix.ribbon:ribbon-transport:jar:2.3.0:runtime</span><br><span class="line">org.springframework.boot:spring-boot-starter-json:jar:2.3.6.RELEASE:compile</span><br><span class="line">org.springframework.cloud:spring-cloud-starter-openfeign:jar:2.2.6.RELEASE:compile</span><br><span class="line">com.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.11.3:compile</span><br><span class="line">com.sun.jersey.contribs:jersey-apache-client4:jar:1.19.1:runtime</span><br><span class="line">io.github.openfeign:feign-hystrix:jar:10.10.1:compile</span><br><span class="line">io.github.openfeign:feign-slf4j:jar:10.10.1:compile</span><br><span class="line">com.alibaba.nacos:nacos-client:jar:1.4.2:compile</span><br><span class="line">org.apache.httpcomponents:httpcore-nio:jar:4.4.13:compile</span><br><span class="line">com.sun.jersey:jersey-client:jar:1.19.1:runtime</span><br><span class="line">org.springframework.cloud:spring-cloud-context:jar:2.2.6.RELEASE:compile</span><br><span class="line">org.glassfish:jakarta.el:jar:3.0.3:compile</span><br><span class="line">org.apache.logging.log4j:log4j-to-slf4j:jar:2.13.3:compile</span><br><span class="line">com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.11.3:compile</span><br><span class="line">org.springframework.cloud:spring-cloud-commons:jar:2.2.6.RELEASE:compile</span><br><span class="line">org.aspectj:aspectjweaver:jar:1.9.6:compile</span><br><span class="line">com.alibaba.cloud:spring-cloud-starter-alibaba-nacos-discovery:jar:2.2.6.RELEASE:compile</span><br><span class="line">com.google.guava:listenablefuture:jar:9999.0-empty-to-avoid-conflict-with-guava:compile</span><br><span class="line">com.alibaba.spring:spring-context-support:jar:1.0.10:compile</span><br><span class="line">jakarta.annotation:jakarta.annotation-api:jar:1.3.5:compile</span><br><span class="line">org.bouncycastle:bcpkix-jdk15on:jar:1.64:compile</span><br><span class="line">com.netflix.netflix-commons:netflix-commons-util:jar:0.3.0:runtime</span><br><span class="line">com.fasterxml.jackson.core:jackson-annotations:jar:2.11.3:compile</span><br><span class="line">com.google.guava:guava:jar:29.0-jre:compile</span><br><span class="line">com.google.guava:failureaccess:jar:1.0.1:compile</span><br><span class="line">org.springframework.boot:spring-boot:jar:2.3.6.RELEASE:compile</span><br><span class="line">com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.11.3:compile</span><br><span class="line">com.atguigu.demo:demo08-base-api:jar:1.0-SNAPSHOT:compile</span><br><span class="line">org.springframework.cloud:spring-cloud-starter-netflix-archaius:jar:2.2.6.RELEASE:compile</span><br><span class="line">org.springframework.boot:spring-boot-autoconfigure:jar:2.3.6.RELEASE:compile</span><br><span class="line">org.slf4j:slf4j-api:jar:1.7.30:compile</span><br><span class="line">commons-io:commons-io:jar:2.7:compile</span><br><span class="line">org.springframework.cloud:spring-cloud-starter:jar:2.2.6.RELEASE:compile</span><br><span class="line">org.apache.tomcat.embed:tomcat-embed-core:jar:9.0.39:compile</span><br><span class="line">io.reactivex:rxnetty:jar:0.4.9:runtime</span><br><span class="line">com.fasterxml.jackson.core:jackson-core:jar:2.11.3:compile</span><br><span class="line">com.google.code.findbugs:jsr305:jar:3.0.2:compile</span><br><span class="line">com.netflix.archaius:archaius-core:jar:0.7.6:compile</span><br><span class="line">org.springframework.boot:spring-boot-starter-web:jar:2.3.6.RELEASE:compile</span><br><span class="line">commons-codec:commons-codec:jar:1.14:compile</span><br><span class="line">com.netflix.servo:servo-core:jar:0.12.21:runtime</span><br><span class="line">com.google.errorprone:error_prone_annotations:jar:2.3.4:compile</span><br><span class="line">org.attoparser:attoparser:jar:2.0.5.RELEASE:compile</span><br><span class="line">com.atguigu.demo:demo10-base-util:jar:1.0-SNAPSHOT:compile</span><br><span class="line">org.checkerframework:checker-qual:jar:2.11.1:compile</span><br><span class="line">org.thymeleaf:thymeleaf-spring5:jar:3.0.11.RELEASE:compile</span><br><span class="line">commons-fileupload:commons-fileupload:jar:1.4:compile</span><br><span class="line">com.netflix.ribbon:ribbon-httpclient:jar:2.3.0:compile</span><br><span class="line">com.netflix.netflix-commons:netflix-statistics:jar:0.1.1:runtime</span><br><span class="line">org.unbescape:unbescape:jar:1.1.6.RELEASE:compile</span><br><span class="line">org.springframework:spring-jcl:jar:5.2.11.RELEASE:compile</span><br><span class="line">com.alibaba.nacos:nacos-common:jar:1.4.2:compile</span><br><span class="line">commons-collections:commons-collections:jar:3.2.2:runtime</span><br><span class="line">javax.persistence:persistence-api:jar:1.0:compile</span><br><span class="line">com.alibaba.nacos:nacos-api:jar:1.4.2:compile</span><br><span class="line">org.thymeleaf:thymeleaf:jar:3.0.11.RELEASE:compile</span><br><span class="line">org.springframework:spring-aop:jar:5.2.11.RELEASE:compile</span><br><span class="line">org.springframework.boot:spring-boot-starter:jar:2.3.6.RELEASE:compile</span><br><span class="line">org.springframework.boot:spring-boot-starter-tomcat:jar:2.3.6.RELEASE:compile</span><br><span class="line">org.springframework.cloud:spring-cloud-netflix-ribbon:jar:2.2.6.RELEASE:compile</span><br><span class="line">org.springframework:spring-expression:jar:5.2.11.RELEASE:compile</span><br><span class="line">org.springframework.cloud:spring-cloud-netflix-archaius:jar:2.2.6.RELEASE:compile</span><br></pre></td></tr></table></figure></li><li><p>而如果使用Maven来引入这些jar包只需要配置三个<strong>依赖</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- Nacos 服务注册发现启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- web启动器依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 视图模板技术 thymeleaf --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>剩下的依赖Maven通过处理依赖结构、利用依赖传递的特性自动帮我们导入了。</p></li></ul><h3 id="jar包的来源良莠不齐"><a href="#jar包的来源良莠不齐" class="headerlink" title="jar包的来源良莠不齐"></a>jar包的来源良莠不齐</h3><ul><li>多数jar包所属技术的官网通常是英文界面，网站的结构又不尽相同，甚至找到下载链接还发现需要通过特殊的工具下载。</li><li>第三方网站提供下载。问题是不规范，在使用过程中会出现各种问题。<ul><li>jar包的名称可能不同</li><li>jar包的版本可能不同</li><li>jar包内的具体细节可能不同</li></ul></li><li>而使用 Maven 后，<strong>依赖对应的 jar 包能够自动下载</strong>，方便、快捷又规范。</li></ul><h3 id="jar包之间的依赖关系难以手动处理"><a href="#jar包之间的依赖关系难以手动处理" class="headerlink" title="jar包之间的依赖关系难以手动处理"></a>jar包之间的依赖关系难以手动处理</h3><ul><li><p>框架中使用的 jar 包，不仅数量庞大，而且<strong>彼此之间存在错综复杂的依赖关系。依赖关系的复杂程度，已经上升到了完全不能靠人力手动解决的程度</strong>。另外，<strong>jar 包之间有可能产生冲突</strong>。进一步增加了我们在 jar 包使用过程中的难度。</p></li><li><p>下面是前面的例子中jar包之间的依赖关系，属于是看都看不过来了……：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221101204923420.png" alt="image-20221101204923420"></p></li><li><p>而实际上<strong>jar 包之间的依赖关系是普遍存在的，如果要由程序员手动梳理无疑会增加极高的学习成本</strong>，而这些工作又对实现业务功能毫无帮助。</p></li><li><p>而<strong>使用 Maven 则几乎不需要管理这些关系，极个别的地方调整一下即可，极大的减轻了我们的工作量</strong>。</p></li></ul><h2 id="Maven作为构建的管理工具"><a href="#Maven作为构建的管理工具" class="headerlink" title="Maven作为构建的管理工具"></a>Maven作为构建的管理工具</h2><h3 id="你没有注意过的构建"><a href="#你没有注意过的构建" class="headerlink" title="你没有注意过的构建"></a>你没有注意过的构建</h3><ul><li>你可以不使用 Maven，但是构建必须要做。当我们使用 IDEA 进行开发时，构建是 IDEA 替我们做的。</li><li><strong>编译源文件、测试、打包、部署等步骤都属于项目的构建</strong></li></ul><h3 id="脱离IDE环境仍需构建"><a href="#脱离IDE环境仍需构建" class="headerlink" title="脱离IDE环境仍需构建"></a>脱离IDE环境仍需构建</h3><ul><li><p>以下是企业开发代码从开发到部署的流程，可以看到代码在推送到服务器上之后仍需要构建，Maven在服务器上对于代码的构建也起到了举足轻重的作用：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221101210513468.png" alt="image-20221101210513468"></p></li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul><li><strong>管理规模庞大的 jar 包，需要专门工具。</strong></li><li><strong>脱离 IDE 环境执行构建操作，需要专门工具。</strong></li></ul><h1 id="什么是Maven"><a href="#什么是Maven" class="headerlink" title="什么是Maven"></a>什么是Maven</h1><ul><li><p>Maven 是 Apache 软件基金会组织维护的一款专门<strong>为 Java 项目提供构建和依赖管理支持的工具</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221101231358965.png" alt="image-20221101231358965"></p></li></ul><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><ul><li><p>Java项目开发过程中，<strong>构建指的是使用原材料生产产品的过程</strong>。</p><p><strong>原材料</strong>：Java源代码、基于HTML的Thymeleaf文件、图片、配置文件等</p><p><strong>产品</strong>：一个可以在服务器上运行的项目</p></li><li><p>构建过程包含的主要环节：</p><ul><li><strong>清理</strong>：删除上一次构建的结果，为下一次构建做好准备</li><li><strong>编译</strong>：Java 源程序编译成 *.class 字节码文件</li><li><strong>测试</strong>：运行提前准备好的测试程序</li><li><strong>报告</strong>：针对刚才测试的结果生成一个全面的信息</li><li><strong>打包</strong>：<ul><li>Java工程：jar包</li><li>Web工程：war包</li></ul></li><li><strong>安装</strong>：把一个 Maven 工程经过打包操作生成的 jar 包或 war 包存入 Maven 仓库</li><li><strong>部署</strong>：<ul><li>部署 jar 包：把一个 jar 包部署到 Nexus 私服服务器上</li><li>部署 war 包：借助相关 Maven 插件（例如 cargo），将 war 包部署到 Tomcat 服务器上</li></ul></li></ul></li></ul><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li><p>如果 A 工程里面用到了 B 工程的类、接口、配置文件等等这样的资源，那么我们就可以说 A 依赖 B。例如：</p><ul><li>junit-4.12 依赖 hamcrest-core-1.3</li><li>thymeleaf-3.0.12.RELEASE 依赖 ognl-3.1.26<ul><li>ognl-3.1.26 依赖 javassist-3.20.0-GA</li></ul></li><li>thymeleaf-3.0.12.RELEASE 依赖 attoparser-2.0.5.RELEASE</li><li>thymeleaf-3.0.12.RELEASE 依赖 unbescape-1.1.6.RELEASE</li><li>thymeleaf-3.0.12.RELEASE 依赖 slf4j-api-1.7.26</li></ul></li><li><p>依赖管理中要解决的具体问题：</p><ul><li><strong>jar 包的下载</strong>：使用 Maven 之后，jar 包会从规范的远程仓库下载到本地</li><li><strong>jar 包之间的依赖</strong>：通过依赖的传递性自动完成</li><li><strong>jar 包之间的冲突</strong>：通过对依赖的配置进行调整，让某些jar包不会被导入</li></ul></li></ul><h2 id="Maven的工作机制"><a href="#Maven的工作机制" class="headerlink" title="Maven的工作机制"></a>Maven的工作机制</h2><ul><li>下面的图很清晰的说明了Maven的工作机制：<img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221101232114478.png" alt="image-20221101232114478"></li></ul><h1 id="Maven核心程序解压与配置"><a href="#Maven核心程序解压与配置" class="headerlink" title="Maven核心程序解压与配置"></a>Maven核心程序解压与配置</h1><h2 id="Maven官网地址"><a href="#Maven官网地址" class="headerlink" title="Maven官网地址"></a>Maven官网地址</h2><ul><li><p>首页：<a href="https://maven.apache.org/">https://maven.apache.org/</a></p></li><li><p>下载页面：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a></p></li><li><p>下载链接：<a href="https://dlcdn.apache.org/maven/maven-3/3.8.4/binaries/apache-maven-3.8.4-bin.zip">https://dlcdn.apache.org/maven/maven-3/3.8.4/binaries/apache-maven-3.8.4-bin.zip</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102091030137.png" alt="image-20221102091030137"></p><p>带src的是带源码的版本，扩展名是.tar.gz的是linux的。</p></li></ul><h2 id="解压Maven核心程序"><a href="#解压Maven核心程序" class="headerlink" title="解压Maven核心程序"></a>解压Maven核心程序</h2><ul><li><p>核心程序压缩包：apache-maven-3.8.4-bin.zip，<strong>解压到非中文、没有空格的目录</strong>。例如：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102091153825.png" alt="image-20221102091153825"></p></li><li><p>在解压目录中，我们需要着重关注Maven的核心配置文件：<strong>conf&#x2F;settings.xml</strong></p></li></ul><h2 id="指定本地仓库"><a href="#指定本地仓库" class="headerlink" title="指定本地仓库"></a>指定本地仓库</h2><ul><li><p><strong>本地仓库默认值：用户家目录&#x2F;.m2&#x2F;repository</strong>。由于本地仓库的默认位置是在用户的家目录下，而家目录往往是在 C 盘，也就是系统盘。将来 Maven 仓库中 jar 包越来越多，仓库体积越来越大，可能会拖慢 C 盘运行速度，影响系统性能。所以<strong>建议将 Maven 的本地仓库放在其他盘符下</strong>。配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">| The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">| Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\maven-repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>本地仓库这个目录，我们<strong>手动创建一个空的目录即可</strong>。注意配置不要写到配置文件的注释里面，然后<strong>本地仓库本身也需要使用一个非中文、没有空格的目录</strong>。</p></li></ul><h2 id="配置阿里云提供的镜像仓库"><a href="#配置阿里云提供的镜像仓库" class="headerlink" title="配置阿里云提供的镜像仓库"></a>配置阿里云提供的镜像仓库</h2><ul><li>Maven 下载 jar 包默认访问境外的中央仓库，而国外网站速度很慢。<strong>改成阿里云提供的镜像仓库，访问国内网站，可以让 Maven 下载 jar 包的时候速度更快</strong>。配置的方式是：</li></ul><h3 id="将原有的例子配置注释掉"><a href="#将原有的例子配置注释掉" class="headerlink" title="将原有的例子配置注释掉"></a>将原有的例子配置注释掉</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;mirror&gt;</span></span><br><span class="line"><span class="comment">  &lt;id&gt;maven-default-http-blocker&lt;/id&gt;</span></span><br><span class="line"><span class="comment">  &lt;mirrorOf&gt;external:http:*&lt;/mirrorOf&gt;</span></span><br><span class="line"><span class="comment">  &lt;name&gt;Pseudo repository to mirror external repositories initially using HTTP.&lt;/name&gt;</span></span><br><span class="line"><span class="comment">  &lt;url&gt;http://0.0.0.0/&lt;/url&gt;</span></span><br><span class="line"><span class="comment">  &lt;blocked&gt;true&lt;/blocked&gt;</span></span><br><span class="line"><span class="comment">&lt;/mirror&gt; --&gt;</span></span><br></pre></td></tr></table></figure><h3 id="加入阿里云的镜像配置"><a href="#加入阿里云的镜像配置" class="headerlink" title="加入阿里云的镜像配置"></a>加入阿里云的镜像配置</h3><ul><li><p>将下面的mirror标签整体复制到settings.xml文件的<strong>mirrors标签内部</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="配置Maven工程的基础JDK版本"><a href="#配置Maven工程的基础JDK版本" class="headerlink" title="配置Maven工程的基础JDK版本"></a>配置Maven工程的基础JDK版本</h2><ul><li><p><strong>如果按照默认配置运行，Java 工程使用的默认 JDK 版本是 1.5</strong>，而我们熟悉和常用的是 JDK 1.8 版本。修改配置的方式是：<strong>将自定义的 profile 标签整个复制到 settings.xml 文件的 profiles 标签内</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><ul><li><p>Maven 是一个用 Java 语言开发的程序，它必须基于 JDK 来运行，<strong>需要通过 JAVA_HOME 来找到 JDK 的安装位置</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102092313207.png" alt="image-20221102092313207"></p></li><li><p>可以使用下面的命令验证JDK是否被正确的加入到了环境变量中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;echo %JAVA_HOME%</span><br><span class="line">D:\software\Java</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;java -version</span><br><span class="line">java version &quot;1.8.0_141&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_141-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode)</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置MAVEN-HOME"><a href="#配置MAVEN-HOME" class="headerlink" title="配置MAVEN_HOME"></a>配置MAVEN_HOME</h2><ul><li><p>新建系统变量：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102092502592.png" alt="image-20221102092502592"></p></li></ul><h2 id="配置Path"><a href="#配置Path" class="headerlink" title="配置Path"></a>配置Path</h2><ul><li>编辑Path，<strong>用两个百分号可以引用刚才配置的系统变量</strong>：</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102092831843.png" alt="image-20221102092831843"></p><ul><li>配置环境变量的规律：<strong>XXX_HOME通常配置的是目标bin目录的上一级目录，Path中配置的是目标bin目录</strong>。</li></ul><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><ul><li><p>在非maven的bin目录下输入下方的命令来检测maven的环境变量是否配置正确：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;mvn -v</span><br><span class="line">Apache Maven 3.8.4 (9b656c72d54e5bacbed989b64718c159fe39b537)</span><br><span class="line">Maven home: D:\software\apache-maven-3.8.4</span><br><span class="line">Java version: 1.8.0_141, vendor: Oracle Corporation, runtime: D:\software\Java\jre</span><br><span class="line">Default locale: zh_CN, platform encoding: GBK</span><br><span class="line">OS name: &quot;windows 10&quot;, version: &quot;10.0&quot;, arch: &quot;amd64&quot;, family: &quot;windows&quot;</span><br></pre></td></tr></table></figure></li></ul><h1 id="实验一：根据坐标创建Maven工程"><a href="#实验一：根据坐标创建Maven工程" class="headerlink" title="实验一：根据坐标创建Maven工程"></a>实验一：根据坐标创建Maven工程</h1><ul><li>前面的实验先讲maven在命令行页面的使用，之后再讲在IDEA中使用maven。</li></ul><h2 id="Maven核心概念：坐标"><a href="#Maven核心概念：坐标" class="headerlink" title="Maven核心概念：坐标"></a>Maven核心概念：坐标</h2><h3 id="数学中的坐标"><a href="#数学中的坐标" class="headerlink" title="数学中的坐标"></a>数学中的坐标</h3><ul><li>使用x、y、z三个<strong>向量</strong>作为空间的坐标系，可以在<strong>空间</strong>中<strong>唯一地</strong>定位到一个<strong>点</strong>。</li></ul><h3 id="Maven中的坐标"><a href="#Maven中的坐标" class="headerlink" title="Maven中的坐标"></a>Maven中的坐标</h3><h4 id="向量说明"><a href="#向量说明" class="headerlink" title="向量说明"></a>向量说明</h4><ul><li>Maven使用三个<strong>向量</strong>在<strong>Maven的仓库</strong>中<strong>唯一</strong>地定位到一个<strong>jar包</strong>：<ol><li><strong>groupId</strong>：公司或组织的 id</li><li><strong>artifactId</strong>：一个项目或者是项目中的一个模块的 id</li><li><strong>version</strong>：版本号</li></ol></li></ul><h4 id="三个向量的取值方式"><a href="#三个向量的取值方式" class="headerlink" title="三个向量的取值方式"></a>三个向量的取值方式</h4><ul><li><strong>groupId</strong>：公司或组织域名的倒序，通常也会加上项目名称<ul><li>例如：com.atguigu.maven</li></ul></li><li><strong>artifactId</strong>：模块的名称，将来作为 Maven 工程的工程名</li><li><strong>version</strong>：模块的版本号，根据自己的需要设定<ul><li>例如：SNAPSHOT 表示快照版本，正在迭代过程中，不稳定的版本</li><li>例如：RELEASE 表示正式版本</li></ul></li></ul><h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><ul><li>groupId：com.atguigu.maven</li><li>artifactId：pro01-atguigu-maven</li><li>version：1.0-SNAPSHOT</li></ul><h3 id="坐标和仓库中jar包的存储路径之间的对应关系"><a href="#坐标和仓库中jar包的存储路径之间的对应关系" class="headerlink" title="坐标和仓库中jar包的存储路径之间的对应关系"></a>坐标和仓库中jar包的存储路径之间的对应关系</h3><ul><li><p>坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>上面坐标对应的jar包在Maven本地仓库中的位置：<strong>Maven本地仓库根目录\javax\servlet\servlet-api\2.5\servlet-api-2.5.jar</strong>，可以看到<strong>每一个坐标对应着一层或多层目录，坐标的值由点分开，每一段都是一层目录，最后找到的jar包名称是artifactId-version.jar的格式</strong>。</p></li><li><p>一定要学会根据坐标到本地仓库中找到对应的jar包。</p></li></ul><h2 id="实验操作"><a href="#实验操作" class="headerlink" title="实验操作"></a>实验操作</h2><h3 id="创建目录作为后面maven操作的工作空间"><a href="#创建目录作为后面maven操作的工作空间" class="headerlink" title="创建目录作为后面maven操作的工作空间"></a>创建目录作为后面maven操作的工作空间</h3><ul><li>例如：D:\maven-workspace\space201026</li><li>此时我们已经有了三个目录，分别是：<ol><li><strong>Maven 核心程序</strong>：中军大帐</li><li><strong>Maven 本地仓库</strong>：兵营</li><li><strong>本地工作空间</strong>：战场</li></ol></li></ul><h3 id="在工作空间目录下打开命令行窗口"><a href="#在工作空间目录下打开命令行窗口" class="headerlink" title="在工作空间目录下打开命令行窗口"></a>在工作空间目录下打开命令行窗口</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102094855936.png" alt="image-20221102094855936"></p><h3 id="使用命令生成Maven工程"><a href="#使用命令生成Maven工程" class="headerlink" title="使用命令生成Maven工程"></a>使用命令生成Maven工程</h3><ul><li><p>maven命令结构：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102095138936.png" alt="image-20221102095138936"></p></li><li><p>运行 <strong>mvn archetype:generate</strong> 命令，下面根据提示进行操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Choose a number or apply filter (format: [groupId:]artifactId, case sensitive contains): 7:【直接回车，使用默认值】</span><br><span class="line"></span><br><span class="line">Define value for property &#x27;groupId&#x27;: com.atguigu.maven</span><br><span class="line"></span><br><span class="line">Define value for property &#x27;artifactId&#x27;: pro01-maven-java</span><br><span class="line"></span><br><span class="line">Define value for property &#x27;version&#x27; 1.0-SNAPSHOT: :【直接回车，使用默认值】</span><br><span class="line"></span><br><span class="line">Define value for property &#x27;package&#x27; com.atguigu.maven: :【直接回车，使用默认值】</span><br><span class="line"></span><br><span class="line">Confirm properties configuration: groupId: com.atguigu.maven artifactId: pro01-maven-java version: 1.0-SNAPSHOT package: com.atguigu.maven Y: :【直接回车，表示确认。如果前面有输入错误，想要重新输入，则输入 N 再回车。】</span><br></pre></td></tr></table></figure></li></ul><h3 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h3><ul><li><p>Maven 默认生成的工程，对 junit 依赖的是较低的 3.8.1 版本，我们可以改成较适合的 4.12 版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 依赖信息配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- dependencies复数标签：里面包含dependency单数标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- dependency单数标签：配置一个具体的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 通过坐标来依赖其他jar包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 依赖的范围 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>自动生成的 App.java 和 AppTest.java 可以删除。</p></li></ul><h3 id="自动生成的pom-xml文件解读"><a href="#自动生成的pom-xml文件解读" class="headerlink" title="自动生成的pom.xml文件解读"></a>自动生成的pom.xml文件解读</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当前Maven工程的坐标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 当前Maven工程的打包方式，可选值有下面三种： --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- jar：表示这个工程是一个Java工程  --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- war：表示这个工程是一个Web工程 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- pom：表示这个工程是“管理其他工程”的工程 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span><span class="comment">&lt;!--在这里定义的标签后面都可以通过$&#123;标签名&#125;来取到标签的值--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 工程构建过程中读取源码时使用的字符集 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 当前工程所依赖的jar包 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用dependency配置一个具体的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 在dependency标签内使用具体的坐标依赖我们需要的一个jar包 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- scope标签配置依赖的范围 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Maven的核心概念：POM"><a href="#Maven的核心概念：POM" class="headerlink" title="Maven的核心概念：POM"></a>Maven的核心概念：POM</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ul><li>POM：<strong>P</strong>roject <strong>O</strong>bject <strong>M</strong>odel，<strong>项目对象模型</strong>。和 POM 类似的是：DOM（Document Object Model），文档对象模型。它们都是模型化思想的具体体现。</li></ul><h3 id="模型化思想"><a href="#模型化思想" class="headerlink" title="模型化思想"></a>模型化思想</h3><ul><li>POM 表示<strong>将工程抽象为一个模型，再用程序中的对象来描述这个模型</strong>。这样我们就可以用程序来管理项目了。我们在开发过程中，最基本的做法就是<strong>将现实生活中的事物抽象为模型，然后封装模型相关的数据作为一个对象，这样就可以在程序中计算与现实事物相关的数据</strong>。</li></ul><h3 id="对应的配置文件"><a href="#对应的配置文件" class="headerlink" title="对应的配置文件"></a>对应的配置文件</h3><ul><li>POM 理念集中体现在 Maven 工程根目录下 <strong>pom.xml</strong> 这个配置文件中。所以这个 <strong>pom.xml 配置文件就是 Maven 工程的核心配置文件</strong>。其实<strong>学习 Maven 就是学这个文件怎么配置，各个配置有什么用</strong>。</li></ul><h2 id="Maven核心概念：约定的目录结构"><a href="#Maven核心概念：约定的目录结构" class="headerlink" title="Maven核心概念：约定的目录结构"></a>Maven核心概念：约定的目录结构</h2><h3 id="各个目录的作用"><a href="#各个目录的作用" class="headerlink" title="各个目录的作用"></a>各个目录的作用</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102095906918.png" alt="image-20221102095906918"></p><ul><li>除此之外，还有一个<strong>target目录专门存放构建操作输出的结果</strong>。</li></ul><h3 id="约定目录结构的意义"><a href="#约定目录结构的意义" class="headerlink" title="约定目录结构的意义"></a>约定目录结构的意义</h3><ul><li>Maven <strong>为了让构建过程能够尽可能自动化完成，所以必须约定目录结构的作用</strong>。例如：Maven 执行编译操作，必须先去 Java 源程序目录读取 Java 源代码，然后执行编译，最后把编译结果存放在 target 目录。</li></ul><h3 id="约定大于配置"><a href="#约定大于配置" class="headerlink" title="约定大于配置"></a>约定大于配置</h3><ul><li><p><strong>Maven 对于目录结构这个问题，没有采用配置的方式，而是基于约定</strong>。这样会让我们在开发过程中非常方便。如果每次创建 Maven 工程后，还需要针对各个目录的位置进行详细的配置，那肯定非常麻烦。</p></li><li><p>目前开发领域的技术发展趋势就是：<strong>约定优于配置，配置优于编码</strong>。先把约定的做好了再做配置然后再开始编码，这其实<strong>是一种开发原则或者说是一种软件设计范式</strong>，我个人理解其指的是<strong>在开发过程中形成的软件结构应该让工作尽可能着重于更优的开发原则&#x2F;软件设计范式提供的任务上</strong>，比如一个工程的结构使得工作着重于编码，那么它就不如工作着重于配置的工程的结构，这些<strong>更优的开发原则、软件设计范式给工程提供了更简单的开发难度、更好的可维护性，同时也让工程不失灵活性</strong>。</p></li></ul><h1 id="实验二：在Maven工程中编写代码"><a href="#实验二：在Maven工程中编写代码" class="headerlink" title="实验二：在Maven工程中编写代码"></a>实验二：在Maven工程中编写代码</h1><h2 id="主体程序"><a href="#主体程序" class="headerlink" title="主体程序"></a>主体程序</h2><ul><li><p>主体程序指的是被测试的程序，同时也是<strong>将来在项目中真正要使用的程序</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102113412498.png" alt="image-20221102113412498"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><ul><li><p>通过测试程序<strong>对主体程序进行测试</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102113529912.png" alt="image-20221102113529912"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.maven.Calculator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态导入的效果是将Assert类中的静态资源导入当前类</span></span><br><span class="line"><span class="comment">// 这样一来，在当前类中就可以直接使用Assert类中的静态资源，不需要写类名</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorTest</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSum</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建Calculator对象</span></span><br><span class="line"><span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调用Calculator对象的方法，获取到程序运行实际的结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">actualResult</span> <span class="operator">=</span> calculator.sum(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.声明一个变量，表示程序运行期待的结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">expectedResult</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.使用断言来判断实际结果和期待结果是否一致</span></span><br><span class="line"><span class="comment">// 如果一致：测试通过，不会抛出异常</span></span><br><span class="line"><span class="comment">// 如果不一致：抛出异常，测试失败</span></span><br><span class="line">assertEquals(expectedResult, actualResult);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="实验三：执行Maven的构建命令"><a href="#实验三：执行Maven的构建命令" class="headerlink" title="实验三：执行Maven的构建命令"></a>实验三：执行Maven的构建命令</h1><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ul><li><p><strong>运行 Maven 中和构建操作相关的命令时，必须进入到 pom.xml 所在的目录</strong>。如果没有在 pom.xml 所在的目录运行 Maven 的构建命令，那么会看到下面的错误信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The goal you specified requires a project to execute but there is no POM in this directory</span><br></pre></td></tr></table></figure></li><li><p>mvn -v 命令和构建操作无关，只要正确配置了 PATH，在任何目录下执行都可以。而<strong>与构建相关的命令要在 pom.xml 所在目录下运行——操作哪个工程，就进入这个工程的 pom.xml 目录</strong>。</p></li></ul><h2 id="清理操作"><a href="#清理操作" class="headerlink" title="清理操作"></a>清理操作</h2><ul><li><strong>mvn clean</strong>：删除构建操作生成的target目录。</li></ul><h2 id="编译操作"><a href="#编译操作" class="headerlink" title="编译操作"></a>编译操作</h2><ul><li>主程序编译：<strong>mvn compile</strong></li><li>测试程序编译：<strong>mvn test-compile</strong></li><li>主体程序编译结果存放的目录：<strong>target&#x2F;classes</strong></li><li>测试程序编译结果存放的目录：<strong>target&#x2F;test-classes</strong></li></ul><h2 id="测试操作"><a href="#测试操作" class="headerlink" title="测试操作"></a>测试操作</h2><ul><li><strong>mvn test</strong>：测试的报告存放的目录为<strong>target&#x2F;surefire-reports</strong></li></ul><h2 id="打包操作"><a href="#打包操作" class="headerlink" title="打包操作"></a>打包操作</h2><ul><li><strong>mvn package</strong>：打包的结果在pom.xml中指定过了，存放的目录：<strong>target</strong></li></ul><h2 id="安装操作"><a href="#安装操作" class="headerlink" title="安装操作"></a>安装操作</h2><ul><li><p><strong>mvn install</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Installing D:\maven-workspace\space201026\pro01-maven-java\target\pro01-maven-java-1.0-SNAPSHOT.jar to D:\maven-rep1026\com\atguigu\maven\pro01-maven-java\1.0-SNAPSHOT\pro01-maven-java-1.0-SNAPSHOT.jar</span><br><span class="line">[INFO] Installing D:\maven-workspace\space201026\pro01-maven-java\pom.xml to D:\maven-rep1026\com\atguigu\maven\pro01-maven-java\1.0-SNAPSHOT\pro01-maven-java-1.0-SNAPSHOT.pom</span><br></pre></td></tr></table></figure></li><li><p>安装的效果是<strong>将本地构建过程中生成的 jar 包存入 Maven 本地仓库</strong>。这个 <strong>jar 包在 Maven 仓库中的路径是根据它的坐标生成的</strong>。</p><p>坐标信息如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Maven仓库中生成的路径如下，之前也说过这个路径和坐标的关系了，看也能很容易看出来其实：</p><p><strong>D:\maven-rep1026\com\atguigu\maven\pro01-maven-java\1.0-SNAPSHOT\pro01-maven-java-1.0-SNAPSHOT.jar</strong></p></li><li><p>另外，<strong>安装操作还会将 pom.xml 文件转换为 XXX.pom 文件一起存入本地仓库</strong>。所以我们在 Maven 的本地仓库中想看一个 jar 包原始的 pom.xml 文件时，查看对应 XXX.pom 文件即可，它们是名字发生了改变，本质上是同一个文件。</p></li></ul><h1 id="实验四：创建Maven版的Web工程"><a href="#实验四：创建Maven版的Web工程" class="headerlink" title="实验四：创建Maven版的Web工程"></a>实验四：创建Maven版的Web工程</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li><p>使用 mvn archetype:generate 命令生成 Web 工程时，需要使用一个专门的 archetype。这个专门生成 Web 工程骨架的 archetype 可以参照官网看到它的用法：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221102183514646.png" alt="image-20221102183514646"></p></li><li><p>参数 archetypeGroupId、archetypeArtifactId、archetypeVersion 用来指定现在使用的 maven-archetype-webapp 的坐标。</p></li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul><li><p>注意：如果在上一个工程的目录下执行 mvn archetype:generate 命令，那么 Maven 会报错：<strong>不能在一个打包类型非 pom 的工程下再创建其他工程</strong>。所以不要再刚才创建的工程里再创建新的工程，<strong>请回到工作空间根目录来操作</strong>。</p></li><li><p>然后运行生成工程的命令：<strong>mvn archetype:generate -DarchetypeGroupId&#x3D;org.apache.maven.archetypes -DarchetypeArtifactId&#x3D;maven-archetype-webapp -DarchetypeVersion&#x3D;1.4</strong></p></li><li><p>下面的操作按照提示执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Define value for property &#x27;groupId&#x27;: com.atguigu.maven Define value for property &#x27;artifactId&#x27;: pro02-maven-web Define value for property &#x27;version&#x27; 1.0-SNAPSHOT: :【直接回车，使用默认值】</span><br><span class="line"></span><br><span class="line">Define value for property &#x27;package&#x27; com.atguigu.maven: :【直接回车，使用默认值】 Confirm properties configuration: groupId: com.atguigu.maven artifactId: pro02-maven-web version: 1.0-SNAPSHOT package: com.atguigu.maven Y: :【直接回车，表示确认】</span><br></pre></td></tr></table></figure></li></ul><h2 id="生成的pom-xml"><a href="#生成的pom-xml" class="headerlink" title="生成的pom.xml"></a>生成的pom.xml</h2><ul><li><p>确认打包的方式是war包形式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="生成的Web工程的目录结构"><a href="#生成的Web工程的目录结构" class="headerlink" title="生成的Web工程的目录结构"></a>生成的Web工程的目录结构</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103100725735.png" alt="image-20221103100725735"></p><ul><li>webapp目录下有index.jsp</li><li>WEB-INF目录下有web.xml</li></ul><h2 id="创建Servlet"><a href="#创建Servlet" class="headerlink" title="创建Servlet"></a>创建Servlet</h2><h3 id="在main目录下创建java目录"><a href="#在main目录下创建java目录" class="headerlink" title="在main目录下创建java目录"></a>在main目录下创建java目录</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103101207930.png" alt="image-20221103101207930"></p><h3 id="在java目录下创建Servlet类所在的包的目录"><a href="#在java目录下创建Servlet类所在的包的目录" class="headerlink" title="在java目录下创建Servlet类所在的包的目录"></a>在java目录下创建Servlet类所在的包的目录</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103101236668.png" alt="image-20221103101236668"></p><h3 id="在包下创建Servlet类"><a href="#在包下创建Servlet类" class="headerlink" title="在包下创建Servlet类"></a>在包下创建Servlet类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">response.getWriter().write(<span class="string">&quot;hello maven web&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在web-xml中注册Servlet"><a href="#在web-xml中注册Servlet" class="headerlink" title="在web.xml中注册Servlet"></a>在web.xml中注册Servlet</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>helloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.maven.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>helloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/helloServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="在index-jsp页面编写超链接"><a href="#在index-jsp页面编写超链接" class="headerlink" title="在index.jsp页面编写超链接"></a>在index.jsp页面编写超链接</h2><ul><li><p>虽然现在几乎用不到jsp技术了，这里只是为了进行演示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;helloServlet&quot;</span>&gt;</span>Access Servlet<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>JSP全称是 Java Server Page，和 Thymeleaf 一样，是服务器端页面渲染技术。这里我们不必关心 JSP 语法细节，编写一个超链接标签即可。</p></li></ul><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul><li><p>此时直接执行<strong>mvn compile</strong>命令出错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DANGER</span><br><span class="line"></span><br><span class="line">程序包 javax.servlet.http 不存在</span><br><span class="line"></span><br><span class="line">程序包 javax.servlet 不存在</span><br><span class="line"></span><br><span class="line">找不到符号</span><br><span class="line"></span><br><span class="line">符号: 类 HttpServlet</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure></li><li><p>上面的错误信息说明：我们的 Web 工程用到了 HttpServlet 这个类，而 HttpServlet 这个类属于 servlet-api.jar 这个 jar 包。此时我们说，Web 工程需要依赖 servlet-api.jar 包。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103102538266.png" alt="image-20221103102538266"></p></li></ul><h2 id="配置对servlet-api-jar包的依赖"><a href="#配置对servlet-api-jar包的依赖" class="headerlink" title="配置对servlet-api.jar包的依赖"></a>配置对servlet-api.jar包的依赖</h2><ul><li><p>对于不知道详细信息的依赖可以到<a href="https://mvnrepository.com/%E7%BD%91%E7%AB%99%E6%9F%A5%E8%AF%A2%E3%80%82**%E4%BD%BF%E7%94%A8%E5%85%B3%E9%94%AE%E8%AF%8D%E6%90%9C%E7%B4%A2**%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%E5%88%97%E8%A1%A8%E4%B8%AD%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%82">https://mvnrepository.com/网站查询。**使用关键词搜索**，然后在搜索结果列表中选择适合的使用。</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103102743004.png" alt="image-20221103102743004"></p></li><li><p>比如，我们找到的servlet-api的依赖信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>这样就可以把上面的信息加入pom.xml。重新执行mvn compile命令即可顺利编译。</p></li></ul><h2 id="将Web工程打包为war包"><a href="#将Web工程打包为war包" class="headerlink" title="将Web工程打包为war包"></a>将Web工程打包为war包</h2><ul><li><p>运行<strong>mvn package</strong>命令，生成war包的位置如下图所示：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103103051932.png" alt="image-20221103103051932"></p></li></ul><h2 id="将war包部署到Tomcat上运行"><a href="#将war包部署到Tomcat上运行" class="headerlink" title="将war包部署到Tomcat上运行"></a>将war包部署到Tomcat上运行</h2><ul><li><p>将war包复制到<strong>Tomcat&#x2F;webapps</strong>目录下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103103150452.png" alt="image-20221103103150452"></p></li><li><p>启动Tomcat：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103103219090.png" alt="image-20221103103219090"></p></li><li><p>Tomcat会自动解压war包，反正都要解压之后使用，所以<strong>也可以直接把解压好的war包放到Tomcat中</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103103320669.png" alt="image-20221103103320669"></p></li><li><p>通过浏览器尝试访问：<a href="http://localhost:8080/pro02-maven-web/index.jsp%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%AE%BF%E9%97%AE%E6%88%90%E5%8A%9F%E8%AF%B4%E6%98%8EWeb%E5%B7%A5%E7%A8%8B%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F%E5%B9%B6%E8%83%BD%E9%A1%BA%E5%88%A9%E8%BF%90%E8%A1%8C%E3%80%82">http://localhost:8080/pro02-maven-web/index.jsp，如果访问成功说明Web工程部署成功并能顺利运行。</a></p></li></ul><h1 id="实验五：让Web工程依赖Java工程"><a href="#实验五：让Web工程依赖Java工程" class="headerlink" title="实验五：让Web工程依赖Java工程"></a>实验五：让Web工程依赖Java工程</h1><h2 id="观念"><a href="#观念" class="headerlink" title="观念"></a>观念</h2><ul><li>明确一个意识：<strong>从来只有 Web 工程依赖 Java 工程，没有反过来 Java 工程依赖 Web 工程</strong>。本质上来说，<strong>Web 工程依赖的 Java 工程其实就是 Web 工程里导入的 jar 包</strong>。最终 Java 工程会变成 jar 包，<strong>放在 Web 工程的 WEB-INF&#x2F;lib 目录下</strong>。</li></ul><h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><ul><li><p>在 pro02-maven-web 工程的 pom.xml 中，找到 dependencies 标签，在 dependencies 标签中做如下配置，这样依赖的是我们刚才实验用到的java工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置对Java工程pro01-maven-java的依赖 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体的配置方式：在dependency标签内使用坐标实现依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="在Web工程中，编写测试代码"><a href="#在Web工程中，编写测试代码" class="headerlink" title="在Web工程中，编写测试代码"></a>在Web工程中，编写测试代码</h2><h3 id="补充自动创建的目录"><a href="#补充自动创建的目录" class="headerlink" title="补充自动创建的目录"></a>补充自动创建的目录</h3><ul><li>pro02-maven-web<strong>\src\test\java\com\atguigu\maven</strong>，test目录下的结构尽量和main目录下的结构保持一致。</li></ul><h3 id="确认Web工程依赖了junit"><a href="#确认Web工程依赖了junit" class="headerlink" title="确认Web工程依赖了junit"></a>确认Web工程依赖了junit</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建测试类"><a href="#创建测试类" class="headerlink" title="创建测试类"></a>创建测试类</h3><ul><li>把 Java 工程的 CalculatorTest.java 类复制到 pro02-maven-wb<strong>\src\test\java\com\atguigu\maven</strong> 目录下</li></ul><h2 id="执行Maven命令"><a href="#执行Maven命令" class="headerlink" title="执行Maven命令"></a>执行Maven命令</h2><h3 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h3><ul><li>使用<strong>mvn test</strong>命令</li><li>说明：测试操作中会提前自动执行编译操作，测试成功就说明编译也是成功的，这样的特性是由于<strong>编译和测试操作同属一个生命周期并且在那个生命周期中编译操作在测试操作的前面</strong>。</li></ul><h3 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h3><ul><li><p>使用<strong>mvn package</strong>命令</p></li><li><p><strong>打包后的文件会放到target目录下</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103114152535.png" alt="image-20221103114152535"></p></li><li><p>通过查看war包内的结构，我们看到<strong>被Web工程依赖的Java工程确实是会变成Web工程的WEB-INF&#x2F;lib目录下的jar包</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103114306748.png" alt="image-20221103114306748"></p></li></ul><h3 id="查看当前Web工程所依赖的jar包的列表"><a href="#查看当前Web工程所依赖的jar包的列表" class="headerlink" title="查看当前Web工程所依赖的jar包的列表"></a>查看当前Web工程所依赖的jar包的列表</h3><ul><li><p>使用命令<strong>mvn dependency:list</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[INFO] The following files have been resolved:</span><br><span class="line">[INFO] org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] javax.servlet:javax.servlet-api:jar:3.1.0:provided</span><br><span class="line">[INFO] com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile</span><br><span class="line">[INFO] junit:junit:jar:4.12:test</span><br></pre></td></tr></table></figure></li><li><p>说明：像javax.servlet:javax.servlet-api:jar:3.1.0:provided这样的格式显示的是一个 jar 包的坐标信息。格式是：<strong>groupId:artifactId:打包方式:version:依赖的范围</strong></p></li><li><p>这样的格式虽然和我们 XML 配置文件中坐标的格式不同，但是<strong>本质上还是坐标信息</strong>，我们需要能够认识这样的格式，将来从 Maven 命令的日志或错误信息中看到这样格式的信息，就能够识别出来这是坐标。进而根据坐标到Maven 仓库找到对应的jar包，用这样的方式解决我们遇到的报错的情况。</p></li></ul><h3 id="以树形结构查看当前Web工程的依赖信息"><a href="#以树形结构查看当前Web工程的依赖信息" class="headerlink" title="以树形结构查看当前Web工程的依赖信息"></a>以树形结构查看当前Web工程的依赖信息</h3><ul><li><p>使用命令<strong>mvn dependency:tree</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] | \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided</span><br><span class="line">[INFO] \- com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile</span><br></pre></td></tr></table></figure></li><li><p>我们在 pom.xml 中并没有依赖 hamcrest-core，但是它却被加入了我们依赖的列表。原因是：junit 依赖了hamcrest-core，然后<strong>基于依赖的传递性</strong>，hamcrest-core 被传递到我们的工程了。</p></li></ul><h1 id="实验六：测试依赖的范围"><a href="#实验六：测试依赖的范围" class="headerlink" title="实验六：测试依赖的范围"></a>实验六：测试依赖的范围</h1><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><ul><li>scope标签的位置：dependencies -&gt; dependency -&gt; <strong>scope</strong></li><li>scope标签的可选值：<strong>compile</strong>&#x2F;<strong>test</strong>&#x2F;<strong>provided</strong>&#x2F;system&#x2F;runtime&#x2F;<strong>import</strong></li><li>scope标签的<strong>默认值</strong>：<strong>compile</strong></li></ul><h3 id="compile和test作用的时空对比"><a href="#compile和test作用的时空对比" class="headerlink" title="compile和test作用的时空对比"></a>compile和test作用的时空对比</h3><table><thead><tr><th></th><th>main目录(空间)</th><th>test目录(空间)</th><th>开发过程(时间)</th><th>部署到服务器(时间)</th></tr></thead><tbody><tr><td>compile</td><td>有效</td><td>有效</td><td>有效</td><td>有效</td></tr><tr><td>test</td><td>无效</td><td>有效</td><td>有效</td><td>无效</td></tr></tbody></table><h3 id="compile和provided作用的时空对比"><a href="#compile和provided作用的时空对比" class="headerlink" title="compile和provided作用的时空对比"></a>compile和provided作用的时空对比</h3><table><thead><tr><th></th><th>main目录(空间)</th><th>test目录(空间)</th><th>开发过程(时间)</th><th>部署到服务器(时间)</th></tr></thead><tbody><tr><td>compile</td><td>有效</td><td>有效</td><td>有效</td><td>有效</td></tr><tr><td>provided</td><td>有效</td><td>有效</td><td>有效</td><td>无效</td></tr></tbody></table><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><ul><li><strong>compile</strong>：通常使用的第三方框架的 jar 包这样<strong>在项目实际运行时真正要用到的 jar 包</strong>都是以 compile 范围进行依赖的。比如 SSM 框架所需jar包。</li><li><strong>test</strong>：<strong>测试过程中使用</strong>的 jar 包，以 test 范围依赖进来。比如 junit。</li><li><strong>provided</strong>：在<strong>开发过程中需要用到的“服务器上的 jar 包”</strong>通常以 provided 范围依赖进来，scope为这个值的包说明<strong>其在服务器上已经被提供</strong>。比如 servlet-api、jsp-api。而这个范围的 jar 包之所以<strong>不参与部署、不放进 war 包，就是避免和服务器上已有的同类 jar 包产生冲突，同时减轻服务器的负担</strong>。说白了就是：“<strong>服务器上已经有了，你就别带啦！</strong>”</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li>测试方法很简单，向要测试的地方导个要检测的包看一下能不能过编译就行了</li></ul><h3 id="验证compile范围对main目录有效"><a href="#验证compile范围对main目录有效" class="headerlink" title="验证compile范围对main目录有效"></a>验证compile范围对main目录有效</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main目录下的类：HelloServlet 使用compile范围导入的依赖：pro01-atguigu-maven</span><br><span class="line"></span><br><span class="line">验证：使用compile范围导入的依赖对main目录下的类来说是有效的</span><br><span class="line"></span><br><span class="line">有效：HelloServlet 能够使用 pro01-atguigu-maven 工程中的 Calculator 类</span><br><span class="line"></span><br><span class="line">验证方式：在 HelloServlet 类中导入 Calculator 类，然后编译就说明有效。</span><br></pre></td></tr></table></figure><h3 id="验证test范围对main目录无效"><a href="#验证test范围对main目录无效" class="headerlink" title="验证test范围对main目录无效"></a>验证test范围对main目录无效</h3><ul><li><p>测试方式：在主体程序中导入org.junit.Test这个注解，然后执行编译。</p></li><li><p>具体操作：在pro01-maven-java\src\main\java\com\atguigu\maven目录下修改Calculator.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行Maven编译命令，发现报错了，说明scope为test的jar包不对main目录有效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR] /D:/maven-workspace/space201026/pro01-maven-java/src/main/java/com/atguigu/maven/Calculator.java:[3,17] 程序包org.junit不存在</span><br></pre></td></tr></table></figure></li></ul><h3 id="验证test和provided范围不参与服务器部署"><a href="#验证test和provided范围不参与服务器部署" class="headerlink" title="验证test和provided范围不参与服务器部署"></a>验证test和provided范围不参与服务器部署</h3><ul><li><p>其实就是验证：通过compile范围依赖的jar包会放入war包，通过test范围依赖的jar包不会放入war包。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221103232528630.png" alt="image-20221103232528630"></p></li></ul><h3 id="验证provided范围对测试程序有效"><a href="#验证provided范围对测试程序有效" class="headerlink" title="验证provided范围对测试程序有效"></a>验证provided范围对测试程序有效</h3><ul><li><p>测试方式是在pro02-maven-web的测试程序中加入servlet-api.jar包中的类。</p></li><li><p>修改：<strong>pro02-maven-web</strong>\src\<strong>test</strong>\java\com\atguigu\maven\<strong>CalculatorTest.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.maven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.maven.Calculator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态导入的效果是将Assert类中的静态资源导入当前类</span></span><br><span class="line"><span class="comment">// 这样一来，在当前类中就可以直接使用Assert类中的静态资源，不需要写类名</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorTest</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSum</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建Calculator对象</span></span><br><span class="line"><span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调用Calculator对象的方法，获取到程序运行实际的结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">actualResult</span> <span class="operator">=</span> calculator.sum(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.声明一个变量，表示程序运行期待的结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">expectedResult</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.使用断言来判断实际结果和期待结果是否一致</span></span><br><span class="line"><span class="comment">// 如果一致：测试通过，不会抛出异常</span></span><br><span class="line"><span class="comment">// 如果不一致：抛出异常，测试失败</span></span><br><span class="line">assertEquals(expectedResult, actualResult);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后运行Maven的编译命令：<strong>mvn compile</strong>，然后看到编译成功。</p></li></ul><h1 id="实验七：测试依赖的传递性"><a href="#实验七：测试依赖的传递性" class="headerlink" title="实验七：测试依赖的传递性"></a>实验七：测试依赖的传递性</h1><h2 id="依赖的传递性"><a href="#依赖的传递性" class="headerlink" title="依赖的传递性"></a>依赖的传递性</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>A 依赖 B，B 依赖 C，那么在 A 没有配置对 C 的依赖的情况下，A 里面能不能直接使用 C？</li></ul><h3 id="传递的原则"><a href="#传递的原则" class="headerlink" title="传递的原则"></a>传递的原则</h3><ul><li>在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围：<ul><li>B 依赖 C 时使用 <strong>compile 范围：可以传递</strong></li><li>B 依赖 C 时使用 <strong>test 或 provided 范围：不能传递</strong>，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。</li></ul></li></ul><h2 id="使用compile范围依赖spring-core"><a href="#使用compile范围依赖spring-core" class="headerlink" title="使用compile范围依赖spring-core"></a>使用compile范围依赖spring-core</h2><ul><li><p>测试方式：让 pro01-maven-java 工程依赖 spring-core</p></li><li><p>具体操作：编辑 pro01-maven-java 工程根目录下 pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用<strong>mvn dependency:tree</strong>命令查看效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[INFO] com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] | \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] \- org.springframework:spring-core:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] \- commons-logging:commons-logging:jar:1.1.1:compile</span><br></pre></td></tr></table></figure></li><li><p>还可以在 Web 工程中，使用 <strong>mvn dependency:tree</strong> 命令查看效果（<strong>需要重新将 pro01-maven-java 安装到仓库</strong>），可以看到spring-core这个依赖被传递过去了，所以证明<strong>scope为compile的依赖可以被传递</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] | \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided</span><br><span class="line">[INFO] \- com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile</span><br><span class="line">[INFO] \- org.springframework:spring-core:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] \- commons-logging:commons-logging:jar:1.1.1:compile</span><br></pre></td></tr></table></figure></li><li><p>注意上面提到改变pro01-maven-java的pom.xml之后，需要重新安装到仓库才能被别的工程引用最新的版本，原因是<strong>pom.xml中的依赖都是从maven仓库中取的，因此如果只在工作空间更新了一个包的内容而没有将其安装到本地仓库中的话，别的工程是无法正确获取最新的包的内容的</strong>。</p></li></ul><h2 id="验证test和provided范围不能传递"><a href="#验证test和provided范围不能传递" class="headerlink" title="验证test和provided范围不能传递"></a>验证test和provided范围不能传递</h2><ul><li><p>从上面的例子已经能够看到，pro01-maven-java 依赖了 junit，但是在 pro02-maven-web 工程中查看依赖树的时候并没有看到 junit。</p></li><li><p>要验证 provided 范围不能传递，可以在 pro01-maven-java 工程中加入 servlet-api 的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>效果还是和之前一样，证明<strong>scope为test和provided的依赖无法被传递</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] | \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided</span><br><span class="line">[INFO] \- com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile</span><br><span class="line">[INFO] \- org.springframework:spring-core:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] \- commons-logging:commons-logging:jar:1.1.1:compile</span><br></pre></td></tr></table></figure></li></ul><h1 id="实验八：测试依赖的排除"><a href="#实验八：测试依赖的排除" class="headerlink" title="实验八：测试依赖的排除"></a>实验八：测试依赖的排除</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ul><li><p>当 A 依赖 B，B 依赖 C 而且 C 可以传递到 A 的时候，A 不想要 C，需要在 A 里面把 C 排除掉。而往往这种情况都是<strong>为了避免 jar 包之间的冲突</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104093931728.png" alt="image-20221104093931728"></p></li><li><p>所以<strong>配置依赖的排除其实就是阻止某些jar包的传递</strong>，因为这样的jar包传递过来会和其他jar包冲突。</p></li></ul><h2 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h2><ul><li><p>需要<strong>在dependency标签中配置exclusions标签和exclusion标签</strong>：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用excludes标签配置依赖的排除--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version，因为没有歧义）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><ul><li><p>测试的方式：在 pro02-maven-web 工程中配置对 commons-logging 的排除：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro01-maven-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用excludes标签配置依赖的排除--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>运行<strong>mvn dependency:tree</strong>命令查看效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[INFO] com.atguigu.maven:pro02-maven-web:war:1.0-SNAPSHOT</span><br><span class="line">[INFO] +- junit:junit:jar:4.12:test</span><br><span class="line">[INFO] | \- org.hamcrest:hamcrest-core:jar:1.3:test</span><br><span class="line">[INFO] +- javax.servlet:javax.servlet-api:jar:3.1.0:provided</span><br><span class="line">[INFO] \- com.atguigu.maven:pro01-maven-java:jar:1.0-SNAPSHOT:compile</span><br><span class="line">[INFO] \- org.springframework:spring-core:jar:4.0.0.RELEASE:compile</span><br></pre></td></tr></table></figure></li><li><p>发现在spring-core下面就没有commons-logging了，说明依赖排除生效了。</p></li></ul><h1 id="实验九：继承"><a href="#实验九：继承" class="headerlink" title="实验九：继承"></a>实验九：继承</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><ul><li><p>Maven工程之间，A 工程继承 B 工程</p><ul><li>B 工程：父工程</li><li>A 工程：子工程</li></ul></li><li><p>本质上是 <strong>A 工程的 pom.xml 中的配置继承了 B 工程中 pom.xml 的配置</strong>。</p></li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li><p>在<strong>父工程中统一管理项目中的依赖信息，具体来说是管理依赖信息的版本</strong>。</p></li><li><p>这一特性作用的背景是：</p><ul><li>对一个比较大型的项目进行了模块拆分。</li><li>一个 project 下面，创建了很多个 module。</li><li>每一个 module 都需要配置自己的依赖信息。</li></ul></li><li><p>它背后的需求是：</p><ul><li>在<strong>每一个 module 中各自维护各自的依赖信息很容易发生出入，不易统一管理</strong>。</li><li>使用同一个框架内的不同 jar 包，它们应该是同一个版本，所以<strong>整个项目中使用的框架版本需要统一</strong>。</li><li>使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个<strong>耗费很大精力总结出来的方案不应该在新的项目中重新摸索</strong>。</li></ul></li><li><p>综上所述，我们<strong>需要在父工程中对整个项目的依赖信息进行统一管理</strong>，通过在父工程中为整个项目维护依赖信息的组合既<strong>保证了整个项目使用规范、准确的 jar 包</strong>；又能够<strong>将以往的经验沉淀下来，节约时间和精力</strong>。</p></li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ul><li><p>在一个工程中依赖多个Spring的jar包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[INFO] +- org.springframework:spring-core:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] | \- commons-logging:commons-logging:jar:1.1.1:compile</span><br><span class="line">[INFO] +- org.springframework:spring-beans:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] +- org.springframework:spring-context:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] +- org.springframework:spring-expression:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] +- org.springframework:spring-aop:jar:4.0.0.RELEASE:compile</span><br><span class="line">[INFO] | \- aopalliance:aopalliance:jar:1.0:compile</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Spring 时要求所有 Spring 自己的 jar 包版本必须一致</strong>，比如上面的例子中，就都是4.0.0版本。为了能够对这些 jar 包的版本进行统一管理，我们使用继承这个机制，将所有版本信息统一在父工程中进行管理。</p></li></ul><h2 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h2><h3 id="创建父工程"><a href="#创建父工程" class="headerlink" title="创建父工程"></a>创建父工程</h3><ul><li><p>创建的过程和前面创建 pro01-maven-java 一样。</p></li><li><p>工程名称：pro03-maven-parent</p></li><li><p>工程创建好之后，要修改它的打包方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>只有打包方式为 pom 的 Maven 工程能够管理其他 Maven 工程</strong>。打包方式为 pom 的 Maven 工程中<strong>不写业务代码</strong>，它是<strong>专门管理其他 Maven 工程</strong>的工程。</p></li></ul><h3 id="创建模块工程"><a href="#创建模块工程" class="headerlink" title="创建模块工程"></a>创建模块工程</h3><ul><li><p>模块工程类似于 IDEA 中的 module，所以需要<strong>进入 pro03-maven-parent 工程的根目录</strong>，然后<strong>运行 mvn archetype:generate 命令来创建模块工程</strong>。</p></li><li><p>假设，我们创建三个模块工程：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104102340362.png" alt="image-20221104102340362"></p></li></ul><h3 id="查看被添加新内容的父工程pom-xml"><a href="#查看被添加新内容的父工程pom-xml" class="headerlink" title="查看被添加新内容的父工程pom.xml"></a>查看被添加新内容的父工程pom.xml</h3><ul><li><p>在<strong>创建子工程之后，父工程的pom.xml中更新后会自动生成和子工程建立聚合关系的配置</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro05-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro06-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="解读子工程的pom-xml"><a href="#解读子工程的pom-xml" class="headerlink" title="解读子工程的pom.xml"></a>解读子工程的pom.xml</h3><ul><li><p><strong>子工程中也存在和其父工程相关的配置</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 父工程的坐标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子工程的坐标 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="在父工程中配置依赖的统一管理"><a href="#在父工程中配置依赖的统一管理" class="headerlink" title="在父工程中配置依赖的统一管理"></a>在父工程中配置依赖的统一管理</h3><ul><li><p>使用<strong>dependencyManagement标签</strong>实现管理依赖，<strong>被管理的依赖并没有真正被引入到父工程</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="子工程中引用那些被父工程管理的依赖"><a href="#子工程中引用那些被父工程管理的依赖" class="headerlink" title="子工程中引用那些被父工程管理的依赖"></a>子工程中引用那些被父工程管理的依赖</h3><ul><li><p>关键在于子工程引用的时候，如果依赖被父工程管理，那么在引用的时候<strong>可以省略版本号</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-expression<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="测试依赖性，在父工程中升级依赖信息的版本"><a href="#测试依赖性，在父工程中升级依赖信息的版本" class="headerlink" title="测试依赖性，在父工程中升级依赖信息的版本"></a>测试依赖性，在父工程中升级依赖信息的版本</h3><ul><li><p>把所有和spring相关的依赖都改个版本：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure></li><li><p>然后在子工程中运行<strong>mvn dependency:list</strong>，效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[INFO] org.springframework:spring-aop:jar:4.1.4.RELEASE:compile</span><br><span class="line">[INFO] org.springframework:spring-core:jar:4.1.4.RELEASE:compile</span><br><span class="line">[INFO] org.springframework:spring-context:jar:4.1.4.RELEASE:compile</span><br><span class="line">[INFO] org.springframework:spring-beans:jar:4.1.4.RELEASE:compile</span><br><span class="line">[INFO] org.springframework:spring-expression:jar:4.1.4.RELEASE:compile</span><br></pre></td></tr></table></figure><p>可以看到子工程中的依赖版本也都发生了改变，所以父工程对于依赖的管理是生效的。</p></li></ul><h3 id="在父工程中声明自定义属性"><a href="#在父工程中声明自定义属性" class="headerlink" title="在父工程中声明自定义属性"></a>在父工程中声明自定义属性</h3><ul><li><p>在<strong>properties标签</strong>中自定义属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过自定义属性，统一指定Spring的版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 自定义标签，维护Spring版本数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">atguigu.spring.version</span>&gt;</span>4.3.6.RELEASE<span class="tag">&lt;/<span class="name">atguigu.spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在需要的地方使用**${自定义属性名}**的形式来引用自定义的属性名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;atguigu.spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>这样真正实现了**”一处修改，处处生效”**。</p></li></ul><h2 id="实际意义"><a href="#实际意义" class="headerlink" title="实际意义"></a>实际意义</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104103614834.png" alt="image-20221104103614834"></p><ul><li>编写一套符合要求、开发各种功能都能正常工作的依赖组合并不容易。如果公司里已经有人总结了成熟的组合方案，那么再开发新项目时，如果不使用原有的积累，而是重新摸索，会浪费大量的时间。为了提高效率，我们可以<strong>使用工程继承的机制，让成熟的依赖组合方案能够保留下来</strong>。</li><li>如上图所示，<strong>公司级的父工程中管理的就是成熟的依赖组合方案，各个新项目、子系统各取所需即可</strong>。</li></ul><h1 id="实验十：聚合"><a href="#实验十：聚合" class="headerlink" title="实验十：聚合"></a>实验十：聚合</h1><h2 id="聚合本身的含义"><a href="#聚合本身的含义" class="headerlink" title="聚合本身的含义"></a>聚合本身的含义</h2><ul><li>部分组成整体，整体和部分之间就是聚合的关系。</li><li>设计模式中<strong>组合是部分和整体之间的关系，部分和整体共存亡</strong>；设计模式中<strong>聚合是比较松散的关系，只是说明整体中包含部分，但是他们的生命周期一般不一致</strong>。</li></ul><h2 id="Maven中的聚合"><a href="#Maven中的聚合" class="headerlink" title="Maven中的聚合"></a>Maven中的聚合</h2><ul><li><p><strong>使用一个“总工程”将各个“模块工程”汇集起来，作为一个整体对应完整的项目</strong>。</p><ul><li>项目：整体</li><li>模块：部分</li></ul></li><li><p>概念的对应关系：</p><ul><li>从继承关系角度来看是：父工程和子工程</li><li>从聚合关系角度来看是：总工程和模块工程</li></ul></li></ul><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>一键执行 Maven 命令：<strong>很多构建命令都可以在“总工程”中一键执行</strong>。</li><li>以 mvn install 命令为例：Maven 要求有父工程时先安装父工程；有依赖的工程时，先安装被依赖的工程。我们自己考虑这些规则会很麻烦。但是<strong>工程聚合之后，在总工程执行 mvn install 可以一键完成安装，而且会自动按照正确的顺序执行</strong>。</li><li><strong>配置聚合之后，各个模块工程会在总工程中展示一个列表，让项目中的各个模块一目了然</strong>。</li></ul><h2 id="聚合的配置"><a href="#聚合的配置" class="headerlink" title="聚合的配置"></a>聚合的配置</h2><ul><li><p>在总工程中配置modules即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro05-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>pro06-maven-module<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="依赖循环问题"><a href="#依赖循环问题" class="headerlink" title="依赖循环问题"></a>依赖循环问题</h2><ul><li>如果 A 工程依赖 B 工程，B 工程依赖 C 工程，C 工程又反过来依赖 A 工程，那么在执行构建操作时会报下面的错误：**[ERROR] [ERROR] The projects in the reactor contain a cyclic reference:<strong>，这个错误的含义是：</strong>循环引用**</li><li>在工程中不要出现这样的依赖关系。</li></ul><h1 id="在IDEA环境中使用Maven"><a href="#在IDEA环境中使用Maven" class="headerlink" title="在IDEA环境中使用Maven"></a>在IDEA环境中使用Maven</h1><h2 id="创建父工程-1"><a href="#创建父工程-1" class="headerlink" title="创建父工程"></a>创建父工程</h2><h3 id="创建Project"><a href="#创建Project" class="headerlink" title="创建Project"></a>创建Project</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104120215910.png" alt="image-20221104120215910"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104120226562.png" alt="image-20221104120226562"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104120237465.png" alt="image-20221104120237465"></p><h3 id="开启自动导入"><a href="#开启自动导入" class="headerlink" title="开启自动导入"></a>开启自动导入</h3><ul><li><p>创建 Project 后，IDEA 会自动弹出下面提示，我们选择<strong>『Enable Auto-Import』</strong>，意思是启用自动导入：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104120305916.png" alt="image-20221104120305916"></p></li><li><p>这个<strong>自动导入一定要开启</strong>，因为 Project、Module 新创建或 pom.xml <strong>每次修改时都应该让 IDEA 重新加载 Maven 信息</strong>。这对 Maven 目录结构认定、Java 源程序编译、依赖 jar 包的导入都有非常关键的影响。另外<strong>也可以通过 IDEA 的 Settings 设置来开启</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104120403416.png" alt="image-20221104120403416"></p></li></ul><h2 id="配置Maven信息"><a href="#配置Maven信息" class="headerlink" title="配置Maven信息"></a>配置Maven信息</h2><ul><li><p><strong>每次创建 Project 后都需要设置 Maven 家目录位置，否则 IDEA 将使用内置的 Maven 核心程序（不稳定）并使用默认的本地仓库位置</strong>。这样一来，我们在命令行操作过程中已下载好的 jar 包就白下载了，默认的本地仓库通常在 C 盘，还影响系统运行。</p></li><li><p>配置之后，IDEA 会根据我们在这里指定的 Maven 家目录自动识别到我们在 settings.xml 配置文件中指定的本地仓库。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104121608954.png" alt="image-20221104121608954"></p></li><li><p>每次创建新的工程都要重新配置maven，这样做非常不方便，所幸高版本的IDEA提供了这样一个设置：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104121919660.png" alt="image-20221104121919660"></p><p>在这个地方<strong>可以设置每次创建新工程之后应该遵循的setting和structure</strong>，在这个地方设置一下就不用每次都设置了。</p></li></ul><h2 id="创建Java模块工程"><a href="#创建Java模块工程" class="headerlink" title="创建Java模块工程"></a>创建Java模块工程</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104122125032.png" alt="image-20221104122125032"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104122137263.png" alt="image-20221104122137263"></p><h2 id="创建Web模块工程"><a href="#创建Web模块工程" class="headerlink" title="创建Web模块工程"></a>创建Web模块工程</h2><h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h3><ul><li>按照前面的同样操作创建模块，<strong>此时</strong>这个模块其实还是一个<strong>Java模块</strong>。</li></ul><h3 id="修改打包方式"><a href="#修改打包方式" class="headerlink" title="修改打包方式"></a>修改打包方式</h3><ul><li><p>Web 模块将来打包当然应该是 <strong>war</strong> 包。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Web设定"><a href="#Web设定" class="headerlink" title="Web设定"></a>Web设定</h3><ul><li><p>首先打开项目结构菜单：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104122437463.png" alt="image-20221104122437463"></p></li><li><p>然后到 Facets 下查看 IDEA 是否已经帮我们自动生成了 Web 设定。正常来说<strong>只要我们确实设置了打包方式为 war，那么 IDEA 2019 版就会自动生成 Web 设定</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104122508382.png" alt="image-20221104122508382"></p></li><li><p>另外，对于IDEA 2018 诸版本没有自动生成 Web 设定，那么请参照下面两图，我们自己创建，简单地说就是<strong>如果IDEA没有把我们的模块识别成web模块，那么我们就手动告诉IDEA</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104122547971.png" alt="image-20221104122547971"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104122601249.png" alt="image-20221104122601249"></p></li></ul><h3 id="借助IDEA生成web-xml"><a href="#借助IDEA生成web-xml" class="headerlink" title="借助IDEA生成web.xml"></a>借助IDEA生成web.xml</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104123239315.png" alt="image-20221104123239315"></p><ul><li><p>这个上面这个<strong>部署描述符实际上就是指的web.xml文件</strong>，可以点击那个加号按钮来声明一个web.xml的位置：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104123352730.png" alt="image-20221104123352730"></p></li></ul><h3 id="设置Web资源的根目录"><a href="#设置Web资源的根目录" class="headerlink" title="设置Web资源的根目录"></a>设置Web资源的根目录</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104123846594.png" alt="image-20221104123846594"></p><ul><li><p>在上面这个地方指定Web资源的目录，点击加号按钮新增一个Web资源目录。</p></li><li><p>结合 Maven 的目录结构，<strong>Web 资源的根目录需要设置为 src&#x2F;main&#x2F;webapp 目录</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104124016366.png" alt="image-20221104124016366"></p></li></ul><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="在IDEA中执行Maven命令"><a href="#在IDEA中执行Maven命令" class="headerlink" title="在IDEA中执行Maven命令"></a>在IDEA中执行Maven命令</h3><h4 id="直接执行"><a href="#直接执行" class="headerlink" title="直接执行"></a>直接执行</h4><ul><li><p>在IDEA右边的maven界面中双击操作即可执行：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104124226175.png" alt="image-20221104124226175"></p></li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104124144107.png" alt="image-20221104124144107"></p><h4 id="手动输入"><a href="#手动输入" class="headerlink" title="手动输入"></a>手动输入</h4><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104141358112.png" alt="image-20221104141358112"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104141408290.png" alt="image-20221104141408290"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104141417494.png" alt="image-20221104141417494"></p><ul><li><p>如果有需要，还可以给命令后面附加参数：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104141443717.png" alt="image-20221104141443717"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -D 表示后面要附加命令的参数，字母 D 和后面的参数是紧挨着的，中间没有任何其它字符</span></span><br><span class="line"><span class="comment"># maven.test.skip=true 表示在执行命令的过程中跳过测试</span></span><br><span class="line">mvn clean install -Dmaven.test.skip=<span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="在IDEA中查看某个模块的依赖信息"><a href="#在IDEA中查看某个模块的依赖信息" class="headerlink" title="在IDEA中查看某个模块的依赖信息"></a>在IDEA中查看某个模块的依赖信息</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104141551740.png" alt="image-20221104141551740"></p><h3 id="工程导入"><a href="#工程导入" class="headerlink" title="工程导入"></a>工程导入</h3><ul><li>Maven工程除了自己创建的，还有很多情况是别人创建的。而为了参与开发或者是参考学习，我们都需要导入到 IDEA 中。下面我们分几种不同情况来说明：</li></ul><h4 id="来自版本控制系统（VCS）"><a href="#来自版本控制系统（VCS）" class="headerlink" title="来自版本控制系统（VCS）"></a>来自版本控制系统（VCS）</h4><ul><li>通常使用git+gitee&#x2F;github来实现版本控制，IDEA中也有对于它们的相关操作方式，这里不再赘述。</li></ul><h4 id="来自工程目录"><a href="#来自工程目录" class="headerlink" title="来自工程目录"></a>来自工程目录</h4><ul><li><p>直接使用IDEA打开工程目录即可。下面举个例子：</p><ol><li><p><strong>获取工程压缩包</strong>：假设别人发给我们一个 Maven 工程的 zip 压缩包：maven-rest-demo.zip。从码云或GitHub上也可以以 ZIP 压缩格式对项目代码打包下载。</p></li><li><p><strong>解压工程压缩包</strong>：如果你的所有 IDEA 工程有一个专门的目录来存放，而不是散落各处，那么首先我们就把 ZIP 包解压到这个指定目录中。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104142023322.png" alt="image-20221104142023322"></p></li><li><p><strong>使用IDEA打开解压好的目录</strong>：只要我们确认在解压目录下可以直接看到 pom.xml，那就能证明这个解压目录就是我们的工程目录。那么接下来让 IDEA 打开这个目录就可以了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104142112084.png" alt="image-20221104142112084"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104142129071.png" alt="image-20221104142129071"></p></li><li><p><strong>设置Maven核心程序的位置</strong>（如果在IDEA中配置了新工程的setting就不用这步了）：打开一个新的 Maven 工程，和新创建一个 Maven 工程是一样的，此时 IDEA 的 settings 配置中关于 Maven 仍然是默认值，所以我们还是需要像新建 Maven 工程那样，指定一下 Maven 核心程序位置：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104142354750.png" alt="image-20221104142354750"></p></li></ol></li></ul><h3 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h3><h4 id="情景重现"><a href="#情景重现" class="headerlink" title="情景重现"></a>情景重现</h4><ul><li><p><strong>在实际开发中，通常会忽略模块（也就是module）所在的项目（也就是project）仅仅导入某一个模块本身</strong>。这么做很可能是类似这样的情况：比如基于 Maven 学习 SSM 的时候，做练习需要导入老师发给我们的代码参考。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104142714234.png" alt="image-20221104142714234"></p></li></ul><h4 id="导入Java类型模块"><a href="#导入Java类型模块" class="headerlink" title="导入Java类型模块"></a>导入Java类型模块</h4><ol><li><p>找到想要导入模块的所在目录：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104142754321.png" alt="image-20221104142754321"></p></li><li><p>复制我们想要导入的模块目录：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104142821800.png" alt="image-20221104142821800"></p></li><li><p>粘贴到我们自己的工程目录下，这个工程（project）是我们事先在IDEA中创建好的：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104143342073.png" alt="image-20221104143342073"></p></li><li><p>在IDEA中执行导入：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104143420462.png" alt="image-20221104143420462"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104143431264.png" alt="image-20221104143431264"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104143449031.png" alt="image-20221104143449031"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104143502738.png" alt="image-20221104143502738"></p></li><li><p>修改pom.xml，刚刚导入的 module 的父工程坐标还是以前的，需要改成我们自己的 project：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104143833323.png" alt="image-20221104143833323"></p></li><li><p>最终效果：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104143858373.png" alt="image-20221104143858373"></p></li></ol><h4 id="导入Web类型模块"><a href="#导入Web类型模块" class="headerlink" title="导入Web类型模块"></a>导入Web类型模块</h4><ul><li><p>其它操作和上面演示的都一样，只是多一步：删除多余的、不正确的 web.xml 设置。如下图所示：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104143952837.png" alt="image-20221104143952837"></p></li></ul><h1 id="其他核心概念"><a href="#其他核心概念" class="headerlink" title="其他核心概念"></a>其他核心概念</h1><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ul><li>为了让构建过程自动化完成，Maven 设定了<strong>三个生命周期</strong>，<strong>生命周期中的每一个环节对应构建过程中的一个操作</strong>。</li></ul><h3 id="三个生命周期"><a href="#三个生命周期" class="headerlink" title="三个生命周期"></a>三个生命周期</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104144831599.png" alt="image-20221104144831599"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>前面<strong>三个生命周期彼此是独立的</strong>。</li><li><strong>在任何一个生命周期内部，执行任何一个具体环节的操作，都是从本周期最初的位置开始执行，直到指定的地方</strong>。（本节记住这句话就行了，其他的都不需要记）</li><li>Maven 之所以这么设计其实就是<strong>为了提高构建过程的自动化程度</strong>：让使用者只关心最终要干的即可，过程中的各个环节是自动执行的。</li></ul><h2 id="插件和目标"><a href="#插件和目标" class="headerlink" title="插件和目标"></a>插件和目标</h2><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><ul><li>Maven 的<strong>核心程序仅仅负责宏观调度，不做具体工作</strong>。<strong>具体工作都是由 Maven 插件完成的</strong>。例如：编译就是由 maven-compiler-plugin-3.1.jar 插件来执行的。</li></ul><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li><strong>一个插件可以对应多个目标，而每一个目标都和生命周期中的某一个环节对应</strong>。</li><li>Default 生命周期中有 compile 和 test-compile 两个和编译相关的环节，这两个环节对应 compile 和 test-compile 两个目标，而这两个目标都是由 maven-compiler-plugin-3.1.jar 插件来执行的。</li></ul><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><ul><li><p><strong>本地仓库</strong>：在当前电脑上，为电脑上所有 Maven 工程服务</p></li><li><p><strong>远程仓库</strong>：需要联网</p><ul><li>局域网：我们自己搭建的 Maven 私服，例如使用 Nexus 技术。</li><li>Internet：<ul><li>中央仓库</li><li>镜像仓库：内容和中央仓库保持一致，但是能够分担中央仓库的负载，同时让用户能够就近访问提高下载速度，例如：Nexus aliyun</li></ul></li></ul></li><li><p>建议：<strong>不要中央仓库和阿里云镜像混用，否则 jar 包来源不纯，彼此冲突</strong>。</p></li><li><p>专门搜索 Maven 依赖信息的网站：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;为什么要学习Maven？&quot;&gt;&lt;a href=&quot;#为什么要学习Maven？&quot; class=&quot;headerlink&quot; title=&quot;为什么要学习Maven？&quot;&gt;&lt;/a&gt;为什么</summary>
      
    
    
    
    
    <category term="Maven" scheme="https://konjacor.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ入门</title>
    <link href="https://konjacor.github.io/2022/10/28/RabbitMQ%E5%85%A5%E9%97%A8/"/>
    <id>https://konjacor.github.io/2022/10/28/RabbitMQ%E5%85%A5%E9%97%A8/</id>
    <published>2022-10-28T01:29:59.000Z</published>
    <updated>2022-12-20T12:11:43.199Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="MQ的相关概念"><a href="#MQ的相关概念" class="headerlink" title="MQ的相关概念"></a>MQ的相关概念</h1><h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h2><ul><li>MQ(message queue)，从字面意思上看，<strong>本质是个队列，FIFO 先入先出</strong>，只不过队列中存放的内容是message 而已，还<strong>是一种跨进程的通信机制，用于上下游传递消息</strong>。在互联网架构中，MQ 是一种非常常见的<strong>上下游“逻辑解耦+物理解耦”的消息通信服务</strong>。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。</li></ul><h2 id="为什么要用MQ"><a href="#为什么要用MQ" class="headerlink" title="为什么要用MQ"></a>为什么要用MQ</h2><h3 id="流量削-消-峰"><a href="#流量削-消-峰" class="headerlink" title="流量削(消)峰"></a>流量削(消)峰</h3><ul><li>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。<strong>使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好</strong>。</li></ul><h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><ul><li><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，<strong>如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常</strong>。当<strong>转变成基于消息队列的方式后，系统间调用的问题会减少很多</strong>，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统<strong>要处理的内容被缓存在消息队列中</strong>，用户的下单操作可以正常完成。当物流<strong>系统恢复后，继续处理订单信息</strong>即可，下单用户感受不到物流系统的故障，<strong>提升系统的可用性</strong>。</p></li><li><p>引入消息队列后系统的结构：<img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221028095447013.png" alt="image-20221028095447013"></p></li></ul><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><ul><li><p><strong>有些服务间调用是异步的</strong>，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，<strong>使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务</strong>。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p></li><li><p>加入消息队列后的异步消息处理：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221028100044425.png" alt="image-20221028100044425"></p></li></ul><h2 id="MQ的分类"><a href="#MQ的分类" class="headerlink" title="MQ的分类"></a>MQ的分类</h2><h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><ul><li><strong>优点</strong>：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据。</li><li><strong>缺点</strong>：官方社区现在对 ActiveMQ 5.x <strong>维护越来越少，高吞吐量场景较少使用</strong>。</li></ul><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><ul><li>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款<strong>为大数据而生的消息中间件</strong>，以其<strong>百万级</strong> <strong>TPS</strong> 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</li><li><strong>优点</strong>: 性能卓越，单机写入 TPS 约在百万条&#x2F;秒，最大的优点，就是<strong>吞吐量高</strong>。时效性 ms 级可用性非常高，<strong>kafka 是分布式的</strong>，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;<strong>有优秀的第三方Kafka Web 管理界面 Kafka-Manager</strong>；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能较为简单，主要支持简单的 MQ 功能，<strong>在大数据领域的实时计算以及日志采集被大规模使用</strong>。</li><li><strong>缺点</strong>：Kafka 单机超过 64 个队列&#x2F;分区，Load（负载）会发生明显的飙高现象，<strong>队列越多，load 越高，发送消息响应时间变长</strong>，<strong>使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试</strong>；<strong>支持消息顺序，但是一台代理宕机后，就会产生消息乱序</strong>，<strong>社区更新较慢</strong>；</li></ul><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><ul><li>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。‘</li><li><strong>优点</strong>：<strong>单机吞吐量十万级</strong>,可用性非常高，分布式架构,<strong>消息可以做到</strong> <strong>0</strong> <strong>丢失</strong>,MQ 功能较为完善，还是<strong>分布式的，扩展性好</strong>,<strong>支持</strong> <strong>10</strong> <strong>亿级别的消息堆积</strong>，不会因为堆积导致性能下降,源码是 java 我们可以自己阅读源码，定制自己公司的 MQ。</li><li><strong>缺点</strong>：<strong>支持的客户端语言不多</strong>，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在 MQ核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码。</li></ul><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><ul><li>2007 年发布，是一个<strong>在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统</strong>，是<strong>当前最主流的消息中间件之一</strong>。</li><li><strong>优点</strong>：由于 erlang 语言的<strong>高并发特性</strong>，性能较好；<strong>吞吐量到万级</strong>，MQ 功能比较完备,健壮、稳定、易用、跨平台、<strong>支持多种语言</strong> 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持 AJAX 文档齐全；<strong>开源提供的管理界面非常棒</strong>，用起来很好用,<strong>社区活跃度高</strong>；<strong>更新频率相当高</strong>。</li><li><strong>缺点</strong>：商业版需要收费,学习成本较高。</li></ul><h2 id="MQ的选择"><a href="#MQ的选择" class="headerlink" title="MQ的选择"></a>MQ的选择</h2><h3 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h3><ul><li>Kafka 主要特点是<strong>基于 Pull 的模式来处理消息消费，追求高吞吐量</strong>，一开始的目的就是用于日志收集和传输，<strong>适合产生大量数据的互联网服务的数据收集业务</strong>。<strong>大型公司建议可以选用</strong>，如果<strong>有日志采集功能，肯定是首选 kafka</strong>了。</li></ul><h3 id="RocketMQ-1"><a href="#RocketMQ-1" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><ul><li>天生<strong>为金融互联网领域而生</strong>，对于<strong>可靠性要求很高的场景</strong>，尤其是<strong>电商里面的订单扣款，以及业务削峰</strong>，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</li></ul><h3 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><ul><li>结合 <strong>erlang 语言本身的并发优势</strong>，性能好<strong>时效性微秒级</strong>，<strong>社区活跃度也比较高</strong>，<strong>管理界面用起来十分方便</strong>，如果你的<strong>数据量没有那么大</strong>，中小型公司优先选择功能比较完备的 RabbitMQ。</li></ul><h1 id="RabbitMQ-2"><a href="#RabbitMQ-2" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="RabbitMQ的概念"><a href="#RabbitMQ的概念" class="headerlink" title="RabbitMQ的概念"></a>RabbitMQ的概念</h2><ul><li>RabbitMQ 是一个消息中间件：它<strong>接受并转发消息</strong>。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑<strong>RabbitMQ 是一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据</strong>。</li></ul><h2 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><ul><li>产生数据发送消息的程序是生产者。</li></ul><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><ul><li>交换机是 RabbitMQ 非常重要的一个部件，一方面<strong>它接收来自生产者的消息，另一方面它将消息推送到队列中</strong>。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得由交换机类型决定。</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>队列是 RabbitMQ 内部使用的一种数据结构，<strong>尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中</strong>。队列仅受主机的内存和磁盘限制的约束，<strong>本质上是一个大的消息缓冲区</strong>。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式。</li></ul><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><ul><li>消费与接收具有相似的含义。<strong>消费者大多时候是一个等待接收消息的程序</strong>。请注意<strong>生产者，消费者和消息中间件很多时候并不在同一机器上</strong>。同一个应用程序既可以是生产者又是可以是消费者。</li></ul><h2 id="RabbitMQ核心部分"><a href="#RabbitMQ核心部分" class="headerlink" title="RabbitMQ核心部分"></a>RabbitMQ核心部分</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029093156586.png" alt="image-20221029093156586"></p><ol><li>“Hello World”：消息队列的简单使用</li><li>Work queues：工作队列</li><li>Publish&#x2F;Subscribe：消息的发布订阅</li><li>Routing：不同的路由方式</li><li>Topics：主题路由</li><li>Publisher Confirms：消息的发布确认</li></ol><h2 id="相关名词介绍"><a href="#相关名词介绍" class="headerlink" title="相关名词介绍"></a>相关名词介绍</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029093829448.png" alt="image-20221029093829448"></p><ul><li><strong>Broker（代理）</strong>：<strong>接收和分发消息的应用</strong>，RabbitMQ Server 就是 Message Broker。</li><li><strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP（协议）的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。<strong>当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</strong>。</li><li><strong>Connection</strong>：<strong>publisher／consumer 和 broker 之间的 TCP 连接</strong>。</li><li><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。<strong>Channel 是在 connection 内部建立的逻辑连接</strong>，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的Connection极大减少了操作系统建立TCP connection的开销</strong>。</li><li><strong>Exchange</strong>：message 到达 broker 的第一站，<strong>根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去</strong>。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</li><li><strong>Queue</strong>：<strong>消息最终被送到这里等待 consumer 取走</strong>。</li><li><strong>Binding</strong>：<strong>exchange 和 queue 之间的虚拟连接</strong>，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h3><ul><li><a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a></li></ul><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><ul><li><p>下载到&#x2F;usr&#x2F;local&#x2F;software 目录下(如果没有 software 需要自己创建)</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029100246651.png" alt="image-20221029100246651"></p></li></ul><h3 id="安装文件-分别按照以下顺序安装"><a href="#安装文件-分别按照以下顺序安装" class="headerlink" title="安装文件(分别按照以下顺序安装)"></a>安装文件(分别按照以下顺序安装)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh erlang-21.3-1.el7.x86_64.rpm</span><br><span class="line">yum install socat -y</span><br><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><h3 id="常用命令（按照以下顺序执行）"><a href="#常用命令（按照以下顺序执行）" class="headerlink" title="常用命令（按照以下顺序执行）"></a>常用命令（按照以下顺序执行）</h3><ul><li><p>添加开机启动RabbitMQ服务：<strong>chkconfig rabbitmq-server on</strong></p></li><li><p>启动服务：**&#x2F;sbin&#x2F;service rabbitmq-server start**</p></li><li><p>查看服务状态：**&#x2F;sbin&#x2F;service rabbitmq-server status**</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029100508454.png" alt="image-20221029100508454"></p></li><li><p>停止服务（选择执行）：**&#x2F;sbin&#x2F;service rabbitmq-server stop**</p></li><li><p>开启web管理插件：<strong>rabbitmq-plugins enable rabbitmq_management</strong></p></li><li><p>用默认账号密码(guest)访问地址<a href="http://47.115.185.244:15672/%E5%87%BA%E7%8E%B0%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%EF%BC%9A">http://47.115.185.244:15672/出现权限问题：</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029100645974.png" alt="image-20221029100645974"></p></li></ul><h3 id="添加一个新的用户"><a href="#添加一个新的用户" class="headerlink" title="添加一个新的用户"></a>添加一个新的用户</h3><ul><li><p>创建帐号：<strong>rabbitmqctl add_user admin 123</strong></p></li><li><p>设置用户角色：<strong>rabbitmqctl set_user_tags admin administrator</strong></p></li><li><p>设置用户权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span><br><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">用户 user_admin 具有/vhost1 这个 virtual host 中所有资源的配置、写、读权限当前用户和角色</span><br><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure></li></ul><h3 id="再次利用admin用户登录"><a href="#再次利用admin用户登录" class="headerlink" title="再次利用admin用户登录"></a>再次利用admin用户登录</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029100915001.png" alt="image-20221029100915001"></p><h3 id="重置命令"><a href="#重置命令" class="headerlink" title="重置命令"></a>重置命令</h3><ul><li>关闭应用的命令为：<strong>rabbitmqctl stop_app</strong></li><li>清除的命令为：<strong>rabbitmqctl reset</strong></li><li>重新启动命令为：<strong>rabbitmqctl start_app</strong></li></ul><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><ul><li><p>在这一部分中，我们将用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者。我们将介绍 Java API 中的一些细节。</p></li><li><p>在下图中，“P”是我们的生产者，“C”是我们的消费者。中间的框是一个队列-RabbitMQ代表使用者保留的消息缓冲区。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221030093742819.png" alt="image-20221030093742819"></p></li></ul><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定 jdk 编译版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--rabbitmq 依赖客户端--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--操作文件流的一个依赖--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//创建一个连接工厂</span></span><br><span class="line"> <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"> factory.setHost(<span class="string">&quot;182.92.234.71&quot;</span>);</span><br><span class="line"> factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"> factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"> <span class="comment">//channel 实现了自动 close 接口 自动关闭 不需要显示关闭</span></span><br><span class="line"> <span class="keyword">try</span>(<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;<span class="comment">//从factory中获得connection，再从connection中获得channel</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 生成一个队列</span></span><br><span class="line"><span class="comment">  * 1.队列名称</span></span><br><span class="line"><span class="comment">  * 2.队列里面的消息是否持久化 默认消息存储在内存中</span></span><br><span class="line"><span class="comment">  * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费</span></span><br><span class="line"><span class="comment">  * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除</span></span><br><span class="line"><span class="comment">  * 5.其他参数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);<span class="comment">//声明队列</span></span><br><span class="line"> String message=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 发送一个消息</span></span><br><span class="line"><span class="comment">  * 1.发送到那个交换机</span></span><br><span class="line"><span class="comment">  * 2.路由的 key 是哪个</span></span><br><span class="line"><span class="comment">  * 3.其他的参数信息</span></span><br><span class="line"><span class="comment">  * 4.发送消息的消息体</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());<span class="comment">//由于没有设置交换机，所以消息发布到队列中</span></span><br><span class="line">System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"> factory.setHost(<span class="string">&quot;182.92.234.71&quot;</span>);</span><br><span class="line"> factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"> factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"> System.out.println(<span class="string">&quot;等待接收消息....&quot;</span>);</span><br><span class="line"> <span class="comment">//推送的消息如何进行消费的接口回调</span></span><br><span class="line"> DeliverCallback deliverCallback=(consumerTag,delivery)-&gt;&#123;</span><br><span class="line"> String message= <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line"> System.out.println(message);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span></span><br><span class="line"> CancelCallback cancelCallback=(consumerTag)-&gt;&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 消费者消费消息</span></span><br><span class="line"><span class="comment">  * 1.消费哪个队列</span></span><br><span class="line"><span class="comment">  * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答</span></span><br><span class="line"><span class="comment">  * 3.消费者未成功消费的回调</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);<span class="comment">//从队列中消费消息</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h1><ul><li><p>工作队列(又称任务队列)的主要思想是<strong>避免立即执行资源密集型任务</strong>，而不得不等待它完成。</p><p>相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进</p><p>程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p></li></ul><h2 id="轮询分发消息"><a href="#轮询分发消息" class="headerlink" title="轮询分发消息"></a>轮询分发消息</h2><ul><li><p>在这个案例中我们会启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程</p><p>是如何工作的。</p></li></ul><h3 id="抽取工具类"><a href="#抽取工具类" class="headerlink" title="抽取工具类"></a>抽取工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqUtils</span> &#123;</span><br><span class="line"> <span class="comment">//得到一个连接的 channel</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"> <span class="comment">//创建一个连接工厂</span></span><br><span class="line"> <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"> factory.setHost(<span class="string">&quot;182.92.234.71&quot;</span>);</span><br><span class="line"> factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"> factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"> <span class="keyword">return</span> channel;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动两个工作线程"><a href="#启动两个工作线程" class="headerlink" title="启动两个工作线程"></a>启动两个工作线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker01</span> &#123;<span class="comment">//改个文本再开第二个线程比较有辨识度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">DeliverCallback deliverCallback=(consumerTag,delivery)-&gt;&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">System.out.println(<span class="string">&quot;接收到消息:&quot;</span>+receivedMessage);</span><br><span class="line">&#125;;</span><br><span class="line">CancelCallback cancelCallback=(consumerTag)-&gt;&#123;</span><br><span class="line">System.out.println(consumerTag+<span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;C2 消费者启动等待消费......&quot;</span>);</span><br><span class="line">channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221030230515903.png" alt="image-20221030230515903"></p><h3 id="启动一个发送线程"><a href="#启动一个发送线程" class="headerlink" title="启动一个发送线程"></a>启动一个发送线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task01</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="keyword">try</span>(Channel channel=RabbitMqUtils.getChannel();) &#123;</span><br><span class="line"> channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"> <span class="comment">//从控制台当中接受信息</span></span><br><span class="line"> <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"> <span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line"> channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line"> System.out.println(<span class="string">&quot;发送消息完成:&quot;</span>+message);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><ul><li><p>通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221030230922398.png" alt="image-20221030230922398"></p></li></ul><h2 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。<strong>默认情况下RabbitMQ一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息，以及后续发送给该消费者的消息</strong>，因为它无法接收到。</li><li>为了保证消息在发送过程中不丢失，rabbitmq引入<strong>消息应答机制</strong>，消息应答就是：<strong>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong></li></ul><h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><ul><li><strong>消息发送后立即被认为已经传送成功</strong>，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面<strong>这种模式消费者那边可以传递过载的消息（因为传过去就马上确认，就可以马上传下一个了），没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压</strong>，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以<strong>这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用</strong>。</li></ul><h3 id="手动消息应答的方法"><a href="#手动消息应答的方法" class="headerlink" title="手动消息应答的方法"></a>手动消息应答的方法</h3><ul><li>**Channel.basicAck(args)**：用于肯定确认，RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了。</li><li>**Channel.basicNack()**：用于否定确认。</li><li>**Channel.basicReject()**：用于否定确认，与 Channel.basicNack 相比少一个参数，不处理该消息了直接拒绝，可以将其丢弃了</li></ul><h3 id="手动应答方法参数Multiple的解释"><a href="#手动应答方法参数Multiple的解释" class="headerlink" title="手动应答方法参数Multiple的解释"></a>手动应答方法参数Multiple的解释</h3><ul><li><p>手动应答的好处是<strong>可以批量应答并且减少网络拥堵</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031090701521.png" alt="image-20221031090701521"></p></li><li><p>multiple的true和false代表不同的意思：</p><ul><li><p>true代表<strong>批量应答channel上未应答的消息</strong>。比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031091013530.png" alt="image-20221031091013530"></p></li><li><p>false同上面相比，只会应答tag&#x3D;8的消息，5，6，7这三个消息依然不会被确认收到消息应答</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031091025972.png" alt="image-20221031091025972"></p></li></ul></li></ul><h3 id="消息自动重新入队"><a href="#消息自动重新入队" class="headerlink" title="消息自动重新入队"></a>消息自动重新入队</h3><ul><li><p>如果消费者由于某些原因失去连接（其通道已关闭，连接已关闭或TCP连接丢失），导致<strong>消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将对其重新排队</strong>。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031091402285.png" alt="image-20221031091402285"></p></li></ul><h3 id="消息手动应答代码"><a href="#消息手动应答代码" class="headerlink" title="消息手动应答代码"></a>消息手动应答代码</h3><ul><li><p>默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答，消费者在上面代码的基础上增加下面画红色部分代码。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031091631480.png" alt="image-20221031091631480"></p></li><li><p>消息生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task02</span> &#123;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line"> channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"> <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"> System.out.println(<span class="string">&quot;请输入信息&quot;</span>);</span><br><span class="line"> <span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"> channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"> System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者01：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work03</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACK_QUEUE_NAME=<span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"> System.out.println(<span class="string">&quot;C1 等待接收消息处理时间较短&quot;</span>);</span><br><span class="line"><span class="comment">//消息消费的时候如何处理消息</span></span><br><span class="line"> DeliverCallback deliverCallback=(consumerTag,delivery)-&gt;&#123;</span><br><span class="line"> String message= <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line"> SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;接收到消息:&quot;</span>+message);</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 1.消息标记 tag</span></span><br><span class="line"><span class="comment">  * 2.是否批量应答未应答消息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">//采用手动应答</span></span><br><span class="line"> <span class="type">boolean</span> autoAck=<span class="literal">false</span>;</span><br><span class="line"> channel.basicConsume(ACK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag)-&gt;&#123;</span><br><span class="line"> System.out.println(consumerTag+<span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者02：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work04</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACK_QUEUE_NAME=<span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"> System.out.println(<span class="string">&quot;C2 等待接收消息处理时间较长&quot;</span>);</span><br><span class="line"> <span class="comment">//消息消费的时候如何处理消息</span></span><br><span class="line"> DeliverCallback deliverCallback=(consumerTag,delivery)-&gt;&#123;</span><br><span class="line"> String message= <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line"> SleepUtils.sleep(<span class="number">30</span>);</span><br><span class="line"> System.out.println(<span class="string">&quot;接收到消息:&quot;</span>+message);</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 1.消息标记 tag</span></span><br><span class="line"><span class="comment">  * 2.是否批量应答未应答消息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="comment">//采用手动应答</span></span><br><span class="line"> <span class="type">boolean</span> autoAck=<span class="literal">false</span>;</span><br><span class="line"> channel.basicConsume(ACK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag)-&gt;&#123;</span><br><span class="line"> System.out.println(consumerTag+<span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="手动应答效果演示"><a href="#手动应答效果演示" class="headerlink" title="手动应答效果演示"></a>手动应答效果演示</h3><ul><li><p>正常情况下消息发送方发送两个消息，C1和C2分别接收到消息并进行处理：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031092726539.png" alt="image-20221031092726539"></p></li><li><p>在发送者发送消息 dd，发出消息之后把 C2 消费者停掉，按理说该 C2 来处理该消息，但是由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了，此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031092917687.png" alt="image-20221031092917687"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031092931800.png" alt="image-20221031092931800"></p></li></ul><h2 id="RabbitMQ持久化"><a href="#RabbitMQ持久化" class="headerlink" title="RabbitMQ持久化"></a>RabbitMQ持久化</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li>刚刚我们已经看到了如何处理任务不丢失的情况，但是如何保障当 RabbitMQ 服务停掉以后消息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化</strong>。</li></ul><h3 id="队列如何实现持久化"><a href="#队列如何实现持久化" class="headerlink" title="队列如何实现持久化"></a>队列如何实现持久化</h3><ul><li><p>之前我们创建的队列都是非持久化的，rabbitmq 如果重启的话，该队列就会被删除掉，如果要队列实现持久化 需要<strong>在声明队列的时候把durable参数设置为true</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031093551216.png" alt="image-20221031093551216"></p></li><li><p>但是需要注意的就是<strong>如果之前声明的队列不是持久化的，需要把原先的队列先删除，或者重新创建一个持久化的队列，不然就会出现错误</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031093753906.png" alt="image-20221031093753906"></p></li><li><p>以下为控制台中持久化与非持久化队列的UI显示区：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031093845725.png" alt="image-20221031093845725"></p></li><li><p>将队列设置为持久化后，即使重启rabbitmq队列也依然存在。</p></li></ul><h3 id="消息实现持久化"><a href="#消息实现持久化" class="headerlink" title="消息实现持久化"></a>消息实现持久化</h3><ul><li><p>要想让消息实现持久化需要<strong>在消息生产者修改代码，添加MessageProperties.PERSISTENT_TEXT_PLAIN这个属性</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031094022385.png" alt="image-20221031094022385"></p></li><li><p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里<strong>依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点，此时并没有真正写入磁盘。持久性保证并不强</strong>，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果需要更强有力的持久化策略，参考后边课件发布确认章节。</p></li></ul><h3 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h3><ul><li><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮询分发，但是在某种场景下这种策略并不是很好，<strong>比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者2处理速度却很慢，这个时候我们还是采用轮询分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好</strong>，但是RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p></li><li><p>为了避免这种情况，我们可以<strong>设置参数channel.basicQos(1);</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031094452126.png" alt="image-20221031094452126"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031094517497.png" alt="image-20221031094517497"></p></li><li><p>意思就是<strong>如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我</strong>，我目前只能处理一个任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。</p></li></ul><h3 id="预取值"><a href="#预取值" class="headerlink" title="预取值"></a>预取值</h3><ul><li><p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以<strong>通过使用basic.qos 方法设置“预取计数”值</strong>来完成的。<strong>该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认</strong>，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的RAM消耗</strong>(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。<strong>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031095001072.png" alt="image-20221031095001072"></p></li></ul><h1 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h1><h2 id="发布确认原理"><a href="#发布确认原理" class="headerlink" title="发布确认原理"></a>发布确认原理</h2><ul><li>生产者将信道设置成 confirm 模式，<strong>一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出</strong>，broker 回传给生产者的确认消息中 <strong>delivery-tag 域包含了确认消息的序列号</strong>，此外broker 也可以<strong>设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理</strong>。</li><li>confirm 模式最大的好处在于<strong>他是异步的</strong>，一旦发布一条消息，<strong>生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息</strong>，如果<strong>RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息</strong>。</li></ul><h2 id="发布确认的策略"><a href="#发布确认的策略" class="headerlink" title="发布确认的策略"></a>发布确认的策略</h2><h3 id="开启发布确认的方法"><a href="#开启发布确认的方法" class="headerlink" title="开启发布确认的方法"></a>开启发布确认的方法</h3><ul><li><p>发布确认默认是没有开启的，如果<strong>要开启需要调用方法 confirmSelect</strong>，每当你要想使用发布确认，都需要在 channel 上调用该方法：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105092853970.png" alt="image-20221105092853970"></p></li></ul><h3 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h3><ul><li><p>这是一种简单的确认方式，它是一种<strong>同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布</strong>,<strong>waitForConfirmsOrDie(long)这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常</strong>。</p></li><li><p>这种确认方式有一个最大的缺点就是:<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageIndividually</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line"><span class="comment">//服务端返回 false 或超时时间内未返回，生产者可以消息重发</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个单独确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h3><ul><li><p>上面那种方式非常慢，与单个等待确认消息相比，<strong>先发布一批消息然后一起确认可以极大地提高吞吐量</strong>，当然这种方式的<strong>缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息</strong>。当然<strong>这种方案仍然是同步的，也一样阻塞消息的发布</strong>。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">//批量确认消息大小</span></span><br><span class="line"><span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">//未确认消息个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">outstandingMessageCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">outstandingMessageCount++;</span><br><span class="line"><span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class="line">channel.waitForConfirms();</span><br><span class="line">outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为了确保还有剩余没有确认消息 再次确认</span></span><br><span class="line"><span class="keyword">if</span> (outstandingMessageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">channel.waitForConfirms();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个批量确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h3><ul><li><p>异步确认虽然编程逻辑比上两个要复杂，但是<strong>性价比最高，无论是可靠性还是效率都没得说</strong>，他是<strong>利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功</strong>，下面就让我们来详细讲解异步确认是怎么实现的。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105094400729.png" alt="image-20221105094400729"></p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//开启发布确认</span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程安全有序的一个哈希表，适用于高并发的情况</span></span><br><span class="line"><span class="comment"> * 1.轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment"> * 2.轻松批量删除条目 只要给到序列号</span></span><br><span class="line"><span class="comment"> * 3.支持并发访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 确认收到消息的一个回调</span></span><br><span class="line"><span class="comment"> * 1.消息序列号</span></span><br><span class="line"><span class="comment"> * 2.true 可以确认小于等于当前序列号的消息</span></span><br><span class="line"><span class="comment"> *  false 确认当前序列号消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (multiple) &#123;</span><br><span class="line"><span class="comment">//返回的是小于等于当前序列号的未确认消息 是一个 map</span></span><br><span class="line">ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outstandingConfirms.headMap(sequenceNumber, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">//清除该部分未确认消息</span></span><br><span class="line">confirmed.clear();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//只清除当前序列号的消息</span></span><br><span class="line">outstandingConfirms.remove(sequenceNumber);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> outstandingConfirms.get(sequenceNumber);</span><br><span class="line">System.out.println(<span class="string">&quot;发布的消息&quot;</span>+message+<span class="string">&quot;未被确认，序列号&quot;</span>+sequenceNumber);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加一个异步确认的监听器</span></span><br><span class="line"><span class="comment"> * 1.确认收到消息的回调</span></span><br><span class="line"><span class="comment"> * 2.未收到消息的回调</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">channel.addConfirmListener(ackCallback, <span class="literal">null</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;消息&quot;</span> + i;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * channel.getNextPublishSeqNo() 获取下一个消息的序列号</span></span><br><span class="line"><span class="comment"> * 通过序列号与消息体进行一个关联</span></span><br><span class="line"><span class="comment"> * 全部都是未确认的消息体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个异步确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="如何处理异步未确认消息"><a href="#如何处理异步未确认消息" class="headerlink" title="如何处理异步未确认消息"></a>如何处理异步未确认消息</h3><ul><li>最好的解决的解决方案就是<strong>把未确认的消息放到一个基于内存的能被发布线程访问的队列</strong>，比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。</li></ul><h3 id="以上3种发布确认速度对比"><a href="#以上3种发布确认速度对比" class="headerlink" title="以上3种发布确认速度对比"></a>以上3种发布确认速度对比</h3><ul><li><p><strong>单独发布消息</strong>：同步等待确认，简单，但吞吐量非常有限。</p></li><li><p><strong>批量发布消息</strong>：批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。</p></li><li><p><strong>异步处理</strong>：最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些。</p></li><li><p>三种方式的确认速度对比：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105095710510.png" alt="image-20221105095710510"></p></li></ul><h1 id="交换机-1"><a href="#交换机-1" class="headerlink" title="交换机"></a>交换机</h1><ul><li>在上一节中，我们创建了一个工作队列。我们<strong>假设的是工作队列背后，每个任务都恰好交付给一个消费者(工作进程)<strong>。在这一部分中，我们将做一些完全不同的事情-我们</strong>将消息传达给多个消费者。这种模式称为 ”发布&#x2F;订阅”</strong>。</li><li>为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者</li></ul><h2 id="Exchange简介"><a href="#Exchange简介" class="headerlink" title="Exchange简介"></a>Exchange简介</h2><h3 id="Exchanges概念"><a href="#Exchanges概念" class="headerlink" title="Exchanges概念"></a>Exchanges概念</h3><ul><li><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中</strong>。</p></li><li><p>相反，<strong>生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列</strong>。<strong>交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116093140914.png" alt="image-20221116093140914"></p></li></ul><h3 id="Exchanges的类型"><a href="#Exchanges的类型" class="headerlink" title="Exchanges的类型"></a>Exchanges的类型</h3><ul><li>目前总共有以下类型：**直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)**。</li></ul><h3 id="无名exchange"><a href="#无名exchange" class="headerlink" title="无名exchange"></a>无名exchange</h3><ul><li><p>在前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="literal">null</span>,message.getBytes());</span><br></pre></td></tr></table></figure></li><li><p>第一个参数是交换机的名称。<strong>空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey)绑定 key 指定的</strong>，如果它存在的话.</p></li></ul><h2 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h2><ul><li><p>之前的部分我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。<strong>队列的名称我们来说至关重要-我们需要指定我们的消费者去消费哪个队列的消息</strong>。</p></li><li><p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们<strong>可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了</strong>。其次<strong>一旦我们断开了消费者的连接，临时队列将被自动删除</strong>。</p></li><li><p>创建临时队列的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure></li><li><p>创建出来之后长这样儿：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116093814696.png" alt="image-20221116093814696"></p></li></ul><h2 id="绑定（bindings）"><a href="#绑定（bindings）" class="headerlink" title="绑定（bindings）"></a>绑定（bindings）</h2><ul><li><p>什么是 bingding 呢，<strong>binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系</strong>。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116093917802.png" alt="image-20221116093917802"></p></li></ul><h2 id="Fanout-Exchange-扇出交换机"><a href="#Fanout-Exchange-扇出交换机" class="headerlink" title="Fanout Exchange(扇出交换机)"></a>Fanout Exchange(扇出交换机)</h2><h3 id="Fanout介绍"><a href="#Fanout介绍" class="headerlink" title="Fanout介绍"></a>Fanout介绍</h3><ul><li><p>Fanout这种类型非常简单。正如从名称中猜到的那样，<strong>它是将接收到的所有消息广播到它知道的所有队列中</strong>。系统中某些exchange的默认类型：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116094214448.png" alt="image-20221116094214448"></p></li></ul><h3 id="Fanout实战"><a href="#Fanout实战" class="headerlink" title="Fanout实战"></a>Fanout实战</h3><ul><li><p>准备实现以下结构：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116094408254.png" alt="image-20221116094408254"></p></li><li><p>Logs和临时队列的绑定关系如下图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116094434664.png" alt="image-20221116094434664"></p></li><li><p>ReceiveLogs01 将接收到的消息打印在控制台：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs01</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成一个临时的队列 队列的名称是随机的</span></span><br><span class="line"><span class="comment"> * 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串</span></span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收消息,把接收到的消息打印在屏幕.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;控制台打印接收到的消息&quot;</span>+message);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ReceiveLogs02 将接收到的消息存储在磁盘：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs02</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成一个临时的队列 队列的名称是随机的</span></span><br><span class="line"><span class="comment"> * 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line"><span class="comment">//把该临时队列绑定我们的 exchange其中 routingkey(也称之为 binding key)为空字符串</span></span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收消息,把接收到的消息写到文件.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\work\\rabbitmq_info.txt&quot;</span>);</span><br><span class="line">FileUtils.writeStringToFile(file,message,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;数据写入文件成功&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>EmitLog 发送消息给两个消费者接收：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLog</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel()) &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明一个 exchange</span></span><br><span class="line"><span class="comment"> * 1.exchange 的名称</span></span><br><span class="line"><span class="comment"> * 2.exchange 的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入信息&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Direct-Exchange-直接交换机"><a href="#Direct-Exchange-直接交换机" class="headerlink" title="Direct Exchange(直接交换机)"></a>Direct Exchange(直接交换机)</h2><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><ul><li>在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能-比方说<strong>我们只让某个消费者订阅发布的部分消息</strong>。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。</li><li>我们再次来回顾一下什么是 bindings，<strong>绑定是交换机和队列之间的桥梁关系</strong>。也可以这么理解：<strong>队列只对它绑定的交换机的消息感兴趣</strong>。</li><li>绑定用参数：routingKey 来表示也可称该参数为 binding key，<strong>创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);<strong>，</strong>绑定之后的意义由其交换类型决定，交换类型由交换机决定</strong>。</li></ul><h3 id="Direct-Exchange介绍"><a href="#Direct-Exchange介绍" class="headerlink" title="Direct Exchange介绍"></a>Direct Exchange介绍</h3><ul><li><p>上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志消息避免浪费磁盘空间。<strong>Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的广播</strong>，在这里我们将<strong>使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的routingKey 队列中去</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116095810639.png" alt="image-20221116095810639"></p></li><li><p>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列 Q1 绑定键为 orange，队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green。</p></li><li><p>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p></li></ul><h3 id="多重绑定"><a href="#多重绑定" class="headerlink" title="多重绑定"></a>多重绑定</h3><ul><li><p><strong>同一个routingKey可以和多个队列进行绑定</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116100026526.png" alt="image-20221116100026526"></p></li><li><p>当然如果 exchange 的绑定类型是 direct，但是它绑定的多个队列的 key 如果都相同，在这种情况下虽然绑定类型是 direct 但是它表现的就和 fanout 有点类似了，就跟广播差不多，如上图所示。</p></li></ul><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><ul><li><p>准备实现以下结构，通过不同的routingKey给日志区分级别并由不同的消费者进行处理（或没有消费者处理，直接丢弃）。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116100257537.png" alt="image-20221116100257537"></p></li><li><p>交换机的绑定关系如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116100330363.png" alt="image-20221116100330363"></p></li><li><p>消费者1接收错误日志并将其存储到磁盘中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect01</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;disk&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">message=<span class="string">&quot;接收绑定键:&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="string">&quot;,消息:&quot;</span>+message;</span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\work\\rabbitmq_info.txt&quot;</span>);</span><br><span class="line">FileUtils.writeStringToFile(file,message,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;错误日志已经接收&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者2接收info和warning级别的日志并输出到终端上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect02</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;console&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot; 接 收 绑 定 键 :&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="string">&quot;, 消息:&quot;</span>+message);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生产者发送消息到直接交换机中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLogDirect</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel()) &#123;</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="comment">//创建多个 bindingKey</span></span><br><span class="line">Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;info&quot;</span>,<span class="string">&quot;普通 info 信息&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;warning&quot;</span>,<span class="string">&quot;警告 warning 信息&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;error&quot;</span>,<span class="string">&quot;错误 error 信息&quot;</span>);</span><br><span class="line"><span class="comment">//debug 没有消费这接收这个消息 所有就丢失了</span></span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;debug&quot;</span>,<span class="string">&quot;调试 debug 信息&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry: bindingKeyMap.entrySet())&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">bindingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME,bindingKey, <span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;生产者发出消息:&quot;</span> + message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Topic-Exchange-主题交换机"><a href="#Topic-Exchange-主题交换机" class="headerlink" title="Topic Exchange(主题交换机)"></a>Topic Exchange(主题交换机)</h2><h3 id="之前类型的交换机存在的问题"><a href="#之前类型的交换机存在的问题" class="headerlink" title="之前类型的交换机存在的问题"></a>之前类型的交换机存在的问题</h3><ul><li>在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。</li><li>尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候 direct 就办不到了。这个时候就只能使用 topic 类型。</li></ul><h3 id="Topic-Exchange的要求"><a href="#Topic-Exchange的要求" class="headerlink" title="Topic Exchange的要求"></a>Topic Exchange的要求</h3><ul><li>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它<strong>必须是一个单词列表，以点号分隔开</strong>。这些单词可以是任意单词，比如说：”stock.usd.nyse”, “nyse.vmw”,”quick.orange.rabbit”.这种类型的。当然<strong>这个单词列表最多不能超过 255 个字节</strong>。</li><li>在这个规则列表中，其中有两个替换符是大家需要注意的：<ol><li>***(星号)可以代替一个单词**</li><li><strong>#(井号)可以替代零个或多个单词</strong></li></ol></li><li>之后<strong>主题交换机就通过结合了单词列表和替换符的routingKey进行路由</strong>。</li></ul><h3 id="Topic-Exchange匹配案例"><a href="#Topic-Exchange匹配案例" class="headerlink" title="Topic Exchange匹配案例"></a>Topic Exchange匹配案例</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116103116297.png" alt="image-20221116103116297"></p><ul><li>上图的绑定关系如下：<ul><li>Q1–&gt;绑定的是中间带 orange 带 3 个单词的字符串(*.orange.*)</li><li>Q2–&gt;绑定的是最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)和第一个单词是 lazy 的多个单词(lazy.#)</li></ul></li><li>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的：<ul><li>quick.orange.rabbit 被队列 Q1Q2 接收到</li><li>lazy.orange.elephant 被队列 Q1Q2 接收到</li><li>quick.orange.fox 被队列 Q1 接收到</li><li>lazy.brown.fox 被队列 Q2 接收到</li><li>lazy.pink.rabbit 虽然满足两个绑定但只被队列 Q2 接收一次</li><li>quick.brown.fox 不匹配任何绑定不会被任何队列接收到会被丢弃</li><li>quick.orange.male.rabbit 是四个单词不匹配任何绑定会被丢弃</li><li>lazy.orange.male.rabbit 是四个单词但匹配 Q2</li></ul></li><li>当队列绑定关系是下列这种情况时需要引起注意：<ul><li><strong>当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像 fanout 了</strong></li><li><strong>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了</strong></li></ul></li></ul><h3 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h3><ul><li><p>交换机的绑定关系如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116103417491.png" alt="image-20221116103417491"></p></li><li><p>生产者发送消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLogTopic</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel()) &#123;</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Q1--&gt;绑定的是中间带 orange带3个单词的字符串(*.orange.*)</span></span><br><span class="line"><span class="comment"> * Q2--&gt;绑定的是最后一个单词是 rabbit的 3个单词(*.*.rabbit)和第一个单词是 lazy的多个单词(lazy.#)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;quick.orange.rabbit&quot;</span>,<span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;lazy.orange.elephant&quot;</span>,<span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;quick.orange.fox&quot;</span>,<span class="string">&quot;被队列 Q1 接收到&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;lazy.brown.fox&quot;</span>,<span class="string">&quot;被队列 Q2 接收到&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;lazy.pink.rabbit&quot;</span>,<span class="string">&quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;quick.brown.fox&quot;</span>,<span class="string">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;quick.orange.male.rabbit&quot;</span>,<span class="string">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class="line">bindingKeyMap.put(<span class="string">&quot;lazy.orange.male.rabbit&quot;</span>,<span class="string">&quot;是四个单词但匹配 Q2&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry: bindingKeyMap.entrySet())&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">bindingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME,bindingKey, <span class="literal">null</span>,</span><br><span class="line">message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic01</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"><span class="comment">//声明 Q1队列与绑定关系</span></span><br><span class="line">String queueName=<span class="string">&quot;Q1&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot; 接 收 队 列 :&quot;</span>+queueName+<span class="string">&quot; 绑 定键:&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="string">&quot;,消息:&quot;</span>+message);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic02</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line"><span class="comment">//声明 Q2队列与绑定关系</span></span><br><span class="line">String queueName=<span class="string">&quot;Q2&quot;</span>;</span><br><span class="line">channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot; 接 收 队 列 :&quot;</span>+queueName+<span class="string">&quot; 绑 定键:&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="string">&quot;,消息:&quot;</span>+message);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Header-Exchange-标题-x2F-首部交换机"><a href="#Header-Exchange-标题-x2F-首部交换机" class="headerlink" title="Header Exchange(标题&#x2F;首部交换机)"></a>Header Exchange(标题&#x2F;首部交换机)</h2><ul><li><strong>首部交换机是忽略<code>routing_key</code>的一种路由方式</strong>。路由器和交换机<strong>路由的规则是通过<code>Headers</code>信息来交换的</strong>，这个有点像<code>HTTP</code>的<code>Headers</code>。<strong>将一个交换机声明成首部交换机，绑定一个队列的时候，定义一个<code>Hash</code>的数据结构，消息发送的时候，会携带一组hash数据结构的信息，当<code>Hash</code>的内容匹配上的时候，消息就会被写入队列</strong>。</li><li>绑定交换机和队列的时候，Hash结构中要求携带一个键<strong>“x-match”</strong>，这个键的<code>Value</code>可以是<code>any</code>或者<code>all</code>，这代表消息携带的<code>Hash</code>是需要<strong>全部匹配</strong>(all)，还是<strong>仅匹配一个键</strong>(any)就可以了。**相比直连交换机，首部交换机的优势是匹配的规则不被限定为字符串(string)**。</li></ul><h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><h2 id="死信的概念"><a href="#死信的概念" class="headerlink" title="死信的概念"></a>死信的概念</h2><ul><li>先从概念解释上搞清楚这个定义，<strong>死信，顾名思义就是无法被消费的消息，字面意思可以这样理解</strong>，一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息进行消费，但<strong>某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列</strong>。</li><li>应用场景:<strong>为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中</strong>.还有比如说: <strong>用户在商城下单成功并点击去支付后在指定时间未支付时自动失效</strong>。</li></ul><h2 id="死信的来源"><a href="#死信的来源" class="headerlink" title="死信的来源"></a>死信的来源</h2><ol><li><strong>消息 TTL 过期</strong></li><li><strong>队列达到最大长度</strong>(队列满了，无法再添加数据到 mq 中)</li><li><strong>消息被拒绝(basic.reject 或 basic.nack)并且 requeue&#x3D;false</strong>.</li></ol><h2 id="死信实战"><a href="#死信实战" class="headerlink" title="死信实战"></a>死信实战</h2><h3 id="代码架构图"><a href="#代码架构图" class="headerlink" title="代码架构图"></a>代码架构图</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117110145349.png" alt="image-20221117110145349"></p><p>需要手动给队列配置它的死信队列。</p><h3 id="消息TTL过期造成的死信"><a href="#消息TTL过期造成的死信" class="headerlink" title="消息TTL过期造成的死信"></a>消息TTL过期造成的死信</h3><ul><li><p>主要是<strong>发送消息的时候给消息设置TTL时间，然后发送到队列中，将对应的消费者关闭以模拟消费者无法消费队列中的消息的场景，然后TTL到期后，相关消息就会被送到和当前队列绑定的死信队列中，被死信队列的消费者消费掉</strong>。</p></li><li><p>生产者代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">channel.exchangeDeclare(NORMAL_EXCHANGE,BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="comment">//设置消息的 TTL时间</span></span><br><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">AMQP</span>.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line"><span class="comment">//该信息是用作演示队列个数限制</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">11</span> ; i++) &#123;</span><br><span class="line">String message=<span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, properties,message.getBytes());</span><br><span class="line">System.out.println(<span class="string">&quot;生产者发送消息:&quot;</span>+message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消费者C1代码（启动之后关闭该消费者，模拟其接收不到消息的情况）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line"><span class="comment">//普通交换机名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"><span class="comment">//死信交换机名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line"><span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="comment">//声明死信队列</span></span><br><span class="line"><span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//死信队列绑定死信交换机与 routingkey</span></span><br><span class="line">channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"><span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//正常队列设置死信交换机 参数 key是固定值</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line"><span class="comment">//正常队列设置死信 routing-key参数 key是固定值</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">normalQueue</span> <span class="operator">=</span> <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">channel.queueDeclare(normalQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span>+message);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(normalQueue, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117110757546.png" alt="image-20221117110757546"></p></li><li><p>消费者C2代码（以上步骤完成后，启动C2消费者，它消费死信队列里面的信息）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer02</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收死信队列消息.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Consumer02 接收死信队列的消息&quot;</span> + message);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(deadQueue, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117111130151.png" alt="image-20221117111130151"></p></li></ul><h3 id="队列达到最大长度造成死信"><a href="#队列达到最大长度造成死信" class="headerlink" title="队列达到最大长度造成死信"></a>队列达到最大长度造成死信</h3><ul><li><p>也是<strong>通过关闭消费者来模拟消费者无法消费队列中的消息，然后队列中的消息越来越多，最后达到队列所能存储消息的上限，多余的消息就会被送到死信队列中</strong>。</p></li><li><p>上面消息生产者的代码去掉设置消息的TTL这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">             <span class="comment">//该信息是用作演示队列个数限制</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">11</span> ; i++) &#123;</span><br><span class="line">String message=<span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">channel.basicPublish(NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>,<span class="literal">null</span>, message.getBytes());</span><br><span class="line">System.out.println(<span class="string">&quot;生产者发送消息:&quot;</span>+message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C1 消费者修改以下代码(启动之后关闭该消费者 模拟其接收不到消息)：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117112737502.png" alt="image-20221117112737502"></p><p>需要手动删除之前的队列以更新队列的配置。</p></li><li><p>C2 消费者代码不变(启动 C2 消费者)：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117112840830.png" alt="image-20221117112840830"></p></li></ul><h3 id="消息被拒造成的死信"><a href="#消息被拒造成的死信" class="headerlink" title="消息被拒造成的死信"></a>消息被拒造成的死信</h3><ul><li><p>通过<strong>手动让消费者拒绝消息来模拟消息在消费的时候被拒绝的情景，被拒绝的消息会进入死信队列中</strong>。</p></li><li><p>消息生产者代码同上生产者一致</p></li><li><p>C1 消费者代码(手动拒绝消息 模拟其拒绝消息)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line"><span class="comment">//普通交换机名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line"><span class="comment">//死信交换机名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line"><span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line"><span class="comment">//声明死信队列</span></span><br><span class="line"><span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"><span class="comment">//死信队列绑定死信交换机与 routingkey</span></span><br><span class="line">channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"><span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//正常队列设置死信交换机 参数 key是固定值</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line"><span class="comment">//正常队列设置死信 routing-key参数 key是固定值</span></span><br><span class="line">params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">normalQueue</span> <span class="operator">=</span> <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">channel.queueDeclare(normalQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line"><span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(message.equals(<span class="string">&quot;info5&quot;</span>))&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message + <span class="string">&quot;并拒绝签收该消息&quot;</span>);</span><br><span class="line"><span class="comment">//requeue设置为 false代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中</span></span><br><span class="line">channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span>+message);</span><br><span class="line">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">channel.basicConsume(normalQueue, autoAck, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117113216967.png" alt="image-20221117113216967"></p></li><li><p>C2消费者代码不变。启动消费者1然后再启动消费者2：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117113300286.png" alt="image-20221117113300286"></p></li></ul><h1 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1><h2 id="延迟队列概念"><a href="#延迟队列概念" class="headerlink" title="延迟队列概念"></a>延迟队列概念</h2><ul><li>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</li></ul><h2 id="延迟队列使用场景"><a href="#延迟队列使用场景" class="headerlink" title="延迟队列使用场景"></a>延迟队列使用场景</h2><ol><li>订单在十分钟之内未支付则自动取消</li><li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</li><li>用户注册成功后，如果三天内没有登陆则进行短信提醒。</li><li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。</li><li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li></ol><ul><li><p>这些场景都有一个特点，<strong>需要在某个事件发生之后或者之前的指定时间点完成某一项任务</strong>，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求，如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118093518414.png" alt="image-20221118093518414"></p></li></ul><h2 id="RabbitMQ中的TTL"><a href="#RabbitMQ中的TTL" class="headerlink" title="RabbitMQ中的TTL"></a>RabbitMQ中的TTL</h2><ul><li>TTL 是什么呢？<strong>TTL就是Time To Live生存时间</strong>，TTL 是 RabbitMQ 中一个消息或者队列的属性，<strong>表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒</strong>。换句话说，<strong>如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为”死信”<strong>。如果</strong>同时配置了队列的 TTL 和消息的TTL，那么较小的那个值将会被使用</strong>，有两种方式设置 TTL。</li></ul><h3 id="队列设置TTL"><a href="#队列设置TTL" class="headerlink" title="队列设置TTL"></a>队列设置TTL</h3><ul><li><p>第一种是在创建队列的时候设置队列的“x-message-ttl”属性：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118093824706.png" alt="image-20221118093824706"></p></li></ul><h3 id="消息设置TTL"><a href="#消息设置TTL" class="headerlink" title="消息设置TTL"></a>消息设置TTL</h3><ul><li><p>另一种方式便是针对每条消息设置 TTL：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118093848655.png" alt="image-20221118093848655"></p></li></ul><h3 id="两种设置TTL方式的区别"><a href="#两种设置TTL方式的区别" class="headerlink" title="两种设置TTL方式的区别"></a>两种设置TTL方式的区别</h3><ul><li><strong>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)<strong>，而</strong>如果设置消息的TTL，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的（也就是说如果设置了消息的TTL，只有该消息将要被消费者消费的时候会检查一遍TTL，别的时间不检查TTL），如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间（因为消息始终没有将被消费者消费，所以它们的TTL一直得不到检查）</strong>；另外，还需要注意的一点是，<strong>如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃</strong>。</li><li>前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，<strong>TTL 则刚好能让消息在延迟多久之后成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息</strong>。</li></ul><h2 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118095817073.png" alt="image-20221118095817073"></p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--RabbitMQ依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--RabbitMQ测试依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">182.92.234.71</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure><h3 id="添加Swagger配置类"><a href="#添加Swagger配置类" class="headerlink" title="添加Swagger配置类"></a>添加Swagger配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Docket <span class="title function_">webApiConfig</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">.groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">.apiInfo(webApiInfo())</span><br><span class="line">.select()</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> ApiInfo <span class="title function_">webApiInfo</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">.title(<span class="string">&quot;rabbitmq 接口文档&quot;</span>)</span><br><span class="line">.description(<span class="string">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)</span><br><span class="line">.version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">.contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;enjoy6288&quot;</span>, <span class="string">&quot;http://atguigu.com&quot;</span>,<span class="string">&quot;1551388580@qq.com&quot;</span>))</span><br><span class="line">.build();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过设置队列的TTL实现延迟队列"><a href="#通过设置队列的TTL实现延迟队列" class="headerlink" title="通过设置队列的TTL实现延迟队列"></a>通过设置队列的TTL实现延迟队列</h2><h3 id="代码架构图-1"><a href="#代码架构图-1" class="headerlink" title="代码架构图"></a>代码架构图</h3><ul><li><p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118100311986.png" alt="image-20221118100311986"></p></li></ul><h3 id="配置文件类代码"><a href="#配置文件类代码" class="headerlink" title="配置文件类代码"></a>配置文件类代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlQueueConfig</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">X_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_A</span> <span class="operator">=</span> <span class="string">&quot;QA&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_B</span> <span class="operator">=</span> <span class="string">&quot;QB&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;QD&quot;</span>;</span><br><span class="line"><span class="comment">//声明 xExchange</span></span><br><span class="line"><span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">xExchange</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(X_EXCHANGE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明 xExchange</span></span><br><span class="line"><span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">yExchange</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明队列 A ttl 为 10s 并绑定到对应的死信交换机</span></span><br><span class="line"><span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line"><span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line"><span class="comment">//声明队列的 TTL</span></span><br><span class="line">args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明队列 A 绑定 X 交换机</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">queueaBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明队列 B ttl为 40s并绑定到对应的死信交换机</span></span><br><span class="line"><span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line"><span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line"><span class="comment">//声明队列的 TTL</span></span><br><span class="line">args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">40000</span>);</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(args).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明队列 B 绑定 X 交换机</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">queuebBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queue1B,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queue1B).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明死信队列 QD</span></span><br><span class="line"><span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queueD</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DEAD_LETTER_QUEUE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明死信队列 QD 绑定关系</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">deadLetterBindingQAD</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,<span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息生产者代码"><a href="#消息生产者代码" class="headerlink" title="消息生产者代码"></a>消息生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ttl&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMsgController</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="meta">@GetMapping(&quot;sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条信息给两个 TTL 队列:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), message);</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot;消息来自 ttl 为 10S 的队列: &quot;</span>+message);</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;消息来自 ttl 为 40S 的队列: &quot;</span>+message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息消费者代码"><a href="#消息消费者代码" class="headerlink" title="消息消费者代码"></a>消息消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterQueueConsumer</span> &#123;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到死信队列信息&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li><p>发起一个请求 <a href="http://localhost:8080/ttl/sendMsg/%E5%98%BB%E5%98%BB%E5%98%BB%EF%BC%9A">http://localhost:8080/ttl/sendMsg/嘻嘻嘻：</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118101038315.png" alt="image-20221118101038315"></p></li><li><p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息，然后被消费掉，这样一个延时队列就打造完成了。</p></li><li><p>不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p></li><li><p>问题在于<strong>无法很方便地添加处理新的延时长度的解决方案</strong>。</p></li></ul><h2 id="通过设置消息的TTL实现延迟队列"><a href="#通过设置消息的TTL实现延迟队列" class="headerlink" title="通过设置消息的TTL实现延迟队列"></a>通过设置消息的TTL实现延迟队列</h2><h3 id="代码架构图-2"><a href="#代码架构图-2" class="headerlink" title="代码架构图"></a>代码架构图</h3><ul><li><p>在这里新增了一个队列QC，绑定关系如下，该队列不设置TTL时间：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118101405136.png" alt="image-20221118101405136"></p></li></ul><h3 id="配置文件类代码-1"><a href="#配置文件类代码-1" class="headerlink" title="配置文件类代码"></a>配置文件类代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgTtlQueueConfig</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_C</span> <span class="operator">=</span> <span class="string">&quot;QC&quot;</span>;</span><br><span class="line"><span class="comment">//声明队列 C 死信交换机</span></span><br><span class="line"><span class="meta">@Bean(&quot;queueC&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span>&#123;</span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line"><span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line"><span class="comment">//没有声明 TTL属性</span></span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(args).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明队列 B 绑定 X 交换机</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">queuecBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息生产者代码-1"><a href="#消息生产者代码-1" class="headerlink" title="消息生产者代码"></a>消息生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message,<span class="meta">@PathVariable</span> String ttlTime)</span> &#123;</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, message, correlationData -&gt;&#123;</span><br><span class="line">correlationData.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line"><span class="keyword">return</span> correlationData;</span><br><span class="line">&#125;);</span><br><span class="line">log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒 TTL 信息给队列 C:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(),ttlTime, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><ul><li><p>发起请求<br><a href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendExpirationMsg/你好</a> 1&#x2F;20000<br><a href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendExpirationMsg/你好</a> 2&#x2F;2000</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118101718111.png" alt="image-20221118101718111"></p></li><li><p>看起来似乎没什么问题，但是在最开始的时候，就介绍过<strong>如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“，因为 RabbitMQ 只会检查第一个消息是否过期</strong>，如果过期则丢到死信队列，如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。</p></li><li><p>问题在于<strong>无法保证检查各消息TTL的并行性，也就是无法保证各消息按时死亡</strong>。</p></li></ul><h2 id="Rabbitmq插件实现延迟队列解决上述问题"><a href="#Rabbitmq插件实现延迟队列解决上述问题" class="headerlink" title="Rabbitmq插件实现延迟队列解决上述问题"></a>Rabbitmq插件实现延迟队列解决上述问题</h2><ul><li>上文中两种实现方式提到的问题，确实是我们需要去解决的，<strong>如果不能实现在消息粒度上的 TTL，并使其在设置的 TTL 时间及时死亡，就无法设计成一个通用的延时队列</strong>。那如何解决呢，接下来我们就去解决该问题。</li></ul><h3 id="安装延时队列插件"><a href="#安装延时队列插件" class="headerlink" title="安装延时队列插件"></a>安装延时队列插件</h3><ul><li><p>在官网上下载 <a href="https://www.rabbitmq.com/community-plugins.html%EF%BC%8C%E4%B8%8B%E8%BD%BD">https://www.rabbitmq.com/community-plugins.html，下载</a><br><strong>rabbitmq_delayed_message_exchange</strong>插件，然后解压放置到 RabbitMQ 的plugins目录。</p></li><li><p>进入 RabbitMQ 的安装目录下的 <strong>plgins 目录</strong>，<strong>执行下面命令让该插件生效</strong>，然后<strong>重启RabbitMQ</strong>：<strong>rabbitmq-plugins enable rabbitmq_delayed_message_exchange</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118103039084.png" alt="image-20221118103039084"></p></li><li><p>在RabbitMQ的图形化界面中查看插件的安装情况：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118103116179.png" alt="image-20221118103116179"></p></li></ul><h3 id="代码架构图-3"><a href="#代码架构图-3" class="headerlink" title="代码架构图"></a>代码架构图</h3><ul><li><p>在这里新增了一个队列 delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118103144304.png" alt="image-20221118103144304"></p></li><li><p>确实比之前的方案简洁了不少。</p></li></ul><h3 id="配置文件类代码-2"><a href="#配置文件类代码-2" class="headerlink" title="配置文件类代码"></a>配置文件类代码</h3><ul><li><p>主要是<strong>通过设置交换机的类型为我们新安装的那个插件的类型来让交换机实现延时投递消息的功能</strong>。</p></li><li><p>在我们自定义的交换机中，这是一种新的交换类型，<strong>该类型消息支持延迟投递机制 消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayedQueueConfig</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DELAYED_QUEUE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义交换机 我们在这里定义的是一个延迟交换机</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CustomExchange <span class="title function_">delayedExchange</span><span class="params">()</span> &#123;</span><br><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//自定义交换机的类型</span></span><br><span class="line">args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>,args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bindingDelayedQueue</span><span class="params">(<span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue queue,<span class="meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="消息生产者代码-2"><a href="#消息生产者代码-2" class="headerlink" title="消息生产者代码"></a>消息生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line"><span class="meta">@GetMapping(&quot;sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message,<span class="meta">@PathVariable</span> Integer delayTime)</span> &#123;</span><br><span class="line">rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message,correlationData -&gt;&#123;</span><br><span class="line">    correlationData.getMessageProperties().setDelay(delayTime);</span><br><span class="line"><span class="keyword">return</span> correlationData;</span><br><span class="line">&#125;);</span><br><span class="line">log.info(<span class="string">&quot; 当 前 时 间 ： &#123;&#125;, 发 送 一 条 延 迟 &#123;&#125; 毫 秒 的 信 息 给 队 列 delayed.queue:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(),delayTime, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息消费者代码-1"><a href="#消息消费者代码-1" class="headerlink" title="消息消费者代码"></a>消息消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line"><span class="meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDelayedQueue</span><span class="params">(Message message)</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到延时队列的消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><ul><li><p>发起请求：</p><p><a href="http://localhost:8080/ttl/sendDelayMsg/come">http://localhost:8080/ttl/sendDelayMsg/come</a> on baby1&#x2F;20000<br><a href="http://localhost:8080/ttl/sendDelayMsg/come">http://localhost:8080/ttl/sendDelayMsg/come</a> on baby2&#x2F;2000</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118105503523.png" alt="image-20221118105503523"></p></li><li><p>第二个消息被先消费掉了，符合预期</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>延时队列在需要延时处理的场景下非常有用，<strong>使用 RabbitMQ 来实现延时队列可以很好的利用RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃</strong>。另外，<strong>通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失</strong>。</li><li>当然，延时队列还有很多其它选择，比如利用<strong>Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮</strong>，这些方式各有特点,看需要适用的场景</li></ul><h1 id="发布确认高级"><a href="#发布确认高级" class="headerlink" title="发布确认高级"></a>发布确认高级</h1><ul><li><p>在生产环境中<strong>由于一些不明原因，导致 rabbitmq 重启，在RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复</strong>。于是，我们开始思考，<strong>如何才能进行 RabbitMQ 的消息可靠投递呢</strong>？特别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">应 用 [xxx] 在 [08-1516:36:04] 发 生 [ 错 误 日 志 异 常 ] ， alertId=[xxx] 。 </span><br><span class="line">由[org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:620] 触 发 。</span><br><span class="line">应用 xxx 可能原因如下</span><br><span class="line">服 务 名 为 ：</span><br><span class="line">异 常 为 ： org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:620,</span><br><span class="line">产 生 原 因 如 下 :1.org.springframework.amqp.rabbit.listener.QueuesNotAvailableException:</span><br><span class="line">Cannot prepare queue for listener. Either the queue doesn&#x27;t exist or the broker will not</span><br><span class="line">allow us to use it.||Consumer received fatal=false exception on startup:</span><br></pre></td></tr></table></figure></li></ul><h2 id="发布确认的SpringBoot版本"><a href="#发布确认的SpringBoot版本" class="headerlink" title="发布确认的SpringBoot版本"></a>发布确认的SpringBoot版本</h2><ul><li>针对上面的问题我们通常<strong>采用消息的发布确认模式，并且设置缓存，可以尽可能保证消息的可靠传递</strong>。</li></ul><h3 id="确认机制方案"><a href="#确认机制方案" class="headerlink" title="确认机制方案"></a>确认机制方案</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121165323942.png" alt="image-20221121165323942"></p><h3 id="代码架构图-4"><a href="#代码架构图-4" class="headerlink" title="代码架构图"></a>代码架构图</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121165344609.png" alt="image-20221121165344609"></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li><p>在配置文件当中需要添加<strong>spring.rabbitmq.publisher-confirm-type&#x3D;correlated</strong></p><p>后面的值可以换不同的，有不同的效果：</p><p><strong>none</strong>：禁用发布确认模式，是默认值</p><p><strong>correlated</strong>：发布消息成功到交换机后会出发回调方法</p><p><strong>simple</strong>：经测试有两种效果，其一效果和correlated值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法<br>等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是<br>waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">182.92.234.71</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>=<span class="string">123</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="添加配置类"><a href="#添加配置类" class="headerlink" title="添加配置类"></a>添加配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line"><span class="comment">//声明业务 Exchange</span></span><br><span class="line"><span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明确认队列</span></span><br><span class="line"><span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明确认队列绑定关系</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">queueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息生产者-1"><a href="#消息生产者-1" class="headerlink" title="消息生产者"></a>消息生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyCallBack myCallBack;</span><br><span class="line"><span class="comment">//依赖注入 rabbitTemplate 之后再设置它的回调对象</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">rabbitTemplate.setConfirmCallback(myCallBack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;sendMessage/&#123;message&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line"><span class="comment">//指定消息 id为 1</span></span><br><span class="line">CorrelationData correlationData1=<span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">String routingKey=<span class="string">&quot;key1&quot;</span>;</span><br><span class="line">rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME,routingKey,message+routingKey,correlationData1);</span><br><span class="line">CorrelationData correlationData2=<span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">routingKey=<span class="string">&quot;key2&quot;</span>;</span><br><span class="line">rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME,routingKey,message+routingKey,correlationData2);</span><br><span class="line">log.info(<span class="string">&quot;发送消息内容:&#123;&#125;&quot;</span>,message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回调接口"><a href="#回调接口" class="headerlink" title="回调接口"></a>回调接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换机不管是否收到消息的一个回调方法</span></span><br><span class="line"><span class="comment"> * CorrelationData 消息相关数据</span></span><br><span class="line"><span class="comment"> * ack 交换机是否收到消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">String id=correlationData!=<span class="literal">null</span>?correlationData.getId():<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(ack)&#123;</span><br><span class="line">log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>,id);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>,id,cause);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息消费者-1"><a href="#消息消费者-1" class="headerlink" title="消息消费者"></a>消息消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConsumer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line"><span class="meta">@RabbitListener(queues =CONFIRM_QUEUE_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">String msg=<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">log.info(<span class="string">&quot;接受到队列 confirm.queue 消息:&#123;&#125;&quot;</span>,msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121185348719.png" alt="image-20221121185348719"></p><ul><li>可以看到，发送了两条消息，第一条消息的 RoutingKey 为 “key1”，第二条消息的 RoutingKey 为”key2”，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。</li></ul><h2 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h2><h3 id="Mandatory参数"><a href="#Mandatory参数" class="headerlink" title="Mandatory参数"></a>Mandatory参数</h3><ul><li>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</li></ul><h3 id="消息生产者代码-3"><a href="#消息生产者代码-3" class="headerlink" title="消息生产者代码"></a>消息生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageProducer</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback ,</span><br><span class="line">RabbitTemplate.ReturnCallback &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"><span class="comment">//rabbitTemplate 注入之后就设置该值</span></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * true：交换机无法将消息进行路由时，会将该消息返回给生产者</span></span><br><span class="line"><span class="comment"> * false：如果发现消息无法进行路由，则直接丢弃</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">rabbitTemplate.setMandatory(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//设置回退消息交给谁处理</span></span><br><span class="line">rabbitTemplate.setReturnCallback(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@GetMapping(&quot;sendMessage&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span>&#123;</span><br><span class="line"><span class="comment">//让消息绑定一个 id值</span></span><br><span class="line"><span class="type">CorrelationData</span> <span class="variable">correlationData1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;confirm.exchange&quot;</span>,<span class="string">&quot;key1&quot;</span>,message+<span class="string">&quot;key1&quot;</span>,correlationData1);</span><br><span class="line">log.info(<span class="string">&quot;发送消息 id 为:&#123;&#125;内容为&#123;&#125;&quot;</span>,correlationData1.getId(),message+<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"><span class="type">CorrelationData</span> <span class="variable">correlationData2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;confirm.exchange&quot;</span>,<span class="string">&quot;key2&quot;</span>,message+<span class="string">&quot;key2&quot;</span>,correlationData2);</span><br><span class="line">log.info(<span class="string">&quot;发送消息 id 为:&#123;&#125;内容为&#123;&#125;&quot;</span>,correlationData2.getId(),message+<span class="string">&quot;key2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (ack) &#123;</span><br><span class="line">log.info(<span class="string">&quot;交换机收到消息确认成功, id:&#123;&#125;&quot;</span>, id);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.error(<span class="string">&quot;消息 id:&#123;&#125;未成功投递到交换机,原因是:&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class="line">log.info(<span class="string">&quot;消息:&#123;&#125;被服务器退回，退回原因:&#123;&#125;, 交换机是:&#123;&#125;, 路由 key:&#123;&#125;&quot;</span>,</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()),replyText, exchange, routingKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回调接口-1"><a href="#回调接口-1" class="headerlink" title="回调接口"></a>回调接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span></span><br><span class="line"><span class="title class_">RabbitTemplate</span>.ConfirmCallback,RabbitTemplate.ReturnCallback &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 交换机不管是否收到消息的一个回调方法</span></span><br><span class="line"><span class="comment"> * CorrelationData 消息相关数据</span></span><br><span class="line"><span class="comment">  * ack 交换机是否收到消息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">String id=correlationData!=<span class="literal">null</span>?correlationData.getId():<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(ack)&#123;</span><br><span class="line">log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>,id);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>,id,cause);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当消息无法路由的时候的回调方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class="line">log.error(<span class="string">&quot; 消 息 &#123;&#125;, 被 交 换 机 &#123;&#125; 退 回 ， 退 回 原 因 :&#123;&#125;, 路 由 key:&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()),exchange,replyText,routingKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121192233476.png" alt="image-20221121192233476"></p><h2 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h2><ul><li><strong>有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息无法被投递时发现并处理</strong>。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。什么是备份交换机呢？<strong>备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理</strong>，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进入这个队列了。当然，我们<strong>还可以建立一个报警队列，用独立的消费者来进行监测和报警</strong>。</li></ul><h3 id="代码架构图-5"><a href="#代码架构图-5" class="headerlink" title="代码架构图"></a>代码架构图</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121192654594.png" alt="image-20221121192654594"></p><h3 id="修改配置类"><a href="#修改配置类" class="headerlink" title="修改配置类"></a>修改配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;backup.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;backup.queue&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WARNING_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;warning.queue&quot;</span>;</span><br><span class="line"><span class="comment">//声明确认队列</span></span><br><span class="line"><span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明确认队列绑定关系</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">queueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明备份 Exchange</span></span><br><span class="line"><span class="meta">@Bean(&quot;backupExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> FanoutExchange <span class="title function_">backupExchange</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(BACKUP_EXCHANGE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明确认 Exchange 交换机的备份交换机</span></span><br><span class="line"><span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">ExchangeBuilder</span> <span class="variable">exchangeBuilder</span> <span class="operator">=</span> </span><br><span class="line">           ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME).durable(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">//设置该交换机的备份交换机</span></span><br><span class="line">.withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME);</span><br><span class="line"><span class="keyword">return</span> (DirectExchange)exchangeBuilder.build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明警告队列</span></span><br><span class="line"><span class="meta">@Bean(&quot;warningQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">warningQueue</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明报警队列绑定关系</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">warningBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明备份队列</span></span><br><span class="line"><span class="meta">@Bean(&quot;backQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">backQueue</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明备份队列绑定关系</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">backupBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;backQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="报警消费者"><a href="#报警消费者" class="headerlink" title="报警消费者"></a>报警消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarningConsumer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WARNING_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;warning.queue&quot;</span>;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = WARNING_QUEUE_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveWarningMsg</span><span class="params">(Message message)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">log.error(<span class="string">&quot;报警发现不可路由消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试注意事项"><a href="#测试注意事项" class="headerlink" title="测试注意事项"></a>测试注意事项</h3><ul><li><p><strong>重新启动项目的时候需要把原来的 confirm.exchange 删除因为我们修改了其绑定属性</strong>，不然报以下错:</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121193524288.png" alt="image-20221121193524288"></p></li></ul><h3 id="结果分析-2"><a href="#结果分析-2" class="headerlink" title="结果分析"></a>结果分析</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121193542021.png" alt="image-20221121193542021"></p><ul><li>mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是<strong>备份交换机优先级高</strong>。</li></ul><h1 id="RabbitMQ其他知识点"><a href="#RabbitMQ其他知识点" class="headerlink" title="RabbitMQ其他知识点"></a>RabbitMQ其他知识点</h1><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul><li><strong>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用</strong>。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等。</li></ul><h3 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h3><ul><li>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断，故 <strong>MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息</strong>。</li></ul><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><ul><li>MQ 消费者的幂等性的解决<strong>一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过</strong>。</li></ul><h3 id="消费端的幂等性保障"><a href="#消费端的幂等性保障" class="headerlink" title="消费端的幂等性保障"></a>消费端的幂等性保障</h3><ul><li>在海量订单生成的业务高峰期，<strong>生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性，这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息</strong>。业界主流的幂等性有两种操作:a.<strong>唯一 ID+指纹码机制,利用数据库主键去重</strong>, b.<strong>利用 redis 的原子性去实现</strong></li></ul><h3 id="唯一ID-指纹码机制"><a href="#唯一ID-指纹码机制" class="headerlink" title="唯一ID+指纹码机制"></a>唯一ID+指纹码机制</h3><ul><li><strong>指纹码:我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性</strong>，然后就<strong>利用查询语句进行判断这个 id 是否存在数据库中</strong>,<strong>优势就是实现简单就一个拼接，然后查询判断是否重复</strong>；<strong>劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能</strong>，但也不是我们最推荐的方式。</li></ul><h3 id="Redis原子性"><a href="#Redis原子性" class="headerlink" title="Redis原子性"></a>Redis原子性</h3><ul><li><strong>利用redis执行setnx命令，天然具有幂等性</strong>，从而实现不重复消费。</li></ul><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>在我们系统中有一个<strong>订单催付的场景</strong>，我们的客户在天猫下的订单,淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以<strong>订单量大了后采用 RabbitMQ 进行改造和优化,如果发现是大客户的订单就给一个相对比较高的优先级，否则就给默认优先级</strong>。</li></ul><h3 id="如何添加优先级"><a href="#如何添加优先级" class="headerlink" title="如何添加优先级"></a>如何添加优先级</h3><ul><li><p>可以<strong>在控制台页面给队列添加最大优先级属性</strong>，从而使队列变成优先级队列：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122121113089.png" alt="image-20221122121113089"></p></li><li><p>也可以在<strong>声明队列的代码中添加最大优先级属性</strong>从而让队列变成优先级队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122121153693.png" alt="image-20221122121153693"></p></li><li><p><strong>在生成消息的代码中添加优先级</strong>表示当前消息的优先级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br></pre></td></tr></table></figure></li><li><p>注意事项：要让队列实现优先级需要做的事情有如下事情：<strong>队列需要设置为优先级队列，消息需要设置消息的优先级，消费者需要等待消息已经发送到队列中才去消费</strong>，因为这样才有机会对消息进行排序</p></li></ul><h3 id="实战-2"><a href="#实战-2" class="headerlink" title="实战"></a>实战</h3><ul><li><p>消息生产者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();) &#123;</span><br><span class="line"><span class="comment">//给消息赋予一个 priority属性来表示当前消息的优先级</span></span><br><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">11</span>; i++) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>+i;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;发送消息完成:&quot;</span> + message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>消息消费者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU</span></span><br><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">System.out.println(<span class="string">&quot;消费者启动等待消费......&quot;</span>);</span><br><span class="line">DeliverCallback deliverCallback=(consumerTag, delivery)-&gt;&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">System.out.println(<span class="string">&quot;接收到消息:&quot;</span>+receivedMessage);</span><br><span class="line">&#125;;</span><br><span class="line">channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,(consumerTag)-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;消费者无法消费消息时调用，如队列被删除&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。<strong>惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储</strong>。当消费者<strong>由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了</strong>。</li><li><strong>默认情况（不使用惰性队列）下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者</strong>。即使是<strong>持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息</strong>。虽然 RabbitMQ 的开发者们一直在升级相关的算法，但是效果始终不太理想，尤其是在消息量特别大的时候。</li></ul><h3 id="队列的两种模式"><a href="#队列的两种模式" class="headerlink" title="队列的两种模式"></a>队列的两种模式</h3><ul><li><p><strong>队列具备两种模式：default 和 lazy</strong>。默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。<strong>lazy模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级</strong>。如果<strong>要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的</strong>。</p></li><li><p>在队列声明的时候<strong>可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”</strong>。下面示例中演示了一个惰性队列的声明细节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br></pre></td></tr></table></figure></li></ul><h3 id="内存开销对比"><a href="#内存开销对比" class="headerlink" title="内存开销对比"></a>内存开销对比</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122122542824.png" alt="image-20221122122542824"></p><ul><li>在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅占用 1.5MB，毕竟大部分数据全存到磁盘中了。</li></ul><h1 id="RabbitMQ集群"><a href="#RabbitMQ集群" class="headerlink" title="RabbitMQ集群"></a>RabbitMQ集群</h1><h2 id="clustering-使用集群"><a href="#clustering-使用集群" class="headerlink" title="clustering(使用集群)"></a>clustering(使用集群)</h2><h3 id="使用集群的原因"><a href="#使用集群的原因" class="headerlink" title="使用集群的原因"></a>使用集群的原因</h3><ul><li>最开始我们介绍了如何安装及运行 RabbitMQ 服务，不过这些是单机版的，无法满足目前真实应用的要求。如果 RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？单台 RabbitMQ服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要RabbitMQ 服务满足每秒 10 万条消息的吞吐量呢？<strong>购买昂贵的服务器来增强单机RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是解决实际问题的关键</strong>。</li></ul><h3 id="搭建步骤（三台机器）"><a href="#搭建步骤（三台机器）" class="headerlink" title="搭建步骤（三台机器）"></a>搭建步骤（三台机器）</h3><ol><li><p>使用命令<strong>vim &#x2F;etc&#x2F;hostname</strong>修改3台机器的主机名称，最好使用比较规范的命名方式，方便识别，这里将3台机器分别命名为node1、node2、node3。</p></li><li><p>使用命令<strong>vim &#x2F;etc&#x2F;hosts</strong>配置各个节点的hosts文件，让各个节点都能互相识别对方，<strong>把所有机器对应的ip和其对应机器的机器名组成的映射写到所有机器的hosts文件中</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122163145480.png" alt="image-20221122163145480"></p></li><li><p>在node1上执行远程操作命令：</p><p><strong>scp &#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie root@node2:&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie</strong></p><p><strong>scp &#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie root@node3:&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie</strong></p><p>以确保各个节点的cookie文件使用的是同一个值</p></li><li><p>启动RabbitMQ 服务,顺带启动 Erlang 虚拟机和 RbbitMQ 应用服务(在三台节点上分别执行以下命令)：<strong>rabbitmq-server -detached</strong></p></li><li><p>在节点2执行：</p><p><strong>rabbitmqctl stop_app</strong>（rabbitmqctl stop 会将Erlang 虚拟机和RabbitMQ服务一起关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务）</p><p><strong>rabbitmqctl reset</strong></p><p><strong>rabbitmqctl join_cluster rabbit@node1</strong></p><p><strong>rabbitmqctl start_app</strong>（只启动应用服务）</p></li><li><p>在节点3执行：</p><p><strong>rabbitmqctl stop_app</strong><br><strong>rabbitmqctl reset</strong><br><strong>rabbitmqctl join_cluster rabbit@node2</strong><br><strong>rabbitmqctl start_app</strong></p></li><li><p>查询集群状态：<strong>rabbitmqctl cluster_status</strong></p></li><li><p>需要重新设置集群的用户：</p><p>创建帐号：<strong>rabbitmqctl add_user admin 123</strong></p><p>设置用户角色：<strong>rabbitmqctl set_user_tags admin administrator</strong></p><p>设置用户权限：<strong>rabbitmqctl set_permissions -p “&#x2F;“ admin “.*“ “.*“ “.*“</strong></p></li><li><p>解除集群节点（node2和node3机器分别执行）：</p><p><strong>rabbitmqctl stop_app</strong><br><strong>rabbitmqctl reset</strong><br><strong>rabbitmqctl start_app</strong><br><strong>rabbitmqctl cluster_status</strong></p><p>在node1机器上执行：</p><p><strong>rabbitmqctl forget_cluster_node rabbit@node2</strong></p></li><li><p>总结一下就是：<strong>创建集群的时候需要重启从机并设置其归属主机；解除集群的时候需要重启从机以让从机忘掉主机，再在主机上执行对应的命令以让主机忘记从机</strong>。（集群中应该没有不对等的主从关系，这里使用主机从机只是为了表述归属关系）</p></li></ol><h2 id="镜像队列-Mirror-Queue"><a href="#镜像队列-Mirror-Queue" class="headerlink" title="镜像队列(Mirror Queue)"></a>镜像队列(Mirror Queue)</h2><h3 id="使用镜像队列的原因"><a href="#使用镜像队列的原因" class="headerlink" title="使用镜像队列的原因"></a>使用镜像队列的原因</h3><ul><li><strong>如果 RabbitMQ 集群中只有一个 Broker 节点，那么该节点的失效将导致整体服务的临时性不可用，并且也可能会导致消息的丢失</strong>。可以将所有消息都设置为持久化，并且对应队列的 durable 属性也设置为 true，但是这样仍然无法避免由于缓存导致的问题：因为<strong>消息在发送之后和被写入磁盘井执行刷盘动作之间存在一个短暂却会产生问题的时间窗</strong>。通过 publisher-confirm 机制能够确保客户端知道哪些消息己经存入磁盘，尽管如此，<strong>一般不希望遇到因单点故障导致的服务不可用</strong>。</li><li>引入镜像队列(Mirror Queue)的机制，<strong>可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性</strong>。</li></ul><h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol><li><p>启动三台集群节点</p></li><li><p>随便找一个节点添加policy，这个数字参数是配置在集群中队列镜像的个数：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122165327443.png" alt="image-20221122165327443"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122165539951.png" alt="image-20221122165539951"></p></li><li><p>在 node1 上创建一个队列发送一条消息，在node3中存在该队列的镜像队列：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122165658467.png" alt="image-20221122165658467"></p></li><li><p>停掉node1之后发现使用的队列变成了node3里的那个镜像队列，而node2中出现了另外一个镜像队列，说明无论何时，只要机器数量足够，那么一个队列总会有一个镜像队列：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122170014398.png" alt="image-20221122170014398"></p></li><li><p>就算整个集群只剩下一台机器了 依然能消费队列里面的消息，说明队列里面的消息被镜像队列传递到相应机器里面了</p></li></ol><h2 id="Haproxy-Keepalive实现高可用负载均衡"><a href="#Haproxy-Keepalive实现高可用负载均衡" class="headerlink" title="Haproxy+Keepalive实现高可用负载均衡"></a>Haproxy+Keepalive实现高可用负载均衡</h2><ul><li>用nginx好像也可以，都是用来做反向代理服务器的。</li></ul><h3 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122170143227.png" alt="image-20221122170143227"></p><h3 id="Haproxy实现负载均衡"><a href="#Haproxy实现负载均衡" class="headerlink" title="Haproxy实现负载均衡"></a>Haproxy实现负载均衡</h3><ul><li><strong>HAProxy 提供高可用性、负载均衡及基于 TCP-HTTP 应用的代理</strong>，支持虚拟主机，它是免费、快速并且可靠的一种解决方案，包括 Twitter,Reddit,StackOverflow,GitHub 在内的多家知名互联网公司在使用。<strong>HAProxy 实现了一种事件驱动、单一进程模型，此模型支持非常大的井发连接数</strong>。</li><li>扩展 nginx,lvs,haproxy 之间的区别: <a href="http://www.ha97.com/5646.html">http://www.ha97.com/5646.html</a></li></ul><h3 id="搭建步骤-1"><a href="#搭建步骤-1" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol><li><p>下载 haproxy(在 node1 和 node2)：<strong>yum -y install haproxy</strong></p></li><li><p>修改 node1 和 node2 的 haproxy.cfg：<strong>vim &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg</strong></p><p>需要修改红色部分的IP为当前机器的IP：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122170545602.png" alt="image-20221122170545602"></p></li><li><p>在两台机器上启动haproxy：</p><p><strong>haproxy -f &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg</strong></p><p><strong>ps -ef | grep haproxy</strong></p></li><li><p>访问地址：<strong><a href="http://10.211.55.71:8888/stats">http://10.211.55.71:8888/stats</a></strong></p></li></ol><h2 id="Keepalived实现双机-主备-热备-热备份"><a href="#Keepalived实现双机-主备-热备-热备份" class="headerlink" title="Keepalived实现双机(主备)热备(热备份)"></a>Keepalived实现双机(主备)热备(热备份)</h2><ul><li>试想如果前面配置的 HAProxy 主机突然宕机或者网卡失效，那么虽然 RbbitMQ 集群没有任何故障但是对于外界的客户端来说所有的连接都会被断开结果将是灾难性的，<strong>确保负载均衡服务的可靠性同样显得十分重要</strong>，这里就要引入<strong>Keepalived，它能够通过自身健康检查、资源接管功能做高可用(双机热备)，实现故障转移</strong>。</li></ul><h3 id="搭建步骤-2"><a href="#搭建步骤-2" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol><li>下载keepalived：<strong>yum -y install keepalived</strong></li><li>修改节点node1的配置文件：<strong>vim &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf</strong>，把资料里面的keepalived.conf修改之后替换</li><li>节点node2配置文件，需要修改global_defs的router_id，如nodeB；其次要修改 vrrp_instance_VI 中 state 为”BACKUP”；最后要将 priority 设置为小于 100 的值。</li><li>添加haproxy_chk.sh(为了<strong>防止 HAProxy 服务挂掉之后 Keepalived 还在正常工作而没有切换到 Backup 上，所以这里需要编写一个脚本来检测 HAProxy 务的状态,当 HAProxy 服务挂掉之后该脚本会自动重启HAProxy 的服务，如果不成功则关闭 Keepalived 服务，这样便可以切换到 Backup 继续工作</strong>)：<strong>vim &#x2F;etc&#x2F;keepalived&#x2F;haproxy_chk.sh(可以直接上传文件)<strong>，修改权限</strong>chmod 777 &#x2F;etc&#x2F;keepalived&#x2F;haproxy_chk.sh</strong></li><li>启动keepalive命令（node1和node2启动）：<strong>systemctl start keepalived</strong></li><li>观察 Keepalived 的日志：<strong>tail -f &#x2F;var&#x2F;log&#x2F;messages -n 200</strong></li><li>观察最新添加的vip：<strong>ip add show</strong></li><li>node1 模拟 keepalived 关闭状态：<strong>systemctl stop keepalived</strong></li><li>使用 vip 地址来访问 rabbitmq 集群</li></ol><h2 id="Federation-Exchange（联邦交换机）"><a href="#Federation-Exchange（联邦交换机）" class="headerlink" title="Federation Exchange（联邦交换机）"></a>Federation Exchange（联邦交换机）</h2><h3 id="使用它的原因"><a href="#使用它的原因" class="headerlink" title="使用它的原因"></a>使用它的原因</h3><ul><li><p><strong>(broker 北京)，(broker 深圳)彼此之间相距甚远，网络延迟是一个不得不面对的问题</strong>。有一个在北京的业务(Client 北京) 需要连接(broker 北京)，向其中的交换器 exchangeA 发送消息，此时的网络延迟很小，(Client 北京)可以迅速将消息发送至 exchangeA 中，就算在开启了 publisher-confirm 机制或者事务机制的情况下，也可以迅速收到确认信息。此时又有个在深圳的业务(Client 深圳)需要向 exchangeA 发送消息，那么**(Client 深圳) (broker 北京)之间有很大的网络延迟，(Client 深圳) 将发送消息至 exchangeA 会经历一定的延迟，尤其是在开启了 publisher-confirm 机制或者事务机制的情况下，(Client 深圳) 会等待很长的延迟时间来接收(broker 北京)的确认信息，进而必然造成这条发送线程的性能降低，甚至造成一定程度上的阻塞**。</p></li><li><p>将业务(Client 深圳)部署到北京的机房可以解决这个问题，但是如果(Client 深圳)调用的另些服务都部署在深圳，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么容灾又何以实现？这里<strong>使用 Federation 插件就可以很好地解决这个问题</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122181644954.png" alt="image-20221122181644954"></p></li></ul><h3 id="搭建步骤-3"><a href="#搭建步骤-3" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol><li><p>需要保证每台节点单独运行</p></li><li><p>在每台机器上开启federation相关插件：</p><p><strong>rabbitmq-plugins enable rabbitmq_federation</strong></p><p><strong>rabbitmq-plugins enable rabbitmq_federation_management</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122202128016.png" alt="image-20221122202128016"></p></li><li><p>原理图（先运行consumer在node2创建fed_exchange）：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122202308766.png" alt="image-20221122202308766"></p></li><li><p>在downstream（node2）配置upstream（node1）：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122202343393.png" alt="image-20221122202343393"></p></li><li><p>添加policy：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122202405537.png" alt="image-20221122202405537"></p></li><li><p>成功的前提是联邦交换机的state是running：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122202450382.png" alt="image-20221122202450382"></p></li></ol><h2 id="Federation-Queue（联邦队列）"><a href="#Federation-Queue（联邦队列）" class="headerlink" title="Federation Queue（联邦队列）"></a>Federation Queue（联邦队列）</h2><h3 id="使用它的原因-1"><a href="#使用它的原因-1" class="headerlink" title="使用它的原因"></a>使用它的原因</h3><ul><li><strong>联邦队列可以在多个 Broker 节点(或者集群)之间为单个队列提供均衡负载的功能</strong>。<strong>一个联邦队列可以连接一个或者多个上游队列(upstream queue)，并从这些上游队列中获取消息以满足本地消费者消费消息的需求</strong>。</li></ul><h3 id="搭建步骤-4"><a href="#搭建步骤-4" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol><li><p>原理图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122201858251.png" alt="image-20221122201858251"></p></li><li><p>添加upstream（同上）</p></li><li><p>添加policy：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122201931786.png" alt="image-20221122201931786"></p></li></ol><h2 id="Shovel"><a href="#Shovel" class="headerlink" title="Shovel"></a>Shovel</h2><h3 id="使用它的原因-2"><a href="#使用它的原因-2" class="headerlink" title="使用它的原因"></a>使用它的原因</h3><ul><li>Federation 具备的数据转发功能类似，<strong>Shovel 能够可靠、持续地从一个 Broker 中的队列(作为源端，即source)拉取数据并转发至另一个 Broker 中的交换器(作为目的端，即 destination)。作为源端的队列和作为目的端的交换器可以同时位于同一个 Broker，也可以位于不同的 Broker 上</strong>。Shovel 可以翻译为”铲子”，是一种比较形象的比喻，这个”铲子”可以将消息从一方”铲子”另一方。<strong>Shovel的行为就像优秀的客户端应用程序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理</strong>。</li></ul><h3 id="搭建步骤-5"><a href="#搭建步骤-5" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol><li><p>开启插件（需要的机器都开启）：</p><p><strong>rabbitmq-plugins enable rabbitmq_shovel</strong></p><p><strong>rabbitmq-plugins enable rabbitmq_shovel_management</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122201615713.png" alt="image-20221122201615713"></p></li><li><p>原理图（在源头发送的消息直接会进入到目的地队列）：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122201702271.png" alt="image-20221122201702271"></p></li><li><p>添加shovel源和目的地：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122201727815.png" alt="image-20221122201727815"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;MQ的相关概念&quot;&gt;&lt;a href=&quot;#MQ的相关概念&quot; class=&quot;headerlink&quot; title=&quot;MQ的相关概念&quot;&gt;&lt;/a&gt;MQ的相关概念&lt;/h1&gt;&lt;h2 id</summary>
      
    
    
    
    
    <category term="消息队列" scheme="https://konjacor.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="RabbitMQ" scheme="https://konjacor.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://konjacor.github.io/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://konjacor.github.io/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2022-10-17T01:38:45.000Z</published>
    <updated>2022-12-26T13:41:23.892Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="什么是计算机网络？"><a href="#什么是计算机网络？" class="headerlink" title="什么是计算机网络？"></a>什么是计算机网络？</h1><h2 id="计算机网络-x3D-通信技术-计算机技术"><a href="#计算机网络-x3D-通信技术-计算机技术" class="headerlink" title="计算机网络&#x3D;通信技术+计算机技术"></a>计算机网络&#x3D;通信技术+计算机技术</h2><ul><li><p>计算机网络是<strong>通信技术</strong>与<strong>计算机技术</strong>紧密结合的产物。</p></li><li><p>通信系统模型：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221110205335510.png" alt="image-20221110205335510"></p></li><li><p>计算机网络实际上<strong>就是一种通信网络</strong></p></li></ul><h2 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h2><ul><li><p>定义：计算机网络就是<strong>互连的、自治的计算机集合</strong>。</p><ul><li><strong>自治</strong>：无主从关系</li><li><strong>互连</strong>：互联互通</li></ul></li><li><p>通信链路举例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221110205557996.png" alt="image-20221110205557996"></p></li></ul><h2 id="主机之间距离远、数量大如何保证互连？"><a href="#主机之间距离远、数量大如何保证互连？" class="headerlink" title="主机之间距离远、数量大如何保证互连？"></a>主机之间距离远、数量大如何保证互连？</h2><ul><li><p>可以<strong>通过交换网络</strong>互连主机：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221110210012748.png" alt="image-20221110210012748"></p></li></ul><h2 id="什么是Internet？"><a href="#什么是Internet？" class="headerlink" title="什么是Internet？"></a>什么是Internet？</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>Internet就是因特网，是<strong>全球最大的互联网络</strong>，我们现在使用的网络其实就是Internet，如果<strong>用java的概念来理解的话，互联网就是一个接口，而Internet是互联网这个接口的实现</strong>。</li></ul><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><ul><li><p>Internet服务由<strong>因特网服务提供商（Internet server provider 简称 ISP）</strong>提供，而Internet实际上就是ISP提供的网络之间互相连接的网络，也就是<strong>网络之网络</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221110211710548.png" alt="image-20221110211710548"></p></li></ul><h3 id="从组成细节看"><a href="#从组成细节看" class="headerlink" title="从组成细节看"></a>从组成细节看</h3><ul><li>Internet<strong>是数以百万计的互连的计算设备集合</strong>：<ul><li><strong>主机</strong>（hosts） &#x3D; <strong>端系统</strong>（end systems）</li><li>在主机或者端系统上<strong>可以运行各种网络应用</strong></li></ul></li><li>Internet内的<strong>通信链路多种多样</strong>，可以是光纤、铜缆、无线电、卫星等</li><li>Internet内部采取<strong>分组交换的形式来传递信息</strong>，也就是<strong>通过路由器（routers）和交换机（switches）来对数据包进行分组转发</strong>。</li></ul><h3 id="从服务角度看"><a href="#从服务角度看" class="headerlink" title="从服务角度看"></a>从服务角度看</h3><ul><li>Internet<strong>为网络应用提供通信服务的通信基础设施</strong>：<ul><li>网络应用比如Web，VoIP，email，网络游戏，电子商务，社交网络，…</li></ul></li><li>为网络应用<strong>提供应用编程接口（API）</strong>：<ul><li>支持应用程序<strong>”连接“Internet，发送&#x2F;接收数据</strong>。</li><li>提供类似于邮政系统的<strong>数据传输服务</strong>。</li></ul></li></ul><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ul><li>仅有硬件（主机、链路、路由器……）连接，Internet能否顺畅运行？能保证应用数据有序交付吗？</li><li>答：很明显不能，还<strong>需要一些约束和规则才能让数据有序、完整、快速地交付</strong>，而这个约束和规则实际上就是<strong>网络协议</strong>，详细的之后会讲。</li></ul><h1 id="什么是网络协议？"><a href="#什么是网络协议？" class="headerlink" title="什么是网络协议？"></a>什么是网络协议？</h1><h2 id="协议是计算机网络有序运行的重要保证"><a href="#协议是计算机网络有序运行的重要保证" class="headerlink" title="协议是计算机网络有序运行的重要保证"></a>协议是计算机网络有序运行的重要保证</h2><ul><li>硬件（主机、路由器、通信链路等）是计算机网络的基础</li><li><strong>计算机网络中的数据交换必须遵守事先约定好的规则</strong>，就像是交通规则一样，每个交通工具就像是一组数据，而马路就是数据通信的线路，要想让交通流畅，就要制定一系列的交通规则来作为道路的通行规范，在这种规则的限定下，交通就会比较流畅，一旦出现交通事故，我们又需要遵循另外的规则来对交通事故进行处理以防止对之后的交通产生影响，就像数据传输出问题后我们需要采取一系列的措施来弥补产生的损失，这些行为都是被规定在相应协议中的。</li></ul><h2 id="任何通信或信息交换过程都需要规则"><a href="#任何通信或信息交换过程都需要规则" class="headerlink" title="任何通信或信息交换过程都需要规则"></a>任何通信或信息交换过程都需要规则</h2><h3 id="人类交谈"><a href="#人类交谈" class="headerlink" title="人类交谈"></a>人类交谈</h3><ul><li><p>我们在互相交谈的时候都是遵循一定的规则的，这样才能产生有效的交流，比如我问一个人今天天气怎么样，那个人回复我现在是11点50分，这样的交流实际上就是无效的，但是如果那个人遵循我询问的规则回答今天下小雨，那么这样的交流就是有效的，我可以从中获益。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221123122047986.png" alt="image-20221123122047986"></p></li></ul><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><ul><li><strong>在网络通信中，通信主体是“机器”而不是“人”在交换“电子化”或者“数字化”的消息</strong>，人在长时间的社会生活中，自然会懂得一些交流的规则，但是<strong>机器没有经过长时间的学习，因此我们不能指望机器可以不依靠任何东西就懂得交换数据的规则</strong>。</li><li>既然无法指望机器自己懂得交换数据的规则，那么就<strong>由我们人类给它们定义一些规则，并通过一系列的方式让机器遵守这些规则</strong>，这样在我们的帮助下，机器也就懂得如何进行数据交换了。</li><li><strong>计算机网络的通信过程必须遵守的某种&#x2F;些规则就是协议</strong></li><li><strong>不同的通信过程使用不同的协议，在计算机网络中，通信类型是多样的，所以通信协议也是多样的</strong>，我们<strong>应该根据具体的情况去选择最合适的协议来作为这种情况下数据交换的规则</strong>。</li></ul><h2 id="网络协议的定义"><a href="#网络协议的定义" class="headerlink" title="网络协议的定义"></a>网络协议的定义</h2><ul><li>网络协议(network protocol)，简称为协议，<strong>是为进行网络中的数据交换而建立的规则、标准或约定</strong>。</li><li><strong>协议规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到信息或发生的事件所采取的“动作”（actions）</strong>。</li></ul><h2 id="协议的三要素"><a href="#协议的三要素" class="headerlink" title="协议的三要素"></a>协议的三要素</h2><ol><li><strong>语法（Syntax）</strong>：规定了数据与控制信息的结构或格式以及信号电平等。</li><li><strong>语义（Semantics）</strong>：规定了需要发出何种控制信息、完成何种动作以及做出何种响应、如何进行差错控制等。</li><li><strong>时序（Timing）</strong>：规定了事件顺序、速度匹配等。</li></ol><h2 id="协议是计算机网络的重要内容"><a href="#协议是计算机网络的重要内容" class="headerlink" title="协议是计算机网络的重要内容"></a>协议是计算机网络的重要内容</h2><ul><li><p>协议规范了网络中所有信息发送和接收的过程。e.g., TCP, IP, HTTP, Skype, 802.11</p></li><li><p>协议是学习网络的重要内容之一</p></li><li><p>协议是网络创新的表现形式之一</p></li><li><p>Internet协议标准被IETF（互联网工程任务组 Internet Engineering Task </p><p>Force）规定在RFC（Request for Comments）文件中。</p></li></ul><h1 id="TCP协议及其版本迭代"><a href="#TCP协议及其版本迭代" class="headerlink" title="TCP协议及其版本迭代"></a>TCP协议及其版本迭代</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;什么是计算机网络？&quot;&gt;&lt;a href=&quot;#什么是计算机网络？&quot; class=&quot;headerlink&quot; title=&quot;什么是计算机网络？&quot;&gt;&lt;/a&gt;什么是计算机网络？&lt;/h</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="https://konjacor.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>五子棋网络游戏项目</title>
    <link href="https://konjacor.github.io/2022/10/16/%E4%BA%94%E5%AD%90%E6%A3%8B%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE/"/>
    <id>https://konjacor.github.io/2022/10/16/%E4%BA%94%E5%AD%90%E6%A3%8B%E7%BD%91%E7%BB%9C%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-10-16T12:17:39.000Z</published>
    <updated>2022-12-20T12:11:43.203Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>突然想试试不用框架来写一个几乎是纯java的C&#x2F;S架构软件了，也是想应用一下自己学的设计模式和计网相关的知识吧。</li><li>选了个比较好写的五子棋项目，准备写个客户端，写个服务端。</li></ul><h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><h2 id="搭建项目基本结构"><a href="#搭建项目基本结构" class="headerlink" title="搭建项目基本结构"></a>搭建项目基本结构</h2><ul><li>采用了一种比较规范的项目结构。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221017201229777.png" alt="image-20221017201229777"></p><h2 id="编写棋子实体"><a href="#编写棋子实体" class="headerlink" title="编写棋子实体"></a>编写棋子实体</h2><ul><li><p>先写抽象父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.five.entity.pawn.abs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 10:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Pawn</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> type;<span class="comment">//棋子类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Pawn</span><span class="params">(<span class="type">int</span> type)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getType</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再写子类，子类有黑棋子、白棋子还有一种用来表示没有棋子的空棋子，其中<strong>棋子均采用基于静态内部类实现的单例模式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************黑棋子*************************/</span></span><br><span class="line"><span class="keyword">package</span> com.konjacer.five.entity.pawn.sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.abs.Pawn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 10:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlackPawn</span> <span class="keyword">extends</span> <span class="title class_">Pawn</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private static volatile WhitePawn instance;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BlackPawn</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;<span class="comment">//利用静态内部类的加载特性实现线程安全和懒加载的单例模式</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BlackPawn</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlackPawn</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> BlackPawn <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BlackPawn.SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************白棋子*************************/</span></span><br><span class="line"><span class="keyword">package</span> com.konjacer.five.entity.pawn.sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.abs.Pawn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 10:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WhitePawn</span> <span class="keyword">extends</span> <span class="title class_">Pawn</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private static volatile WhitePawn instance;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">WhitePawn</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;<span class="comment">//利用静态内部类的加载特性实现线程安全和懒加载的单例模式</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">WhitePawn</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WhitePawn</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> WhitePawn <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/***********************空棋子*************************/</span></span><br><span class="line"><span class="keyword">package</span> com.konjacer.five.entity.pawn.sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.abs.Pawn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 11:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NullPawn</span> <span class="keyword">extends</span> <span class="title class_">Pawn</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private static volatile WhitePawn instance;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">NullPawn</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;<span class="comment">//利用静态内部类的加载特性实现线程安全和懒加载的单例模式</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">NullPawn</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NullPawn</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> NullPawn <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> NullPawn.SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编写棋子工厂"><a href="#编写棋子工厂" class="headerlink" title="编写棋子工厂"></a>编写棋子工厂</h2><ul><li><p>棋子工厂用来返回棋子实例，同样先需要一个抽象工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.five.factory.abs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.abs.Pawn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 11:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AbsPawnFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    Pawn <span class="title function_">getGoods</span><span class="params">(<span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后就是一个<strong>基于静态内部类实现单例模式的返回棋子实例的工厂</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.five.factory.sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.abs.Pawn;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.sub.BlackPawn;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.sub.NullPawn;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.sub.WhitePawn;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.factory.abs.AbsPawnFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 11:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PawnFactory</span> <span class="keyword">implements</span> <span class="title class_">AbsPawnFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">PawnFactory</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Pawn <span class="title function_">getGoods</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(type==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> NullPawn.getInstance();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> BlackPawn.getInstance();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> WhitePawn.getInstance();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">PawnFactory</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PawnFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> PawnFactory <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PawnFactory.SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编写胜利监视器"><a href="#编写胜利监视器" class="headerlink" title="编写胜利监视器"></a>编写胜利监视器</h2><ul><li><p>需要一个监视器来监视棋局是否胜利，<strong>监视器和棋盘是双分派关联的关系</strong>，监视器内有方法判定当前棋局是否胜利，每当棋盘中的棋发生了变化，都会通知监视器来判断当前棋局是否满足胜利条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.five.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.chessboard.abs.ChessBoard;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.pawn.abs.Pawn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-16 20:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckVictory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ChessBoard chessBoard;<span class="comment">//组合棋盘</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//private PawnFactory pawnFactory;//组合棋子工厂</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CheckVictory</span><span class="params">(ChessBoard chessBoard)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.chessBoard = chessBoard;</span><br><span class="line">        <span class="comment">//pawnFactory = PawnFactory.getInstance();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;<span class="comment">//判断刚下完的一步棋是否满足胜利条件</span></span><br><span class="line">        <span class="keyword">if</span>(((Pawn)(chessBoard.getElement(i,j))).getType()!=<span class="number">0</span>)&#123;<span class="comment">//如果当前位置不是空棋子，那就开始检查当前位置是否满足获胜条件</span></span><br><span class="line">            <span class="keyword">if</span>(checkRow(i,j) || checkColumn(i,j) || checkLeftDiagonal(i,j) || checkRightDiagonal(i,j))&#123;<span class="comment">//如果任何一个方向满足获胜条件，那就返回当前的棋子表示当前棋子类型胜利</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkRow</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> ((Pawn)(chessBoard.getElement(i,j))).getType();<span class="comment">//获取当前棋子类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//当前获胜路线上当前棋子类型的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> j-<span class="number">1</span>;<span class="comment">//通过cur遍历当前获胜路线上的棋子</span></span><br><span class="line">        <span class="keyword">while</span> (cur&gt;=<span class="number">0</span> &amp;&amp; ((Pawn)(chessBoard.getElement(i,cur))).getType()==type)&#123;<span class="comment">//向左检查</span></span><br><span class="line">            sum++;</span><br><span class="line">            cur--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否胜利</span></span><br><span class="line">        cur = j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur&lt;chessBoard.getColumn() &amp;&amp; ((Pawn)(chessBoard.getElement(i,cur))).getType()==type)&#123;<span class="comment">//向右检查</span></span><br><span class="line">            sum++;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否胜利</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkColumn</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> ((Pawn)(chessBoard.getElement(i,j))).getType();<span class="comment">//获取当前棋子类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//当前获胜路线上当前棋子类型的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> i-<span class="number">1</span>;<span class="comment">//通过cur遍历当前获胜路线上的棋子</span></span><br><span class="line">        <span class="keyword">while</span> (cur&gt;=<span class="number">0</span> &amp;&amp; ((Pawn)(chessBoard.getElement(cur,j))).getType()==type)&#123;<span class="comment">//向上检查</span></span><br><span class="line">            sum++;</span><br><span class="line">            cur--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否胜利</span></span><br><span class="line">        cur = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur&lt;chessBoard.getRow() &amp;&amp; ((Pawn)(chessBoard.getElement(cur,j))).getType()==type)&#123;<span class="comment">//向下检查</span></span><br><span class="line">            sum++;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否胜利</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkLeftDiagonal</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> ((Pawn)(chessBoard.getElement(i,j))).getType();<span class="comment">//获取当前棋子类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//当前获胜路线上当前棋子类型的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curi</span> <span class="operator">=</span> i-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curj</span> <span class="operator">=</span> j-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (curi&gt;=<span class="number">0</span> &amp;&amp; curj&gt;=<span class="number">0</span> &amp;&amp; ((Pawn)(chessBoard.getElement(curi,curj))).getType()==type)&#123;<span class="comment">//向左上检查</span></span><br><span class="line">            sum++;</span><br><span class="line">            curi--;</span><br><span class="line">            curj--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否胜利</span></span><br><span class="line">        curi = i+<span class="number">1</span>;</span><br><span class="line">        curj = j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (curi&lt;chessBoard.getRow() &amp;&amp; curj&lt;chessBoard.getColumn() &amp;&amp; ((Pawn)(chessBoard.getElement(curi,curj))).getType()==type)&#123;<span class="comment">//向右下检查</span></span><br><span class="line">            sum++;</span><br><span class="line">            curi++;</span><br><span class="line">            curj++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否胜利</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">checkRightDiagonal</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">type</span> <span class="operator">=</span> ((Pawn)(chessBoard.getElement(i,j))).getType();<span class="comment">//获取当前棋子类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//当前获胜路线上当前棋子类型的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curi</span> <span class="operator">=</span> i-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curj</span> <span class="operator">=</span> j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (curi&gt;=<span class="number">0</span> &amp;&amp; curj&lt;chessBoard.getColumn() &amp;&amp; ((Pawn)(chessBoard.getElement(curi,curj))).getType()==type)&#123;<span class="comment">//向右上检查</span></span><br><span class="line">            sum++;</span><br><span class="line">            curi--;</span><br><span class="line">            curj++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否胜利</span></span><br><span class="line">        curi = i+<span class="number">1</span>;</span><br><span class="line">        curj = j-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (curi&lt;chessBoard.getRow() &amp;&amp; curj&gt;=<span class="number">0</span> &amp;&amp; ((Pawn)(chessBoard.getElement(curi,curj))).getType()==type)&#123;<span class="comment">//向左下检查</span></span><br><span class="line">            sum++;</span><br><span class="line">            curi++;</span><br><span class="line">            curj--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;=<span class="number">5</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//判断是否胜利</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编写棋盘实体"><a href="#编写棋盘实体" class="headerlink" title="编写棋盘实体"></a>编写棋盘实体</h2><ul><li><p>五子棋是15x15的棋盘，所以用15x15的Object数组代表棋盘，和棋子一样，首先需要一个抽象父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.five.entity.chessboard.abs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-16 21:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ChessBoard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Object[][] board;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ChessBoard</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        board = <span class="keyword">new</span> <span class="title class_">Object</span>[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span>&#123;<span class="comment">//重置棋盘，这里给出了默认实现，子类有需要可以重写该方法，虽然不符合里氏替换原则，但是使用起来更加灵活</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;board.length;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;board[i].length;++j)&#123;</span><br><span class="line">                board[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getElement</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;<span class="comment">//返回指定位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> board[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRow</span><span class="params">()</span>&#123;<span class="comment">//返回行数</span></span><br><span class="line">        <span class="keyword">return</span> board.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getColumn</span><span class="params">()</span>&#123;<span class="comment">//返回列数</span></span><br><span class="line">        <span class="keyword">return</span> board[<span class="number">0</span>].length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后再写五子棋棋盘，它和胜利监视器是双分派的关联关系，和棋子工厂是组合的关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.five.entity.chessboard.sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.algorithm.CheckVictory;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.chessboard.abs.ChessBoard;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.factory.abs.AbsPawnFactory;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.factory.sub.PawnFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 10:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FiveChessBoard</span> <span class="keyword">extends</span> <span class="title class_">ChessBoard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">AbsPawnFactory</span> <span class="variable">pawnFactory</span> <span class="operator">=</span> PawnFactory.getInstance();<span class="comment">//棋子工厂</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CheckVictory checkVictory;<span class="comment">//组合胜利监听器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">curType</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//当前应该轮到谁下了，1是黑子，2是白子</span></span><br><span class="line"></span><br><span class="line">    FiveChessBoard()&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">15</span>,<span class="number">15</span>);</span><br><span class="line">        checkVictory = <span class="keyword">new</span> <span class="title class_">CheckVictory</span>(<span class="built_in">this</span>);<span class="comment">//双分派</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;board.length;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;board[i].length;++i)&#123;</span><br><span class="line">                board[i][j] = pawnFactory.getGoods(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">putBlack</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;<span class="comment">//放黑子，放完检查是否胜利</span></span><br><span class="line">        board[i][j] = pawnFactory.getGoods(<span class="number">1</span>);</span><br><span class="line">        curType = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> checkVictory.check(i,j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">putWhite</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;<span class="comment">//放白子，放完检查是否胜利</span></span><br><span class="line">        board[i][j] = pawnFactory.getGoods(<span class="number">2</span>);</span><br><span class="line">        curType = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> checkVictory.check(i,j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编写玩家实体"><a href="#编写玩家实体" class="headerlink" title="编写玩家实体"></a>编写玩家实体</h2><ul><li><p>编写抽象玩家类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.five.entity.player.abs;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 19:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写五子棋玩家类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.five.entity.player.sub;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.five.entity.player.abs.Player;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-17 19:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FivePlayer</span> <span class="keyword">extends</span> <span class="title class_">Player</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> roleType;<span class="comment">//角色执子，1为黑子，2为白子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FivePlayer</span><span class="params">(<span class="type">int</span> roleType)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.roleType = roleType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;突然想试试不用框架来写一个几乎是纯</summary>
      
    
    
    
    
    <category term="项目" scheme="https://konjacor.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="java" scheme="https://konjacor.github.io/tags/java/"/>
    
    <category term="网络编程" scheme="https://konjacor.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="游戏" scheme="https://konjacor.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis入门</title>
    <link href="https://konjacor.github.io/2022/10/05/Redis%E5%85%A5%E9%97%A8/"/>
    <id>https://konjacor.github.io/2022/10/05/Redis%E5%85%A5%E9%97%A8/</id>
    <published>2022-10-05T03:17:52.000Z</published>
    <updated>2023-02-23T15:04:44.099Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="NoSQL数据库简介"><a href="#NoSQL数据库简介" class="headerlink" title="NoSQL数据库简介"></a>NoSQL数据库简介</h1><h2 id="技术的发展以及用户增多带来的压力使得NoSQL数据库成为需求"><a href="#技术的发展以及用户增多带来的压力使得NoSQL数据库成为需求" class="headerlink" title="技术的发展以及用户增多带来的压力使得NoSQL数据库成为需求"></a>技术的发展以及用户增多带来的压力使得NoSQL数据库成为需求</h2><h3 id="技术发展"><a href="#技术发展" class="headerlink" title="技术发展"></a>技术发展</h3><ul><li>技术的分类：<ol><li>解决功能性的问题：Java、Jsp、RDBMS、Tomcat、HTML、Linux、JDBC、SVN</li><li>解决扩展性的问题：Struts、Spring、SpringMVC、Hibernate、Mybatis</li><li>解决性能的问题：NoSQL、Java线程、Hadoop、Nginx、MQ、ElasticSearch</li></ol></li></ul><h3 id="Web1-0时代"><a href="#Web1-0时代" class="headerlink" title="Web1.0时代"></a>Web1.0时代</h3><ul><li><p>Web1.0的时代，数据访问量很有限，用一夫当关的高性能的单点服务器可以解决大部分问题。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005112404492.png" alt="image-20221005112404492"></p></li></ul><h3 id="Web2-0时代"><a href="#Web2-0时代" class="headerlink" title="Web2.0时代"></a>Web2.0时代</h3><ul><li><p>随着Web2.0的时代的到来，用户访问量大幅度提升，同时产生了大量的用户数据。加上后来的智能移动设备的普及，所有的互联网平台都面临了巨大的性能挑战。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005112518190.png" alt="image-20221005112518190"></p></li></ul><h3 id="缓解CPU及内存压力"><a href="#缓解CPU及内存压力" class="headerlink" title="缓解CPU及内存压力"></a>缓解CPU及内存压力</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005112604896.png" alt="image-20221005112604896"></p><h3 id="缓解IO压力"><a href="#缓解IO压力" class="headerlink" title="缓解IO压力"></a>缓解IO压力</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005112629768.png" alt="image-20221005112629768"></p><h2 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h2><h3 id="NoSQL数据库概述"><a href="#NoSQL数据库概述" class="headerlink" title="NoSQL数据库概述"></a>NoSQL数据库概述</h3><ul><li><p>NoSQL(NoSQL &#x3D; <strong>Not Only SQL</strong> )，意即“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。 NoSQL <strong>不依赖业务逻辑方式存储，而以简单的key-value模式存储</strong>。因此大大的增加了数据库的扩展能力。</p></li><li><p>NoSQL数据库不遵循SQL标准</p></li><li><p>NoSQL数据库不支持ACID</p></li><li><p>NoSQL数据库有着远超于SQL的性能</p></li></ul><h3 id="NoSQL数据库的适用场景"><a href="#NoSQL数据库的适用场景" class="headerlink" title="NoSQL数据库的适用场景"></a>NoSQL数据库的适用场景</h3><ul><li>对数据高并发的读写的场景</li><li>海量数据的读写的场景</li><li>对数据有高可扩展性的要求的场景</li><li>用不着sql和用了sql也不行的情况，可以考虑使用NoSQL</li></ul><h3 id="NoSQL数据库不适用的场景"><a href="#NoSQL数据库不适用的场景" class="headerlink" title="NoSQL数据库不适用的场景"></a>NoSQL数据库不适用的场景</h3><ul><li>需要事务支持的场景</li><li>基于sql的结构化查询存储，处理复杂的关系，需要<strong>即席查询</strong>的场景。</li></ul><h2 id="常见的NoSQL数据库"><a href="#常见的NoSQL数据库" class="headerlink" title="常见的NoSQL数据库"></a>常见的NoSQL数据库</h2><h3 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005113605921.png" alt="image-20221005113605921"></p><ul><li><strong>很早出现</strong>的NoSQL数据库</li><li>数据都在内存中，一般<strong>不持久化</strong></li><li>支持简单的key-value模式，<strong>支持类型单一</strong></li><li>一般是作为<strong>缓存数据库</strong>辅助持久化的数据库</li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005113855265.png" alt="image-20221005113855265"></p><ul><li>几乎覆盖了Memcached的绝大部分功能</li><li>数据都在内存中，<strong>支持持久化</strong>，主要用作备份恢复</li><li>除了支持简单的key-value模式，还<strong>支持多种数据结构的存储</strong>，比如 list、set、hash、zset等。</li><li>一般是作为<strong>缓存数据库</strong>辅助持久化的数据库</li></ul><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005114004041.png" alt="image-20221005114004041"></p><ul><li>高性能、开源、模式自由(schema  free)的<strong>文档型数据库</strong></li><li>数据都在内存中， 如果内存不足，<strong>把不常用的数据保存到硬盘</strong></li><li>虽然是key-value模式，但是<strong>对value（尤其是json）提供了丰富的查询功能</strong></li><li><strong>支持二进制数据及大型对象</strong></li><li>可以根据数据的特点<strong>替代RDBMS</strong>，成为独立的数据库。或者<strong>配合RDBMS</strong>，存储特定的数据。</li></ul><h3 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005114922236.png" alt="image-20221005114922236"></p><ul><li>HBase是<strong>Hadoop项目中的数据库</strong>。它<strong>用于需要对大量的数据进行随机、实时的读写操作的场景中</strong>。</li><li>HBase的目标就是<strong>处理数据量非常庞大的表</strong>，可以用普通的计算机处理超过<strong>10亿行数据</strong>，还可处理有<strong>数百万列元素</strong>的数据表。</li></ul><h3 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005115202672.png" alt="image-20221005115202672"></p><ul><li>Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于<strong>管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到PB级别)<strong>。在众多显著特性当中，Cassandra</strong>最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程</strong>。</li><li>计算机存储单位 计算机存储单位一般用bit，B，KB，MB，GB，TB，EB，ZB，YB，BB来表示，它们之间的关系是：除了1B&#x3D;8bit，其它的都是1024进制。（注：“兆”是百万级数量单位）</li></ul><h2 id="大数据时代使得行式存储数据库成为需求"><a href="#大数据时代使得行式存储数据库成为需求" class="headerlink" title="大数据时代使得行式存储数据库成为需求"></a>大数据时代使得行式存储数据库成为需求</h2><h3 id="行式数据库"><a href="#行式数据库" class="headerlink" title="行式数据库"></a>行式数据库</h3><ul><li>按行存储，这样的结构使得查询特定信息时速度很快，但是在求很多记录的某属性的数据特征的时候速度就有点不尽人意了。<img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005114528568.png" alt="image-20221005114528568"></li></ul><h3 id="列式数据库"><a href="#列式数据库" class="headerlink" title="列式数据库"></a>列式数据库</h3><ul><li><p>按列存储，这样的结构使得求多记录的某属性的数据特征的时候速度很快， 但是在查询特定信息时速度有点不尽人意。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005114816603.png" alt="image-20221005114816603"></p></li></ul><h2 id="图关系型数据库"><a href="#图关系型数据库" class="headerlink" title="图关系型数据库"></a>图关系型数据库</h2><h3 id="Noe4j"><a href="#Noe4j" class="headerlink" title="Noe4j"></a>Noe4j</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005115736182.png" alt="image-20221005115736182"></p><ul><li><p>主要应用：社会关系、公共交通网络、地图及网络拓扑(n*(n-1)&#x2F;2)</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005115903720.png" alt="image-20221005115903720"></p></li></ul><h2 id="DB-Engines数据库排名"><a href="#DB-Engines数据库排名" class="headerlink" title="DB-Engines数据库排名"></a>DB-Engines数据库排名</h2><ul><li><p><a href="http://db-engines.com/en/ranking">http://db-engines.com/en/ranking</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005120026236.png" alt="image-20221005120026236"></p></li></ul><h1 id="Redis概述"><a href="#Redis概述" class="headerlink" title="Redis概述"></a>Redis概述</h1><ul><li>Redis是一个<strong>开源的key-value存储系统</strong>。</li><li>和Memcached类似，它<strong>支持存储的value类型相对更多</strong>，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。</li><li>这些数据类型都<strong>支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作</strong>，而且<strong>这些操作都是原子性的</strong>。</li><li>在此基础上，<strong>Redis支持各种不同方式的排序</strong>。</li><li>与memcached一样，<strong>为了保证效率，数据都是缓存在内存中</strong>。区别的是<strong>Redis会按照要求周期性地把更新的数据写入磁盘或者把修改操作写入追加的记录文件</strong>。</li><li>并且在此基础上<strong>实现了master-slave(主从)同步</strong>。</li></ul><h1 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h1><h3 id="配合关系型数据库做高速缓存"><a href="#配合关系型数据库做高速缓存" class="headerlink" title="配合关系型数据库做高速缓存"></a>配合关系型数据库做高速缓存</h3><ul><li><p>缓存<strong>高频次、热门访问</strong>的数据，从而<strong>降低数据库的IO压力</strong></p></li><li><p>利用分布式的架构，做<strong>session共享</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005121420678.png" alt="image-20221005121420678"></p></li></ul><h3 id="用多样的数据结构存储持久化数据"><a href="#用多样的数据结构存储持久化数据" class="headerlink" title="用多样的数据结构存储持久化数据"></a>用多样的数据结构存储持久化数据</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005121553991.png" alt="image-20221005121553991"></p><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><table><thead><tr><th>Redis官方网站</th><th>Redis中文官方网站</th></tr></thead><tbody><tr><td><a href="http://redis.io/">http://redis.io</a></td><td><a href="http://redis.cn/">http://redis.cn/</a></td></tr></tbody></table><h2 id="安装版本"><a href="#安装版本" class="headerlink" title="安装版本"></a>安装版本</h2><ul><li>Linux无脑装最新版就行了，不用考虑在windows环境下对Redis的支持，因为Redis官方根本就没出windows的客户端，要想在windows运行Redis，要去github下载一个微软做了适配的Redis版本，不过那个版本就很低了。</li><li>下面的安装步骤是针对Linux操作系统的。</li></ul><h2 id="安装步骤（Linux）"><a href="#安装步骤（Linux）" class="headerlink" title="安装步骤（Linux）"></a>安装步骤（Linux）</h2><h3 id="准备工作：下载安装最新版的gcc编译器"><a href="#准备工作：下载安装最新版的gcc编译器" class="headerlink" title="准备工作：下载安装最新版的gcc编译器"></a>准备工作：下载安装最新版的gcc编译器</h3><ul><li><p>安装C语言的编译环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build</span><br><span class="line">yum install -y devtoolset-8-toolchain</span><br><span class="line">scl enable devtoolset-8 bash #这个只是暂时修改了gcc的版本为8，当会话结束时gcc的版本会恢复默认</span><br></pre></td></tr></table></figure></li><li><p>测试gcc版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc --version</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221006093350737.png" alt="image-20221006093350737"></p></li></ul><h3 id="从官网下载redis-6-2-1-tar-gz放到自己想放的目录"><a href="#从官网下载redis-6-2-1-tar-gz放到自己想放的目录" class="headerlink" title="从官网下载redis-6.2.1.tar.gz放到自己想放的目录"></a>从官网下载redis-6.2.1.tar.gz放到自己想放的目录</h3><ul><li>下载支持linux的最新版就行了，linux压缩文件的后缀是**.tar.gz**</li></ul><h3 id="解压压缩文件"><a href="#解压压缩文件" class="headerlink" title="解压压缩文件"></a>解压压缩文件</h3><ul><li>先移动到刚才压缩包所在的目录下，用解压命令：<strong>tar -zxvf redis-6.2.1.tar.gz</strong>进行解压</li></ul><h3 id="进入解压完成后的目录"><a href="#进入解压完成后的目录" class="headerlink" title="进入解压完成后的目录"></a>进入解压完成后的目录</h3><ul><li>用cd命令</li></ul><h3 id="编译文件"><a href="#编译文件" class="headerlink" title="编译文件"></a>编译文件</h3><ul><li>在解压完成后的目录下执行<strong>make</strong>命令将文件编译好。</li><li>如果没有准备好C语言的编译环境，make会报错：Jemalloc&#x2F;jemalloc.h：没有那个文件，解决方案：运行<strong>make distclean</strong>，然后再次执行<strong>make</strong>命令</li></ul><h3 id="安装文件"><a href="#安装文件" class="headerlink" title="安装文件"></a>安装文件</h3><ul><li>继续在当前目录下执行<strong>make install</strong>命令</li><li>安装目录：**&#x2F;usr&#x2F;local&#x2F;bin**</li></ul><h2 id="在默认安装目录查看安装结果"><a href="#在默认安装目录查看安装结果" class="headerlink" title="在默认安装目录查看安装结果"></a>在默认安装目录查看安装结果</h2><ul><li>以下是常用文件：<ol><li>redis-benchmark:性能测试工具，可以在自己本子运行，看看自己本子性能如何</li><li>redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲</li><li>redis-check-dump：修复有问题的dump.rdb文件</li><li>redis-sentinel：Redis集群使用</li><li>redis-server：Redis服务器启动命令</li><li>redis-cli：客户端，操作入口</li></ol></li></ul><h2 id="前台启动（不推荐）"><a href="#前台启动（不推荐）" class="headerlink" title="前台启动（不推荐）"></a>前台启动（不推荐）</h2><ul><li><p>如果使用前台启动，那么命令行窗口不能关闭，否则服务器停止。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221006095121261.png" alt="image-20221006095121261"></p></li></ul><h2 id="后台启动（推荐）"><a href="#后台启动（推荐）" class="headerlink" title="后台启动（推荐）"></a>后台启动（推荐）</h2><h3 id="备份redis-conf"><a href="#备份redis-conf" class="headerlink" title="备份redis.conf"></a>备份redis.conf</h3><ul><li>拷贝一份redis.conf到其他目录：<strong>cp 文件目录 想要复制到的目录</strong></li></ul><h3 id="在redis-conf中将后台启动设置daemonize-no改成yes"><a href="#在redis-conf中将后台启动设置daemonize-no改成yes" class="headerlink" title="在redis.conf中将后台启动设置daemonize no改成yes"></a>在redis.conf中将后台启动设置daemonize no改成yes</h3><ul><li>修改redis.conf(128行左右)文件将里面的daemonize no 改成 yes，允许服务默认在后台启动</li></ul><h3 id="选择配置文件启动Redis"><a href="#选择配置文件启动Redis" class="headerlink" title="选择配置文件启动Redis"></a>选择配置文件启动Redis</h3><ul><li>使用命令：<strong>redis-server 配置文件相对路径</strong>，由于配置了后台启动，所以这次启动是后台启动，可以用<strong>ps -ef | grep redis</strong>命令来查询信息中含有redis的进程来查看启动结果。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221006095817088.png" alt="image-20221006095817088"></p><h3 id="用客户端访问"><a href="#用客户端访问" class="headerlink" title="用客户端访问"></a>用客户端访问</h3><ul><li><p>在安装目录下运行<strong>redis-cli</strong>，就可以以默认端口号访问到redis服务</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221006100350168.png" alt="image-20221006100350168"></p></li><li><p>如果想要以特定端口号访问redis服务可以这样写：<strong>redis-cli -p端口号</strong></p></li></ul><h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><ul><li><p>使用ping命令，如果回复是PONG说明连通了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221006100419596.png" alt="image-20221006100419596"></p></li></ul><h3 id="关闭Redis"><a href="#关闭Redis" class="headerlink" title="关闭Redis"></a>关闭Redis</h3><ul><li><p>单实例关闭：<strong>redis-cli shutdown</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221006100454106.png" alt="image-20221006100454106"></p></li><li><p>也可以进入redis的客户端后再使用<strong>shutdown</strong>命令关闭</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221006100547655.png" alt="image-20221006100547655"></p></li><li><p>多实例关闭、指定端口关闭：<strong>redis-cli -p 端口号 shutdown</strong></p></li></ul><h1 id="Redis相关知识"><a href="#Redis相关知识" class="headerlink" title="Redis相关知识"></a>Redis相关知识</h1><ul><li><p>Redis的默认端口6379有来头，可以上网搜搜</p></li><li><p>Redis默认有16个数据库，类似数组下标从0开始，初始<strong>默认使用0号库</strong></p></li><li><p>使用命令**select &lt;dbid&gt;**来切换数据库，如：select 8</p></li><li><p>统一密码管理，<strong>所有库都是同样的密码</strong></p></li><li><p>用<strong>dbsize</strong>命令查看当前数据库的key的数量</p></li><li><p>用<strong>flushdb</strong>清空当前库</p></li><li><p>用<strong>flushall</strong>通杀全部库</p></li><li><p>Redis是<strong>单线程+多路IO复用技术</strong>，多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）</p></li><li><p>串行  vs  多线程+锁（memcached） vs  单线程+多路IO复用(Redis) ，他们三个各有什么优劣？</p></li><li><p>与Memcache的三点不同：redis支持多数据类型，redis支持持久化，redis采用单线程+多路IO复用的形式</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221006104716983.png" alt="image-20221006104716983"></p></li></ul><h1 id="常用五大数据类型"><a href="#常用五大数据类型" class="headerlink" title="常用五大数据类型"></a>常用五大数据类型</h1><ul><li>获得redis常见数据类型操作命令：<a href="http://www.redis.cn/commands.html">http://www.redis.cn/commands.html</a></li></ul><h2 id="Redis键（key）"><a href="#Redis键（key）" class="headerlink" title="Redis键（key）"></a>Redis键（key）</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>keys *：查看当前库所有key   (匹配：keys *1)</li><li>exists key：判断某个key是否存在</li><li>type key：查看你的key是什么类型</li><li>del key： 删除指定的key数据</li><li>unlink key：  根据value选择非阻塞删除，仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</li><li>expire key 10：为给定的key设置过期时间为10秒钟</li><li>ttl key： 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li><li>select：命令切换数据库</li><li>dbsize：查看当前数据库的key的数量</li><li>flushdb：清空当前库</li><li>flushall：通杀全部库</li></ul><h2 id="Redis字符串（String）"><a href="#Redis字符串（String）" class="headerlink" title="Redis字符串（String）"></a>Redis字符串（String）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，<strong>一个key对应一个value</strong>。</li><li>String类型<strong>是二进制安全的</strong>。意味着Redis的string<strong>可以包含任何数据</strong>。比如jpg图片或者序列化的对象。</li><li>String类型是Redis最基本的数据类型，一个Redis中字符串value<strong>最多可以是512M</strong></li></ul><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221007103952053.png" alt="image-20221007103952053"></p><ul><li>所谓原子操作是指不会被线程调度机制打断的操作，<strong>这种操作一旦开始，就一直运行到结束</strong>，中间不会有任何context switch（切换到另外一个线程）。原子操作原本指不可再分的操作，但是对于可再分的操作我们可以通过一些手段让他表现出不可再分的特性，所以对于这种操作我们也称其为原子操作。</li><li><strong>在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间</strong>。</li><li><strong>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作</strong>。</li><li>Redis单命令的原子性主要得益于Redis的单线程。</li></ul><h3 id="原子性的案例"><a href="#原子性的案例" class="headerlink" title="原子性的案例"></a>原子性的案例</h3><ul><li><p>问：java中的i++是否是原子操作？</p></li><li><p>答：不是原子操作，尽管从代码上来看，i++似乎是一个不可分割的操作，但是底层在执行这个操作的时候实际上是分了好几步的：</p><ol><li>从内存中读i到寄存器</li><li>在寄存器中让i自增</li><li>将寄存器中的i写回内存</li></ol><p>java是一个支持多线程的语言，<strong>若不实行一些同步措施那么在i++执行上面的任意一个步骤的时候别的线程也有可能同时在操作i自变量</strong>，所以最后的结果可能不是预期的结果。</p></li><li><p>问：java中令i&#x3D;0，两个线程分别对i进行++100次，值是多少？</p></li><li><p>答：2-200都有可能，因为根据上个问题的答案，任何一次++操作的第三步操作之后都有可能被别的线程的++操作的第三步操作覆盖。（答案是对，但是解析不确定，之后懂了再回来改吧）</p></li></ul><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><p>set  &lt;key&gt; &lt;value&gt;：添加键值对</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221007103011842.png" alt="image-20221007103011842"></p><ul><li>NX：当数据库中key不存在时，可以将key-value添加到数据库</li><li>XX：当数据库中key存在时，可以将key-value添加到数据库，与NX参数互斥</li><li>EX：key的超时秒数</li><li>PX：key的超时毫秒数，与EX互斥</li></ul></li><li><p>get  &lt;key&gt;：查询对应键值</p></li><li><p>append  &lt;key&gt; &lt;value&gt;：将给定的&lt;value&gt; 追加到原值的末尾</p></li><li><p>strlen  &lt;key&gt;：获得值的长度</p></li><li><p>setnx  &lt;key&gt; &lt;value&gt;：只有在 key 不存在时   设置 key 的值 </p></li><li><p>incr  &lt;key&gt;：将 key 中储存的数字值增1，只能对数字值操作，如果为空，新增值为1</p></li><li><p>decr  &lt;key&gt;：将 key 中储存的数字值减1，只能对数字值操作，如果为空，新增值为-1</p></li><li><p>incrby &#x2F; decrby  &lt;key&gt; &lt;步长&gt;：将 key 中储存的数字值增减。自定义步长。</p></li><li><p>mset  &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt;  ….. ：同时设置一个或多个 key-value对  </p></li><li><p>mget  &lt;key1&gt; &lt;key2&gt; &lt;key3&gt; …..：同时获取一个或多个 value  </p></li><li><p>msetnx &lt;key1&gt; &lt;value1&gt; &lt;key2&gt; &lt;value2&gt;  ….. ：同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。原子性，有一个失败则都失败</p></li><li><p>getrange  &lt;key&gt; &lt;起始位置&gt; &lt;结束位置&gt;：获得值的范围，类似java中的substring，前包，后包</p></li><li><p>setrange  &lt;key&gt; &lt;起始位置&gt; &lt;value&gt;：用 &lt;value&gt;  覆写&lt;key&gt;所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。</p></li><li><p>setex  &lt;key&gt; &lt;过期时间&gt; &lt;value&gt;：设置键值的同时，设置过期时间，单位秒。</p></li><li><p>getset &lt;key&gt; &lt;value&gt;：以新换旧，设置了新值同时获得旧值。</p></li></ul><h3 id="String数据结构"><a href="#String数据结构" class="headerlink" title="String数据结构"></a>String数据结构</h3><ul><li><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，<strong>采用预分配冗余空间的方式来减少内存的频繁分配</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221007110816409.png" alt="image-20221007110816409"></p></li><li><p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。<strong>当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M</strong>。</p></li></ul><h2 id="Redis列表（List）"><a href="#Redis列表（List）" class="headerlink" title="Redis列表（List）"></a>Redis列表（List）</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>List列表是采用<strong>单键多值</strong>的方式进行存储的，是简单的字符串列表，元素按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</li><li>它的底层实际是个双向链表，对两端的操作性能很高，但通过索引下标的操作中间的节点性能会较差。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221008101337715.png" alt="image-20221008101337715"></p><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>lpush&#x2F;rpush  &lt;key&gt; &lt;value1&gt; &lt;value2&gt; &lt;value3&gt; …. ：从左边&#x2F;右边插入一个或多个值。</li><li>lpop&#x2F;rpop  &lt;key&gt;：从左边&#x2F;右边吐出一个值。值在键在，值光键亡。</li><li>rpoplpush  &lt;key1&gt; &lt;key2&gt;：从&lt;key1&gt;列表右边吐出一个值，插到&lt;key2&gt;列表左边。</li><li>lrange &lt;key&gt; &lt;start&gt; &lt;stop&gt;：按照索引下标获得元素(从左到右)</li><li>lrange mylist 0 -1：  0左边第一个，-1右边第一个，（0-1表示获取所有）</li><li>lindex &lt;key&gt; &lt;index&gt;：按照索引下标获得元素(从左到右)</li><li>llen &lt;key&gt;：获得列表长度 </li><li>linsert &lt;key&gt;  before &lt;value&gt; &lt;newvalue&gt;：在&lt;value&gt;的后面插入&lt;newvalue&gt;插入值</li><li>lrem &lt;key&gt; &lt;n&gt; &lt;value&gt;：从左边删除n个value(从左到右)</li><li>lset &lt;key&gt; &lt;index&gt; &lt;value&gt;：将列表key下标为index的值替换成value</li></ul><h3 id="List数据结构"><a href="#List数据结构" class="headerlink" title="List数据结构"></a>List数据结构</h3><ul><li><p>List的数据结构为<strong>快速链表quickList</strong>。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是<strong>ziplist</strong>，也即是<strong>压缩列表</strong>。它将所有的元素紧挨着一起存储，<strong>分配的是一块连续的内存</strong>。当<strong>数据量比较多的时候才会改成quicklist</strong>。</p></li><li><p>因为<strong>普通的链表需要的附加指针空间太大，会比较浪费空间</strong>。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221008101933655.png" alt="image-20221008101933655"></p><p>Redis将链表和ziplist结合起来组成了quicklist。也就是<strong>将多个ziplist使用双向指针串起来使用</strong>。这样<strong>既满足了快速的插入删除性能，又不会出现太大的空间冗余</strong>。</p></li></ul><h2 id="Redis集合（Set）"><a href="#Redis集合（Set）" class="headerlink" title="Redis集合（Set）"></a>Redis集合（Set）</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><ul><li>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以<strong>自动排重</strong>的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且<strong>set提供了判断某个成员是否在一个set集合内的重要接口</strong>，这个也是list所不能提供的。</li><li>Redis的<strong>Set是string类型的无序集合</strong>。它<strong>底层其实是一个value为null的hash表</strong>，所以添加，删除，查找的**复杂度都是O(1)**。</li><li>一个算法，随着数据的增加，执行时间的长短也可能会有变化，但复杂度如果是O(1)，数据增加，查找数据的时间不变。</li></ul><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>sadd &lt;key&gt; &lt;value1&gt; &lt;value2&gt; ….. ：将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</li><li>smembers &lt;key&gt;：取出该集合的所有值。</li><li>sismember &lt;key&gt; &lt;value&gt;：判断集合&lt;key&gt;是否为含有该&lt;value&gt;值，有1，没有0</li><li>scard &lt;key&gt;：返回该集合的元素个数。</li><li>srem &lt;key&gt; &lt;value1&gt; &lt;value2&gt; …. ：删除集合中的某个元素。</li><li>spop &lt;key&gt;：<strong>随机从该集合中吐出一个值。</strong></li><li>srandmember &lt;key&gt; &lt;n&gt;：随机从该集合中取出n个值。不会从集合中删除 。</li><li>smove &lt;source&gt; &lt;destination&gt;：value把集合中一个值从一个集合移动到另一个集合</li><li>sinter &lt;key1&gt; &lt;key2&gt;：返回两个集合的交集元素。</li><li>sunion &lt;key1&gt; &lt;key2&gt;：返回两个集合的并集元素。</li><li>sdiff &lt;key1&gt; &lt;key2&gt;：返回两个集合的<strong>差集</strong>元素(key1中的，不包含key2中的)</li></ul><h3 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h3><ul><li>Set数据结构是<strong>dict字典</strong>，字典<strong>是用哈希表实现</strong>的。</li><li>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，<strong>它的内部也使用hash结构，所有的value都指向同一个内部值</strong>。</li></ul><h2 id="Redis哈希（Hash）"><a href="#Redis哈希（Hash）" class="headerlink" title="Redis哈希（Hash）"></a>Redis哈希（Hash）</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><ul><li><p>Redis hash 是一个<strong>键值对集合</strong>。</p></li><li><p>Redis hash是一个<strong>string类型的field和value的映射表</strong>，hash特别<strong>适合用于存储对象</strong>。<strong>类似Java里面的Map&lt;String,Object&gt;</strong></p></li><li><p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key&#x2F;value结构来存储，主要有以下两种存储方式：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221008105151907.png" alt="image-20221008105151907"></p><p>使用Redis hash来存储，解决了上述两种方式的问题：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221008105233869.png" alt="image-20221008105233869"></p></li></ul><h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>hset &lt;key&gt; &lt;field&gt; &lt;value&gt;：给&lt;key&gt;集合中的&lt;field&gt;键赋值&lt;value&gt;</li><li>hget &lt;key1&gt; &lt;field&gt;：从&lt;key1&gt;集合&lt;field&gt;取出 value </li><li>hmset &lt;key1&gt; &lt;field1&gt; &lt;value1&gt; &lt;field2&gt; &lt;value2&gt;… ：批量设置hash的值</li><li>hexists &lt;key1&gt; &lt;field&gt;：查看哈希表 key 中，给定域 field 是否存在。 </li><li>hkeys &lt;key&gt;：列出该hash集合的所有field</li><li>hvals &lt;key&gt;：列出该hash集合的所有value</li><li>hincrby &lt;key&gt; &lt;field&gt; &lt;increment&gt;：为哈希表 key 中的域 field 的值加上增量 1  -1</li><li>hsetnx &lt;key&gt; &lt;field&gt; &lt;value&gt;：将哈希表 key 中的域 field 的值设置为 value ，当且仅当域field 不存在</li></ul><h3 id="Hash数据结构"><a href="#Hash数据结构" class="headerlink" title="Hash数据结构"></a>Hash数据结构</h3><ul><li>Hash类型对应的数据结构是两种：<strong>ziplist（压缩列表），hashtable（哈希表）</strong>。<strong>当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable</strong>。</li></ul><h2 id="Redis有序集合Zset-sorted-set"><a href="#Redis有序集合Zset-sorted-set" class="headerlink" title="Redis有序集合Zset(sorted set)"></a>Redis有序集合Zset(sorted set)</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><ul><li>Redis有序集合zset与普通集合set非常相似，是一个<strong>没有重复元素的字符串集合</strong>。</li><li>不同之处是有序集合的<strong>每个成员都关联了一个评分（score）</strong>,这个评分（score）被<strong>用来按照从最低分到最高分的方式排序集合中的成员</strong>。<strong>集合的成员是唯一的</strong>，但是<strong>评分可以是重复</strong>的 。</li><li>因为元素是有序的, 所以你也<strong>可以很快的根据评分（score）或者次序（position）来获取一个范围的元素</strong>。</li><li><strong>访问有序集合的中间元素也是非常快</strong>的,因此你<strong>能够使用有序集合作为一个没有重复成员的智能列表</strong>。</li></ul><h3 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a>常用命令</h3><h3 id="Zset数据结构"><a href="#Zset数据结构" class="headerlink" title="Zset数据结构"></a>Zset数据结构</h3><ul><li>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，<strong>不能有重复的key，并且可以给每一个元素value赋予一个权重score</strong>，另一方面它又类似于TreeSet，<strong>内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表</strong>。</li><li>zset底层使用了两个数据结构：<ol><li>hash，<strong>hash的作用就是关联元素value和权重score，保障元素value的唯一性</strong>，可以通过元素value找到相应的score值。</li><li>跳跃表，<strong>跳跃表的目的在于给元素value排序，根据score的范围获取元素列表</strong>。</li></ol></li></ul><h3 id="跳跃表（跳表）"><a href="#跳跃表（跳表）" class="headerlink" title="跳跃表（跳表）"></a>跳跃表（跳表）</h3><h4 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h4><ul><li>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。<strong>跳跃表效率堪比红黑树，实现远比红黑树简单</strong>。</li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul><li><p>对比有序链表和跳跃表，从链表中查询出51</p></li><li><p>有序链表：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221008111754655.png" alt="image-20221008111754655"></p><p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p></li><li><p>跳跃表：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221008111823462.png" alt="image-20221008111823462"></p><p>从第2层开始，1节点比51节点小，向后比较。</p><p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</p><p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</p><p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p></li><li><p>从此可以看出<strong>跳跃表比有序链表效率要高</strong></p></li></ul><h1 id="Redis配置文件介绍"><a href="#Redis配置文件介绍" class="headerlink" title="Redis配置文件介绍"></a>Redis配置文件介绍</h1><ul><li>配置文件名称：redis.conf</li></ul><h2 id="Units-单位"><a href="#Units-单位" class="headerlink" title="Units 单位"></a>Units 单位</h2><ul><li><p>配置大小单位,开头定义了一些基本的度量单位，<strong>只支持bytes，不支持bit</strong>，<strong>大小写不敏感</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009104414297.png" alt="image-20221009104414297"></p></li></ul><h2 id="INCLUDES-包含"><a href="#INCLUDES-包含" class="headerlink" title="INCLUDES 包含"></a>INCLUDES 包含</h2><ul><li><p>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来，之后可以通过直接include那个配置文件来引入那个配置文件的相关配置。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009104601357.png" alt="image-20221009104601357"></p></li></ul><h2 id="网络相关配置"><a href="#网络相关配置" class="headerlink" title="网络相关配置"></a>网络相关配置</h2><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><ul><li><p>默认情况bind&#x3D;127.0.0.1只能接受本机的访问请求，不写的情况下，无限制接受任何ip地址的访问。</p></li><li><p>生产环境肯定要写你应用服务器的地址；<strong>服务器是需要远程访问的，所以需要将其注释掉</strong></p></li><li><p><strong>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009105041816.png" alt="image-20221009105041816"></p></li><li><p>注：修改完配置之后需要<strong>保存配置、停止服务、重新启动服务</strong>才能生效。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009105239588.png" alt="image-20221009105239588"></p></li></ul><h3 id="protected-mode"><a href="#protected-mode" class="headerlink" title="protected-mode"></a>protected-mode</h3><ul><li><p>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应。</p></li><li><p>在开发阶段建议先把这个选项设置为no</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009110217704.png" alt="image-20221009110217704"></p></li></ul><h3 id="port"><a href="#port" class="headerlink" title="port"></a>port</h3><ul><li><p>设置redis服务的端口号，默认为6379。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009110033805.png" alt="image-20221009110033805"></p></li></ul><h3 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp-backlog"></a>tcp-backlog</h3><ul><li><p>设置tcp的backlog，backlog其实是一个连接队列，<strong>backlog队列总和&#x3D;未完成三次握手队列 + 已经完成三次握手队列</strong>。</p></li><li><p>在<strong>高并发环境下你需要一个高backlog值来避免慢客户端连接问题</strong>。</p></li><li><p>注意Linux内核会将这个值减小到&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn的值（128），所以<strong>需要确认增大&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn和&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog（128）两个值来达到想要的效果</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009110702327.png" alt="image-20221009110702327"></p></li></ul><h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><ul><li><p>设置<strong>一个空闲的客户端维持多少秒会关闭</strong>，0表示关闭该功能。即永不关闭。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009110740091.png" alt="image-20221009110740091"></p></li></ul><h3 id="tcp-keepalive"><a href="#tcp-keepalive" class="headerlink" title="tcp-keepalive"></a>tcp-keepalive</h3><ul><li><p>对访问客户端的一种心跳检测，每个n秒检测一次，<strong>如果没有心跳即没有请求了，那么就关闭tcp通道</strong>。</p></li><li><p>单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009110922733.png" alt="image-20221009110922733"></p></li></ul><h2 id="GENERAL-通用"><a href="#GENERAL-通用" class="headerlink" title="GENERAL 通用"></a>GENERAL 通用</h2><h3 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a>daemonize</h3><ul><li><p>启动时是否是后台启动，设置为yes后，启动redis服务端的时候就会在后台启动。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009111238488.png" alt="image-20221009111238488"></p></li></ul><h3 id="pidfile"><a href="#pidfile" class="headerlink" title="pidfile"></a>pidfile</h3><ul><li><p>存放pid文件的位置，<strong>每个redis进程实例会产生一个不同的pid文件</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009111407502.png" alt="image-20221009111407502"></p></li></ul><h3 id="loglevel"><a href="#loglevel" class="headerlink" title="loglevel"></a>loglevel</h3><ul><li><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，<strong>默认为notice</strong>，越往左输出的内容越详细。</p></li><li><p>四个级别根据使用阶段来选择，生产环境选择notice 或者warning</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009111548869.png" alt="image-20221009111548869"></p></li></ul><h3 id="logfile"><a href="#logfile" class="headerlink" title="logfile"></a>logfile</h3><ul><li><p>日志文件名称</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009111619547.png" alt="image-20221009111619547"></p></li></ul><h3 id="databases-16"><a href="#databases-16" class="headerlink" title="databases 16"></a>databases 16</h3><ul><li><p><strong>设定库的数量</strong>默认16，默认数据库为0，<strong>可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009111723684.png" alt="image-20221009111723684"></p></li></ul><h2 id="SECURITY-安全"><a href="#SECURITY-安全" class="headerlink" title="SECURITY 安全"></a>SECURITY 安全</h2><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><ul><li><p>可以在配置文件的<strong>requirepass后面设置访问密码</strong>，也可以使用命令设置密码，但是使用命令设置的密码只是临时的，如果重启redis服务器，密码会被还原，<strong>如果需要永久设置密码，需要在配置文件中进行设置</strong>。</p></li><li><p>在配置文件中设置密码：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009113843381.png" alt="image-20221009113843381"></p></li><li><p>使用命令查看访问密码、修改访问密码、登录：<br><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009113913607.png" alt="image-20221009113913607"></p></li></ul><h2 id="LIMITS-限制"><a href="#LIMITS-限制" class="headerlink" title="LIMITS 限制"></a>LIMITS 限制</h2><h3 id="maxclients"><a href="#maxclients" class="headerlink" title="maxclients"></a>maxclients</h3><ul><li><p><strong>设置redis同时可以与多少个客户端进行连接</strong>。</p></li><li><p>默认情况下为10000个客户端。</p></li><li><p>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009112836144.png" alt="image-20221009112836144"></p></li></ul><h3 id="maxmemory"><a href="#maxmemory" class="headerlink" title="maxmemory"></a>maxmemory</h3><ul><li><p>设置<strong>redis可以使用的内存量</strong>。一旦到达内存使用上限，redis将会试图移除内部数据，<strong>移除规则可以通过maxmemory-policy来指定</strong>。</p></li><li><p>建议<strong>必须设置</strong>，否则将内存占满可能会造成服务器宕机。</p></li><li><p>如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</p></li><li><p>但是对于无内存申请的指令，仍然会正常响应，比如GET等。<strong>如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009114449510.png" alt="image-20221009114449510"></p></li></ul><h3 id="maxmemory-policy"><a href="#maxmemory-policy" class="headerlink" title="maxmemory-policy"></a>maxmemory-policy</h3><ul><li><p>设置<strong>redis到达内存使用上限后的行为规则</strong>。</p></li><li><p>volatile-lru：使用LRU（最近最少使用）算法移除key，<strong>只针对设置了过期时间的键</strong>。</p></li><li><p>allkeys-lru：在<strong>所有集合key</strong>中，使用LRU（最近最少使用）算法移除key。</p></li><li><p>volatile-random：在过期集合中移除随机的key，<strong>只针对设置了过期时间的键</strong>。</p></li><li><p>allkeys-random：在<strong>所有集合key</strong>中，移除随机的key。</p></li><li><p>volatile-ttl：移除那些TTL值最小的key，即那些<strong>最近要过期的key</strong>，<strong>只针对设置了过期时间的键</strong>。</p></li><li><p>noeviction：<strong>不进行移除</strong>。针对写操作，只是<strong>返回错误信息</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009115003839.png" alt="image-20221009115003839"></p></li></ul><h3 id="maxmemory-samples"><a href="#maxmemory-samples" class="headerlink" title="maxmemory-samples"></a>maxmemory-samples</h3><ul><li><p><strong>设置LRU算法和最小TTL算法执行时检查的样本规模</strong>，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。</p></li><li><p><strong>一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221009115057158.png" alt="image-20221009115057158"></p></li></ul><h1 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h1><h2 id="什么是发布和订阅"><a href="#什么是发布和订阅" class="headerlink" title="什么是发布和订阅"></a>什么是发布和订阅</h2><ul><li>Redis 发布订阅 (pub&#x2F;sub) 是一种消息通信模式：<strong>发送者 (pub) 发送消息，订阅者 (sub) 接收消息</strong>。</li><li>Redis客户端可以订阅任意数量的频道。</li></ul><h2 id="Redis的发布和订阅-1"><a href="#Redis的发布和订阅-1" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h2><ul><li><p>客户端可以订阅频道，如下图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010101505044.png" alt="image-20221010101505044"></p></li><li><p>当另一个客户端给这个频道发布消息后，消息就会发送给订阅的客户端：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010101548295.png" alt="image-20221010101548295"></p></li></ul><h2 id="发布订阅的命令行实现"><a href="#发布订阅的命令行实现" class="headerlink" title="发布订阅的命令行实现"></a>发布订阅的命令行实现</h2><ol><li><p>打开一个客户端订阅channel1：<strong>SUBSCRIBE channel1</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010101704069.png" alt="image-20221010101704069"></p></li><li><p>打开另一个客户端，给channel1发布消息hello：<strong>publish channel1 hello</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010101934952.png" alt="image-20221010101934952"></p><p>返回的1是订阅者的数量。</p></li><li><p>打开第一个客户端可以看到发送的消息：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010102101292.png" alt="image-20221010102101292"></p><p>注：发布的消息没有持久化。</p></li></ol><h1 id="Redis新数据类型"><a href="#Redis新数据类型" class="headerlink" title="Redis新数据类型"></a>Redis新数据类型</h1><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><ul><li><p>现代计算机用二进制（位） 作为信息的基础单位， <strong>1个字节等于8位</strong>， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010102548868.png" alt="image-20221010102548868"></p><p><strong>合理地使用操作位能够有效地提高内存使用率和开发效率</strong>。</p></li><li><p>Redis提供了<strong>Bitmaps</strong>这个“数据类型”可以<strong>实现对位的操作</strong>：</p><ol><li>Bitmaps本身不是一种数据类型， <strong>实际上它就是Map&lt;key,String&gt;<strong>， 但是</strong>它可以对字符串的位进行操作</strong>。</li><li>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以<strong>把Bitmaps想象成一个以位为单位的数组</strong>， <strong>数组的每个单元只能存储0和1</strong>， <strong>数组的下标在Bitmaps中叫做偏移量</strong>。</li></ol><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010102819858.png" alt="image-20221010102819858"></p></li></ul><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul><li><p>setbit：</p><ol><li><p>格式：</p><p><strong>setbit &lt;key&gt; &lt;offset&gt; &lt;value&gt;<strong>：</strong>设置Bitmaps中某个value的偏移量的值（0或1）</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010103405710.png" alt="image-20221010103405710"></p><p>offset：偏移量从0开始</p></li><li><p>实例：</p><p><strong>每个独立用户是否访问过网站存放在Bitmaps中</strong>， 将访问的用户记做1， 没有访问的用户记做0， <strong>用偏移量作为用户的id</strong>。</p><p>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid&#x3D;1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010103548835.png" alt="image-20221010103548835"></p><p>unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010103743958.png" alt="image-20221010103743958"></p><p>注：很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是<strong>每次做setbit操作时将用户id减去这个指定数字</strong>。<strong>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞</strong>。</p></li></ol></li><li><p>getbit：</p><ol><li><p>格式：</p><p><strong>getbit &lt;key&gt; &lt;offset&gt;<strong>：</strong>获取Bitmaps中某个value的偏移量的值</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010104454677.png" alt="image-20221010104454677"></p><p>获取键对应值的第offset位的值（从0开始算）</p></li><li><p>实例：</p><p>获取id&#x3D;8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010104554699.png" alt="image-20221010104554699"></p><p>注：因为100根本不存在，所以也是返回0。</p></li></ol></li><li><p>bitcount：<strong>统计字符串被设置为1的bit数</strong>。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。</p><ol><li><p>格式：</p><p><strong>bitcount &lt;key&gt; [start end]<strong>：统计字符串从start</strong>字节</strong>到end<strong>字节</strong>（左右都是闭）比特值为1的数量</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010104852283.png" alt="image-20221010104852283"></p></li><li><p>实例：</p><p>计算2022-11-06这天的独立访问用户数量</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010104922486.png" alt="image-20221010104922486"></p><p><strong>start和end代表起始和结束字节数</strong>， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。</p></li><li><p>举例：K1 【01000001 01000000  00000000 00100001】，对应【0，1，2，3】字节bitcount K1 0 -2  ： 统计下标0到下标倒数第2，字节组中bit&#x3D;1的个数，即01000001  01000000  00000000中bit&#x3D;1的个数，结果是3</p></li></ol><p>注意：<strong>redis的setbit设置或清除是以bit为单位，而bitcount计算是以byte区间为单位</strong>。</p></li><li><p>bitop：</p><ol><li><p>格式：</p><p>**bitop and(or&#x2F;not&#x2F;xor) &lt;destkey&gt; [key…]**：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010112055534.png" alt="image-20221010112055534"></p><p>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集）&#x2F; or（并集） &#x2F;not（非）&#x2F;xor（异或） 操作并将结果保存在destkey中。</p></li><li><p>实例：</p><p>计算出两天都访问过网站的用户数量：<strong>bitop and unique:users:and:20201104_03 unique:users:20201103 unique:users:20201104</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010112529496.png" alt="image-20221010112529496"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010112605365.png" alt="image-20221010112605365"></p><p>计算出任意一天访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集：<strong>bitop or unique:users:or:20201104_03 unique:users:20201103 unique:users:20201104</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010112834145.png" alt="image-20221010112834145"></p></li></ol></li></ul><h3 id="Bitmaps与set对比"><a href="#Bitmaps与set对比" class="headerlink" title="Bitmaps与set对比"></a>Bitmaps与set对比</h3><ul><li><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010112959645.png" alt="image-20221010112959645"></p></li><li><p>很明显，<strong>假如该网站每天的独立访问用户很多</strong>， <strong>这种情况下使用Bitmaps能节省很多的内存空间</strong>， 尤其是随着时间推移节省的内存还是非常可观的：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010113056084.png" alt="image-20221010113056084"></p></li><li><p>但Bitmaps并不是万金油， <strong>假如该网站每天的独立访问用户很少</strong>， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， <strong>这时候使用Bitmaps就不太合适了</strong>， 因为基本上大部分位都是0：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010113311567.png" alt="image-20221010113311567"></p></li></ul><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><ul><li><p>在工作当中，我们经常会遇到<strong>与统计相关的功能需求</strong>，比如统计网站PV（PageView页面访问量）,<strong>可以使用Redis的incr、incrby轻松实现</strong>。</p></li><li><p>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种<strong>求集合中不重复元素个数的问题称为基数问题</strong>。</p></li><li><p>解决基数问题有很多种方案：</p><ol><li>数据存储在MySQL表中，使用distinct count计算不重复个数</li><li>使用Redis提供的hash、set、bitmaps等数据结构来处理</li></ol><p>以上的方案结果精确，但<strong>随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的</strong>。能否能够<strong>降低一定的精度来平衡存储空间</strong>？针对这个问题Redis推出了HyperLogLog。</p></li><li><p>Redis HyperLogLog 是<strong>用来做基数统计的算法</strong>，HyperLogLog 的优点是，<strong>在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的</strong>。</p></li><li><p>在 Redis 里面，<strong>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数</strong>。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p></li><li><p>什么是基数？其实就是<strong>一个数据集中不重复元素的个数</strong>，比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p></li></ul><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><ul><li><p>pfadd：</p><ol><li><p>格式：</p><p>**pfadd &lt;key&gt; &lt; element&gt; [element …]**：添加指定元素到HyperLogLog中</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011093114682.png" alt="image-20221011093114682"></p></li><li><p>实例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011093200199.png" alt="image-20221011093200199"></p><p>将所有元素添加到指定HyperLogLog数据结构中。<strong>如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0</strong>。</p></li></ol></li><li><p>pfcount：</p><ol><li><p>格式：</p><p><strong>pfcount &lt;key&gt; [key …]<strong>：计算HLL的近似基数，</strong>可以计算多个HLL并集的基数</strong>，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011093442399.png" alt="image-20221011093442399"></p></li><li><p>实例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011093504462.png" alt="image-20221011093504462"></p></li></ol></li><li><p>pfmerge：</p><ol><li><p>格式：</p><p><strong>pfmerge &lt;destkey&gt; &lt;sourcekey&gt; [sourcekey …]<strong>：</strong>将一个或多个HLL合并后的结果存储在另一个HLL中</strong>，比如每月活跃用户可以使用每天的活跃用户来合并计算可得。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011093653921.png" alt="image-20221011093653921"></p></li><li><p>实例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011093717593.png" alt="image-20221011093717593"></p></li></ol></li></ul><h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h2><h3 id="简介-8"><a href="#简介-8" class="headerlink" title="简介"></a>简介</h3><ul><li>Redis 3.2 中<strong>增加了对GEO类型的支持</strong>。GEO，Geographic，地理信息的缩写。<strong>该类型，就是元素的2维坐标，在地图上就是经纬度</strong>。redis基于该类型，<strong>提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作</strong>。</li></ul><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><ul><li><p>geoadd：</p><ol><li><p>格式：</p><p>**geoadd &lt;key&gt; &lt; longitude&gt; &lt;latitude&gt; &lt;member&gt; [longitude latitude member…]**：添加地理位置（经度，纬度，名称）</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011095713245.png" alt="image-20221011095713245"></p></li><li><p>实例：</p><p>geoadd china:city 121.47 31.23 shanghai</p><p>geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011095900818.png" alt="image-20221011095900818"></p><p><strong>两极地区无法直接添加</strong>，一般会下载城市数据，直接通过 Java 程序一次性导入。</p><p><strong>有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度</strong>。</p><p><strong>当坐标位置超出指定范围时，该命令将会返回一个错误</strong>。</p><p><strong>已经添加的数据，是无法再次往里面添加的</strong>。</p></li></ol></li><li><p>geopos：</p><ol><li><p>格式：</p><p>**geopos  &lt;key&gt; &lt;member&gt; [member…]**：获得指定地区的坐标值</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011100158382.png" alt="image-20221011100158382"></p></li><li><p>实例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011100217221.png" alt="image-20221011100217221"></p></li></ol></li><li><p>geodist：</p><ol><li><p>格式：</p><p>geodist &lt;key&gt; &lt;member1&gt; &lt;member2&gt;  [m|km|ft|mi ]：获取两个位置之间的直线距离</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011100306916.png" alt="image-20221011100306916"></p></li><li><p>实例：</p><p>获取两个位置之间的直线距离</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011100332658.png" alt="image-20221011100332658"></p><p>单位：</p><p>m 表示单位为米[默认值]。</p><p>km 表示单位为千米。</p><p>mi 表示单位为英里。</p><p>ft 表示单位为英尺。</p><p><strong>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</strong>。</p></li></ol></li><li><p>georadius：</p><ol><li><p>格式：</p><p>georadius &lt;key&gt; &lt; longitude&gt; &lt;latitude&gt; &lt;radius&gt; m|km|ft|mi  以给定的经纬度为中心，找出某一半径内的元素</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011120642761.png" alt="image-20221011120642761"></p></li><li><p>实例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011120719951.png" alt="image-20221011120719951"></p></li></ol></li></ul><h1 id="Java操作Redis（使用Jedis）测试"><a href="#Java操作Redis（使用Jedis）测试" class="headerlink" title="Java操作Redis（使用Jedis）测试"></a>Java操作Redis（使用Jedis）测试</h1><h2 id="Jedis所需要的jar包"><a href="#Jedis所需要的jar包" class="headerlink" title="Jedis所需要的jar包"></a>Jedis所需要的jar包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="连接Redis注意事项"><a href="#连接Redis注意事项" class="headerlink" title="连接Redis注意事项"></a>连接Redis注意事项</h2><ul><li>禁用Linux的防火墙：Linux(CentOS7)里执行命令<strong>systemctl stop&#x2F;disable firewalld.service</strong></li><li>redis.conf中<strong>注释掉bind 127.0.0.1</strong>,然后<strong>protected-mode no</strong></li></ul><h2 id="Jedis常用操作"><a href="#Jedis常用操作" class="headerlink" title="Jedis常用操作"></a>Jedis常用操作</h2><h3 id="创建动态的工程"><a href="#创建动态的工程" class="headerlink" title="创建动态的工程"></a>创建动态的工程</h3><h3 id="创建测试程序"><a href="#创建测试程序" class="headerlink" title="创建测试程序"></a>创建测试程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.137.3&quot;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">pong</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">System.out.println(<span class="string">&quot;连接成功：&quot;</span>+pong);</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试相关数据类型"><a href="#测试相关数据类型" class="headerlink" title="测试相关数据类型"></a>测试相关数据类型</h2><h3 id="Jedis-API：key"><a href="#Jedis-API：key" class="headerlink" title="Jedis-API：key"></a>Jedis-API：key</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jedis.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);<span class="comment">//向redis中存入数据</span></span><br><span class="line">jedis.set(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">jedis.set(<span class="string">&quot;k3&quot;</span>, <span class="string">&quot;v3&quot;</span>);</span><br><span class="line">Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);<span class="comment">//获取所有key？</span></span><br><span class="line">System.out.println(keys.size());</span><br><span class="line"><span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">System.out.println(key);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(jedis.exists(<span class="string">&quot;k1&quot;</span>));<span class="comment">//redis中是否存在指定key</span></span><br><span class="line">System.out.println(jedis.ttl(<span class="string">&quot;k1&quot;</span>));<span class="comment">//常看指定key的过期时间</span></span><br><span class="line">System.out.println(jedis.get(<span class="string">&quot;k1&quot;</span>));<span class="comment">//获取指定key对应的值</span></span><br></pre></td></tr></table></figure><h3 id="Jedis-API：String"><a href="#Jedis-API：String" class="headerlink" title="Jedis-API：String"></a>Jedis-API：String</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jedis.mset(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;v2&quot;</span>,<span class="string">&quot;str3&quot;</span>,<span class="string">&quot;v3&quot;</span>);<span class="comment">//批量添加数据</span></span><br><span class="line">System.out.println(jedis.mget(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;str3&quot;</span>));<span class="comment">//批量获取数据</span></span><br></pre></td></tr></table></figure><h3 id="Jedis-API：List"><a href="#Jedis-API：List" class="headerlink" title="Jedis-API：List"></a>Jedis-API：List</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = jedis.lrange(<span class="string">&quot;mylist&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);<span class="comment">//取出List指定范围内的数据</span></span><br><span class="line"><span class="keyword">for</span> (String element : list) &#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jedis-API：set"><a href="#Jedis-API：set" class="headerlink" title="Jedis-API：set"></a>Jedis-API：set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order01&quot;</span>);<span class="comment">//向对应的set中添加数据</span></span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order02&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order03&quot;</span>);</span><br><span class="line">jedis.sadd(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order04&quot;</span>);</span><br><span class="line">Set&lt;String&gt; smembers = jedis.smembers(<span class="string">&quot;orders&quot;</span>);<span class="comment">//获取指定set中的所有数据</span></span><br><span class="line"><span class="keyword">for</span> (String order : smembers) &#123;</span><br><span class="line">System.out.println(order);</span><br><span class="line">&#125;</span><br><span class="line">jedis.srem(<span class="string">&quot;orders&quot;</span>, <span class="string">&quot;order02&quot;</span>);<span class="comment">//删除指定set中的指定元素</span></span><br></pre></td></tr></table></figure><h3 id="Jedis-API：hash"><a href="#Jedis-API：hash" class="headerlink" title="Jedis-API：hash"></a>Jedis-API：hash</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jedis.hset(<span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;lisi&quot;</span>);<span class="comment">//向指定的hash中添加键值对</span></span><br><span class="line">System.out.println(jedis.hget(<span class="string">&quot;hash1&quot;</span>,<span class="string">&quot;userName&quot;</span>));<span class="comment">//获取指定hash中的指定key的值</span></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">map.put(<span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;13810169999&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;abc@163.com&quot;</span>);</span><br><span class="line">jedis.hmset(<span class="string">&quot;hash2&quot;</span>,map);<span class="comment">//批量向指定的hash中添加键值对</span></span><br><span class="line">List&lt;String&gt; result = jedis.hmget(<span class="string">&quot;hash2&quot;</span>, <span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;email&quot;</span>);<span class="comment">//批量获取指定的hash中的指定key的值</span></span><br><span class="line"><span class="keyword">for</span> (String element : result) &#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jedis-API：zset"><a href="#Jedis-API：zset" class="headerlink" title="Jedis-API：zset"></a>Jedis-API：zset</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">100d</span>, <span class="string">&quot;z3&quot;</span>);<span class="comment">//向有序集合中添加数据并设置评分</span></span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">90d</span>, <span class="string">&quot;l4&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">80d</span>, <span class="string">&quot;w5&quot;</span>);</span><br><span class="line">jedis.zadd(<span class="string">&quot;zset01&quot;</span>, <span class="number">70d</span>, <span class="string">&quot;z6&quot;</span>);</span><br><span class="line"> </span><br><span class="line">Set&lt;String&gt; zrange = jedis.zrange(<span class="string">&quot;zset01&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);<span class="comment">//获取指定有序集合中指定范围的数据</span></span><br><span class="line"><span class="keyword">for</span> (String e : zrange) &#123;</span><br><span class="line">System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Jedis实例"><a href="#Jedis实例" class="headerlink" title="Jedis实例"></a>Jedis实例</h1><h2 id="完成一个手机验证码功能"><a href="#完成一个手机验证码功能" class="headerlink" title="完成一个手机验证码功能"></a>完成一个手机验证码功能</h2><ul><li>要求：<ol><li>输入手机号，点击发送后随机生成6位数字码，2分钟有效</li><li>输入验证码，点击验证，返回成功或失败</li><li>每个手机号每天只能输入3次</li></ol></li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221012180940414.png" alt="image-20221012180940414"></p><h1 id="Redis与Spring-Boot整合"><a href="#Redis与Spring-Boot整合" class="headerlink" title="Redis与Spring Boot整合"></a>Redis与Spring Boot整合</h1><ul><li>Spring Boot整合Redis非常简单，只需要按照如下步骤进行整合即可。</li></ul><h2 id="整合步骤"><a href="#整合步骤" class="headerlink" title="整合步骤"></a>整合步骤</h2><ol><li><p>在pom.xml文件中引入redis相关依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- spring2.X集成redis所需common-pool2，这东西是个redis的连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在application.properties中配置redis的配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">192.168.140.136</span></span><br><span class="line"><span class="comment">#Redis服务器连接端口</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="attr">spring.redis.database</span>= <span class="string">0</span></span><br><span class="line"><span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line"><span class="attr">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-idle</span>=<span class="string">5</span></span><br><span class="line"><span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure></li><li><p>添加redis配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> <span class="keyword">extends</span> <span class="title class_">CachingConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"><span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line"><span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"><span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"><span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"><span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        <span class="type">RedisCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进行测试，创建RedisTestController并向其中添加测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">testRedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置值到redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        <span class="comment">//从redis获取值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String)redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><h2 id="Redis的事务定义"><a href="#Redis的事务定义" class="headerlink" title="Redis的事务定义"></a>Redis的事务定义</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221012181544824.png" alt="image-20221012181544824"></p><ul><li>Redis事务<strong>是一个单独的隔离操作</strong>：事务中的所有命令都会<strong>序列化、按顺序地执行</strong>。<strong>事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</strong>。</li><li>Redis事务的<strong>主要作用就是串联多个命令防止别的命令插队</strong>。</li></ul><h2 id="Multi、Exec、discard"><a href="#Multi、Exec、discard" class="headerlink" title="Multi、Exec、discard"></a>Multi、Exec、discard</h2><ul><li><p>从输入<strong>Multi</strong>命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入<strong>Exec</strong>后，Redis会将之前的命令队列中的命令依次执行。</p></li><li><p>组队的过程中可以通过<strong>discard</strong>来放弃组队，放弃组队后之前组的队也无了。</p></li><li><p>案例：</p><p>组队成功，提交成功：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221012182056645.png" alt="image-20221012182056645"></p><p>组队阶段报错，会提交失败：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221012182212710.png" alt="image-20221012182212710"></p><p>组队成功，提交时有失败的不会影响到成功的：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221012182343240.png" alt="image-20221012182343240"></p></li></ul><h2 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a>事务的错误处理</h2><ul><li><p><strong>组队中</strong>某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221012182611402.png" alt="image-20221012182611402"></p></li><li><p>如果<strong>执行阶段</strong>某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221012182757980.png" alt="image-20221012182757980"></p></li></ul><h2 id="为什么要做成事务"><a href="#为什么要做成事务" class="headerlink" title="为什么要做成事务"></a>为什么要做成事务</h2><ul><li>如果没有了事务带来的隔离性，那么在高并发的场景下就会造成事务之间的冲突（同步问题）。</li></ul><h2 id="事务冲突的问题"><a href="#事务冲突的问题" class="headerlink" title="事务冲突的问题"></a>事务冲突的问题</h2><ul><li>就是类似于线程之间的同步问题。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li><p>账户里有10000块钱，一个请求想给金额减8000，一个请求想给金额减5000，一个请求想给金额减1000。按理说如果要是账户里的金额不够的话要拒绝减金额的操作，但是如果事务之间没有隔离性，那么在判断阶段，<strong>这三个操作可能同时被判断为可以减掉指定的数额</strong>，所以会导致最后的数据出现异常，这就是事务冲突。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221013092935421.png" alt="image-20221013092935421"></p></li></ul><h2 id="Redis事务三特性"><a href="#Redis事务三特性" class="headerlink" title="Redis事务三特性"></a>Redis事务三特性</h2><ol><li><strong>单独的隔离操作</strong>：事务中的所有命令都会<strong>序列化、按顺序地执行</strong>。<strong>事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</strong>。</li><li><strong>没有隔离级别的概念</strong>：队列中的命令没有提交之前都不会实际被执行，因为<strong>事务提交前任何指令都不会被实际执行</strong>。</li><li><strong>不保证原子性</strong>：事务中<strong>如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</strong>。</li></ol><h1 id="Redis锁"><a href="#Redis锁" class="headerlink" title="Redis锁"></a>Redis锁</h1><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><ul><li><p><strong>悲观锁(Pessimistic Lock)</strong>, 顾名思义，就是<strong>很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁</strong>。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>，<strong>表锁</strong>等，<strong>读锁</strong>，<strong>写锁</strong>等，都是在做操作之前先上锁。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221013093157920.png" alt="image-20221013093157920"></p></li></ul><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><ul><li><p><strong>乐观锁(Optimistic Lock)</strong>,顾名思义，就是<strong>很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制</strong>。乐观锁<strong>适用于多读的应用类型</strong>，这样<strong>可以提高吞吐量</strong>。Redis就是利用这种check-and-set机制实现事务的。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221013093512211.png" alt="image-20221013093512211"></p></li></ul><h1 id="Redis运用事务的秒杀案例"><a href="#Redis运用事务的秒杀案例" class="headerlink" title="Redis运用事务的秒杀案例"></a>Redis运用事务的秒杀案例</h1><ul><li>就是各大电商平台搞活动的时候搞得那种限时抢多少个特价商品的那种情况。</li></ul><h2 id="解决计数器和人员记录的事务操作"><a href="#解决计数器和人员记录的事务操作" class="headerlink" title="解决计数器和人员记录的事务操作"></a>解决计数器和人员记录的事务操作</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014084815738.png" alt="image-20221014084815738"></p><h2 id="秒杀并发模拟"><a href="#秒杀并发模拟" class="headerlink" title="秒杀并发模拟"></a>秒杀并发模拟</h2><ul><li>使用工具ab模拟测试</li><li>CentOS6默认安装，CentOS7需要手动安装</li></ul><h3 id="联网安装ab"><a href="#联网安装ab" class="headerlink" title="联网安装ab"></a>联网安装ab</h3><ul><li>使用命令：<strong>yum install httpd-tools</strong></li></ul><h3 id="无网络安装ab"><a href="#无网络安装ab" class="headerlink" title="无网络安装ab"></a>无网络安装ab</h3><ul><li>进入cd  &#x2F;run&#x2F;media&#x2F;root&#x2F;CentOS 7 x86_64&#x2F;Packages（路径跟centos6不同）</li><li>顺序安装：<ol><li>apr-1.4.8-3.el7.x86_64.rpm</li><li>apr-util-1.5.2-6.el7.x86_64.rpm</li><li>httpd-tools-2.4.6-67.el7.centos.x86_64.rpm</li></ol></li></ul><h3 id="通过ab测试"><a href="#通过ab测试" class="headerlink" title="通过ab测试"></a>通过ab测试</h3><ul><li>在自定义的目录下，通过<strong>vim postfile</strong>新建文件填写模拟表单提交的参数，以&amp;符号结尾，文件会存放到当前目录中。样例内容：prodid&#x3D;0101&amp;</li><li>然后通过ab提供的命令进行测试：<strong>ab -n 请求数 -c 并发线程数 -k -p 参数文件 -T 请求报文数据类型 请求地址</strong></li><li>命令示例：ab -n 2000 -c 200 -k -p ~&#x2F;postfile -T application&#x2F;x-www-form-urlencoded <a href="http://192.168.2.115:8081/Seckill/doseckill">http://192.168.2.115:8081/Seckill/doseckill</a></li></ul><h3 id="经过ab的测试，发现了超卖的异常情况"><a href="#经过ab的测试，发现了超卖的异常情况" class="headerlink" title="经过ab的测试，发现了超卖的异常情况"></a>经过ab的测试，发现了超卖的异常情况</h3><ul><li><p>到最后商品剩余数量变为-1，很明显这是一个异常的数据。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014090958746.png" alt="image-20221014090958746"></p></li></ul><h2 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h2><ul><li><p>就是线程同步的问题，高并发的情况下如果不采取一定的线程同步措施，那么<strong>线程之间由于缺少隔离性又没有同步措施会互相产生干扰</strong>，影响最后的结果。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014091557208.png" alt="image-20221014091557208"></p></li></ul><h2 id="利用乐观锁淘汰用户，解决超卖问题"><a href="#利用乐观锁淘汰用户，解决超卖问题" class="headerlink" title="利用乐观锁淘汰用户，解决超卖问题"></a>利用乐观锁淘汰用户，解决超卖问题</h2><ul><li><p>让用户每次修改完数据之后改变数据的版本号，这样如果之前有取到同一版本号的数据的另一个线程后来到达之后就不会再修改数据了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014091854452.png" alt="image-20221014091854452"></p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加乐观锁</span></span><br><span class="line">jedis.watch(qtkey);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//3.判断库存</span></span><br><span class="line"><span class="type">String</span> <span class="variable">qtkeystr</span> <span class="operator">=</span> jedis.get(qtkey);</span><br><span class="line"><span class="keyword">if</span>(qtkeystr==<span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(qtkeystr.trim())) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;未初始化库存&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="variable">qt</span> <span class="operator">=</span> Integer.parseInt(qtkeystr);</span><br><span class="line"><span class="keyword">if</span>(qt&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">System.err.println(<span class="string">&quot;已经秒光&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//增加事务</span></span><br><span class="line"><span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//4.减少库存</span></span><br><span class="line"><span class="comment">//jedis.decr(qtkey);</span></span><br><span class="line">multi.decr(qtkey);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//5.加人</span></span><br><span class="line"><span class="comment">//jedis.sadd(usrkey, uid);</span></span><br><span class="line">multi.sadd(usrkey, uid);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//执行事务</span></span><br><span class="line">List&lt;Object&gt; list = multi.exec();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//判断事务提交是否失败</span></span><br><span class="line"><span class="keyword">if</span>(list==<span class="literal">null</span> || list.size()==<span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;秒杀失败&quot;</span>);</span><br><span class="line">jedis.close();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.err.println(<span class="string">&quot;秒杀成功&quot;</span>);</span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure></li><li><p>在使用乐观锁后，超卖问题被解决了：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014092118630.png" alt="image-20221014092118630"></p></li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014092146669.png" alt="image-20221014092146669"></p><h2 id="继续增加并发测试"><a href="#继续增加并发测试" class="headerlink" title="继续增加并发测试"></a>继续增加并发测试</h2><h3 id="连接有限制"><a href="#连接有限制" class="headerlink" title="连接有限制"></a>连接有限制</h3><ul><li><p>在使用ab命令进行并发测试的时候报连接被拒绝的错误：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014092802618.png" alt="image-20221014092802618"></p></li><li><p>通过在请求中增加-r参数解决，**-r，Don’t exit on socket receive errors**。</p></li><li><p>命令示例：ab -n 2000 -c 100 -r -p postfile -T ‘application&#x2F;x-www-form-urlencoded’ <a href="http://192.168.140.1:8080/seckill/doseckill">http://192.168.140.1:8080/seckill/doseckill</a></p></li></ul><h3 id="已经秒光，可是还有库存（库存遗留问题）"><a href="#已经秒光，可是还有库存（库存遗留问题）" class="headerlink" title="已经秒光，可是还有库存（库存遗留问题）"></a>已经秒光，可是还有库存（库存遗留问题）</h3><ul><li><p>ab -n 2000 -c 100 -p postfile -T ‘application&#x2F;x-www-form-urlencoded’ <a href="http://192.168.137.1:8080/seckill/doseckill">http://192.168.137.1:8080/seckill/doseckill</a></p></li><li><p>已经秒光，可是还有库存。原因就是<strong>乐观锁导致很多请求都失败</strong>，而请求一共就那么多。先点的没秒到，后点的可能秒到了。</p></li><li><p>解决思路可以从请求发现数据的版本号不对后重新请求或者赋予请求原子性出发。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014093459750.png" alt="image-20221014093459750"></p></li></ul><h3 id="连接超时，通过连接池解决"><a href="#连接超时，通过连接池解决" class="headerlink" title="连接超时，通过连接池解决"></a>连接超时，通过连接池解决</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014093634038.png" alt="image-20221014093634038"></p><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><ul><li>通过参数管理连接的行为，节省每次连接redis服务带来的消耗，把连接好的实例反复利用。</li><li>链接池参数：<ul><li><strong>MaxTotal</strong>：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。</li><li><strong>maxIdle</strong>：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；</li><li><strong>MaxWaitMillis</strong>：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException；</li><li><strong>testOnBorrow</strong>：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的；</li></ul></li></ul><h2 id="解决库存遗留问题"><a href="#解决库存遗留问题" class="headerlink" title="解决库存遗留问题"></a>解决库存遗留问题</h2><h3 id="LUA脚本"><a href="#LUA脚本" class="headerlink" title="LUA脚本"></a>LUA脚本</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014111425136.png" alt="image-20221014111425136"></p><ul><li>Lua 是一个小巧的<a href="http://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a>，Lua脚本可以很容易的被C&#x2F;C++ 代码调用，也可以反过来调用C&#x2F;C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以Lua不适合作为开发独立应用程序的语言，而是<strong>作为嵌入式脚本语言</strong>。</li><li>很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现<strong>可配置性、可扩展性</strong>。</li><li>这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。</li><li><a href="https://www.w3cschool.cn/lua/">教程链接</a></li></ul><h3 id="LUA脚本在Redis中的优势"><a href="#LUA脚本在Redis中的优势" class="headerlink" title="LUA脚本在Redis中的优势"></a>LUA脚本在Redis中的优势</h3><ul><li><p><strong>将复杂的或者多步的redis操作，写为一个脚本</strong>，一次提交给redis执行，减少反复连接redis的次数。提升性能。</p></li><li><p>LUA脚本是类似redis事务，<strong>有一定的原子性，不会被其他命令插队</strong>，可以完成一些redis事务性的操作。</p></li><li><p>但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。</p></li><li><p>可以利用lua脚本淘汰用户，解决超卖问题</p></li><li><p>redis 2.6版本以后，通过lua脚本解决<strong>争抢问题</strong>，实际上是<strong>redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014112011027.png" alt="image-20221014112011027"></p></li></ul><h2 id="秒杀案例代码"><a href="#秒杀案例代码" class="headerlink" title="秒杀案例代码"></a>秒杀案例代码</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014112057581.png" alt="image-20221014112057581"></p><h3 id="第一版：简单版"><a href="#第一版：简单版" class="headerlink" title="第一版：简单版"></a>第一版：简单版</h3><ul><li>使用ab模拟并发测试，会出现超卖情况，查看库存会出现负数。</li></ul><h3 id="第二版：加事务-x2F-乐观锁（解决超卖问题），但会出现遗留库存和连接超时的问题"><a href="#第二版：加事务-x2F-乐观锁（解决超卖问题），但会出现遗留库存和连接超时的问题" class="headerlink" title="第二版：加事务&#x2F;乐观锁（解决超卖问题），但会出现遗留库存和连接超时的问题"></a>第二版：加事务&#x2F;乐观锁（解决超卖问题），但会出现遗留库存和连接超时的问题</h3><h3 id="第三版：用连接池解决超时问题"><a href="#第三版：用连接池解决超时问题" class="headerlink" title="第三版：用连接池解决超时问题"></a>第三版：用连接池解决超时问题</h3><h3 id="第四版：用LUA脚本解决库存依赖问题（实现方式是不是有点像悲观锁？）"><a href="#第四版：用LUA脚本解决库存依赖问题（实现方式是不是有点像悲观锁？）" class="headerlink" title="第四版：用LUA脚本解决库存依赖问题（实现方式是不是有点像悲观锁？）"></a>第四版：用LUA脚本解决库存依赖问题（实现方式是不是有点像悲观锁？）</h3><ul><li><p>lua脚本示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">local userid=KEYS[<span class="number">1</span>]; </span><br><span class="line">local prodid=KEYS[<span class="number">2</span>];</span><br><span class="line">local qtkey=<span class="string">&quot;sk:&quot;</span>..prodid..<span class="string">&quot;:qt&quot;</span>;</span><br><span class="line">local usersKey=<span class="string">&quot;sk:&quot;</span>..prodid.<span class="string">&quot;:usr&#x27;; </span></span><br><span class="line"><span class="string">local userExists=redis.call(&quot;</span>sismember<span class="string">&quot;,usersKey,userid);</span></span><br><span class="line"><span class="string">if tonumber(userExists)==1 then </span></span><br><span class="line"><span class="string">  return 2;</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">local num= redis.call(&quot;</span>get<span class="string">&quot; ,qtkey);</span></span><br><span class="line"><span class="string">if tonumber(num)&lt;=0 then </span></span><br><span class="line"><span class="string">  return 0; </span></span><br><span class="line"><span class="string">else </span></span><br><span class="line"><span class="string">  redis.call(&quot;</span>decr<span class="string">&quot;,qtkey);</span></span><br><span class="line"><span class="string">  redis.call(&quot;</span>sadd<span class="string">&quot;,usersKey,userid);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">return 1;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h2><ul><li><p>官网介绍：<strong><a href="http://www.redis.io/">http://www.redis.io</a></strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014112951511.png" alt="image-20221014112951511"></p></li><li><p>由官网信息得知，Redis提供了两个不同形式的持久化方式：</p><ol><li><strong>RDB（Redis DataBase）</strong></li><li><strong>AOF（Append Of File）</strong></li></ol></li></ul><h2 id="RDB（Redis-DataBase）"><a href="#RDB（Redis-DataBase）" class="headerlink" title="RDB（Redis DataBase）"></a>RDB（Redis DataBase）</h2><h3 id="官网介绍"><a href="#官网介绍" class="headerlink" title="官网介绍"></a>官网介绍</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014113334621.png" alt="image-20221014113334621"></p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul><li><strong>在指定的时间间隔内将内存中的数据集快照写入磁盘</strong>， 也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</li></ul><h3 id="备份是如何执行的"><a href="#备份是如何执行的" class="headerlink" title="备份是如何执行的"></a>备份是如何执行的</h3><ul><li>Redis会<strong>单独创建（fork）一个子进程来进行持久化</strong>，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 <strong>整个过程中，主进程是不进行任何IO操作的</strong>，这就确保了极高的性能，<strong>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效</strong>。<strong>RDB的缺点是最后一次持久化后的数据可能丢失</strong>。</li></ul><h3 id="Fork"><a href="#Fork" class="headerlink" title="Fork"></a>Fork</h3><ul><li>Fork的作用是<strong>复制一个与当前进程一样的进程</strong>。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并<strong>作为原进程的子进程</strong>。</li><li>在Linux程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，Linux中引入了“<strong>写时复制技术</strong>”</li><li><strong>写时复制技术：一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</strong>。</li></ul><h3 id="RDB持久化流程"><a href="#RDB持久化流程" class="headerlink" title="RDB持久化流程"></a>RDB持久化流程</h3><ul><li>注意子进程在进行生成RDB文件时是<strong>先将数据写到一个临时文件中，写完之后将临时文件和之前的RDB文件进行替换</strong>，这个图里对这一点体现的不明显。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014114220988.png" alt="image-20221014114220988"></p><h3 id="配置rdb文件生成的名称"><a href="#配置rdb文件生成的名称" class="headerlink" title="配置rdb文件生成的名称"></a>配置rdb文件生成的名称</h3><ul><li><p>rdb文件就是每次进行RDB持久化后生成的数据文件</p></li><li><p>我们可以在redis.conf中配置文件名称，默认为dump.rdb</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014114650591.png" alt="image-20221014114650591"></p></li></ul><h3 id="配置rdb文件生成的位置"><a href="#配置rdb文件生成的位置" class="headerlink" title="配置rdb文件生成的位置"></a>配置rdb文件生成的位置</h3><ul><li><p>rdb文件的保存路径，也可以修改。默认为Redis启动时命令行所在的目录下</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014114806183.png" alt="image-20221014114806183"></p></li></ul><h3 id="如何触发RDB快照（快照策略）"><a href="#如何触发RDB快照（快照策略）" class="headerlink" title="如何触发RDB快照（快照策略）"></a>如何触发RDB快照（快照策略）</h3><h4 id="配置文件中默认的快照配置"><a href="#配置文件中默认的快照配置" class="headerlink" title="配置文件中默认的快照配置"></a>配置文件中默认的快照配置</h4><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014115049725.png" alt="image-20221014115049725"></p><h4 id="命令-save-vs-bgsave"><a href="#命令-save-vs-bgsave" class="headerlink" title="命令 save vs bgsave"></a>命令 save vs bgsave</h4><ul><li>save ：save时只管保存，其它不管，全部阻塞。手动保存。<strong>不建议</strong>。</li><li><strong>bgsave：Redis会在后台异步进行快照操作， 快照同时还可以响应客户端请求。</strong></li><li>可以通过lastsave 命令<strong>获取最后一次成功执行快照的时间</strong></li></ul><h4 id="flushall命令"><a href="#flushall命令" class="headerlink" title="flushall命令"></a>flushall命令</h4><ul><li>执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义</li></ul><h3 id="SNAPSHOTTING快照配置"><a href="#SNAPSHOTTING快照配置" class="headerlink" title="SNAPSHOTTING快照配置"></a>SNAPSHOTTING快照配置</h3><h4 id="save"><a href="#save" class="headerlink" title="save"></a>save</h4><ul><li>格式：<strong>save 秒数 写操作次数</strong>，指<strong>在规定秒数内写操作次数达到指定的操作次数就会触发快照</strong>，RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件，默认是1分钟内改了1万次，或者五分钟内改了10次，或者15分钟内改了1次。</li><li>禁用：不设置save指令，或者给save传入空字符串</li></ul><h4 id="stop-writes-on-bgsave-error"><a href="#stop-writes-on-bgsave-error" class="headerlink" title="stop-writes-on-bgsave-error"></a>stop-writes-on-bgsave-error</h4><ul><li><strong>当Redis无法写入磁盘的话，直接关掉Redis的写操作</strong>，<strong>推荐设置为yes</strong>。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014143705419.png" alt="image-20221014143705419"></p><h4 id="rdbcompression压缩文件"><a href="#rdbcompression压缩文件" class="headerlink" title="rdbcompression压缩文件"></a>rdbcompression压缩文件</h4><ul><li><p>对于存储到磁盘中的快照，可以设置是否进行压缩存储。<strong>如果是的话，redis会采用LZF算法进行压缩</strong>。</p></li><li><p>如果你不想消耗CPU来进行压缩的话，可以设置为关闭此功能。<strong>推荐yes</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014143931470.png" alt="image-20221014143931470"></p></li></ul><h4 id="rdbchecksum检查完整性"><a href="#rdbchecksum检查完整性" class="headerlink" title="rdbchecksum检查完整性"></a>rdbchecksum检查完整性</h4><ul><li><p><strong>在存储快照后，还可以让redis使用CRC64算法来进行数据校验</strong>，但是这样做会增加大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能，<strong>推荐yes</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014144104665.png" alt="image-20221014144104665"></p></li></ul><h3 id="rdb的备份"><a href="#rdb的备份" class="headerlink" title="rdb的备份"></a>rdb的备份</h3><ul><li>先通过<strong>config get dir</strong>查询rdb文件的目录，将*.rdb的文件拷贝到别的地方</li><li>rdb的恢复：<ol><li>关闭Redis</li><li>先把备份的文件拷贝到工作目录下，注意名称要和配置文件中配置的一致。</li><li>启动Redis, 备份数据会直接加载</li></ol></li></ul><h3 id="RDB的优势"><a href="#RDB的优势" class="headerlink" title="RDB的优势"></a>RDB的优势</h3><ul><li><p>适合大规模的数据恢复</p></li><li><p>对数据完整性和一致性要求不高更适合使用</p></li><li><p>节省磁盘空间</p></li><li><p>恢复速度快</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014144428846.png" alt="image-20221014144428846"></p></li></ul><h3 id="RDB的劣势"><a href="#RDB的劣势" class="headerlink" title="RDB的劣势"></a>RDB的劣势</h3><ul><li>Fork的时候，内存中的数据被克隆了一份，大致<strong>2倍的膨胀性需要考虑</strong>。</li><li>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>,但是<strong>如果数据庞大时还是比较消耗性能</strong>。</li><li>在备份周期在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就<strong>可能会丢失最后一次快照后的所有修改</strong>。</li></ul><h3 id="如何停止"><a href="#如何停止" class="headerlink" title="如何停止"></a>如何停止</h3><ul><li>动态停止RDB：<strong>redis-cli config set save “”</strong>  #save后给空值，表示禁用保存策略</li><li>静态停止RDB：关闭Redis，<strong>在Redis的配置文件中注释掉save或者给save空值</strong>，然后重启Redis即可。</li></ul><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014144846557.png" alt="image-20221014144846557"></p><h2 id="AOF（Append-Only-File）"><a href="#AOF（Append-Only-File）" class="headerlink" title="AOF（Append Only File）"></a>AOF（Append Only File）</h2><h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ul><li>以<strong>日志</strong>的形式来记录每个写操作（增量保存），将Redis执行过的所有写指令记录下来(<strong>读操作不记录</strong>)， <strong>只许追加文件但不可以改写文件</strong>，redis启动之初会读取该文件重新构建数据，换言之，<strong>redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</strong>。</li></ul><h3 id="AOF持久化流程"><a href="#AOF持久化流程" class="headerlink" title="AOF持久化流程"></a>AOF持久化流程</h3><ol><li><p>客户端的<strong>请求写命令会被append追加到AOF缓冲区内</strong>；</p></li><li><p>AOF缓冲区<strong>根据AOF持久化策略 [ always, everysec, no ] 将操作sync同步到磁盘的AOF文件中</strong>；</p></li><li><p><strong>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写</strong>，压缩AOF文件容量；</p></li><li><p>Redis服务重启时，会<strong>重新load加载AOF文件中的写操作达到数据恢复的目的</strong>；</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014150136936.png" alt="image-20221014150136936"></p></li></ol><h3 id="AOF默认是不开启的"><a href="#AOF默认是不开启的" class="headerlink" title="AOF默认是不开启的"></a>AOF默认是不开启的</h3><ul><li><p>需要在配置文件中配置AOF的开启，<strong>修改默认的appendonly no，改为yes</strong>。</p></li><li><p>可以在redis.conf中配置文件名称，默认为 appendonly.aof。</p></li><li><p>AOF文件设置保存路径，同RDB设置路径一致。</p></li></ul><h3 id="AOF和RDB同时开启，redis听谁的？"><a href="#AOF和RDB同时开启，redis听谁的？" class="headerlink" title="AOF和RDB同时开启，redis听谁的？"></a>AOF和RDB同时开启，redis听谁的？</h3><ul><li>AOF和RDB同时开启，<strong>系统默认取AOF的数据（数据不会存在丢失）</strong>。</li></ul><h3 id="AOF的启动-x2F-修复-x2F-恢复"><a href="#AOF的启动-x2F-修复-x2F-恢复" class="headerlink" title="AOF的启动&#x2F;修复&#x2F;恢复"></a>AOF的启动&#x2F;修复&#x2F;恢复</h3><ul><li><p>AOF的备份机制和性能虽然和RDB不同, 但是备份和恢复的操作同RDB一样，都是拷贝备份文件，需要恢复时再拷贝到Redis工作目录下，启动系统即加载。</p></li><li><p>正常恢复：</p><ol><li>修改默认的appendonly no，改为yes</li><li>将有数据的aof文件复制一份保存到对应目录(查看目录：config get dir)</li><li>恢复：重启redis然后重新加载</li></ol></li><li><p>异常恢复：</p><ol><li>修改默认的appendonly no，改为yes</li><li>如遇到<strong>AOF文件损坏</strong>，通过在&#x2F;usr&#x2F;local&#x2F;bin&#x2F;使用命令<strong>redis-check-aof–fix appendonly.aof</strong>进行恢复</li><li>备份被写坏的AOF文件</li><li>恢复：重启redis，然后重新加载</li></ol></li></ul><h3 id="AOF同步频率设置"><a href="#AOF同步频率设置" class="headerlink" title="AOF同步频率设置"></a>AOF同步频率设置</h3><ul><li><strong>appendfsync always</strong>：<strong>始终同步</strong>，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好。</li><li><strong>appendfsync everysec</strong>：<strong>每秒同步</strong>，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</li><li><strong>appendfsync no</strong>：<strong>redis不主动进行同步，把同步时机交给操作系统</strong>。</li></ul><h3 id="Rewrite（重写）压缩"><a href="#Rewrite（重写）压缩" class="headerlink" title="Rewrite（重写）压缩"></a>Rewrite（重写）压缩</h3><h4 id="这是什么"><a href="#这是什么" class="headerlink" title="这是什么"></a>这是什么</h4><ul><li>AOF采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制, 当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩， <strong>只保留可以恢复数据的最小指令集</strong>。可以<strong>使用命令bgrewriteaof手动触发内容压缩（重写）操作</strong>。</li></ul><h4 id="重写原理，如何实现重写"><a href="#重写原理，如何实现重写" class="headerlink" title="重写原理，如何实现重写"></a>重写原理，如何实现重写</h4><ul><li><p>AOF文件持续增长而过大时，会<strong>fork出一条新进程来将文件重写(也是先写临时文件最后再rename)<strong>，</strong>redis4.0版本后的重写，实际上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作，在这个操作的基础上再压缩剩下的命令</strong>。</p></li><li><p><strong>no-appendfsync-on-rewrite</strong>：如果no-appendfsync-on-rewrite&#x3D;yes，不写入aof文件只写入缓存，用户请求不会阻塞，但是在这段时间如果宕机会丢失这段时间的缓存数据。（降低数据安全性，提高性能）；如果 no-appendfsync-on-rewrite&#x3D;no,  还是会把数据往磁盘里刷，但是遇到重写操作，可能会发生阻塞。（数据安全，但是性能降低）</p></li><li><p>触发机制，何时重写：Redis会记录上次重写时的AOF大小，<strong>默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发</strong>，重写虽然可以节约大量磁盘空间，减少恢复时间。但是每次重写还是有一定的负担的，因此设定Redis要满足一定条件才会进行重写：</p><ul><li><strong>auto-aof-rewrite-percentage</strong>：<strong>当目前aof文件大小超过上一次重写的aof文件大小的百分之多少后进行重写</strong>，默认是100%。</li><li><strong>auto-aof-rewrite-min-size</strong>：<strong>设置允许重写的最小aof 文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写</strong>，默认是64MB。</li></ul></li><li><p>例如：文件达到70MB开始重写，降到50MB，下次什么时候开始重写？100MB</p></li><li><p>系统载入时或者上次重写完毕时，Redis会记录此时AOF大小，设为base_size，<strong>如果Redis的AOF当前大小&gt;&#x3D; base_size +base_size*100% (默认)且当前大小&gt;&#x3D;64mb(默认)的情况下，Redis会对AOF进行重写</strong>。</p></li></ul><h4 id="重写流程"><a href="#重写流程" class="headerlink" title="重写流程"></a>重写流程</h4><ol><li><p>bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</p></li><li><p>主进程fork出子进程执行重写操作，保证主进程不会阻塞。</p></li><li><p>子进程遍历redis内存中数据到临时文件，客户端的写请求同时写入aof_buf缓冲区和aof_rewrite_buf重写缓冲区保证原AOF文件完整以及新AOF文件生成期间的新的数据修改动作不会丢失。</p></li><li><p>1).子进程写完新的AOF文件后，向主进程发信号，父进程更新统计信息。2).主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</p></li><li><p>使用新的AOF文件覆盖旧的AOF文件，完成AOF重写。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014161849951.png" alt="image-20221014161849951"></p></li></ol><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>备份机制更稳健，<strong>丢失数据概率更低</strong>。</li><li>可读的日志文本，<strong>通过操作AOF文件，可以处理误操作</strong>。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014161927407.png" alt="image-20221014161927407"></p><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li>比起RDB<strong>占用更多的磁盘空间</strong>。</li><li><strong>恢复备份速度要慢</strong>。</li><li><strong>每次读写都同步的话，有一定的性能压力</strong>。</li><li><strong>存在个别Bug</strong>，造成恢复不能。</li></ul><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014162114242.png" alt="image-20221014162114242"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="用哪个好"><a href="#用哪个好" class="headerlink" title="用哪个好"></a>用哪个好</h3><ul><li>官方<strong>推荐两个都启用</strong>。</li><li>如果<strong>对数据不敏感，可以选单独用RDB</strong>。</li><li><strong>不建议单独用 AOF</strong>，因为可能会出现Bug。</li><li>如果<strong>只是做纯内存缓存，可以都不用</strong>。</li></ul><h3 id="官网建议"><a href="#官网建议" class="headerlink" title="官网建议"></a>官网建议</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221014162204415.png" alt="image-20221014162204415"></p><ul><li><strong>RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储</strong></li><li><strong>AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据</strong>,AOF命令以redis协议追加保存每次写的操作到文件末尾.，Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大</li><li>只做缓存：<strong>如果你只希望你的数据在服务器运行的时候存在,你也可以不使用任何持久化方式</strong>.</li><li><strong>如非只做缓存，那么推荐同时开启两种持久化方式，</strong>在这种情况下,当redis重启的时候<strong>会优先载入AOF文件来恢复原始的数据, 因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整</strong>.</li><li>RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？ 建议不要，<strong>因为RDB更适合用于备份数据库(AOF在不断变化不好备份)， 快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段</strong>。</li><li>性能建议：<ul><li>因为<strong>RDB文件只用作后备用途</strong>，<strong>建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则</strong>。</li><li>如果使用AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了。代价,一是带来了持续的IO，二是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。</li><li>只要硬盘许可，应该<strong>尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上</strong>。</li><li><strong>可以把默认超过原大小百分之多少时重写这一配置改到适当的数值</strong>。</li></ul></li></ul><h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>主机数据更新后根据配置和策略， 自动同步到备机的<strong>master&#x2F;slaver机制</strong>，<strong>Master以写为主，Slave以读为主</strong>。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li><p><strong>读写分离，性能扩展</strong></p></li><li><p><strong>容灾快速恢复</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015094548694.png" alt="image-20221015094548694"></p></li></ul><h2 id="如何实现主从复制"><a href="#如何实现主从复制" class="headerlink" title="如何实现主从复制"></a>如何实现主从复制</h2><h3 id="新建redis6379-conf"><a href="#新建redis6379-conf" class="headerlink" title="新建redis6379.conf"></a>新建redis6379.conf</h3><ul><li><p>填写以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.conf //引入已有配置文件中的配置</span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">port 6379</span><br><span class="line">dbfilename dump6379.rdb</span><br></pre></td></tr></table></figure></li></ul><h3 id="新建redis6380-conf"><a href="#新建redis6380-conf" class="headerlink" title="新建redis6380.conf"></a>新建redis6380.conf</h3><ul><li><p>填写以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.conf //引入已有配置文件中的配置</span><br><span class="line">pidfile /var/run/redis_6380.pid</span><br><span class="line">port 6380</span><br><span class="line">dbfilename dump6380.rdb</span><br></pre></td></tr></table></figure></li></ul><h3 id="新建redis6381-conf"><a href="#新建redis6381-conf" class="headerlink" title="新建redis6381.conf"></a>新建redis6381.conf</h3><ul><li><p>填写以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include /myredis/redis.conf //引入已有配置文件中的配置</span><br><span class="line">pidfile /var/run/redis_6381.pid</span><br><span class="line">port 6381</span><br><span class="line">dbfilename dump6381.rdb</span><br></pre></td></tr></table></figure></li></ul><h3 id="设置从机的优先级"><a href="#设置从机的优先级" class="headerlink" title="设置从机的优先级"></a>设置从机的优先级</h3><ul><li>slave-priority 10：设置从机的优先级，值越小，优先级越高，<strong>用于选举主机时使用</strong>。默认100。</li></ul><h3 id="启动三台redis服务器"><a href="#启动三台redis服务器" class="headerlink" title="启动三台redis服务器"></a>启动三台redis服务器</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015095228553.png" alt="image-20221015095228553"></p><h3 id="查看系统进程，看看三台服务器是否都正常启动"><a href="#查看系统进程，看看三台服务器是否都正常启动" class="headerlink" title="查看系统进程，看看三台服务器是否都正常启动"></a>查看系统进程，看看三台服务器是否都正常启动</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015095312770.png" alt="image-20221015095312770"></p><h3 id="查看三台主机的主从情况"><a href="#查看三台主机的主从情况" class="headerlink" title="查看三台主机的主从情况"></a>查看三台主机的主从情况</h3><ul><li><p>使用客户端命令：<strong>info replication</strong>来打印主从复制的相关信息。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015095427167.png" alt="image-20221015095427167"></p></li></ul><h3 id="配置从机不配置主机"><a href="#配置从机不配置主机" class="headerlink" title="配置从机不配置主机"></a>配置从机不配置主机</h3><ul><li><p>从上面查看三台主机的主从情况可以看出，每个服务端的role字段都是master，这说明<strong>默认所有的服务端都是主机</strong>，因此如果要是想要配置从机，就应该在想要用作从机的上面进行配置，而主机不用进行配置。</p></li><li><p>使用客户端命令**slaveof  &lt;ip&gt; &lt;port&gt;**来让当前服务端成为某个服务端的从服务端，或者将这个配置加入到配置文件中永久生效。</p></li><li><p>配置示例：在6380和6381上执行: slaveof 127.0.0.1 6379</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015100217990.png" alt="image-20221015100217990"></p></li><li><p>在主机上可以写数据，在从机上可以读取数据，<strong>在从机上写数据会报错</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015100258091.png" alt="image-20221015100258091"></p></li><li><p>如果主机挂掉了，主机重启即可，主机不用做额外的操作。但是从机挂了之后重启，从机会变成主机，所以**从机需要重新设置slaveof  &lt;ip&gt; &lt;port&gt;**，可以将配置增加到配置文件中永久生效。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015100522674.png" alt="image-20221015100522674"></p></li><li><p><strong>从机下面也能配置从机</strong>。</p></li><li><p>用<strong>slaveof  no one</strong>将从机变为主机。</p></li></ul><h2 id="常用的三种主从结构"><a href="#常用的三种主从结构" class="headerlink" title="常用的三种主从结构"></a>常用的三种主从结构</h2><h3 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h3><ul><li><p>切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1,k2,k3是否也可以复制？</p><p>从机是否可以写？set可否？ </p><p>主机shutdown后情况如何？从机是上位还是原地待命？</p><p>主机又回来了后，主机新增记录，从机还能否顺利复制？ </p><p>其中一台从机down后情况如何？依照原有它能跟上大部队吗？</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015100717323.png" alt="image-20221015100717323"></p></li></ul><h3 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h3><ul><li><p>上一个Slave可以是下一个slave的Master，<strong>Slave同样可以接收其他slaves的连接和同步请求</strong>，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</p></li><li><p>用 slaveof  &lt;ip&gt; &lt;port&gt;进行配置</p><p>中途变更转向:会清除之前的数据，重新建立拷贝最新的</p><p>风险是一旦某个slave宕机，后面的slave都没法备份</p><p>主机挂了，从机还是从机，无法写数据了</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101147373.png" alt="image-20221015101147373"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101153056.png" alt="image-20221015101153056"></p></li></ul><h3 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h3><ul><li><strong>当一个master宕机后，后面的slave可以立刻升为master</strong>，其后面的slave不用做任何修改。</li><li>用<strong>slaveof no one</strong>将从机变为主机。</li></ul><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><ul><li><p><strong>Slave启动成功连接到master后会发送一个sync命令</strong>。</p></li><li><p>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，<strong>master将传送整个数据文件到slave,以完成一次完全同步</strong>。</p></li><li><p><strong>全量复制</strong>：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p></li><li><p><strong>增量复制</strong>：Master继续将新的所有收集到的修改命令依次传给slave,完成同步。</p></li><li><p>但是<strong>只要是重新连接master,一次完全同步（全量复制)将被自动执行</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101757180.png" alt="image-20221015101757180"></p></li></ul><h2 id="哨兵模式（sentinel）"><a href="#哨兵模式（sentinel）" class="headerlink" title="哨兵模式（sentinel）"></a>哨兵模式（sentinel）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li><p>这是<strong>反客为主的自动版</strong>，能够<strong>后台监控主机是否故障</strong>，如果故障了<strong>根据投票数自动将从库转换为主库</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101935319.png" alt="image-20221015101935319"></p></li></ul><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><ol><li><p>调整为一主二仆模式，6379带着6380、6381</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015102041213.png" alt="image-20221015102041213"></p></li><li><p>自定义的&#x2F;myredis目录下<strong>新建sentinel.conf文件</strong>，名字绝不能错</p></li><li><p>配置哨兵，在sentinel.conf中填写内容：<strong>sentinel monitor mymaster 127.0.0.1 6379 1</strong>，其中<strong>mymaster为监控对象起的服务器名称</strong>， <strong>1为至少有多少个哨兵同意迁移的数量</strong>。</p></li><li><p>启动哨兵：在&#x2F;usr&#x2F;local&#x2F;bin(安装目录)下执行<strong>redis-sentinel  &#x2F;myredis&#x2F;sentinel.conf</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015102700028.png" alt="image-20221015102700028"></p></li><li><p>redis<strong>做压力测试可以用自带的redis-benchmark工具</strong></p></li></ol><h3 id="当主机挂掉，哨兵会在从机中选出新的主机"><a href="#当主机挂掉，哨兵会在从机中选出新的主机" class="headerlink" title="当主机挂掉，哨兵会在从机中选出新的主机"></a>当主机挂掉，哨兵会在从机中选出新的主机</h3><ul><li><p>大概10秒左右可以看到哨兵窗口日志，切换了新的主机</p></li><li><p>哪个从机会被选举为主机呢？<strong>根据优先级别：slave-priority ，值越小优先级越高</strong>，<strong>原主机重启后会变为从机</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015103019042.png" alt="image-20221015103019042"></p></li></ul><h3 id="复制延时"><a href="#复制延时" class="headerlink" title="复制延时"></a>复制延时</h3><ul><li>由于<strong>所有的写操作都是先在Master上操作，然后同步更新到Slave上</strong>，所以<strong>从Master同步到Slave机器有一定的延迟</strong>，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</li></ul><h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><ul><li>优先级在redis.conf中默认：slave-priority 100，<strong>值越小优先级越高</strong></li><li><strong>偏移量是指获得原主机数据最全的</strong></li><li>每个redis实例启动后都会<strong>随机生成一个40位的runid</strong></li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015103154028.png" alt="image-20221015103154028"></p><h3 id="java代码实现"><a href="#java代码实现" class="headerlink" title="java代码实现"></a>java代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisSentinelPool jedisSentinelPool=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  Jedis <span class="title function_">getJedisFromSentinel</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(jedisSentinelPool==<span class="literal">null</span>)&#123;</span><br><span class="line">        Set&lt;String&gt; sentinelSet=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        sentinelSet.add(<span class="string">&quot;192.168.11.103:26379&quot;</span>);</span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">10</span>); <span class="comment">//最大可用连接数</span></span><br><span class="line">jedisPoolConfig.setMaxIdle(<span class="number">5</span>); <span class="comment">//最大闲置连接数</span></span><br><span class="line">jedisPoolConfig.setMinIdle(<span class="number">5</span>); <span class="comment">//最小闲置连接数</span></span><br><span class="line">jedisPoolConfig.setBlockWhenExhausted(<span class="literal">true</span>); <span class="comment">//连接耗尽是否等待</span></span><br><span class="line">jedisPoolConfig.setMaxWaitMillis(<span class="number">2000</span>); <span class="comment">//等待时间</span></span><br><span class="line">jedisPoolConfig.setTestOnBorrow(<span class="literal">true</span>); <span class="comment">//取连接的时候进行一下测试 ping pong</span></span><br><span class="line">jedisSentinelPool=<span class="keyword">new</span> <span class="title class_">JedisSentinelPool</span>(<span class="string">&quot;mymaster&quot;</span>,sentinelSet,jedisPoolConfig);</span><br><span class="line">        <span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisSentinelPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>容量不够，redis如何进行扩容？</li><li>并发写操作， redis如何分摊？</li><li>另外，主从模式，薪火相传模式，主机宕机，导致ip地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。之前通过代理主机来解决，但是redis3.0中提供了解决方案。就是<strong>无中心化集群配置</strong>。</li></ul><h2 id="什么是集群"><a href="#什么是集群" class="headerlink" title="什么是集群"></a>什么是集群</h2><ul><li>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，<strong>将整个数据库分布存储在这N个节点中，每个节点存储总数据的1&#x2F;N</strong>。</li><li>Redis 集群<strong>通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求</strong>。</li></ul><h2 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h2><h3 id="删除持久化数据"><a href="#删除持久化数据" class="headerlink" title="删除持久化数据"></a>删除持久化数据</h3><ul><li>将rdb、aof文件都删除</li></ul><h3 id="制作6个redis实例，6379，6380，6381，6389，6390，6391"><a href="#制作6个redis实例，6379，6380，6381，6389，6390，6391" class="headerlink" title="制作6个redis实例，6379，6380，6381，6389，6390，6391"></a>制作6个redis实例，6379，6380，6381，6389，6390，6391</h3><h3 id="配置所有实例的基本信息"><a href="#配置所有实例的基本信息" class="headerlink" title="配置所有实例的基本信息"></a>配置所有实例的基本信息</h3><ul><li>include基本配置</li><li>开启daemonize yes</li><li>Pid文件名字</li><li>指定端口</li><li>Log文件名字</li><li>Dump.rdb名字</li><li>Appendonly 关掉或者换名字</li></ul><h3 id="redis-cluster（集群）配置修改"><a href="#redis-cluster（集群）配置修改" class="headerlink" title="redis cluster（集群）配置修改"></a>redis cluster（集群）配置修改</h3><ul><li><p><strong>cluster-enabled yes</strong>  打开集群模式</p></li><li><p><strong>cluster-config-file nodes-6379.conf</strong> 设定节点配置文件名</p></li><li><p><strong>cluster-node-timeout 15000</strong>  设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换。</p></li><li><p>配置示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">include /home/bigdata/redis.conf</span><br><span class="line">port 6379</span><br><span class="line">pidfile &quot;/var/run/redis_6379.pid&quot;</span><br><span class="line">dbfilename &quot;dump6379.rdb&quot;</span><br><span class="line">dir &quot;/home/bigdata/redis_cluster&quot;</span><br><span class="line">logfile &quot;/home/bigdata/redis_cluster/redis_err_6379.log&quot;</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6379.conf</span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure></li></ul><h3 id="修改好redis6379-conf文件，拷贝多个redis-conf文件"><a href="#修改好redis6379-conf文件，拷贝多个redis-conf文件" class="headerlink" title="修改好redis6379.conf文件，拷贝多个redis.conf文件"></a>修改好redis6379.conf文件，拷贝多个redis.conf文件</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015113959317.png" alt="image-20221015113959317"></p><h3 id="使用查找替换修改另外5个文件的内容"><a href="#使用查找替换修改另外5个文件的内容" class="headerlink" title="使用查找替换修改另外5个文件的内容"></a>使用查找替换修改另外5个文件的内容</h3><ul><li>例如：%s&#x2F;6379&#x2F;6380</li></ul><h3 id="启动6个redis服务"><a href="#启动6个redis服务" class="headerlink" title="启动6个redis服务"></a>启动6个redis服务</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015114051147.png" alt="image-20221015114051147"></p><h3 id="将6个节点合成一个集群"><a href="#将6个节点合成一个集群" class="headerlink" title="将6个节点合成一个集群"></a>将6个节点合成一个集群</h3><ul><li><p>组合之前，<strong>请确保所有redis实例启动后，nodes-xxxx.conf文件都生成正常</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015114158540.png" alt="image-20221015114158540"></p></li><li><p>合体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 192.168.11.101:6379 192.168.11.101:6380 192.168.11.101:6381 192.168.11.101:6389 192.168.11.101:6390 192.168.11.101:6391</span><br></pre></td></tr></table></figure><p>此处不要用127.0.0.1，请用真实的IP地址</p><p><strong>–replicas 1 采用最简单的方式配置集群，一台主机，一台从机</strong>，正好三组。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015114356061.png" alt="image-20221015114356061"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015114418734.png" alt="image-20221015114418734"></p></li><li><p>登录：不要使用普通方式登录集群，因为用普通方式登录可能会直接进入读主机，存储数据时，会出现MOVED重定向操作。所以，<strong>应该以集群方式登录</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015114551455.png" alt="image-20221015114551455"></p></li></ul><h2 id="以集群方式登录集群"><a href="#以集群方式登录集群" class="headerlink" title="以集群方式登录集群"></a>以集群方式登录集群</h2><ul><li><p><strong>登录时添加-c参数表示采用集群策略连接，写数据会自动切换到相应的写主机</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015114727624.png" alt="image-20221015114727624"></p></li></ul><h2 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h2><ul><li><p>通过<strong>cluster nodes 命令查看集群信息</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015114809189.png" alt="image-20221015114809189"></p></li></ul><h2 id="redis-cluster（集群）如何分配节点？"><a href="#redis-cluster（集群）如何分配节点？" class="headerlink" title="redis cluster（集群）如何分配节点？"></a>redis cluster（集群）如何分配节点？</h2><ul><li><strong>一个集群至少要有三个主节点</strong>。</li><li>选项 <strong>–cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点</strong>。</li><li>分配原则<strong>尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上</strong>。</li></ul><h2 id="什么是slots"><a href="#什么是slots" class="headerlink" title="什么是slots"></a>什么是slots</h2><ul><li><p>在配置完redis集群之后会弹出这样的信息：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015114418734.png" alt="image-20221015114418734"></p><p>其中的slots代表什么呢？</p></li><li><p>一个 Redis 集群包含 16384 个插槽（hash slot）， <strong>数据库中的每个键都属于这 16384 个插槽的其中一个</strong>，<strong>一个插槽中可以有多个键，但一个键只对应一个插槽</strong>。</p></li><li><p><strong>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽</strong>， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p></li><li><p><strong>集群中的每个节点负责处理一部分插槽</strong>。 举个例子， 如果一个集群可以有主节点， 其中：</p><p>节点 A 负责处理 0 号至 5460 号插槽。</p><p>节点 B 负责处理 5461 号至 10922 号插槽。</p><p>节点 C 负责处理 10923 号至 16383 号插槽。</p></li></ul><h2 id="在集群中录入值"><a href="#在集群中录入值" class="headerlink" title="在集群中录入值"></a>在集群中录入值</h2><ul><li><p><strong>在redis-cli每次录入、查询键值，redis都会计算出该key应该送往的插槽</strong>，如果不是该客户端对应服务器的插槽，redis会报错，并告知应前往的redis实例地址和端口。</p></li><li><p>redis-cli客户端提供了<strong>–c 参数登录实现自动重定向</strong>。如redis-cli  -c –p 6379 登入后，再录入、查询键值对可以自动重定向。</p></li><li><p><strong>不在一个slot下的键值，是不能使用mget,mset等多键操作</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015120213529.png" alt="image-20221015120213529"></p></li><li><p>可以<strong>通过{}来定义组的概念，从而使key中{}内相同内容的键值对放到一个slot中去</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015120259156.png" alt="image-20221015120259156"></p></li></ul><h2 id="查询集群中的值"><a href="#查询集群中的值" class="headerlink" title="查询集群中的值"></a>查询集群中的值</h2><ul><li>**cluster keyslot &lt;key&#x2F;组名&gt;**：返回指定key所在的slot的编号</li><li>**cluster countkeysinslot  &lt;slot&gt;**：返回指定slot所拥有的key的数量</li><li>**cluster getkeysinslot &lt;slot&gt; &lt;count&gt;**：返回 count 个 slot 槽中的键。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015120349902.png" alt="image-20221015120349902"></p><h2 id="故障恢复-1"><a href="#故障恢复-1" class="headerlink" title="故障恢复"></a>故障恢复</h2><ul><li><p>如果主节点下线？从节点能否自动升为主节点？答：能，注意：<strong>15秒超时</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015121830226.png" alt="image-20221015121830226"></p></li><li><p>主节点恢复后，主从关系会如何？答：主节点回来会变成从机。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015121849156.png" alt="image-20221015121849156"></p></li><li><p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p><p><strong>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉。</strong></p><p><strong>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</strong></p><p>redis.conf中的参数  cluster-require-full-coverage</p></li></ul><h2 id="集群的Jedis开发"><a href="#集群的Jedis开发" class="headerlink" title="集群的Jedis开发"></a>集群的Jedis开发</h2><ul><li><p>即使连接的不是主机，<strong>集群会自动切换主机存储。主机写，从机读</strong>。</p></li><li><p><strong>无中心化主从集群。无论从哪台主机写的数据，其他主机上都能读到数据</strong>。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisClusterTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">     Set&lt;HostAndPort&gt;set =<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;HostAndPort&gt;();</span><br><span class="line">     set.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.31.211&quot;</span>,<span class="number">6379</span>));</span><br><span class="line">     JedisCluster jedisCluster=<span class="keyword">new</span> <span class="title class_">JedisCluster</span>(set);</span><br><span class="line">     jedisCluster.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">     System.out.println(jedisCluster.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Redis集群提供了以下好处"><a href="#Redis集群提供了以下好处" class="headerlink" title="Redis集群提供了以下好处"></a>Redis集群提供了以下好处</h2><ul><li><strong>实现扩容</strong></li><li><strong>分摊压力</strong></li><li><strong>无中心配置相对简单</strong></li></ul><h2 id="Redis集群的不足"><a href="#Redis集群的不足" class="headerlink" title="Redis集群的不足"></a>Redis集群的不足</h2><ul><li><strong>多键操作是不被支持的</strong>，因为多个键所在的slot可能不同。</li><li><strong>多键的Redis事务是不被支持的，lua脚本不被支持</strong>。</li><li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而<strong>代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大</strong>。</li></ul><h1 id="Redis应用问题解决"><a href="#Redis应用问题解决" class="headerlink" title="Redis应用问题解决"></a>Redis应用问题解决</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li><p><strong>key对应的数据在数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源</strong>。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015154904013.png" alt="image-20221015154904013"></p></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>一个一定不存在缓存即查询不到的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p></li><li><p>解决方案：</p><ol><li><p><strong>对空值缓存</strong>：如果一个查询返回的数据为空（不管是数据是否不存在），我们<strong>仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</strong>。</p></li><li><p><strong>设置可访问的名单（白名单）</strong>：使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，<strong>如果访问id不在bitmaps里面，进行拦截，不允许访问</strong>。</p></li><li><p><strong>采用布隆过滤器</strong>：(布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。</p><p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。)</p><p><strong>将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被 这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力</strong>。</p></li><li><p><strong>进行实时监控</strong>：当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，<strong>和运维人员配合，可以设置黑名单限制服务</strong>。</p></li></ol></li></ul><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015155516731.png" alt="image-20221015155516731"></p></li></ul><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><p>key可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。这个时候，需要考虑一个问题：缓存被“击穿”的问题。</p></li><li><p>解决问题：</p><ol><li><p><strong>预先设置热门数据</strong>：在redis高峰访问之前，把一些热门数据提前存入到redis里面，<strong>加大这些热门数据key的时长</strong>。</p></li><li><p><strong>实时调整</strong>：现场监控哪些数据热门，<strong>实时调整key的过期时长</strong>。</p></li><li><p><strong>使用锁</strong>：就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db。先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX）去set一个mutex key。当操作返回成功时，再进行load db的操作，并回设缓存,最后删除mutex key；当操作返回失败，证明有线程在load db，当前线程睡眠一段时间再重试整个get缓存的方法。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015155826935.png" alt="image-20221015155826935"></p></li></ol></li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li><p>key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。<strong>缓存雪崩与缓存击穿的区别在于这里针对很多key缓存，前者则是某一个key正常访问</strong>。</p></li><li><p>正常访问：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015160127583.png" alt="image-20221015160127583"></p></li><li><p>缓存失效瞬间：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015160147037.png" alt="image-20221015160147037"></p></li></ul><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>缓存失效时的雪崩效应对底层系统的冲击非常可怕！</li><li>解决方案：<ol><li><strong>构建多级缓存架构</strong>：nginx缓存 + redis缓存 +其他缓存（ehcache等）</li><li><strong>使用锁或队列</strong>：<strong>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写</strong>，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况。</li><li><strong>设置过期标志更新缓存</strong>：记录缓存数据是否过期（设置提前量），如果<strong>过期会触发通知另外的线程在后台去更新实际key的缓存</strong>。</li><li><strong>将缓存失效时间分散开</strong>：比如我们<strong>可以在原有的失效时间基础上增加一个随机值</strong>，比如1-5分钟随机，<strong>这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件</strong>。</li></ol></li></ul><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li><p>随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使<strong>原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问</strong>，这就是分布式锁要解决的问题！</p></li><li><p>分布式锁主流的实现方案：</p><ol><li>基于数据库实现分布式锁</li><li>基于缓存（Redis等）</li><li>基于Zookeeper</li></ol></li><li><p>每一种分布式锁解决方案都有各自的优缺点：</p><ol><li>性能：redis最高</li><li>可靠性：zookeeper最高</li></ol></li><li><p>这里，我们就基于redis实现分布式锁</p></li></ul><h3 id="解决方案：使用redis实现分布式锁"><a href="#解决方案：使用redis实现分布式锁" class="headerlink" title="解决方案：使用redis实现分布式锁"></a>解决方案：使用redis实现分布式锁</h3><ul><li><p>redis命令：<strong>set sku:1:info “OK” NX PX 10000</strong></p><p>**EX second **：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</p><p><strong>PX millisecond</strong> ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX key millisecond value 。</p><p><strong>NX</strong> ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</p><p><strong>XX</strong> ：只在键已经存在时，才对键进行设置操作。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015165627020.png" alt="image-20221015165627020"></p><ol><li>多个客户端同时获取锁（setnx）</li><li>获取成功，执行业务逻辑{从db获取数据，放入缓存}，执行完成释放锁（del）</li><li>其他客户端等待重试</li></ol></li></ul><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><ul><li><p>redis中先set num 0</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLock&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1获取锁，setne</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line">    <span class="comment">//2获取锁成功、查询num的值</span></span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="comment">//2.1判断num为空return</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(value))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.2有值就转成成int</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(value+<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//2.3把redis的num加1</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, ++num);</span><br><span class="line">        <span class="comment">//2.4释放锁，del</span></span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;lock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//3获取锁失败、每隔0.1秒再获取</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            testLock();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重启服务器集群，通过网关进行压力测试：<strong>ab -n 1000 -c 100 <a href="http://192.168.140.1:8080/test/testLock">http://192.168.140.1:8080/test/testLock</a></strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015170050806.png" alt="image-20221015170050806"></p></li><li><p>查看redis中num的值：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015170111047.png" alt="image-20221015170111047"></p><p>可以发现符合预期结果，说明效果基本实现。</p></li><li><p>问题：setnx刚好获取到锁，业务逻辑出现异常，导致锁无法释放。</p><p>解决：设置过期时间，到规定的时间后自动释放锁。</p></li></ul><h3 id="优化之设置锁的过期时间"><a href="#优化之设置锁的过期时间" class="headerlink" title="优化之设置锁的过期时间"></a>优化之设置锁的过期时间</h3><ul><li><p>设置过期时间有两种方式：</p><ol><li>首先想到通过expire设置过期时间（缺乏原子性：如果在setnx和expire之间出现异常，锁也无法释放）</li><li><strong>在set时指定过期时间（推荐）</strong></li></ol><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015170316729.png" alt="image-20221015170316729"></p></li><li><p>设置过期时间：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015170336763.png" alt="image-20221015170336763"></p><p>压力测试肯定也没有问题，自行进行测试。</p></li><li><p>问题：可能会释放其他服务器的锁</p></li><li><p>场景：如果业务逻辑的执行时间是7s。执行流程如下：</p><ol><li>index1业务逻辑没执行完，3秒后锁被自动释放。</li><li>index2获取到锁，执行业务逻辑，3秒后锁被自动释放。</li><li>index3获取到锁，执行业务逻辑</li><li>index1业务逻辑执行完成，开始调用del释放锁，这时释放的是index3的锁，导致index3的业务只执行1s就被别人释放。</li></ol><p>最终等于没锁的情况</p></li><li><p>解决：setnx获取锁时，设置一个指定的唯一值（例如：uuid）；释放前获取这个值，判断是否自己的锁</p></li></ul><h3 id="优化之UUID防误删"><a href="#优化之UUID防误删" class="headerlink" title="优化之UUID防误删"></a>优化之UUID防误删</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015170615036.png" alt="image-20221015170615036"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015170624482.png" alt="image-20221015170624482"></p><ul><li><p>问题：删除操作缺乏原子性</p></li><li><p>场景：</p><ol><li><p>index1执行删除时，查询到的lock值确实和uuid相等</p><p>uuid&#x3D;v1</p><p>set(lock,uuid)；</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015171522206.png" alt="image-20221015171522206"> </p></li><li><p>index1执行删除前，lock刚好过期时间已到，被redis自动释放</p><p>在redis中没有了lock，没有了锁。</p></li></ol><p>​    <img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015172129853.png" alt="image-20221015172129853"></p><ol start="3"><li><p>index2获取了lock</p><p>index2线程获取到了cpu的资源，开始执行方法</p><p>uuid&#x3D;v2</p><p>set(lock,uuid)；</p></li><li><p>index1执行删除，此时会把index2的lock删除</p><p>index1 因为已经在方法中了，所以不需要重新上锁。index1有执行的权限。index1已经比较完成了，这个时候，开始执行</p><p> <img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015172147236.png" alt="image-20221015172147236"></p><p>删除的index2的锁！</p></li></ol></li></ul><h3 id="优化之LUA脚本保证删除的原子性"><a href="#优化之LUA脚本保证删除的原子性" class="headerlink" title="优化之LUA脚本保证删除的原子性"></a>优化之LUA脚本保证删除的原子性</h3><ul><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;testLockLua&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLockLua</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1 声明一个uuid ,将做为一个value 放入我们的key所对应的值中</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">    <span class="comment">//2 定义一个锁：lua 脚本可以使用同一把锁，来实现删除！</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">skuId</span> <span class="operator">=</span> <span class="string">&quot;25&quot;</span>; <span class="comment">// 访问skuId 为25号的商品 100008348542</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">locKey</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span> + skuId; <span class="comment">// 锁住的是每个商品的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3 获取锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(locKey, uuid, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一种： lock 与过期时间中间不写任何的代码。</span></span><br><span class="line">    <span class="comment">// redisTemplate.expire(&quot;lock&quot;,10, TimeUnit.SECONDS);//设置过期时间</span></span><br><span class="line">    <span class="comment">// 如果true</span></span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        <span class="comment">// 执行的业务逻辑开始</span></span><br><span class="line">        <span class="comment">// 获取缓存中的num 数据</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;num&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果是空直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是空 如果说在这出现了异常！ 那么delete 就删除失败！ 也就是说锁永远存在！</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(value + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 使num 每次+1 放入缓存</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;num&quot;</span>, String.valueOf(++num));</span><br><span class="line">        <span class="comment">/*使用lua脚本来锁*/</span></span><br><span class="line">        <span class="comment">// 定义lua 脚本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="comment">// 使用redis执行lua执行</span></span><br><span class="line">        DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        redisScript.setScriptText(script);</span><br><span class="line">        <span class="comment">// 设置一下返回值类型 为Long</span></span><br><span class="line">        <span class="comment">// 因为删除判断的时候，返回的0,给其封装为数据类型。如果不封装那么默认返回String 类型，</span></span><br><span class="line">        <span class="comment">// 那么返回字符串与0 会有发生错误。</span></span><br><span class="line">        redisScript.setResultType(Long.class);</span><br><span class="line">        <span class="comment">// 第一个要是script 脚本 ，第二个需要判断的key，第三个就是key所对应的值。</span></span><br><span class="line">        redisTemplate.execute(redisScript, Arrays.asList(locKey), uuid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他线程等待</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 睡眠</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">// 睡醒了之后，调用方法。</span></span><br><span class="line">            testLockLua();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Lua脚本详解：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015170739599.png" alt="image-20221015170739599"></p></li><li><p>项目中正确使用：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015170812863.png" alt="image-20221015170812863"></p></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li><p>加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 从redis中获取锁,set k1 v1 px 20000 nx</span></span><br><span class="line"><span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.redisTemplate.opsForValue()</span><br><span class="line">      .setIfAbsent(<span class="string">&quot;lock&quot;</span>, uuid, <span class="number">2</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></li><li><p>使用lua释放锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 释放锁 del</span></span><br><span class="line"><span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line"><span class="comment">// 设置lua脚本返回的数据类型</span></span><br><span class="line">DefaultRedisScript&lt;Long&gt; redisScript = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 设置lua脚本返回类型为Long</span></span><br><span class="line">redisScript.setResultType(Long.class);</span><br><span class="line">redisScript.setScriptText(script);</span><br><span class="line">redisTemplate.execute(redisScript, Arrays.asList(<span class="string">&quot;lock&quot;</span>),uuid);</span><br></pre></td></tr></table></figure></li><li><p>重试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line">testLock();</span><br></pre></td></tr></table></figure></li><li><p>为了确保分布式锁可用，我们至少要确保锁的实现同时<strong>满足以下四个条件</strong>：</p><ul><li>互斥性。<strong>在任意时刻，只有一个客户端能持有锁</strong>。</li><li><strong>不会发生死锁</strong>。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>解铃还须系铃人。<strong>加锁和解锁必须是同一个客户端</strong>，客户端自己不能把别人加的锁给解了。</li><li><strong>加锁和解锁必须具有原子性</strong>。</li></ul></li></ol><h1 id="Redis6-0新功能"><a href="#Redis6-0新功能" class="headerlink" title="Redis6.0新功能"></a>Redis6.0新功能</h1><h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><h3 id="简介-9"><a href="#简介-9" class="headerlink" title="简介"></a>简介</h3><ul><li><p>Redis ACL是Access Control List（访问控制列表）的缩写，<strong>该功能允许根据可以执行的命令和可以访问的键来限制某些连接，说白了就是可以进行基于用户的权限管理</strong>。</p></li><li><p>在Redis 5版本之前，Redis 安全规则只有密码控制 还有通过rename 来调整高危命令比如 flushdb ， KEYS* ， shutdown 等。<strong>Redis 6 则提供ACL的功能对用户进行更细粒度的权限控制</strong> ：</p><ol><li>接入权限:用户名和密码 </li><li>可以执行的命令 </li><li>可以操作的 KEY</li></ol></li><li><p>参考官网：<a href="https://redis.io/topics/acl">https://redis.io/topics/acl</a></p></li></ul><h3 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h3><ol><li><p>使用<strong>acl list</strong>命令<strong>展现用户权限列表</strong>，数据说明：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015161827095.png" alt="image-20221015161827095"></p></li><li><p>使用<strong>acl cat</strong>命令<strong>查看添加权限指令类别</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015161936151.png" alt="image-20221015161936151"></p><p><strong>加参数类型名可以查看类型下具体命令</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015162016482.png" alt="image-20221015162016482"></p></li><li><p>使用<strong>acl whoami</strong>命令查看当前用户：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015162046674.png" alt="image-20221015162046674"></p></li><li><p>使用<strong>acl setuser</strong>命令<strong>创建和编辑用户的ACL</strong></p><ul><li><p>ACL规则：下面是有效ACL规则的列表。某些规则只是用于激活或删除标志，或对用户ACL执行给定更改的单个单词。其他规则是字符前缀，它们与命令或类别名称、键模式等连接在一起。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015162430565.png" alt="image-20221015162430565"></p></li><li><p>通过命令创建新用户默认权限：<strong>acl setuser user1</strong>，在这个示例中，我根本没有指定任何规则。如果用户不存在，这将<strong>使用just created的默认属性来创建用户</strong>。如果用户已经存在，则上面的命令将不执行任何操作。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015162749523.png" alt="image-20221015162749523"></p></li><li><p>设置有用户名、密码、ACL权限并启用的用户：<em><em>acl setuser user2 on &gt;password ~cached:</em> +get</em>*</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015162858006.png" alt="image-20221015162858006"></p></li><li><p>使用<strong>auth username password</strong>切换用户，验证权限：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015162942902.png" alt="image-20221015162942902"></p></li></ul></li></ol><h2 id="IO多线程"><a href="#IO多线程" class="headerlink" title="IO多线程"></a>IO多线程</h2><h3 id="简介-10"><a href="#简介-10" class="headerlink" title="简介"></a>简介</h3><ul><li><p>Redis6终于支撑多线程了，告别单线程了吗？IO多线程其实指<strong>客户端交互部分</strong>的<strong>网络IO</strong>交互处理模块<strong>多线程</strong>，而非执行命令多线程。<strong>Redis6执行命令依然是单线程</strong>。</p></li><li><p>另外，多线程IO默认也是不开启的，需要在配置文件中配置：</p><p><strong>io-threads-do-reads  yes</strong> &#x2F;&#x2F;开启多线程IO</p><p><strong>io-threads 4</strong> &#x2F;&#x2F;最大线程数？</p></li></ul><h3 id="原理架构"><a href="#原理架构" class="headerlink" title="原理架构"></a>原理架构</h3><ul><li><p>Redis 6 加入多线程,但跟 Memcached 这种从 IO处理到数据访问多线程的实现模式有些差异。<strong>Redis 的多线程部分只是用来处理网络数据的读写和协议解析</strong>，执行命令仍然是单线程。之所以这么设计是不想因为多线程而变得复杂，需要去控制 key、lua、事务，LPUSH&#x2F;LPOP 等等的并发问题。整体的设计大体如下:</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015164018542.png" alt="image-20221015164018542"></p></li></ul><h2 id="工具支持Cluster"><a href="#工具支持Cluster" class="headerlink" title="工具支持Cluster"></a>工具支持Cluster</h2><ul><li><p>之前老版Redis想要搭集群需要单独安装ruby环境，<strong>Redis 5 将 redis-trib.rb 的功能集成到 redis-cli</strong>。另外<strong>官方 redis-benchmark 工具开始支持 cluster 模式了，通过多线程的方式对多个分片进行压测</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015164928416.png" alt="image-20221015164928416"></p></li></ul><h2 id="Redis新功能持续关注"><a href="#Redis新功能持续关注" class="headerlink" title="Redis新功能持续关注"></a>Redis新功能持续关注</h2><ul><li>Redis6新功能还有：<ol><li><strong>RESP3新的 Redis 通信协议</strong>：优化服务端与客户端之间通信</li><li><strong>Client side caching客户端缓存</strong>：基于 RESP3 协议实现的客户端缓存功能。为了进一步提升缓存的性能，将客户端经常访问的数据cache到客户端。减少TCP网络交互。</li><li><strong>Proxy集群代理模式</strong>：Proxy 功能，让 Cluster 拥有像单实例一样的接入方式，降低大家使用cluster的门槛。不过需要注意的是代理不改变 Cluster 的功能限制，不支持的命令还是不会支持，比如跨 slot 的多Key操作。</li><li><strong>Modules API</strong>：Redis 6中模块API开发进展非常大，因为Redis Labs为了开发复杂的功能，从一开始就用上Redis模块。Redis可以变成一个框架，利用Modules来构建不同系统，而不需要从头开始写然后还要BSD许可。Redis一开始就是一个向编写各种系统开放的平台。</li></ol></li></ul><h1 id="Redis实战：黑马点评项目"><a href="#Redis实战：黑马点评项目" class="headerlink" title="Redis实战：黑马点评项目"></a>Redis实战：黑马点评项目</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;NoSQL数据库简介&quot;&gt;&lt;a href=&quot;#NoSQL数据库简介&quot; class=&quot;headerlink&quot; title=&quot;NoSQL数据库简介&quot;&gt;&lt;/a&gt;NoSQL数据库简</summary>
      
    
    
    
    
    <category term="Redis" scheme="https://konjacor.github.io/tags/Redis/"/>
    
    <category term="非关系型数据库" scheme="https://konjacor.github.io/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="中间件" scheme="https://konjacor.github.io/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="https://konjacor.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>https://konjacor.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2022-09-25T11:54:24.000Z</published>
    <updated>2023-03-07T07:05:56.500Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="常用排序算法的总结和对比"><a href="#常用排序算法的总结和对比" class="headerlink" title="常用排序算法的总结和对比"></a>常用排序算法的总结和对比</h2><h3 id="一张排序算法的比较图"><a href="#一张排序算法的比较图" class="headerlink" title="一张排序算法的比较图"></a>一张排序算法的比较图</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106091748277.png" alt="image-20221106091748277"></p><h3 id="相关术语解释"><a href="#相关术语解释" class="headerlink" title="相关术语解释"></a>相关术语解释</h3><ol><li>稳定：如果 a 原本在 b 前面，而 a&#x3D;b，排序之后 a 仍然在 b 的前面；</li><li>不稳定：如果 a 原本在 b 的前面，而 a&#x3D;b，排序之后 a 可能会出现在 b 的后面；</li><li>内部排序：所有排序操作都在内存中完成；</li><li>外部排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度： 一个算法执行所耗费的时间。</li><li>空间复杂度：运行完一个程序所需内存的大小。</li><li>n: 数据规模</li><li>k: “桶”的个数</li><li>In-place: 不占用额外内存</li><li>Out-place: 占用额外内存</li></ol><h2 id="新人入坑冒泡排序"><a href="#新人入坑冒泡排序" class="headerlink" title="新人入坑冒泡排序"></a>新人入坑冒泡排序</h2><ul><li>这个是典中典了，任何学过算法的人估计都学过这个吧，它简单的算法思想也让他成为了入坑排序算法的最佳选择。</li></ul><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,<strong>依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部</strong>，就象水底下的气泡一样逐渐向上冒。</li><li>需要两层循环，<strong>每次外层循环都会使得无序区域最大的一个数字到达正确的位置</strong>，对于长度为n的序列，我们只需要将外层循环做n-1次即可使整个序列有序，<strong>内层循环遍历整个序列的无序部分，目的是让目标元素和相邻元素做比较从而将目标元素放到它该在的地方</strong>。</li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>由于需要两层循环来实现该算法，并且每层循环都和序列长度n有关，所以它的<strong>时间复杂度是：O(n^2)</strong></li></ul><h3 id="冒泡过程图解"><a href="#冒泡过程图解" class="headerlink" title="冒泡过程图解"></a>冒泡过程图解</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105225817170.png" alt="image-20221105225817170"></p><h3 id="对于冒泡排序的优化"><a href="#对于冒泡排序的优化" class="headerlink" title="对于冒泡排序的优化"></a>对于冒泡排序的优化</h3><ul><li>因为排序的过程中，各元素不断接近自己的位置，<strong>如果一趟比较下来没有进行过交换，就说明序列已经有序，就不用做后续的比较操作了</strong>，因此要<strong>在排序过程中设置一个标志 flag 判断元素是否进行过交换，从而减少不必要的比较</strong>。</li></ul><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-07 20:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//本轮中是否有元素进行过交换，如果没有，说明序列已经有序，可以不用做后面的操作了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//归位n-1个数字即可使数组有序</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n-i;++j)&#123;<span class="comment">//每次内层循环需要的次数由于上次数字归位而递减</span></span><br><span class="line">                <span class="keyword">if</span>(num[j]&gt;num[j+<span class="number">1</span>])&#123;<span class="comment">//交换两数的原地算法,但是这样写在数据很大的情况下有数值溢出风险</span></span><br><span class="line">                    flag = <span class="literal">true</span>;<span class="comment">//标记为本轮进行过元素交换</span></span><br><span class="line">                    num[j] += num[j+<span class="number">1</span>];</span><br><span class="line">                    num[j+<span class="number">1</span>] = num[j] - num[j+<span class="number">1</span>];</span><br><span class="line">                    num[j] -= num[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;<span class="comment">//如果本轮没有进行过元素交换，说明已经有序，后面的操作也就不用做了</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(num[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="先挑后换选择排序"><a href="#先挑后换选择排序" class="headerlink" title="先挑后换选择排序"></a>先挑后换选择排序</h2><ul><li>总是和插入排序混掉，这个选择排序是从后面的序列中按一定规则挑出元素来换到前面，而插入排序是从后面的序列中取第一个数然后按一定规则插入到前面，<strong>它们的区别在于选择排序的比较规则体现在后面的序列中，插入排序的比较规则体现在前面的序列中</strong>。</li></ul><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>选择式排序也属于内部排序法，是<strong>从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的</strong>。</li></ul><h3 id="选择排序思想"><a href="#选择排序思想" class="headerlink" title="选择排序思想"></a>选择排序思想</h3><ul><li>选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：<strong>第一次从 arr[0]<del>arr[n-1]中选取最小值，与 arr[0]交换，第二次从 arr[1]</del>arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]<del>arr[n-1]中选取最小值，与 arr[2]交换，…，第 i 次从 arr[i-1]</del>arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值，与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列</strong>。</li><li>和冒泡排序相似，也是两层循环，<strong>外层循环跑一次都会让一个元素归位，内层循环遍历后面的无序序列，挑出其中最小的和无序队列的头部元素进行交换</strong>。对于长度为n的序列，外层循环只需要跑n-1次即可使序列有序。</li></ul><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>由于是两层循环，还都和序列的长度有关，所以<strong>时间复杂度是O(n^2)的</strong></li></ul><h3 id="选择排序过程图解"><a href="#选择排序过程图解" class="headerlink" title="选择排序过程图解"></a>选择排序过程图解</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105230143186.png" alt="image-20221105230143186"></p><ul><li><p>对一个数组的选择排序再进行图解：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105230338223.png" alt="image-20221105230338223"></p></li></ul><h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-07 20:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;++i)&#123;<span class="comment">//归位n-1个数字即可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> num[i];<span class="comment">//让无序区第一个元素先当min，之后动态更新</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> i;<span class="comment">//最小值对应的坐标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;<span class="comment">//从后面的无序区域找最小的换到无序区的最前面，外面每循环一次，无序区域就减少一个单位，由于之前默认让无序区的第一元素作为最小值并知晓其坐标，所以就没必要遍历第一个元素了</span></span><br><span class="line">                <span class="keyword">if</span>(min&gt;num[j])&#123;</span><br><span class="line">                    min = num[j];</span><br><span class="line">                    pos = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos!=i) &#123;<span class="comment">//如果最小值不是无序区的头元素就原地算法交换两数，如果忘了判断最小值是不是无序区的头元素，利用原地交换算法就会出错，但是还是那个问题，如果数据过大会数值溢出</span></span><br><span class="line">                num[i] += num[pos];</span><br><span class="line">                num[pos] = num[i] - num[pos];</span><br><span class="line">                num[i] -= num[pos];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(num[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="先取后插插入排序"><a href="#先取后插插入排序" class="headerlink" title="先取后插插入排序"></a>先取后插插入排序</h2><ul><li>总是和选择排序混掉，选择排序是从后面的序列中按一定规则挑出元素来换到前面，而插入排序是从后面的序列中取第一个数然后按一定规则插入到前面，<strong>它们的区别在于选择排序的比较规则体现在后面的序列中，插入排序的比较规则体现在前面的序列中</strong>。</li></ul><h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。</li></ul><h3 id="插入排序思想"><a href="#插入排序思想" class="headerlink" title="插入排序思想"></a>插入排序思想</h3><ul><li>插入排序（Insertion Sorting）的基本思想是：<strong>把 n 个待排序的元素看成为一个有序表和一个无序表</strong>，开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，<strong>排序过程中每次从无序表中取出第一个元素，把它的排序码依次与前面有序表元素的排序码进行比较，如果满足给定的条件就进行交换，如果中间某一次没有交换，说明该元素已经归位，这样做能将它插入到有序表中的适当位置，使之成为有序表的一部分</strong>。</li><li>也是需要两层循环，<strong>外层循环每循环一次都会将一个无序区的元素归位，内层循环主要是让选中的元素和前面的有序部分进行逐个比较好确定选中的元素应该插入的位置</strong>。</li></ul><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>由于还是两层循环，并且每层循环都和序列长度有关，所以<strong>时间复杂度还是O(n^2)的</strong>。</li></ul><h3 id="插入排序过程图解"><a href="#插入排序过程图解" class="headerlink" title="插入排序过程图解"></a>插入排序过程图解</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105232220474.png" alt="image-20221105232220474"></p><h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-07 23:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//第一个元素可以看作已经归位，也就是说刚开始有序区是1，接下来把剩下的n-1个元素插入到有序区即可</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=<span class="number">0</span>;--j)&#123;<span class="comment">//让无序区的头元素向前（也就是有序区）基于比较来进行移动，中间某一次没移动就说明归位了，退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(num[j]&lt;num[j-<span class="number">1</span>])&#123;<span class="comment">//交换两数的原地算法，还是那个问题，如果数据过大会数值溢出</span></span><br><span class="line">                    num[j] += num[j-<span class="number">1</span>];</span><br><span class="line">                    num[j-<span class="number">1</span>] = num[j] - num[j-<span class="number">1</span>];</span><br><span class="line">                    num[j] -= num[j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(num[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插排优化希尔排序"><a href="#插排优化希尔排序" class="headerlink" title="插排优化希尔排序"></a>插排优化希尔排序</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。<strong>希尔排序也是一种插入排序</strong>，它<strong>是简单插入排序经过改进之后的一个更高效的版本</strong>，也称为<strong>缩小增量排序</strong>。</li></ul><h3 id="希尔排序思想"><a href="#希尔排序思想" class="headerlink" title="希尔排序思想"></a>希尔排序思想</h3><ul><li><p>在简单插入排序中存在这样一个问题，说极端点就是如果最后一个无序元素非常小，那么它在插入到前面有序序列时的消耗是很大的，我们自然不希望看到这样的情况频繁发生，所以<strong>希尔排序的思想就是以这一点为切入点，通过增量分组的方式，每次分组排序后都尽量让整个序列均匀，也就是每次分组排序后让整个序列尽可能有序，防止出现某个元素消耗过多的时间去比较，从而优化时间复杂度</strong>。</p></li><li><p>希尔排序是<strong>把记录按下标的一定增量分组，对每组使用直接插入排序算法排序</strong>；随着增量逐渐减少，每组包含的关键词越来越多，<strong>当增量减至 1 时，整个文件恰被分成一组，算法便终止</strong>。</p></li><li><p>需要三层循环，<strong>外层循环负责控制分组步长大小，步长大小从序列的长度开始，之后的每次步长都是上次步长的一半，直到步长大小变成0，退出循环</strong>。<strong>中层循环每次从下标为分组步长的元素开始（这个下标对应着所有分组的最前面的无序元素）负责遍历每个分组无序区的元素（步长为1挪到最后就相当于遍历了所有分组的无序元素）</strong>。<strong>内层循环负责对遍历到的无序元素在它们组内（体现在每次比较跨越的步长为外层循环的值，这样可以保证相互比较的值都是同一组）进行插入排序（基于比较往前挪，直到中间某一次没挪，说明归位了）</strong>。</p></li><li><p>写完代码说一句：不愧是历史上时间复杂度首次突破O(n^2)的算法，这三层循环真是挺巧妙的。</p></li></ul><h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>查前面那个表。</li></ul><h3 id="希尔排序流程图解"><a href="#希尔排序流程图解" class="headerlink" title="希尔排序流程图解"></a>希尔排序流程图解</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106092745473.png" alt="image-20221106092745473"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106092757251.png" alt="image-20221106092757251"></p><h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-08 9:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=num.length/<span class="number">2</span>;k&gt;<span class="number">0</span>;k/=<span class="number">2</span>)&#123;<span class="comment">//控制分组步长，从数组长度除2开始，每次迭代都除2，直到小于等于0，说明已经排好序了</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;num.length;++i)&#123;<span class="comment">//为了进行插入排序，我们首先要定位到每一组的第一个无序元素，而每轮的k正好是所有分组的第一个无序元素（因为第一组的有序区元素下标为0，这个下标加上步长k正好是第一个无序元素，而第一组的第一个无序元素又是所有分组中最靠前的，可以保证在它之后的所有元素都是无序区的元素，在它前面的元素都是有序区的元素），之后每次i++的时候就相当于遍历到了别的分组的无序区的头元素，遍历完一轮分组之后，所有分组的无序区的头元素归位，继续i++就是遍历所有分组的新无序区的头元素，直到最后，i可以遍历完所有分组的无序区</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i-k;j&gt;=<span class="number">0</span>;j-=k)&#123;<span class="comment">//把上一层循环选中的元素移动到它所在分组的有序区的正确位置，基于比较移动</span></span><br><span class="line">                    <span class="keyword">if</span>(j!=j+k&amp;&amp;num[j]&gt;num[j+k])&#123;<span class="comment">//原地交换，还是那些问题，数据过大会导致数值溢出并且两边下标相同时会出现问题，总的说就是交换两个元素的时候最少需要两个单位的空间（两个元素已经占用了两个单位的空间）</span></span><br><span class="line">                        num[j] += num[j+k];</span><br><span class="line">                        num[j+k] = num[j] - num[j+k];</span><br><span class="line">                        num[j] -= num[j+k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(num[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="期待已久的堆排序"><a href="#期待已久的堆排序" class="headerlink" title="期待已久的堆排序"></a>期待已久的堆排序</h2><ul><li>堆排序这个东西，在上大一的时候就有所耳闻，然而当时写题都用c++自带的快速排序的函数，所以对这种神奇的排序方法也没有深究，这一眨眼上大三了，学校里也开了算法的课程，正好学到了这个堆排序，我听了听确实巧妙，回来之后根据自己的理解进行了实现，下面细说。</li></ul><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><ul><li><p><strong>同时满足以下两个条件</strong>的数据结构被称为堆：</p><ol><li>堆是一颗<strong>完全二叉树</strong></li><li>堆的<strong>每一个节点的值都大于等于或都小于等于其子节点的值</strong></li></ol></li><li><p>每个节点的值都大于等于其子节点的值的堆被称为<strong>最大堆（或者是大根堆）</strong>，剩下的那种情况被称为<strong>最小堆（或者是小根堆）</strong>。</p></li></ul><h3 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h3><ul><li>由于二叉树特殊的访问性质，所以我们一般都<strong>通过数组来存储堆</strong>，可以通过二叉树的性质来对一个节点的父节点或是子节点进行访问，比如说<strong>下标为i的节点的父节点的下标为floor((i-1)&#x2F;2)</strong>,<strong>其子节点的下标为(i*2+1)和(i*2+2)</strong></li></ul><h3 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h3><h4 id="节点上移（SiftUp）"><a href="#节点上移（SiftUp）" class="headerlink" title="节点上移（SiftUp）"></a>节点上移（SiftUp）</h4><ul><li><p>这个操作可以<strong>让某个节点上移直到合适的位置</strong>，由于其父节点只可能有一个，因此只需要进行一次判断并且只有一种上移路径，其中应该格外注意在进行节点上移的时候不要发生数组越界。</p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (index&gt;<span class="number">0</span> &amp;&amp; num[index]&gt;num[(index-<span class="number">1</span>)/<span class="number">2</span>])&#123;<span class="comment">//没越界，并且当前节点位置异常</span></span><br><span class="line">        <span class="comment">//System.out.println(1);</span></span><br><span class="line">   <span class="comment">//下面三行是交换操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num[index];</span><br><span class="line">        num[index] = num[(index-<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">        num[(index-<span class="number">1</span>)/<span class="number">2</span>] = temp;</span><br><span class="line">        <span class="comment">//坐标重定向为交换过去的位置</span></span><br><span class="line">        index = (index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="节点下移（SiftDown）"><a href="#节点下移（SiftDown）" class="headerlink" title="节点下移（SiftDown）"></a>节点下移（SiftDown）</h4><ul><li><p>这个操作可以<strong>让某个节点下移直到合适的位置</strong>，其子节点可能有多个，因此需要进行两次判断，由于有两种下移路径，我们应该<strong>选用最合适的路径进行下移</strong>，其中应该格外注意在进行节点下移的时候不要发生数组越界。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((index*<span class="number">2</span>+<span class="number">1</span>)&lt;len &amp;&amp; (index*<span class="number">2</span>+<span class="number">2</span>)&lt;len)&#123;<span class="comment">//有俩孩子的情况</span></span><br><span class="line">        <span class="comment">//System.out.println(1);</span></span><br><span class="line">        <span class="keyword">if</span>(!(num[index]&gt;=num[index*<span class="number">2</span>+<span class="number">1</span>]&amp;&amp;num[index]&gt;=num[index*<span class="number">2</span>+<span class="number">2</span>]))&#123;<span class="comment">//当前节点位置异常，选最合适的一条路径进行下移</span></span><br><span class="line">            <span class="keyword">if</span>(num[index*<span class="number">2</span>+<span class="number">1</span>]&gt;num[index*<span class="number">2</span>+<span class="number">2</span>])&#123;<span class="comment">//第一种情况</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num[index];</span><br><span class="line">                num[index] = num[index*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">                num[index*<span class="number">2</span>+<span class="number">1</span>] = temp;</span><br><span class="line">                index = index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//第二种情况</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num[index];</span><br><span class="line">                num[index] = num[index*<span class="number">2</span>+<span class="number">2</span>];</span><br><span class="line">                num[index*<span class="number">2</span>+<span class="number">2</span>] = temp;</span><br><span class="line">                index = index*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">//当前节点的位置正常了则不需要做额外操作，直接break，这个地方少了会死循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((index*<span class="number">2</span>+<span class="number">1</span>)&lt;len)&#123;<span class="comment">//只有一个孩子的情况，顶多再下移一次了，既能处理一开始就是这样的情况，又能处理上面的代码执行完毕后剩下是这种的情况，一举两得。</span></span><br><span class="line">        <span class="keyword">if</span>(num[index]&lt;num[index*<span class="number">2</span>+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num[index];</span><br><span class="line">            num[index] = num[index*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">            num[index*<span class="number">2</span>+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="插入元素（Insert）"><a href="#插入元素（Insert）" class="headerlink" title="插入元素（Insert）"></a>插入元素（Insert）</h4><ul><li>将<strong>新元素加到堆的最后</strong>，将<strong>堆的规模加1</strong>，然后<strong>使用SiftUp操作将新元素移动到合适的位置</strong>上</li><li>代码示例：</li></ul><h4 id="删除元素（Delete）"><a href="#删除元素（Delete）" class="headerlink" title="删除元素（Delete）"></a>删除元素（Delete）</h4><ul><li>将待删除的元素与最后一个元素进行交换，将堆的大小减1（也就是<strong>保证被删除的元素不参与元素上移或者下移的判断</strong>），然后<strong>再用SiftDown操作或者SiftUp操作来调整换上来的那个元素</strong>以维持堆的性质。</li><li>代码示例：</li></ul><h4 id="删除最大值（DeleteMax）"><a href="#删除最大值（DeleteMax）" class="headerlink" title="删除最大值（DeleteMax）"></a>删除最大值（DeleteMax）</h4><ul><li><strong>对栈顶元素进行删除元素（Delete）操作</strong>即可。</li><li>代码示例：</li></ul><h4 id="创建堆（MakeHeap）"><a href="#创建堆（MakeHeap）" class="headerlink" title="创建堆（MakeHeap）"></a>创建堆（MakeHeap）</h4><ul><li><p>目的是<strong>将一个随机排列的数组变成一个符合堆定义的数组</strong></p></li><li><p>叶节点只有他本身，没有子树，所以它本身是符合堆的定义的，那么我们就需要<strong>从倒数第一个非叶节点（实际上就是最后一个节点的父节点）开始进行操作</strong>，因为非叶节点有子树，并不能保证它们是符合堆的性质的，因此需要<strong>通过节点下移进行调整</strong>，调整完毕后当前子树符合堆的性质了，再往上走<strong>遇到节点时总能保证它的子树是符合堆定义的，但是顶点的位置不一定正常，因此只需要让顶点进行下移操作即可将其本身也调整为一个堆</strong>，调整完所有非叶节点后，所有子树包括它本身就都符合堆的定义了，这样一个堆就建好了。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shift</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=((len-<span class="number">1</span>)-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i)&#123;<span class="comment">//从最后一个非叶节点开始，倒数第一个非叶子节点实际上就是最后一个节点的父节点</span></span><br><span class="line">        shiftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="堆排序（HeapSort）"><a href="#堆排序（HeapSort）" class="headerlink" title="堆排序（HeapSort）"></a>堆排序（HeapSort）</h4><ul><li><p>首先要<strong>保证这个数组符合堆的定义才能进行堆排序</strong>。</p></li><li><p>每次都<strong>让顶点元素和最后一个元素换位置</strong>，然后将<strong>堆的逻辑长度减1</strong>（也就是<strong>不让换到最后的元素参与下移的运算</strong>），此时除了顶点外别的部分都符合堆的定义，因此需要<strong>对顶点进行下移操作以保证堆的性质</strong>，这个操作完毕后第一轮就结束了，在<strong>堆最后的有序区增加了一个元素</strong>，一共执行这个操作n（数组长度）次，堆排序就做好了。</p></li><li><p>不难分析出**堆排序的时间复杂度是O(NlogN)**的，换位置的操作复杂度是O(N)，节点下移操作的复杂度是O(logN)，每次换位置的操作后都会有个下移操作，所以整体时间复杂度是O(NlogN)。</p></li><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num.length;++i)&#123;<span class="comment">//做n次</span></span><br><span class="line">        <span class="comment">//换位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num[<span class="number">0</span>];</span><br><span class="line">        num[<span class="number">0</span>] = num[len-<span class="number">1</span>];</span><br><span class="line">        num[len-<span class="number">1</span>] = temp;</span><br><span class="line">        <span class="comment">//堆的逻辑长度--，为的是不让有序区参与下移运算，只让剩下的无序部分参与下移操作</span></span><br><span class="line">        len--;</span><br><span class="line">        <span class="comment">//使用下移操作对堆顶点进行调整</span></span><br><span class="line">        shiftDown(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul><li>很明显，在堆上做的节点上移和节点下移操作时间复杂度都是O(logN)的，而每次得到最大值的操作都有节点下移操作，得到所有元素的时间复杂度是O(N)的，所以时间复杂度应该是O(NlogN)的。</li></ul><h2 id="分而治之归并排序"><a href="#分而治之归并排序" class="headerlink" title="分而治之归并排序"></a>分而治之归并排序</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>这种排序方式主要突出一个分而治之，<strong>将大问题分解成小问题，等小问题解决了之后再合并成为大问题的解</strong>，这种形式的问题就很适合用递归进行解决，每次递归都是一次解决小问题的过程，有些小问题暂时还没法解决怎么办，没事，继续往下递归，到最后层层返回后的答案就是合并后的答案。</li></ul><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li>主要思路就是：<strong>每次递归将数组对半分，分别对左右两半的数组进行递归保证左右两边的数组都是有序的之后，再调用双路归并的算法来对两半数组进行合并</strong>，每次递归都执行上述操作，最后得到的答案就是排序后的数组。</li></ul><h3 id="双路归并算法"><a href="#双路归并算法" class="headerlink" title="双路归并算法"></a>双路归并算法</h3><ul><li>该算法是归并排序中合并两个有序集合的操作，具体实现是：<strong>三个指针i，j，k分别表示左集合的头元素，右集合的头元素，结果集合的头元素，每次比较i，j指向的元素，将比较小的那个元素放到结果集合中并移动指针</strong>，以此类推最后得到的就是合并了两个有序集合的有序集合。</li></ul><h3 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul><li>二分的时间复杂度是O(logN)的，二路归并的时间复杂度是O(N)的，每次二分之后都会有一个二路归并，所以总体的<strong>时间复杂度是O(NlogN)的</strong>，但是递归所造成的空间消耗是巨大的。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-06 23:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入数据规模：&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        random.setSeed(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            arr[i] = random.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">dateBefore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        arr = sort(arr);</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        System.out.println(<span class="string">&quot;一共用时：&quot;</span>+((<span class="keyword">new</span> <span class="title class_">Date</span>().getTime()-dateBefore.getTime())/<span class="number">60000.0</span>)+<span class="string">&quot;分钟&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length==<span class="number">1</span>)&#123;<span class="comment">//如果只有一个元素，那这个集合本身就是有序的，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> arr.length/<span class="number">2</span>;<span class="comment">//二分</span></span><br><span class="line">        <span class="keyword">return</span> merge(sort(Arrays.copyOfRange(arr,<span class="number">0</span>,mid)),sort(Arrays.copyOfRange(arr,mid,arr.length)));<span class="comment">//保证两边的集合都有序后再合并</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] merge(<span class="type">int</span>[] a,<span class="type">int</span>[] b)&#123;<span class="comment">//二路归并操作</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[a.length+b.length];<span class="comment">//结果数组的长度应该是两个数组的长度之和</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;<span class="comment">//分别是两个数组的头指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;ans.length;++k)&#123;<span class="comment">//对结果数组中的每个元素进行赋值</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;a.length&amp;&amp;j&lt;b.length) &#123;<span class="comment">//两个数组都没到头的时候</span></span><br><span class="line">                ans[k] = a[i] &lt; b[j] ? a[i++] : b[j++];<span class="comment">//赋值为较小的那个并移动指针</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//其中至少有一个数组遍历到头了，就把剩下的元素都塞到后面即可</span></span><br><span class="line">                <span class="keyword">for</span>(;i&lt;a.length;++i)&#123;</span><br><span class="line">                    ans[k++] = a[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(;j&lt;b.length;++j)&#123;</span><br><span class="line">                    ans[k++] = b[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>还<strong>可以用来求逆序对的数量</strong>，在归并的<strong>二路归并阶段</strong>，由于左边的有序数组在原数组中一定是在右边的有序数组的前面的，所以<strong>如果遇到左边的有序数组的当前元素大于右边有序数组的当前元素，那么根据左边数组有序和左边数组在原数组中在右边数组的左边这两个条件，我们可以得知，从左边数组的当前元素开始之后的所有元素都能和右边数组的当前元素组成一个逆序对</strong>，就是在这个地方统计逆序对的数量。并且<strong>由于每次二路归并的时候右半部分都是之前从未出现过的元素，所以保证了这样计算的结果不会重复</strong>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="literal">null</span>||nums.length==<span class="number">0</span>|| nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] r = recursion(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r.length;++i)&#123;</span><br><span class="line">            System.out.print(r[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] recursion(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[left]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] leftArr = recursion(nums,left,mid);</span><br><span class="line">        <span class="type">int</span>[] rightArr = recursion(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[leftArr.length+rightArr.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIdx</span> <span class="operator">=</span> <span class="number">0</span>,rightIdx = <span class="number">0</span>,tempIdx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (leftIdx!=leftArr.length&amp;&amp;rightIdx!=rightArr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftArr[leftIdx]&gt;rightArr[rightIdx])&#123;</span><br><span class="line">                ans += leftArr.length-leftIdx;<span class="comment">//统计逆序对的数量</span></span><br><span class="line">                temp[tempIdx++] = rightArr[rightIdx++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[tempIdx++] = leftArr[leftIdx++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(leftIdx!= leftArr.length)&#123;</span><br><span class="line">            temp[tempIdx++] = leftArr[leftIdx++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rightIdx!=rightArr.length)&#123;</span><br><span class="line">            temp[tempIdx++] = rightArr[rightIdx++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="用得最多快速排序"><a href="#用得最多快速排序" class="headerlink" title="用得最多快速排序"></a>用得最多快速排序</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul><li>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</li><li>效率很高，**平均时间复杂度可以达到O(NlogN)**，但是通常情况下都要比这个快。</li></ul><h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><ul><li>也是有一个分治的思想在里面，不过每次调整序列的时候是用了效率比较高的方式，其思想是<strong>选中序列中的一个数作为基准数</strong>，我们要调整当前序列为：<strong>所有在基准数左边的数都比基准数要小，所有在基准数右边的数都比基准数要大</strong>。<strong>调整完毕后，再递归地对其左右边的序列继续上面的步骤</strong>，最后递归层层返回后得到的结果就是排序好的序列。</li><li>怎么调整序列呢？基本思路是：<strong>设置i，j两个指针分别指向序列的头和尾，选取尾部元素作为基准数，提前记录下来，然后i开始向后扫描，扫描到比基准数小的就过，扫描到比基准数大的就把i当前的值赋值给j位置的值，并让j–，由于j位置的值就是基准数，而基准数被提前记录了，所以在这个操作中没有数据的损失；做完上述步骤之后，换为j向前扫描，扫描到比基准数大的就过，扫描到比基准数小的就把j当前的值赋值给i位置的值，并让i++，由于i位置的值在上一步中已经被记录到之前j所在的位置，所以在这个操作中也没有数据的损失，之后就是一直重复上面的步骤直至i和j汇合，此时的位置就是基准数应该在的位置，将基准数赋值给这个位置，调整完毕</strong>。</li><li>为什么上述方式可以保证调整成功呢？是因为最后i和j汇合的地方是基准数的位置，所以在汇合之前，i和j所在的区域都应该是满足调整成功的序列的条件的，所以<strong>无论是谁在扫描序列，在碰上不符合这个区域的条件的元素时，我们就要拜托远在另一个区域的“兄弟”把当前这个不符合条件的数字处理掉，由于处理掉之后产生了空位（至少从逻辑上是这样的，因为当前位置留下的那个数字冗余了），所以当前空位上的指针还要处理一下这个空位，于是它就一直等待它远在另外一个区域的“兄弟”帮它找到一个符合条件的元素来给它处理一下这个空位，而此时另外那个兄弟因为解决了空位问题所以继续扫描，周而复始就能解决所有空位，并能使两边的区域中的元素都符合条件，最后一个空位兄弟俩一起解决，将最开始的那个元素填入，至此调整完毕</strong>。</li><li>总之就是萝卜填坑，一个萝卜一个坑，如果想要把一个萝卜填在已经有萝卜的坑中，那就先把那个萝卜拔出来，然后再把新萝卜填进去。</li></ul><h3 id="时间复杂度分析-2"><a href="#时间复杂度分析-2" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul><li>最坏情况下每次比较都需要交换位置，所以最坏情况下的时间复杂度是O(N^2)的。</li><li>最好情况下和平均情况下的时间复杂度都是O(NlogN)的</li><li>正是因为有如此优秀的平均时间复杂度和较小的空间开销，才使得快速排序立于不败之地。</li></ul><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-07 12:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入数据规模：&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        random.setSeed(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            arr[i] = random.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">dateBefore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        sort(<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        System.out.println(<span class="string">&quot;一共用时：&quot;</span>+((<span class="keyword">new</span> <span class="title class_">Date</span>().getTime()-dateBefore.getTime())/<span class="number">60000.0</span>)+<span class="string">&quot;分钟&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;<span class="comment">//begin是处理的当前区间的左界，end是处理的当前区间的右界</span></span><br><span class="line">        <span class="comment">//System.out.println(begin+&quot; &quot;+end);</span></span><br><span class="line">        <span class="keyword">if</span>(begin&gt;=end) <span class="keyword">return</span>;<span class="comment">//如果出现只有一个元素或者没有元素的情况在逻辑上就是有序的，直接返回即可</span></span><br><span class="line">        <span class="type">int</span> i=begin,j=end,p=arr[end];<span class="comment">//设置左右哨兵，记录最后一个值为基准数，准备扫描</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">shift</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//为true时i往后扫描，为false时j往前扫描</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;<span class="comment">//没有碰头时说明基准数的位置还没定下来</span></span><br><span class="line">            <span class="keyword">if</span>(shift)&#123;<span class="comment">//i往后扫描</span></span><br><span class="line">                <span class="keyword">if</span>(arr[i]&gt;p)&#123;<span class="comment">//找到了异端，拜托j处理掉它，i在此等待填坑</span></span><br><span class="line">                    arr[j] = arr[i];<span class="comment">//处理异端</span></span><br><span class="line">                    j--;<span class="comment">//j的坑填完了可以继续扫描了</span></span><br><span class="line">                    shift = <span class="literal">false</span>;<span class="comment">//让j扫描</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> i++;<span class="comment">//如果没找到异端就继续扫描</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//j往前扫描</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;p)&#123;<span class="comment">//找到了异端，拜托i处理掉它，j在此等待填坑</span></span><br><span class="line">                    arr[i] = arr[j];<span class="comment">//处理异端</span></span><br><span class="line">                    i++;<span class="comment">//i的坑填完了可以继续扫描了</span></span><br><span class="line">                    shift = <span class="literal">true</span>;<span class="comment">//让i扫描</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> j--;<span class="comment">//如果没找到异端就继续扫描</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(i+&quot; &quot;+j);</span></span><br><span class="line">        arr[i] = p;<span class="comment">//将基准数归位</span></span><br><span class="line">        <span class="comment">//System.out.println(p);</span></span><br><span class="line">        sort(begin,i-<span class="number">1</span>);<span class="comment">//处理左半截，开头是begin不是0，因为这次递归处理的是其中一个区间</span></span><br><span class="line">        sort(i+<span class="number">1</span>,end);<span class="comment">//处理右半截，结尾是end不是arr.length-1，因为这次递归处理的是其中一个区间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性复杂度选择数组中的第K个最大-x2F-最小元素"><a href="#线性复杂度选择数组中的第K个最大-x2F-最小元素" class="headerlink" title="线性复杂度选择数组中的第K个最大&#x2F;最小元素"></a>线性复杂度选择数组中的第K个最大&#x2F;最小元素</h3><ul><li><p>是快速排序思想的一种应用，用于在线性复杂度内选择给定数组中的第k个最大&#x2F;最小元素。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230107103905808.png" alt="image-20230107103905808"></p></li><li><p>用快速排序的思想，要找第k个最大的元素，实际上就是找升序排序后的数组的下标为<code>nums.length-k</code>的元素，又因为<strong>快速排序每一轮都会确定这一轮的轴心数在排序完成后的数组中的位置</strong>，所以我们只需要在每一轮快速排序结束的时候，判断一下这一轮轴心数确定下来的位置是不是<code>nums.length-k</code>，如果是的话说明就找到答案了，直接返回即可，如果不是，根据大小关系，继续向左或向右递归。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        recursion(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[right];<span class="comment">//轴心元素为这一段最后一个元素，先记录下来</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftD</span> <span class="operator">=</span> left;<span class="comment">//记录下left的复制，后面递归用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightD</span> <span class="operator">=</span> right;<span class="comment">//记录下right的复制，后面递归用</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//true为left往右走，false为right往左走</span></span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;<span class="comment">//两者相遇，说明两者相遇位置的左右边的元素都符合规则了</span></span><br><span class="line">            <span class="keyword">if</span>(oper)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left]&gt;pivot)&#123;<span class="comment">//如果找到不应该在这一边的元素，就扔给right处理（right在之前肯定留出了位置），空出了当前位置准备放right那边不合理的元素，所以让oper取反，让right行动</span></span><br><span class="line">                    nums[right] = nums[left];</span><br><span class="line">                    oper = !oper;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果元素合理就继续往下巡逻</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[right]&lt;pivot)&#123;<span class="comment">//如果找到不应该在这一边的元素，就扔给left处理（left在之前肯定留出了位置），空出了当前位置准备放left那边不合理的元素，所以让oper取反，让left行动</span></span><br><span class="line">                    nums[left] = nums[right];</span><br><span class="line">                    oper = !oper;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果元素合理就继续往下巡逻</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = pivot;<span class="comment">//相遇的地方是轴心元素的地方，现在轴心左边都小于等于轴心，轴心右边都大于等于轴心</span></span><br><span class="line">        <span class="keyword">if</span>(left == nums.length-k)&#123;<span class="comment">//如果这一轮轴心的位置就是要找的那个位置，答案就找到了，因为每一轮过后都会确定本轮轴心在最后排好序的数组的位置，记录并返回</span></span><br><span class="line">            ans = nums[left];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left&lt;nums.length-k)&#123;<span class="comment">//轴心位置小于要找的位置，就向右再找</span></span><br><span class="line">            recursion(nums,left+<span class="number">1</span>,rightD,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> recursion(nums,leftD,left-<span class="number">1</span>,k);<span class="comment">//轴心位置大于要找的位置，就向左再找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="速度很快的桶排序"><a href="#速度很快的桶排序" class="headerlink" title="速度很快的桶排序"></a>速度很快的桶排序</h2><h3 id="桶排序思路"><a href="#桶排序思路" class="headerlink" title="桶排序思路"></a>桶排序思路</h3><ul><li>将待排序元素划分到不同的桶。先扫描一遍序列求出最大值 maxV 和最小值 minV ，设桶的个数为 k ，则把区间 [minV, maxV] 均匀划分成 k 个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。</li><li>对每个桶内的元素进行排序。可以选择任意一种排序算法。</li><li>将各个桶中的元素合并成一个大的有序序列。</li><li>假设数据是均匀分布的，则每个桶的元素平均个数为 n&#x2F;k 。假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为 O(n&#x2F;klog(n&#x2F;k)) 。总的时间复杂度为O(n)+O(k)O(n&#x2F;klog(n&#x2F;k)) &#x3D; O(n+nlog(n&#x2F;k)) &#x3D; O(n+nlogn-nlogk) 。当 k 接近于 n 时，桶排序的时间复杂度就可以金斯认为是 O(n) 的。即桶越多，时间效率就越高，而桶越多，空间就越大。</li></ul><h3 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="桶数最多计数排序"><a href="#桶数最多计数排序" class="headerlink" title="桶数最多计数排序"></a>桶数最多计数排序</h2><h3 id="计数排序思想"><a href="#计数排序思想" class="headerlink" title="计数排序思想"></a>计数排序思想</h3><ul><li><p>是一种<strong>时间复杂度为O(n)的排序算法</strong>，其思路是开一个长度为 maxValue-minValue+1 的数组，然后</p><ol><li><p><strong>分配</strong>：扫描一遍原始数组，以当前值 - minValue 作为下标，将该下标的计数器增1。</p></li><li><p><strong>收集</strong>：扫描一遍计数器数组，按顺序把值收集起来。</p></li></ol></li><li><p>举个例子， nums&#x3D;[2, 1, 3, 1, 5] , 首先扫描一遍获取最小值和最大值， maxValue&#x3D;5 , minValue&#x3D;1 ，于是开一个长度为5的计数器数组 counter ，</p><ol><li><p>分配。统计每个元素出现的频率，得到 counter&#x3D;[2, 1, 1, 0, 1] ，例如 counter[0] 表示值 0+minValue&#x3D;1 出现了2次。</p></li><li><p>收集。 counter[0]&#x3D;2 表示 1 出现了两次，那就向原始数组写入两个1， counter[1]&#x3D;1 表示 2 出现了1次，那就向原始数组写入一个2，依次类推，最终原始数组变为 [1,1,2,3,5] ，排序好了。</p></li></ol></li><li><p>计数排序本质上<strong>是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序</strong>。</p></li></ul><h3 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-09 10:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> INF;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//存储数据并找出数据中的最大值和最小值</span></span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(min&gt;num[i]) min = num[i];</span><br><span class="line">            <span class="keyword">if</span>(max&lt;num[i]) max = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[max-min+<span class="number">1</span>];<span class="comment">//把桶子创建出来，创建max-min+1个而不是max个实际上是优化空间，但相应要在下面的步骤中多做一点操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//对桶子对应的元素进行计数，计数为几说明存在几个当前桶子对应的元素，不过记得元素减min之后再给对应桶子计数，最后遍历的时候也要将桶子对应的元素加上min，这样才能得到原数据</span></span><br><span class="line">            bucket[num[i]-min]++;<span class="comment">//将元素给个偏移量后放进对应的桶子中，后面输出的时候应该让桶子对应的元素把偏移量加回去</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max-min+<span class="number">1</span>;++i)&#123;<span class="comment">//遍历桶子</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;bucket[i];++j)&#123;<span class="comment">//根据当前桶子的计数来决定输出当前桶子对应的元素的数量，桶子大于1的计数在原数据中体现为重复的元素</span></span><br><span class="line">                System.out.print((i+min)+<span class="string">&quot; &quot;</span>);<span class="comment">//记得输出的时候把偏移量加回去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数位做桶基数排序"><a href="#数位做桶基数排序" class="headerlink" title="数位做桶基数排序"></a>数位做桶基数排序</h2><h3 id="基数排序介绍"><a href="#基数排序介绍" class="headerlink" title="基数排序介绍"></a>基数排序介绍</h3><ul><li>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾名思义，<strong>它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</strong>。</li><li>基数排序法是属于稳定性的排序，基数排序法的是<strong>效率高的稳定性排序法</strong>。</li><li><strong>基数排序(Radix Sort)是桶排序的扩展</strong>。</li><li>基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：<strong>将整数按位数切割成不同的数字，然后按每个位数分别比较</strong>。</li></ul><h3 id="基数排序基本思想"><a href="#基数排序基本思想" class="headerlink" title="基数排序基本思想"></a>基数排序基本思想</h3><ul><li><strong>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零</strong>。然后，<strong>从最低位开始，依次进行一次排序</strong>。这样<strong>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</strong>。</li><li>实际上的原理就是<strong>每次循环过后使得下一次循环放入同一个桶中的元素从当前数位开始到最后组成的数字有序了，而不同的桶本身就自带顺序属性，在两方有序的加持下，整体的表现就是有序</strong>，比如123和221，经过一次循环之后221排到123前面了；那么在下一次循环中，221和123放到了同一个桶中，由于上一次循环把它们的个位数排序了，所以在这次循环中，它们从十位数开始之后的数位组成的数字是有序的，然后221又排到了123前面；再下一次循环，123和221不在一个桶中了，123又排到了221的前面，更高位数的数以此类推。实际上这么多次循环<strong>是在解决由于放入桶中的条件减少导致的桶内元素无序的情况，每次循环都致力于让最后的桶内部的元素是有序的</strong>。（我在说些什么。。。）</li><li>很明显，<strong>外层循环次数由序列中元素的最大数位长度（十进制）决定</strong>，<strong>由于某个数位的大小是0-9，所以桶的数量固定为10</strong>。</li><li>需要两层循环，<strong>外层循环控制本次是用哪个数位进行桶排序，内层循环做桶排序</strong>。</li></ul><h3 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>虽然用到了两层循环，但是<strong>外层循环是和最大数位长度（十进制）k有关，内层循环做桶排序和序列长度n有关</strong>，所以<strong>时间复杂度是O(nk)的</strong>。</li></ul><h3 id="基数排序流程图解"><a href="#基数排序流程图解" class="headerlink" title="基数排序流程图解"></a>基数排序流程图解</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106105500208.png" alt="image-20221106105500208"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106105512310.png" alt="image-20221106105512310"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106105526703.png" alt="image-20221106105526703"></p><h3 id="代码示例-6"><a href="#代码示例-6" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-09 10:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDigit</span> <span class="operator">=</span> -INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//存储数据，顺便找到所有数字中最大的数位长度作为桶排序的次数</span></span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> getDigit(num[i]);<span class="comment">//获取对应数字的数位长度</span></span><br><span class="line">            maxDigit = maxDigit&lt;digit?digit:maxDigit;<span class="comment">//找最大的数位长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;LinkedList&lt;Integer&gt;&gt; bucket = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//创建桶子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;<span class="comment">//因为每个数位的大小只能是0-9，而我们要对某个数位进行桶排序，所以只需要十个桶即可。</span></span><br><span class="line">            bucket.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//bucket = bucket.stream().map((v) -&gt; new LinkedList&lt;Integer&gt;()).collect(Collectors.toList());//流式操作初始化容器（好吧这样好像不太行）</span></span><br><span class="line">        <span class="comment">//System.out.println(bucket.size());</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxDigit;++i)&#123;<span class="comment">//对每个数位进行桶排序，从0开始方便后面做相关计算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">divisor</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">10</span>,i);<span class="comment">//用于获取对应的数位，数字除以这个数，然后再mod10就是对应的数位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;<span class="comment">//遍历数据，根据当前循环到数位往桶子里放</span></span><br><span class="line">                bucket.get((num[j]/divisor)%<span class="number">10</span>).add(num[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//更新num用的下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;++j)&#123;<span class="comment">//遍历桶</span></span><br><span class="line">                <span class="keyword">while</span> (!bucket.get(j).isEmpty())&#123;<span class="comment">//如果桶子里面有元素，取出元素更新num</span></span><br><span class="line">                    num[index++] = bucket.get(j).poll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(num[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDigit</span><span class="params">(<span class="type">int</span> num)</span>&#123;<span class="comment">//获取一个数字的数位长度，就是一个数字十进制下有几位数，比如123的数位长度是3，12的数位长度是2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><ul><li>二分不是单纯指从有序数组中快速找某个数，这只是二分的一个应用。</li><li>二分的<strong>本质是两段性，并非单调性</strong>。也就是说<strong>只要一段满足某个性质，另一段不满足这个性质，就可以使用二分</strong>。</li></ul><h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ul><li>二分法的一个难点在于如何确定移动条件和方式，比如说，在什么条件下我应该左移？怎么左移？对于二分来说不一定就是满足某个条件left就右移，也有可能是满足什么条件后left做什么特殊处理，所以如何确定移动条件和方法这个问题要想清楚</li><li>二分法的另一个难点在于如何确定边界条件的写法，这一个难点主要分为两个小点：第一点就是循环退出的条件，第二点就是满足条件后left、right的移动。其实对于这样的问题，只需要<strong>考虑left和right两个元素贴在一起的场景，计算出mid之后，考虑在这种边界场景下，left和right应该如何移动，循环应该什么时候退出</strong>即可。</li></ul><h2 id="二分问题通用思考模型"><a href="#二分问题通用思考模型" class="headerlink" title="二分问题通用思考模型"></a>二分问题通用思考模型</h2><ul><li>首先<strong>分析数组的二段性</strong>，也就是我们要<strong>找一个分界点（可能是某个元素或者元素之间的空隙），这个分界点左边的元素都满足某个特性，这个分界点右边的元素满足另一个特性</strong>，比如有序数组就满足二段性，在有序数组中我们可以找到一个元素，这个元素左边的元素都小于它，这个元素右边的元素都大于它。</li><li>分析好二段性之后，<strong>二段性实际上就是我们需要移动左右指针的条件</strong>，比如mid满足前一段的特性，那么如果我们想要找分界点，我们就需要让left指针后移。</li><li>分析最后一次移动，也就是<strong>分析left和right在分界点周围的元素重合（通常不止一个，可能重合在分界点前面和后面）的时候进行的最后一次移动，这一次移动完之后循环将退出</strong>，我们需要<strong>考虑这次移动完之后left和right谁才是最后的答案</strong>，考虑出来之后返回答案就好。</li></ul><h2 id="二分找最后一个小于target的元素和第一个大于target的元素"><a href="#二分找最后一个小于target的元素和第一个大于target的元素" class="headerlink" title="二分找最后一个小于target的元素和第一个大于target的元素"></a>二分找最后一个小于target的元素和第一个大于target的元素</h2><ul><li><p>这个主要是考虑left&#x3D;&#x3D;right时的那最后一次移动，应该思考此时如果在答案附近的元素进行最后一次移动之后到底是left还是right是最后的答案。</p></li><li><p>先给个模板代码吧，之后再写思想：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bs</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target,<span class="type">boolean</span> flag)</span>&#123;<span class="comment">//flag是true的时候是找最后一个小于target的元素，flag是false的时候是找第一个大于target的元素，别的情况都可以推断出来</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag?right:left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><ul><li><p>这个算法是用来快速求幂运算的，也就是求a^b^这样的问题，可以带上取模运算，也就是求a^b^ % mod，如果使用普通的算法来求的话，复杂度是O(N)的，但是如果使用快速幂来进行求解，复杂度可以被优化到O(logN)。</p></li><li><p>其原理就是将指数拆解成二进制的形式，通过对二进制的每一位的运算来得到最后的结果，设指数为n，那么普通算法需要遍历n次，而快速幂只需要遍历O(logN)次，所以复杂度是O(logN)的。</p></li><li><p>证明：</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">pow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> mod)</span>&#123;<span class="comment">//求a^b % mod</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//这是最后的结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//这是用来判断指数b某二进制数位的值的变量</span></span><br><span class="line">    <span class="comment">//下面两行将temp调整成和指数b二进制数位长度相同，方便之后从高位到低位获取指数b的二进制数位的值</span></span><br><span class="line">    <span class="keyword">while</span> (temp&lt;=b) temp&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    temp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="number">0</span>)&#123;<span class="comment">//然后就是开始计算，直到temp==0也就是说把指数b的二进制数位的最后一位也用完了</span></span><br><span class="line">        ans = ((ans%mod)*(ans%mod))%mod;<span class="comment">//无论指数b当前二进制数位的值是多少，ans都要平方，注意取模</span></span><br><span class="line">        <span class="keyword">if</span>((temp&amp;b)!=<span class="number">0</span>)&#123;<span class="comment">//如果指数b当前二进制数位的值是1，那么ans就还要乘底数a，注意取模</span></span><br><span class="line">            <span class="comment">//System.out.println(temp);</span></span><br><span class="line">            ans = ((a%mod)*(ans%mod))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        temp&gt;&gt;=<span class="number">1</span>;<span class="comment">//使用完指数b的最高位，下一轮要使用指数b的低一位，所以temp右移1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(ans);</span></span><br><span class="line">    <span class="keyword">return</span> ans;<span class="comment">//返回答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><h1 id="如何创建一棵二叉树"><a href="#如何创建一棵二叉树" class="headerlink" title="如何创建一棵二叉树"></a>如何创建一棵二叉树</h1><ul><li><p><strong>首先将所有节点按照层序遍历的顺序放入一个线性结构</strong>，然后<strong>再遍历这个线性结构，用访问二叉树子节点的方式(左节点下标为i*2+1，右节点下标为i*2+2)访问当前节点的左右节点并将这些节点建立起联系</strong>。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-10 14:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入树的节点(包括空节点)的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;树为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入树的层序结构（空节点用&#x27;#&#x27;表示，元素之间用空格分割）：&quot;</span>);</span><br><span class="line">        List&lt;TreeNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//用线性结构先把树的节点存储起来，之后再建立节点之间的关系</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//输入节点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.next();<span class="comment">//这个读取String的方法可以被空格阻断</span></span><br><span class="line">            <span class="keyword">if</span>(input.charAt(<span class="number">0</span>)==<span class="string">&#x27;#&#x27;</span>)&#123;<span class="comment">//处理空节点</span></span><br><span class="line">                nodes.add(<span class="literal">null</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//处理非空节点</span></span><br><span class="line">                nodes.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(input)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//建立节点之间的联系</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> nodes.get(i);<span class="comment">//取出当前节点，准备给其左右节点赋值</span></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="literal">null</span>) <span class="keyword">continue</span>;<span class="comment">//如果当前节点是个空节点，就continue，不过从面向对象的角度来说，空节点也应该是一个对象，不过有点麻烦所以就没弄</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//左节点下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i*<span class="number">2</span>+<span class="number">2</span>;<span class="comment">//右节点下标</span></span><br><span class="line">            <span class="keyword">if</span>(left&lt;n)&#123;<span class="comment">//检测左节点下标是否越界，如果越界了不用处理，默认反正就是null</span></span><br><span class="line">                temp.setLeft(nodes.get(left));<span class="comment">//设置左节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right&lt;n)&#123;<span class="comment">//检测右节点下标是否越界，如果越界了不用处理，默认反正就是null</span></span><br><span class="line">                temp.setRight(nodes.get(right));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);<span class="comment">//联系建立完毕后，线性结构中的第一个节点就是树的根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;<span class="comment">//二叉树节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;<span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode left;<span class="comment">//左节点</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode right;<span class="comment">//右节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(TreeNode left)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(TreeNode right)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="二叉树遍历算法"><a href="#二叉树遍历算法" class="headerlink" title="二叉树遍历算法"></a>二叉树遍历算法</h1><h2 id="二叉树的纵序遍历"><a href="#二叉树的纵序遍历" class="headerlink" title="二叉树的纵序遍历"></a>二叉树的纵序遍历</h2><h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><ul><li><strong>以下均以先遍历左子树再遍历右子树为前提</strong>。</li></ul><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul><li>该算法巧妙地利用到了一个二叉树中叶节点的空指针，从而使空间复杂度降到了O(1)，原理是<strong>构建了一颗线索二叉树，使得每次访问到每个子树的最后一个节点后都能找到应该回到哪里继续进行遍历</strong>，这一线索在之前学过的遍历方法中由递归、栈提供，但在Morris遍历中利用叶节点的空指针来提供。</li><li>morris遍历是二叉树遍历算法的超强进阶算法，morris遍历可以将非递归遍历中的空间复杂度降为O(1)。从而实现时间复杂度为O(N)，而空间复杂度为O(1)的精妙算法。<strong>morris遍历利用的是树的叶节点左右孩子为空（树的大量空闲指针），实现空间开销的极限缩减</strong>。</li></ul><h4 id="实现原则"><a href="#实现原则" class="headerlink" title="实现原则"></a>实现原则</h4><ul><li>记当前节点为cur：<ol><li>如果cur无左孩子，cur向右移动（cur&#x3D;cur.right）</li><li>如果cur有左孩子，找到cur左子树上最右的节点，记为mostright：如果mostright的right指针指向空，让其指向cur，cur向左移动（cur&#x3D;cur.left）；如果mostright的right指针指向cur，让其指向空，cur向右移动（cur&#x3D;cur.right）。</li></ol></li></ul><h4 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h4><ul><li>建立一种机制，对于没有左子树的节点只到达一次，对于有左子树的节点会到达两次。</li><li>实际上就是<strong>构建了一棵线索二叉树，让每个子树的最后遍历到的元素的右指针指向这颗子树的顶点，这样遍历完这颗子树后，就可以返回到顶点处（返回后要取消线索，意味着左子树已经遍历完毕）进行下一步的遍历操作了</strong>。</li></ul><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-10 14:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Morris</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入树的节点(包括空节点)的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;树为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入树的层序结构（空节点用&#x27;#&#x27;表示，元素之间用空格分割）：&quot;</span>);</span><br><span class="line">        List&lt;TreeNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//用线性结构先把树的节点存储起来，之后再建立节点之间的关系</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//输入节点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.next();<span class="comment">//这个读取String的方法可以被空格阻断</span></span><br><span class="line">            <span class="keyword">if</span>(input.charAt(<span class="number">0</span>)==<span class="string">&#x27;#&#x27;</span>)&#123;<span class="comment">//处理空节点</span></span><br><span class="line">                nodes.add(<span class="literal">null</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//处理非空节点</span></span><br><span class="line">                nodes.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(input)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//建立节点之间的联系</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> nodes.get(i);<span class="comment">//取出当前节点，准备给其左右节点赋值</span></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="literal">null</span>) <span class="keyword">continue</span>;<span class="comment">//如果当前节点是个空节点，就continue，不过从面向对象的角度来说，空节点也应该是一个对象，不过有点麻烦所以就没弄</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//左节点下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i*<span class="number">2</span>+<span class="number">2</span>;<span class="comment">//右节点下标</span></span><br><span class="line">            <span class="keyword">if</span>(left&lt;n)&#123;<span class="comment">//检测左节点下标是否越界，如果越界了不用处理，默认反正就是null</span></span><br><span class="line">                temp.setLeft(nodes.get(left));<span class="comment">//设置左节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right&lt;n)&#123;<span class="comment">//检测右节点下标是否越界，如果越界了不用处理，默认反正就是null</span></span><br><span class="line">                temp.setRight(nodes.get(right));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);<span class="comment">//联系建立完毕后，线性结构中的第一个节点就是树的根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pointer</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">if</span>(pointer==<span class="literal">null</span>) System.out.println(<span class="string">&quot;树为空&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;指定树的前序Morris遍历的结果为&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(pointer!=<span class="literal">null</span>)&#123;<span class="comment">//Morris遍历，这里写个前序</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">mostRight</span> <span class="operator">=</span> pointer.left;<span class="comment">//mostRight用来找左子树的最右边的节点，把当前节点的左树赋给mostRight可以在后面顺便检测左树是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(mostRight!=<span class="literal">null</span>)&#123;<span class="comment">//如果左树存在</span></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="literal">null</span> &amp;&amp; mostRight.right!=pointer)&#123;<span class="comment">//找左子树最靠右的节点，最靠右的节点的右节点一定是null或者当前节点</span></span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(mostRight.right == <span class="literal">null</span>)&#123;<span class="comment">//如果最右节点的右节点是null，说明这个左子树还没有被遍历过，就做好线索之后向左遍历，这个线索指向当前节点，为的是遍历完左子树回到当前节点并且还是作为左子树已经遍历过的标志</span></span><br><span class="line">                    System.out.print(pointer.val+<span class="string">&quot; &quot;</span>);<span class="comment">//前序遍历，在向左遍历之前输出</span></span><br><span class="line">                    mostRight.right = pointer;<span class="comment">//建立线索</span></span><br><span class="line">                    pointer = pointer.left;<span class="comment">//向左遍历</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果最右节点的右节点是当前节点，说明这个左子树已经被遍历过了，恢复右指针为null并向右遍历即可</span></span><br><span class="line">                    <span class="comment">//这里没有输出语句，是因为这个条件中是左子树已经被遍历过了，由于是前序遍历，所以当前节点应该已经被输出过一遍了，不用再输出一遍了。</span></span><br><span class="line">                    mostRight.right = <span class="literal">null</span>;<span class="comment">//消除线索</span></span><br><span class="line">                    pointer = pointer.right;<span class="comment">//向右遍历</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果左树不存在</span></span><br><span class="line">                System.out.print(pointer.val+<span class="string">&quot; &quot;</span>);<span class="comment">//前序遍历，没有左子树的时候，输出再向右遍历</span></span><br><span class="line">                pointer = pointer.right;<span class="comment">//向右遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;<span class="comment">//二叉树节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;<span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode left;<span class="comment">//左节点</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode right;<span class="comment">//右节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(TreeNode left)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(TreeNode right)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码里还有个<strong>创建一棵树</strong>的知识点。</p><h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><h3 id="利用队列实现"><a href="#利用队列实现" class="headerlink" title="利用队列实现"></a>利用队列实现</h3><ul><li><p>总体思想就是BFS的思想，先初始化队列（往队列里面放第一个值），每次从队列中poll一个元素，然后把和这个元素相邻的下一层元素再放到队列中，一直重复操作直到队列为空，不过其中有几个比较难想的点。</p></li><li><p>如何获取每一层的元素数量？<strong>每一层的元素数量就是外层循环刚开始时的队列的长度，内层循环根据这个长度来poll元素即可保证poll出来的元素是同一层的</strong>，不过内层for循环中<strong>不要把queue.size()当作循环结束条件</strong>，而要在for循环之前记录队列在循环刚开始时的值，因为在内层循环中队列的长度是不断变化的，不能当作循环结束的条件。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;TreeNode&gt; qu = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; mid;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        qu.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!qu.isEmpty())&#123;</span><br><span class="line">            mid = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> qu.size();<span class="comment">//本层的节点数量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;++i) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> qu.poll();</span><br><span class="line">                mid.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>)</span><br><span class="line">                    qu.add(temp.left);</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>)</span><br><span class="line">                    qu.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h1 id="分支限界算法"><a href="#分支限界算法" class="headerlink" title="分支限界算法"></a>分支限界算法</h1><h2 id="状态空间树（解空间树）"><a href="#状态空间树（解空间树）" class="headerlink" title="状态空间树（解空间树）"></a>状态空间树（解空间树）</h2><ul><li>状态空间树就是问题的解空间树，分为<strong>子集树</strong>和<strong>排列树</strong>。</li><li>状态空间树<strong>通常是一个虚拟的树，并不需要我们实际将其构建出来，它的存在只是为了让我们能进一步理解解决问题需要计算的规模和问题的可能存在的解等，起到的是辅助的作用</strong>。</li><li><strong>对于明显不可能找到答案的分支我们可以选择不予遍历来提高效率，这样就是对状态空间树剪枝，剪枝的难点在于设计剪枝条件</strong>。</li></ul><h3 id="子集树"><a href="#子集树" class="headerlink" title="子集树"></a>子集树</h3><ul><li><p>当所给的问题是<strong>从n个元素组成的集合set中找到满足某一条件的一个子集时，相应的解空间树称为子集树</strong>。要注意，这个<strong>解空间树是一个虚拟的树，并不是需要实际构建出来的</strong>。</p></li><li><p><strong>0-1背包问题的解空间树实际上就是一个很典型的子集树，因为我们实际上是想要找到所有物品这个集合中的一个子集，使得子集中的物品能全部装到背包中并且价值最大</strong>，所以我们可以使用子集树来描述0-1背包问题的解空间。</p></li><li><p>对于<strong>0-1背包问题</strong>的子集树，我们通常<strong>将每个节点描述为目前装载的物品，向左遍历可以再装下一个物品，向右遍历不装下一个物品</strong>，以此类推，将所有的物品全部都决定完装或者不装之后，当前的节点也就是叶节点就可能是答案，要尝试更新答案，当将状态空间树的所有节点全部遍历一遍之后，答案也就被找出来了。</p></li><li><p>子集树示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121145007229.png" alt="image-20221121145007229"></p></li></ul><h3 id="排列树"><a href="#排列树" class="headerlink" title="排列树"></a>排列树</h3><ul><li><p>当所给的问题是<strong>求n个元素的全排列的时候，相应的解空间树称为排列树</strong>。要注意，这个<strong>解空间树是一个虚拟的树，并不是需要实际构建出来的</strong>。</p></li><li><p><strong>TSP问题（也就是旅行商问题，求从一个节点开始走过所有其它节点一遍后返回起始节点所需的最短路径）的解空间树实际上就是一个很典型的排列树，因为我们无论如何都要走过所有其它的节点一遍，只是顺序有先后，因此我们需要遍历其所有的顺序，从中找出答案</strong>。</p></li><li><p>对于<strong>TSP问题</strong>，我们通常<strong>将每个节点描述为目前经过的图上节点，每一层的遍历都是尝试将所有没经过的图上节点加入到经过的图上节点中，所以一个父节点有几个孩子不一定</strong>。最后所有图上节点都经过一遍之后，当前节点就是叶节点就可能是答案，要尝试更新答案，当将状态空间树的所有节点全部遍历一遍之后，答案也就被找出来了。</p></li><li><p>排列树示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121151314120.png" alt="image-20221121151314120"></p></li></ul><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><ul><li>如果说回溯法是使用深度优先搜索的方式遍历一个问题的状态空间树来寻找可能的答案，那么<strong>分支限界法实际上就是使用广度优先搜索的方式遍历一个问题的状态空间树来寻找可能的答案</strong>。</li><li><strong>相比于回溯法的用递归解决问题，分支限界法常常具有更好的效率和更小的空间开销，每次都能决定状态空间树一整层节点的特性也让依赖于同层节点状态的剪枝变得相对容易一些</strong>。</li><li>在优化方面可以根据具体情况进行<strong>剪枝</strong>；也可以看情况用<strong>优先队列</strong>代替做广度优先搜索用到的队列，让最有可能找出答案的节点尽量早些被遍历到。</li><li>对于分支限界算法来说，<strong>如何设计状态空间树的节点是很重要的</strong>，<strong>状态空间树的节点中包含的属性应该可以准确描述当前状态并能为顺利构建下一个状态提供帮助，最好是还带有一些特定数据从而能更方便地实现剪枝操作</strong>。</li></ul><h2 id="0-1背包问题的分支限界法解决"><a href="#0-1背包问题的分支限界法解决" class="headerlink" title="0-1背包问题的分支限界法解决"></a>0-1背包问题的分支限界法解决</h2><ul><li><p><strong>难点在于设计状态空间树的节点、剪枝以及使用优先队列进行优化</strong>。</p></li><li><p><strong>将所有物品按照性价比进行降序排序，然后从前往后尝试进行选择，向左遍历是选择当前物品，向右遍历时不选择当前物品</strong>。</p></li><li><p>对于节点的设计，需要一个<strong>index来指示下一个应该尝试选择的物品是第几个（在针对性价比排列过的序列中），这个属性对于顺利构建出下一个节点也有很重要的作用</strong>；需要一个<strong>valueNow来表示当前节点代表的状态装了价值为多少的东西</strong>；需要一个<strong>weightNow来表示当前节点代表的状态装了重量为多少的东西</strong>；还需要一个<strong>upperBound来表示当前节点表示的状态中背包的剩余空间全部利用上（装不下的可以装一部分，总之让剩余空间要全部装满）最多还能装多少价值的东西，这个属性是用来剪枝用的，如果要是valueNow+upperBound小于等于目前更新到的可能的答案，那么就可以剪枝了，因为沿着这条路走下去不可能会遍历到一个节点使得valueNow大于当前更新到的可能的答案，也就是说答案不可能在这条路上得到更新，直接剪掉就好了</strong>。</p></li><li><p>还可以<strong>用优先队列代替队列进行广度优先搜索，将最有可能得到答案的节点提前遍历，提高提前找到答案的可能性</strong>。</p></li><li><p>代码示例，没有做剪枝和优先队列优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-20 9:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BranchAndBound01Backpack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入背包的容量：&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">w</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入物品的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">double</span>[] value = <span class="keyword">new</span> <span class="title class_">double</span>[n];<span class="comment">//存物品价值</span></span><br><span class="line">        <span class="type">double</span>[] weight = <span class="keyword">new</span> <span class="title class_">double</span>[n];<span class="comment">//存物品重量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+i+<span class="string">&quot;个物品的价值和重量：&quot;</span>);</span><br><span class="line">            value[i-<span class="number">1</span>] = scanner.nextDouble();</span><br><span class="line">            weight[i-<span class="number">1</span>] = scanner.nextDouble();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//冒泡排序将物品按照性价比排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n-i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(value[j]/weight[j]&lt;value[j+<span class="number">1</span>]/weight[j+<span class="number">1</span>])&#123;<span class="comment">//计算相邻两个物品的性价比，如果顺序不对就交换两个物品的位置（体现在交换两个数组的元素位置上）</span></span><br><span class="line">                    <span class="type">double</span> <span class="variable">temp</span> <span class="operator">=</span> value[j];</span><br><span class="line">                    value[j] = value[j+<span class="number">1</span>];</span><br><span class="line">                    value[j+<span class="number">1</span>] = temp;</span><br><span class="line">                    temp = weight[j];</span><br><span class="line">                    weight[j] = weight[j+<span class="number">1</span>];</span><br><span class="line">                    weight[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//队列</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,getUpperBound(value,weight,<span class="number">0</span>,w)));<span class="comment">//加入初始节点</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;<span class="comment">//广度优先遍历状态空间树</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(temp.index&gt;=n)&#123;<span class="comment">//如果下标越界，说明当前可能是答案，所以对答案尝试更新</span></span><br><span class="line">                <span class="keyword">if</span>(temp.valueNow&gt;ans) ans = temp.valueNow;<span class="comment">//尝试更新答案</span></span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//由于下标越界，所以后面不可能有别的节点了，它是叶节点，所以不用扩展它的子节点，直接continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将空间状态树的两个子节点加入队列中</span></span><br><span class="line">            <span class="keyword">if</span>(temp.weightNow+weight[temp.index]&lt;=w)&#123;<span class="comment">//这是要装下一个物品的节点，如果能装下下一个物品就装，如果不能装下的话就不装，体现在程序上就是是否能计算得到下一个有效的状态节点并将其加入到队列中去</span></span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(temp.index+<span class="number">1</span>,temp.valueNow+value[temp.index],temp.weightNow+weight[temp.index],getUpperBound(value,weight,temp.index+<span class="number">1</span>,w-temp.weightNow-weight[temp.index])));</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(temp.index+<span class="number">1</span>,temp.valueNow,temp.weightNow,getUpperBound(value,weight,temp.index+<span class="number">1</span>,w-temp.weightNow)));<span class="comment">//这是不装下一个物品的节点，由于不装下一个节点，所以除了上界以外的属性都和它的父节点相同。</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;背包所能装下的最大价值为：&quot;</span>+ans);<span class="comment">//输出结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getUpperBound</span><span class="params">(<span class="type">double</span>[] value,<span class="type">double</span>[] weight,<span class="type">int</span> index,<span class="type">double</span> weightRest)</span>&#123;<span class="comment">//index是从哪开始计算，因为要算的是剩下的空间最多还能装多少价值的东西所以已经决定选或不选的元素不参与计算，weightRest是背包剩余的可以装东西的重量</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;value.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(weightRest&gt;=weight[i])&#123;<span class="comment">//如果装的下就装</span></span><br><span class="line">                ans+=value[i];</span><br><span class="line">                weightRest-=weight[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果装不下就按照单位重量的价值计算最多能装的价值是多少</span></span><br><span class="line">                ans+=weightRest*(value[i]/weight[i]);</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//weightRest用光了，直接退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> index;<span class="comment">//下一个应该判断第几个要不要装了</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> valueNow;<span class="comment">//装到现在的价值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> weightNow;<span class="comment">//装到现在的重量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> upperBound;<span class="comment">//装到现在的可能的最大价值上界（也就是理论上最多还能装的价值）</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> index,<span class="type">double</span> valueNow,<span class="type">double</span> weightNow,<span class="type">double</span> upperBound)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.valueNow = valueNow;</span><br><span class="line">            <span class="built_in">this</span>.weightNow = weightNow;</span><br><span class="line">            <span class="built_in">this</span>.upperBound = upperBound;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="TSP问题的分支限界法解决"><a href="#TSP问题的分支限界法解决" class="headerlink" title="TSP问题的分支限界法解决"></a>TSP问题的分支限界法解决</h2><h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><h2 id="DP之编辑距离"><a href="#DP之编辑距离" class="headerlink" title="DP之编辑距离"></a>DP之编辑距离</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>很经典的一个问题，<strong>编辑距离指的是从一个字符串变更为另外一个字符串所需要的最少操作数</strong>，其中可以做三种操作：插入一个字符、删除一个字符、修改一个字符。</li></ul><h3 id="DP思想"><a href="#DP思想" class="headerlink" title="DP思想"></a>DP思想</h3><ul><li><strong>首先将大问题逐步分解为小问题</strong>，以there和here两个字符串为例，大问题是there到here的编辑距离，那么所有小问题就是：t到here、th到here、the到here……</li><li>经过上面对于大问题的分解，我们不难发现<strong>所有小问题的状态是需要一个m*n的二维数组来进行表示的</strong>，因此我们需要建立一个二维dp数组，数组元素dp[i][j]代表第一个字符串的前i个字符和第二个字符串的前j个字符的编辑距离，所以最后的dp[m][n]就是答案。</li><li>分解完问题之后，我们<strong>再来看看对于每个子问题解是否满足无后效性</strong>，也就是说每个子问题的解是否不影响后序子问题求解，很明显是不影响的。</li><li>再<strong>看看子问题是否具有重叠性</strong>。</li><li>然后<strong>再确定dp的状态转移方程</strong>，考虑中间某个值<strong>dp[i][j]可以从哪些值转移过来</strong>，以下都是以对第一个字符串做操作为基础，首先可以<strong>从dp[i-1][j]+1转移过来，这个转移对应着我们对第一个字符串删除一个元素</strong>，因为i-1能变到j，i对应的字符没用了；其次可以<strong>从dp[i][j-1]+1转移过来，这个转移对应着我们对第一个字符串增加一个元素使得其和第二个字符串j位置上的字符相同</strong>，因为都能从i变到j-1了，只需要插入一个和j对应的字符相同的字符就能成了；再者<strong>可以从dp[i-1][j-1]+!(a[i]&#x3D;&#x3D;b[j])转移过来，这个转移对应着我们对第一个字符串修改一个元素使得i对应的元素和j对应的元素相同</strong>，因为已经可以从i-1转移到j-1了，所以只需要将剩下的俩元素修改成一样的就行了，如果剩下得俩字符本来就相同的话，那就没必要修改了，值就和dp[i-1][j-1]一样了。综上所述，所有的三个操作对应三个可能的转移方向，确定值的时候只需要取个最小值即可。</li><li>确定好状态转移方程后，我们只是确定了中间那部分子问题的求解方式，但是边界子问题的求解方式不一定和中间那部分子问题的求解方式相同，所以我们<strong>要再确定边界子问题的求解方式</strong>。对于边界情况，也就是从一个字符串变成空串，所需要的操作数就是这个字符串的长度，因为只需要把字符串的所有元素都删掉就能达成目标。<strong>对于dp数组来说我们可以额外对每个维度再开出一个空间来，以保证较外层求解时可以使用中间层的求解范式而不至于造成数组越界或者是增加一些繁琐的判断操作</strong>。</li><li>确定完边界子问题的求解方式后，我们要<strong>先将边界子问题求出，这一步实际上就是初始化dp数组，然后再使用状态转移方程对其他子问题求解即可</strong>。</li></ul><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-15 20:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EditDistance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第一个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第二个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[a.length()+<span class="number">1</span>][b.length()+<span class="number">1</span>];<span class="comment">//每个维度大小加一对边界初始化后方便状态转移</span></span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;a.length();++i)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.print(a.indexOf(i)+&quot; &quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a.length();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=b.length();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>) dp[i][j] = Math.max(i,j);<span class="comment">//边界子问题求解</span></span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>,Math.min(dp[i][j-<span class="number">1</span>]+<span class="number">1</span>,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+(a.charAt(i-<span class="number">1</span>)==b.charAt(j-<span class="number">1</span>)?<span class="number">0</span>:<span class="number">1</span>)));<span class="comment">//状态转移</span></span><br><span class="line"><span class="comment">//                System.out.print(a.indexOf(i-1)+b.indexOf(j-1)+dp[i][j]);</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;答案为：&quot;</span>+dp[a.length()][b.length()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DP之TSP问题"><a href="#DP之TSP问题" class="headerlink" title="DP之TSP问题"></a>DP之TSP问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>就是旅行商问题，问的是，给你一个图，然后求从一个节点经过剩下所有节点之后回到一开始那个节点所用的最小花费。</li></ul><h3 id="DP思想-1"><a href="#DP思想-1" class="headerlink" title="DP思想"></a>DP思想</h3><ul><li>以下<strong>假设是从节点0开始出发</strong>。</li><li>可以<strong>把问题描述为：从节点0开始出发，经过集合中除了节点0的剩余节点，最后再返回到节点0所需要的最小费用</strong>。</li><li>然后我们可以定义子问题，每次从集合中的节点中拿出一个来当作子问题的起始节点，这样<strong>子问题就变成了：从取出来的节点开始出发，经过集合中除了节点0和取出来的节点的剩余节点，最后回到节点0所需要的最小费用</strong>。当从集合中把每个元素都取遍，实际上所有子问题也就被遍历过了，找到所有第一轮子问题中结果最小的那个就是答案，不过要确定第一轮子问题的答案，还需要将所有第一轮子问题分解出第二轮子问题，然后确定每一个第一轮子问题分解出的所有第二轮子问题的答案的最小值，那就是对应的第一轮子问题的答案……以此类推，直到无法再分后将答案一层层返回上来，思想像递归，不过在dp中是倒推。</li><li>再想想怎么进行状态转移，可以<strong>设置二维dp数组，第一维表示节点，第二位表示当前节点最后到达节点0所通过的子集(都不包括节点0)<strong>，对于子集更长的状态来说，应该从子集长度减一的所有状态中</strong>距离最短的状态</strong>中转移过来，<strong>所以子集更长的状态转移依赖于所有子集长度减一的状态</strong>，所以做状态转移的时候应该是<strong>按轮进行状态转移，子集长度相同的状态在同一轮被确定下来</strong>，这样才能为后面的状态进行确定的时候提供有效的前置状态。</li><li>如果是节点0作为起始点的话，最后的结果应该是dp数组中最右上角的那个元素，那个元素代表着节点0通过除了节点0的所有节点之后回到节点0的距离，<strong>这个答案是从所有子集长度减一的有效状态中转移过来的</strong>。</li></ul><h3 id="dp数组图解"><a href="#dp数组图解" class="headerlink" title="dp数组图解"></a>dp数组图解</h3><ul><li><p>dp状态转移方程：其中V’代表不包含它前面节点和起始节点的子集。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221023194550921.png" alt="image-20221023194550921"></p></li><li><p>dp数组示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221024202014918.png" alt="image-20221024202014918"></p></li></ul><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-22 17:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TSPQuestionDP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">inf</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;<span class="comment">//正无穷</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入节点数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] g = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];<span class="comment">//邻接矩阵存图</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>)];<span class="comment">//dp数组，第一维为节点，第二维为子集</span></span><br><span class="line">        <span class="comment">//int[][] subSet = new int[n][n];</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化邻接矩阵</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                g[i][j] = inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入边的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+(i+<span class="number">1</span> )+<span class="string">&quot;条边的起点、终点、权值：&quot;</span>);</span><br><span class="line">            g[scanner.nextInt()][scanner.nextInt()] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取子集</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subSet = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//所有子集</span></span><br><span class="line">        HashMap&lt;ArrayList&lt;Integer&gt;,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//子集对应的访问下标</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[n-<span class="number">1</span>];<span class="comment">//用于求子集</span></span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n-<span class="number">1</span>];<span class="comment">//用于求子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//初始化要求子集的集合</span></span><br><span class="line">            temp[i-<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(temp,<span class="number">0</span>,vis,subSet);<span class="comment">//求子集</span></span><br><span class="line">        subSet.sort((o1,o2) -&gt; &#123;<span class="comment">//按照自定义的排序方式进行排序，返回负数表示当前两者关系是有序（升序）的，无需做调整</span></span><br><span class="line">            <span class="keyword">if</span>(o1.size()==o2.size())&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;o1.size();++i)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(o1.get(i)!=o2.get(i))&#123;</span><br><span class="line">                        <span class="keyword">return</span> o1.get(i)&lt;=o2.get(i)?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.size()&lt;=o2.size()?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;subSet.size();++i)&#123;<span class="comment">//建立集合和下标的映射</span></span><br><span class="line">            <span class="comment">//System.out.println(subSet.get(i));</span></span><br><span class="line">            map.put(subSet.get(i),i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//初始化dp数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = g[i][<span class="number">0</span>];<span class="comment">//节点i经过空集到节点0，距离就是它们之间的距离</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//节点i经过集合中的单个元素（不能是当前节点）到节点0，距离就是当前节点到集合中的那个节点的距离再加上集合中的那个节点到节点0的距离</span></span><br><span class="line">                    <span class="keyword">if</span>(!subSet.get(j).contains(i) &amp;&amp; g[i][subSet.get(j).get(<span class="number">0</span>)]!=inf &amp;&amp; g[subSet.get(j).get(<span class="number">0</span>)][<span class="number">0</span>]!=inf) dp[i][j] = g[i][subSet.get(j).get(<span class="number">0</span>)] + g[subSet.get(j).get(<span class="number">0</span>)][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = inf;<span class="comment">//如果其中任意两节点无法到达，设置为正无穷，方便之后淘汰经过当前元素的转移方案。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>;m&lt;n;++m)&#123;<span class="comment">//由于更长的子集需要所有之前更短的子集转移出来的结果，所以每轮转移要保证子集长度都相同</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//记录dp的列应该从哪继续转移</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;++j)&#123;<span class="comment">//每一轮的子集数量和组合数有关</span></span><br><span class="line">                begin += C(n-<span class="number">1</span>,j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> begin+C(n-<span class="number">1</span>,m);<span class="comment">//记录dp的列这一轮应该转移到哪里</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">1</span>;--i)&#123;<span class="comment">//dp的行从下往上转移，从上往下也行，但是不转移节点0。</span></span><br><span class="line">                <span class="comment">//System.out.println(begin+&quot; &quot;+end);</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=begin;j&lt;end;++j) &#123;<span class="comment">//dp的列</span></span><br><span class="line">                    <span class="keyword">if</span> (!subSet.get(j).contains(i)) &#123;<span class="comment">//通过的子集中不能包含当前节点</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> inf;<span class="comment">//用于找所有方案中最短的那个</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; subSet.get(j).size(); ++k) &#123;<span class="comment">//依次试遍所有子问题</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">selectedNum</span> <span class="operator">=</span> subSet.get(j).get(k);<span class="comment">//被选中独立出来的元素</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//把一个元素独立出来后，剩下的子集对应的dp列的访问下标</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; subSet.size(); ++l) &#123;<span class="comment">//找独立出元素后的子集对应的dp列的访问下标</span></span><br><span class="line">                                <span class="comment">//先筛一波长度差一并且其中不含独立出来的元素的子集</span></span><br><span class="line">                                <span class="keyword">if</span> (subSet.get(l).size() + <span class="number">1</span> == subSet.get(j).size() &amp;&amp; !subSet.get(l).contains(selectedNum)) &#123;</span><br><span class="line">                                    <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//是否找到</span></span><br><span class="line">                                    <span class="keyword">for</span>(<span class="type">int</span> o=<span class="number">0</span>;o&lt;subSet.get(j).size();++o)&#123;<span class="comment">//检查初筛出来的子集是否包含刚才独立出元素后的子集的所有剩余元素</span></span><br><span class="line">                                        <span class="keyword">if</span>(subSet.get(j).get(o)==selectedNum) <span class="keyword">continue</span>;<span class="comment">//不看独立出来的元素</span></span><br><span class="line">                                        <span class="keyword">else</span>&#123;</span><br><span class="line">                                            <span class="keyword">if</span>(!subSet.get(l).contains(subSet.get(j).get(o)))&#123;<span class="comment">//如果有一个元素不包含，那当前这个子集就不是刚才独立出元素后变成的子集，要继续找</span></span><br><span class="line">                                                found = <span class="literal">false</span>;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">if</span>(found)&#123;<span class="comment">//找到了就通过之前做的映射拿到其访问下标</span></span><br><span class="line">                                        pos = map.get(subSet.get(l));</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//System.out.println(i+&quot; &quot;+j+&quot; &quot;+selectedNum+&quot; &quot;+pos);</span></span><br><span class="line">                            <span class="keyword">if</span> (min &gt; dp[selectedNum][pos] + g[i][selectedNum])<span class="comment">//尝试更新min的值</span></span><br><span class="line">                                min = dp[selectedNum][pos] + g[i][selectedNum];</span><br><span class="line">                        &#125;</span><br><span class="line">                        dp[i][j] = min;<span class="comment">//进行状态转移，由于初始化的时候不可达设置成了正无穷，所以可以保证不会从非法的地方转移过来</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为得到最终的答案进行状态转移</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;subSet.get((<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>))-<span class="number">1</span>).size();++k)&#123;<span class="comment">//遍历除了节点0的全集的子问题</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">selectedNum</span> <span class="operator">=</span> subSet.get((<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>))-<span class="number">1</span>).get(k);<span class="comment">//独立出一个元素来</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;subSet.size();++l)&#123;<span class="comment">//找独立出元素后的集合下标</span></span><br><span class="line">                <span class="comment">//由于全集的答案是从上一轮的子集中转移过来的，而上一轮的子集比全集只少1，因此如果一个子集不包含从全集中独立出来的那个元素，那么这个子集就是独立出元素后的全集，易证</span></span><br><span class="line">                <span class="keyword">if</span>(subSet.get(l).size()+<span class="number">1</span>==subSet.get((<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>))-<span class="number">1</span>).size()&amp;&amp;!subSet.get(l).contains(selectedNum))&#123;</span><br><span class="line">                    pos = map.get(subSet.get(l));<span class="comment">//拿到下标，不过写注释写到这我发现为啥不直接用l当下标。。。</span></span><br><span class="line">                    <span class="comment">//System.out.println(selectedNum+&quot; &quot;+pos+&quot; &quot;+subSet.get(l));</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(dp[selectedNum][pos]+&quot; &quot;+g[0][selectedNum]);</span></span><br><span class="line">            <span class="comment">//尝试更新min</span></span><br><span class="line">            <span class="keyword">if</span>(min &gt; dp[selectedNum][pos]+g[<span class="number">0</span>][selectedNum]) min = dp[selectedNum][pos]+g[<span class="number">0</span>][selectedNum];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][(<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>))-<span class="number">1</span>] = min;<span class="comment">//状态转移得到最后答案</span></span><br><span class="line">        <span class="comment">//输出dp数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>));++i)&#123;</span><br><span class="line">            System.out.print(subSet.get(i)+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>));++j)&#123;</span><br><span class="line">                System.out.print(dp[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出结论</span></span><br><span class="line">        System.out.println(<span class="string">&quot;从0号节点出发经过所有节点返回的最小距离是：&quot;</span>+dp[<span class="number">0</span>][(<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>))-<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] num,<span class="type">int</span> a,<span class="type">boolean</span>[] vis,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subSet)</span>&#123;<span class="comment">//求子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;vis.length;++i)&#123;<span class="comment">//回溯算法求子集</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(num,i+<span class="number">1</span>,vis,subSet);</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vis.length;++i)&#123;<span class="comment">//记录当前求得的子集</span></span><br><span class="line">            <span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">                list.add(num[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        subSet.add(list);<span class="comment">//加入子集的集合</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">C</span><span class="params">(<span class="type">int</span> down,<span class="type">int</span> up)</span>&#123;<span class="comment">//求组合数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;up;++i)&#123;</span><br><span class="line">            ans*=down-i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=up;++i)&#123;</span><br><span class="line">            ans/=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116110146649.png" alt="image-20230116110146649"></p><h2 id="环状DP"><a href="#环状DP" class="headerlink" title="环状DP"></a>环状DP</h2><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><ul><li><p>顾名思义就是在树上进行dp，这种情况<strong>一般用一个或多个HashMap来当作dp数组存放状态</strong>，其中key一般是树的节点，value就具体情况具体分析，然后一般是<strong>要对树进行后序遍历</strong>，因为这样在对子树根节点进行状态转移的时候，能保证它的左右节点都已经转移完成，可以直接利用左右节点的状态来进行根节点的状态转移。</p></li><li><p>无论是对树进行dfs还是dp的时候，树&#x2F;子树的根节点的意义都是至关重要的，因为它在接收左右节点的状态的同时决定着父节点的状态，所以在考虑问题的时候一定要<strong>从树&#x2F;子树的根节点着手</strong>，思考<strong>根节点的意义</strong>、<strong>根节点的所有可能的状态</strong>、<strong>如何利用左右节点来决定根节点</strong>。</p></li><li><p>LeetCode 337.打家劫舍Ⅲ：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230129095508118.png" alt="image-20230129095508118"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//如果是线性结构嘛，这个地方就是一个二维数组，第二维表示两种选择，但是这是非线性结构，所以只能把第二维拆出来，有几维就创建几个hashmap，每个hashmap表示一种选择。</span></span><br><span class="line">    HashMap&lt;TreeNode,Integer&gt; yes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//选该节点能得到的最大收益</span></span><br><span class="line">    HashMap&lt;TreeNode,Integer&gt; no = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//不选该节点能得到的最大收益</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(yes.get(root),no.get(root));<span class="comment">//最后的结果就是在选和不选当前节点这两种情况中取个最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;<span class="comment">//后序遍历保证子树的根节点进行状态转移的时候它的左右节点的状态均已转移完成</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">noL</span> <span class="operator">=</span> no.getOrDefault(root.left,<span class="number">0</span>);<span class="comment">//以左节点为根的子树，不选它的收益</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">noR</span> <span class="operator">=</span> no.getOrDefault(root.right,<span class="number">0</span>);<span class="comment">//以右节点为根的子树，不选它的收益</span></span><br><span class="line">        yes.put(root,noL+noR+root.val);<span class="comment">//选当前节点的话，收益就是左右节点都不选的情况的收益和+当前节点的收益</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">yesL</span> <span class="operator">=</span> yes.getOrDefault(root.left,<span class="number">0</span>);<span class="comment">//以左节点为根的子树，选它的收益</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">yesR</span> <span class="operator">=</span> yes.getOrDefault(root.right,<span class="number">0</span>);<span class="comment">//以右节点为根的子树，选它的收益</span></span><br><span class="line">        no.put(root,Math.max(yesL,noL)+Math.max(yesR,noR));<span class="comment">//不选当前节点的话，当前节点的收益就是选/不选左右节点四种情况的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树上dp，用两个hashmap当作dp数组，两个hashmap分别表示选和不选当前节点能得到的最大收益，然后对树进行后序遍历，这样在转移根节点的时候能保证左右节点的结果都转移出来了，进行状态转移的时候，如果选根节点，那么最大收益就是不选左右节点的最大收益和；如果不选根节点，那么最大收益就是选&#x2F;不选左右节点四种情况的收益最大值，最后的结果就是选根节点和不选根节点的收益情况的最大值。</p></li></ul><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ul><li>解决dp问题通常分五步走，走好这五步，dp问题基本能迎刃而解：<ol><li>首先就是要<strong>确定dp数组的元素含义</strong>，然后就是<strong>确定每一个dp数组元素的所有状态</strong>，状态怎么确定呢？<strong>状态一般体现为做了什么操作对dp数组的当前元素产生了影响，每个操作就是这个dp数组元素的一个状态</strong>，在确定好dp数组元素的含义和dp数组元素的状态之后，我们就可以把这个dp数组给定义出来了，一般前面的维度都是用来定位dp数组的元素，最后一个维度可以设计成存放所有当前元素的状态，<strong>通过物理位置和状态号可以准确定位到一个元素在某个状态时的值</strong>，不过也可以分成多个dp数组来表示dp数组元素的所有状态。</li><li>然后就是要<strong>确定dp数组各元素之间所有状态的递推公式</strong>，这个递推公式一定要做到面面俱到，也就是说<strong>要考虑到当前元素的所有状态应该怎么从别的状态转移过来</strong>，而不是只转移部分状态，如果只转移部分状态，那么后面的状态可能会转移出错，最后的结果大概率是错的。</li><li>然后就是<strong>确定dp数组的边界</strong>，也就是考虑如何初始化dp数组，<strong>本质上是我们要考虑一个元素的状态在从边界及边界之外的状态转移过来的时候应该怎样进行转移</strong>，这个就是要具体情况具体分析，有的问题可以多出一圈虚拟的dp数组元素用来边界转移，也有的问题需要先确定边界的值然后再对后面的状态进行转移。<strong>确定边界值的时候应该考虑dp数组的边界元素转移到其所有状态的值，千万不要只考虑初始化一部分，要把所有边界元素的所有状态都初始化好</strong>。</li><li>然后就是<strong>确定遍历顺序</strong>，遍历顺序是由状态之间的依赖关系决定的，<strong>本质上是要求我们在进行一个元素所有状态的转移的时候，它依赖的所有状态都应该是已经转移完毕的</strong>，有的是前面的元素状态依赖后面的，那就从后向前遍历；有的是后面的元素状态依赖前面的，那就从前向后遍历；还有的是非线性的依赖关系，那就具体情况具体分析。</li><li>最后就是可以<strong>举个例子，看看自己的推导是否正确</strong>。</li></ol></li></ul><h1 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h1><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>单源无负权最短路径，即一个点到其他点的最短路径，所有的边不允许出现负权值。</li></ul><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li><p>每次外层循环确定一个节点到源点的最短距离</p></li><li><p>每次内层循环通过确定最短路径的点对与其相邻的点到源点的距离进行“松弛”操作以确保下一次外层循环能找到正确的距离源点最短的点。</p></li><li><p>贪心的思想，每次找最短路径的节点来对别的节点做“松弛”。</p></li></ul><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><ul><li><p>假设节点数量为n，那么首先我们需要一个<strong>n x n的矩阵g来存放图，或者用邻接表、链式前向星存</strong>，然后我们需要一个<strong>长度为n的boolean数组vis来标识节点到源点的最短距离是否已经被确定</strong>，然后<strong>需要一个长度为n的整型数组dis来记录源点到其他点的最短距离</strong>，如果要<strong>对时间复杂度进行优化的话，我们还需要维护一个优先队列（可以用堆实现）q来表示节点到源点的距离</strong>。</p></li><li><p>初始化g，除了自己到自己的距离为0，其他初始化为inf，然后根据输入的边进行调整；</p><p>初始化vis，源点src到自己的最短距离已经确认，所以让src为true，其余为false；</p><p>初始化dis，就是src到各点的距离，从g中拿就行。</p></li><li><p>然后外层循环n-1次，因为有n-1个节点到src的最短路径需要确认，外层循环每循环一次就确定一个节点到src的最短路径。</p><p>内层先用一个循环来找到当前与src直接或间接相连的节点到src的最短路径（如果使用优先队列进行优化的话就直接取优先队列的头元素即可，不用循环了就），找到之后对应的那个节点的最短路径就被固定了，因为别的路径都必须经过本轮遍历到的其他路径，而由于没有负权值，别的路径第一段就比最短的路径大了，再加上别的段就更不用说了，因此不存在从别的路径到这轮选中的节点距离更短，所以可以确定本轮选中的节点的最短路径。</p><p>确定后更新vis，然后再搞一层循环来更新与本轮选中的节点相邻的节点到src的最短距离，这一操作我们称为通过本轮选中的节点来对src到别的节点的距离进行“松弛”（优先队列的话要对优先队列进行更新操作），这一操作是为了在下一轮的循环中能正确找到距离src最短的节点。最后外层循环完毕，所有节点到src的最短距离也被确定下来了。</p></li></ul><h3 id="代码示例-7"><a href="#代码示例-7" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-28 19:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dijkstra</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">inf</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;<span class="comment">//正无穷</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入节点数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] g = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];<span class="comment">//邻接矩阵存图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化邻接矩阵</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) g[i][j]=<span class="number">0</span>;<span class="comment">//自己到自己的距离为0</span></span><br><span class="line">                <span class="keyword">else</span> g[i][j] = inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入边的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+(i+<span class="number">1</span> )+<span class="string">&quot;条边的起点、终点、权值：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="comment">//这里是无向图的写法，为了方便输入，需要有向图再改</span></span><br><span class="line">            g[begin][end] = value;</span><br><span class="line">            g[end][begin] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入想要看其到别的节点最短路径的节点：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">src</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];<span class="comment">//标识已经确定最小距离的节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) vis[i] = <span class="literal">false</span>;</span><br><span class="line">        vis[src] = <span class="literal">true</span>;<span class="comment">//源节点到自己的距离一直是0，所以是已经确定最小距离的节点</span></span><br><span class="line">        <span class="type">int</span>[] dis = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//源节点到对应节点的最小距离，比如dis[i]就是源节点到节点i的最小距离，动态更新，更新到最后就是答案。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化源节点到对应节点的最小距离为源节点到对应节点的距离，然后之后再动态更新。</span></span><br><span class="line">            dis[i] = g[src][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//还需要找到n-1个节点的最短路径，所以要循环n-1次</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> inf;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//每轮找到的节点下标，该节点应该是本轮中距离src最短的节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;<span class="comment">//找本轮中距离src最短的节点，由于其到src的距离是本轮最短，所以不存在另外一条路径使得被选中的节点和src的距离能更短，因为如果存在这样一条路径，那么一定会从本轮中的其他路径经过，而本轮中的其他路径在不考虑负权值的情况下一定比本轮中的最短路径要长，所以可以放心将本轮最短路径作为选中节点的最短路径。</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[j]&amp;&amp;min&gt;dis[j])&#123;<span class="comment">//只从还没有确定最短路径的节点中找最小值，记录下最小值和节点下标</span></span><br><span class="line">                    min = dis[j];</span><br><span class="line">                    pos = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[pos] = <span class="literal">true</span>;<span class="comment">//标记这一轮选中的节点已经确定了最短路径</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;<span class="comment">//以这一轮选中的节点作为桥梁来更新与其相邻的节点到src的最短距离</span></span><br><span class="line">                <span class="keyword">if</span>(g[pos][j]&lt;inf&amp;&amp;j!=src)&#123;<span class="comment">//找与这一轮选中的节点相邻的节点，不能是src</span></span><br><span class="line">                    <span class="keyword">if</span>(dis[j]&gt;dis[pos]+g[pos][j])&#123;<span class="comment">//如果以这一轮选中的节点为桥梁能使与其相邻的节点到src的距离更短，那就更新，相当于src和那个节点间接建立起了联系，下一轮就可以通过找最小值来固定和src直接或间接有联系的点的最短距离了。</span></span><br><span class="line">                        dis[j] = dis[pos]+g[pos][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;节点&quot;</span>+src+<span class="string">&quot;到各点的最短路径分别为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(dis[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h1><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>找出一个最短路径使得图中各节点连通，对于有n个节点的图来说，最小生成树需要用n-1条边来构建，该算法在稠密图中的效率较高。</li><li>适用于有负权边的情况。</li></ul><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>每次循环选择距离已经被选中的节点组成的集合最短的节点加入集合中，然后将与其连接的路径加入最小生成树中，更新与本轮被选中的节点相邻的节点到已经被选中的节点的集合的距离，以确保下一次循环可以找到正确的需要加入集合的节点，当所有节点都被加入到集合后，最小生成树就建立了。</li><li>实际上就是贪心的思想，每次找到集合最短的节点加入集合。</li></ul><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><ul><li><p>基本上和Dijkstra算法差不多，虽然数据结构和Dijkstra的一样，但是Prim的数据结构的含义和Dijkstra中的数据结构的含义有点出入。</p></li><li><p>假设节点数量为n，那么首先我们需要一个<strong>n x n的矩阵g来存放图，或者用邻接表、链式前向星存</strong>，然后我们需要一个<strong>长度为n的boolean数组vis来表示已经被最小生成树选中的节点</strong>，然后<strong>需要一个长度为n的整型数组dis来记录已经被选中的节点的集合到其他未被选中的点的最短距离</strong>，如果要<strong>对时间复杂度进行优化的话，我们还需要维护一个优先队列（可以用堆实现）q来表示节点到已经被选中的节点的集合的距离</strong>，还需要一个<strong>变量sum来记录最小生成树的值</strong>。</p></li><li><p>初始化g，除了自己到自己的距离为0，其他初始化为inf，然后根据输入的边进行调整；</p><p>初始化vis，一开始被选中的节点集合中的节点只有源点src，所以让src为true，其余为false；</p><p>初始化dis，就是被选中的节点的集合到各点的距离，一开始就是src到各点的距离，从g中拿就行。</p></li><li><p>然后外层循环n-1次，因为有n-1条边需要被选择，外层循环每循环一次就选择一条边放到最小生成树中，同时也是选中一个节点放入已经被选中的节点的集合中。</p><p>内层先用一个循环来找到当前与被选中的节点的集合相连的节点到集合的最短路径（如果使用优先队列进行优化的话就直接取优先队列的头元素即可，不用循环了就），找到之后需要将该点加入集合中，并将该边加入最小生成树中，更新vis和sum，然后再搞一层循环来更新未被选中的节点与新集合的距离，实际上出现变动的只有与这一轮选中的节点相邻的节点，所以更新这一轮选中的节点的相邻节点到新集合的距离就好了，这一步是为了确保下一轮循环中可以正确的选中到集合的最短路径对应的节点。最后外层循环完毕，最小生成树也被确定下来了。</p></li></ul><h3 id="代码示例-8"><a href="#代码示例-8" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-29 14:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">inf</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;<span class="comment">//正无穷</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入节点数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] g = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];<span class="comment">//邻接矩阵存图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化邻接矩阵</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) g[i][j]=<span class="number">0</span>;<span class="comment">//自己到自己的距离为0</span></span><br><span class="line">                <span class="keyword">else</span> g[i][j] = inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入边的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+(i+<span class="number">1</span> )+<span class="string">&quot;条边的起点、终点、权值：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="comment">//这里是无向图的写法，为了方便输入，需要有向图再改</span></span><br><span class="line">            g[begin][end] = value;</span><br><span class="line">            g[end][begin] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入起始节点：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">src</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];<span class="comment">//标识已经确定最小距离的节点，同时也是算法工程中被最小生成树选中的节点集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) vis[i] = <span class="literal">false</span>;</span><br><span class="line">        vis[src] = <span class="literal">true</span>;<span class="comment">//源节点到自己的距离一直是0，所以是已经确定最小距离的节点</span></span><br><span class="line">        <span class="type">int</span>[] dis = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//被最小生成树选中的节点集合到与其相邻节点的距离，比如dis[i]就是被最小生成树选中的节点集合到节点i的距离，动态更新。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化源节点（此时最小生成树选中的节点只有源节点）到所有节点的距离为源节点到对应节点的距离，然后之后再动态更新。</span></span><br><span class="line">            dis[i] = g[src][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最小生成树的大小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//构建最小生成树一共需要n-1条边，所以要循环n-1遍，每一轮循环选中一条边</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> inf;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//到已经选中的节点集合距离最短的那个节点下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;<span class="comment">//找距离已经选中的节点集合距离最短的节点</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[j]&amp;&amp;min&gt;dis[j])&#123;<span class="comment">//从已经选中的节点集合之外找和已经选中的节点的集合相邻的节点中距离最短的那个节点</span></span><br><span class="line">                    min = dis[j];<span class="comment">//记录最小值</span></span><br><span class="line">                    pos = j;<span class="comment">//记录下标</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[pos] = <span class="literal">true</span>;<span class="comment">//将这轮被选中的节点加入到最小生成树选中节点的集合中</span></span><br><span class="line">            sum+=dis[pos];<span class="comment">//将本轮选中的边加入到最小生成树中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;<span class="comment">//由于本轮选中的节点加入了最小生成树，所以与本轮选中节点相邻的节点与最小生成树选中的节点集合也是相邻的，所以动态更新被最小生成树选中的节点集合到其他节点的距离</span></span><br><span class="line">                <span class="keyword">if</span>(g[pos][j]&lt;dis[j]&amp;&amp;!vis[j])&#123;<span class="comment">//更新与这一轮选中的节点相邻的没被最小生成树选中的节点到被最小生成树选中的节点集合的距离，方便下一轮筛选最小值加入最小生成树</span></span><br><span class="line">                    dis[j] = g[pos][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最小生成树的大小为：&quot;</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><ul><li>找出一个最短路径使得图中各节点连通，对于有n个节点的图来说，最小生成树需要用n-1条边来构建，该算法在稀疏图中的效率较高。</li><li>适用于有负权边的情况。</li></ul><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li><strong>以贪心思想和并查集数据结构为基础</strong>，首先将<strong>所有边按照升序排序</strong>，然后遍历所有边，<strong>每当遍历到一个边就判断这条边是否能作为连接两个端点的最短边</strong>（由于边是升序排列，所以两个端点第一次遇到的可以连接它俩的边就一定是最优的，后面能连接它俩的边都不能选了因为不是最优的。）。<strong>如果能，那就将端点合并到已经被最小生成树选中的节点中，并将该边加入到最小生成树中，并且让选中的边数++；如果不能，就继续遍历，直到选中n-1条边后，最小生成树就形成了，退出循环即可</strong>。</li></ul><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><ul><li>上面描述的差不多了。。。。。。</li></ul><h3 id="代码示例-9"><a href="#代码示例-9" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-03 16:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kruskal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入点数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//并查集数组,f[i]=j说明i的父亲节点是j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化每个节点都是独立的，即他们的father都是自己</span></span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入边数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        Edge[] edges = <span class="keyword">new</span> <span class="title class_">Edge</span>[e];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;条边的两个节点和权值：&quot;</span>);</span><br><span class="line">            <span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Edge</span>();</span><br><span class="line">            edge.from = scanner.nextInt();</span><br><span class="line">            edge.to = scanner.nextInt();</span><br><span class="line">            edge.value = scanner.nextInt();</span><br><span class="line">            edges[i] = edge;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(edges,(e1,e2) -&gt; e1.value&lt;=e2.value?-<span class="number">1</span>:<span class="number">1</span>);<span class="comment">//按照边从小到大排序，返回负数不换位置，即顺序正确</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最小生成树的大小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e&amp;&amp;n&gt;<span class="number">1</span>;++i)&#123;<span class="comment">//n可以维护已经选了多少边，当n减到1的时候说明已经选了n-1条边了，最小生成树已经生成，可以走了</span></span><br><span class="line">            <span class="keyword">if</span>(merge(f,edges[i].from,edges[i].to))&#123;<span class="comment">//如果能合并说明可以选这条边作为最小代价连接这条边对应的两个节点</span></span><br><span class="line">                n--;</span><br><span class="line">                sum+=edges[i].value;</span><br><span class="line">                System.out.println(<span class="string">&quot;选择两个点和权值分别为&quot;</span>+edges[i].from+<span class="string">&quot; &quot;</span>+edges[i].to+<span class="string">&quot; &quot;</span>+edges[i].value+<span class="string">&quot;的边&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最小生成树的大小为：&quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span>&#123;<span class="comment">//边</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> from;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> to;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] f,<span class="type">int</span> v)</span>&#123;<span class="comment">//找一个元素的根节点</span></span><br><span class="line">        <span class="keyword">return</span> f[v]==v?v:(f[v] = find(f,f[v]));<span class="comment">//如果该点独立，直接返回;如果该点不独立,往后找根节点，顺便进行路径压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] f,<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;<span class="comment">//合并操作，其中可以做优化：直接把两者的根节点合并</span></span><br><span class="line">        <span class="keyword">return</span> (u = find(f,u))==(v = find(f,v))?<span class="literal">false</span>:(f[v]=u)==u;<span class="comment">//先找到各自的根，然后比较，如果相同说明已经合并无需再合并，返回false；如果不相同就合并，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Huffman编码算法"><a href="#Huffman编码算法" class="headerlink" title="Huffman编码算法"></a>Huffman编码算法</h1><h2 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li><p><strong>哈夫曼（Huffman）编码算法</strong>是基于二叉树构建编码压缩结构的，它是数据压缩中经典的一种算法。算法根据文本字符出现的频率，重新对字符进行编码。因为为了缩短编码的长度，我们自然<strong>希望频率越高的词，编码越短，这样最终才能最大化压缩存储文本数据的空间</strong>。</p></li><li><p>假设现在我们要对下面这句歌词“we will we will r u”进行压缩。我们可以想象，如果是使用ASCII码对这句话编码结果则为：119 101 32 119 105 108 108 32 119 101 32 119 105 108 108 32 114 32 117（十进制表示）。我们可以看出需要19个字节，也就是至少需要152位的内存空间去存储这些数据。</p></li><li><p>很显然直接ASCII码编码是很浪费空间的，Unicode就更不用说了，下面我们先来统计一下这句话中每个字符出现的频率。如下表，按频率高低已排序：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104174352182.png" alt="image-20221104174352182"></p></li></ul><h2 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h2><ul><li>让<strong>被编码的字符全部出现在编码树的叶节点上，这样可以做到没有一个字符的编码是另外一个字符编码的前缀，这样可以防止解码的时候出现歧义</strong>。</li><li><strong>出现频率越低的字符，在树上的深度就越深，最后对于这个字符的编码就越长，最后总的编码就越短，这其中也有贪心的思想</strong>。</li><li>建好哈夫曼树后，<strong>让连接左孩子的边的编码设置为0，让连接右孩子的边的编码设置为1，从根节点开始经过若干边后找到一个字符，那个字符的编码就是经过的所有边的编码的集合</strong>。</li></ul><h2 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h2><h3 id="初始化优先队列"><a href="#初始化优先队列" class="headerlink" title="初始化优先队列"></a>初始化优先队列</h3><ul><li><p>那么我们<strong>按字符出现频率的高低将其放入一个优先队列中，从左到右依次为频率逐渐增加</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104175410606.png" alt="image-20221104175410606"></p></li><li><p>下面我们需要将这个队列转换成哈夫曼二叉树，<strong>哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的</strong>。并且<strong>哈夫曼二叉树始终保证权重越大的字符出现在越高的地方</strong>。</p></li></ul><h3 id="第一步合并"><a href="#第一步合并" class="headerlink" title="第一步合并"></a>第一步合并</h3><ul><li><p>首先我们从左到右进行合并，依次构建二叉树。<strong>第一步取前两个字符u和r来构造初始二叉树，第一个字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新空元素，并且两者权重相加作为新元素的权重</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180042562.png" alt="image-20221104180042562"></p></li><li><p>同理，<strong>由于合并之后优先队列仍有序，所以新元素可以和字符i再合并</strong>，如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180101221.png" alt="image-20221104180101221"></p></li></ul><h3 id="重新调整队列"><a href="#重新调整队列" class="headerlink" title="重新调整队列"></a>重新调整队列</h3><ul><li><p>上图<strong>新元素权重相加后结果是变大了，需要对权重进行重新排序，也就是调整优先队列</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180152267.png" alt="image-20221104180152267"></p></li><li><p>然后再<strong>依次从左到右合并，每合并一次则进行一次队列重新排序调整</strong>。如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180234707.png" alt="image-20221104180234707"></p></li><li><p><strong>经过多步操作之后，优先队列中只剩一个元素，让队列中唯一的元素出队得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180311593.png" alt="image-20221104180311593"></p></li></ul><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><ul><li><p>有了上面带权重的二叉树之后，我们就可以进行编码了。我们<strong>把二叉树分支中左边的支路编码为0，右边分支表示为1</strong>，如下图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180540694.png" alt="image-20221104180540694"></p></li><li><p>这样<strong>依次遍历这颗二叉树就可以获取得到所有字符的编码了</strong>。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。<strong>经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。</strong></p></li><li><p>最终我们可以得到下面这张编码表：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180640922.png" alt="image-20221104180640922"></p></li></ul><h3 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h3><ul><li>有了上面的编码表之后，”we will we will r u”这句重新进行编码就可以得到很大的压缩，编码表示为：01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100。这样最终我们只需50位内存，比原ASCII码表示节约了2&#x2F;3空间，效果还是很理想的。当然<strong>现实中不是简单这样表示的，还需要考虑很多问题</strong>。</li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul><li>我们需要弄明白哈夫曼二叉树概念，<strong>它是带权路径达到最小的二叉树，也叫最优二叉树</strong>。它<strong>不一定是完全二叉树，也不一定是平衡二叉树，它们描述的完全不是一件事情，完全没有概念上的重叠关系</strong>。</li></ul><h2 id="代码示例-10"><a href="#代码示例-10" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-03 18:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Huffman</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line">        <span class="keyword">public</span> Node father;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">char</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//用队列+排序模拟优先队列</span></span><br><span class="line">        ArrayList&lt;Character&gt; charList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//存放所有字符</span></span><br><span class="line">        Node tree;<span class="comment">//Huffman树</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入字符种数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+i+<span class="string">&quot;种字符以及其出现的频数：&quot;</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            node.c = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            charList.add(node.c);</span><br><span class="line">            node.value = scanner.nextInt();</span><br><span class="line">            queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(queue,(n1,n2)-&gt;n1.value&lt;=n2.value?-<span class="number">1</span>:<span class="number">1</span>);<span class="comment">//按照频数排序，返回-1说明顺序正好不用调整</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;queue.size();++i) System.out.print(queue.get(i).c);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">while</span> (queue.size()&gt;<span class="number">1</span>)&#123;<span class="comment">//构建哈夫曼树，频率越低的元素越再下层，对应的编码越长，最后生成的总编码就越短，每次构建都会使队列长度减一，当队列长度为1时，唯一的那个元素就是哈夫曼树</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp1</span> <span class="operator">=</span> queue.poll();<span class="comment">//取出队首第一个元素</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp2</span> <span class="operator">=</span> queue.poll();<span class="comment">//取出队首第二个元素</span></span><br><span class="line">            <span class="comment">//System.out.println(temp1.c+&quot; &quot;+temp2.c);</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();<span class="comment">//准备进行元素合并</span></span><br><span class="line">            temp.value = temp1.value+temp2.value;<span class="comment">//合并权值到新的父节点</span></span><br><span class="line">            <span class="comment">//建立三个节点之间的关系</span></span><br><span class="line">            temp.left = temp1;</span><br><span class="line">            temp.right = temp2;</span><br><span class="line">            temp1.father = temp;</span><br><span class="line">            temp2.father = temp;</span><br><span class="line">            queue.push(temp);<span class="comment">//把合并后的节点加入到优先队列前面</span></span><br><span class="line">            Collections.sort(queue,(n1,n2)-&gt;n1.value&lt;=n2.value?-<span class="number">1</span>:<span class="number">1</span>);<span class="comment">//重新排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        tree = queue.poll();<span class="comment">//取出哈夫曼树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;charList.size();++i)&#123;<span class="comment">//找每个输入的字符对应的哈夫曼编码</span></span><br><span class="line">            ArrayList&lt;Character&gt; code = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            System.out.print(charList.get(i)+<span class="string">&quot;的哈夫曼编码为：&quot;</span>);</span><br><span class="line">            enCode(tree,charList.get(i),code);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">enCode</span><span class="params">(Node tree,<span class="type">char</span> c,ArrayList&lt;Character&gt; now)</span>&#123;<span class="comment">//递归找字符对应的编码，第一个参数是哈夫曼树，第二个参数是字符，第三个参数是当前的编码</span></span><br><span class="line">        <span class="keyword">if</span>(tree==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(tree.value);</span></span><br><span class="line">        <span class="keyword">if</span>(tree.c==c)&#123;<span class="comment">//找到目标了就输出</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> a:now)&#123;</span><br><span class="line">                System.out.print(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯算法遍历左右子树，左0右1</span></span><br><span class="line">        now.add(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        enCode(tree.left,c,now);</span><br><span class="line">        now.remove(now.size()-<span class="number">1</span>);</span><br><span class="line">        now.add(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        enCode(tree.right,c,now);</span><br><span class="line">        now.remove(now.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用霍夫曼编码压缩文件"><a href="#利用霍夫曼编码压缩文件" class="headerlink" title="利用霍夫曼编码压缩文件"></a>利用霍夫曼编码压缩文件</h2><ul><li>如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件。</li><li><strong>赫夫曼编码是按字节来处理的</strong>，因此**可以处理所有的文件(二进制文件、文本文件等)**。</li><li>如果一个文件中的内容，<strong>重复的数据不多，压缩效果也不会很明显</strong>。</li></ul><h2 id="利用霍夫曼编码解压文件"><a href="#利用霍夫曼编码解压文件" class="headerlink" title="利用霍夫曼编码解压文件"></a>利用霍夫曼编码解压文件</h2><h1 id="表达式算法"><a href="#表达式算法" class="headerlink" title="表达式算法"></a>表达式算法</h1><ul><li>这个板块儿<strong>主要是讲前缀、中缀、后缀表达式之间的转换和计算的</strong>。</li></ul><h2 id="中缀表达式算法"><a href="#中缀表达式算法" class="headerlink" title="中缀表达式算法"></a>中缀表达式算法</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>中缀表达式就是我们平时看到的算式，例如：a+b*c，我们想要实现的就是让计算机计算中缀表达式得到正确的结果。</li><li>除了中缀表达式外，还有<strong>运算符在操作数之前的前缀表达式（波兰表达式）和运算符在操作数之后的后缀表达式（逆波兰表达式）</strong>，这两种表达式会在它们的章节细讲。</li></ul><h3 id="使用栈完成中缀表达式计算的思路"><a href="#使用栈完成中缀表达式计算的思路" class="headerlink" title="使用栈完成中缀表达式计算的思路"></a>使用栈完成中缀表达式计算的思路</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106205752521.png" alt="image-20221106205752521"></p><ul><li>有一个小难点就是优先级的问题，<strong>当一个优先级小的符号想要入栈的时候要把之前的运算做了之后再入栈</strong>。</li></ul><h3 id="代码示例-11"><a href="#代码示例-11" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## 逆波兰表达式算法</span><br><span class="line"></span><br><span class="line">### 基本介绍</span><br><span class="line"></span><br><span class="line">- **逆波兰表达式就是后缀表达式**，就是操作符在操作数的后面，至于怎么从中缀表达式转换为后缀表达式下面给出了详细的转换方式。</span><br><span class="line">- 虽然对于人来说计算逆波兰表达式比较困难，但是**对于计算机来说计算逆波兰表达式是非常容易的**，计算机对逆波兰表达式进行计算用到了栈这一数据结构。</span><br><span class="line"></span><br><span class="line">### 算法思想</span><br><span class="line"></span><br><span class="line">- 遍历逆波兰表达式，如果**碰到数字就压入栈中，如果碰到操作符，就从栈顶出栈两个元素，对那两个元素进行对应的运算之后，将运算的结果再压入栈中**。</span><br><span class="line"></span><br><span class="line">### 代码示例</span><br><span class="line"></span><br><span class="line">```java</span><br></pre></td></tr></table></figure><h2 id="中缀表达式转换为后缀表达式"><a href="#中缀表达式转换为后缀表达式" class="headerlink" title="中缀表达式转换为后缀表达式"></a>中缀表达式转换为后缀表达式</h2><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>从上面可以看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此<strong>在开发中，我们需要将中缀表达式转成后缀表达式</strong>。</li><li>中缀表达式转换为后缀表达式的步骤比较繁琐，也<strong>需要借助栈来实现，不过需要两个栈，其中一个存操作数，另外一个存操作符</strong>。</li></ul><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2；</li><li>从左至右扫描中缀表达式；</li><li>遇到操作数时，将其压 s2；</li><li>遇到运算符时，比较其与 s1 栈顶运算符的优先级：<ol><li>如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</li><li>否则，若优先级比栈顶运算符的高，也将运算符压入 s1；</li><li>否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4.1)与 s1 中新的栈顶运算符相比较；</li></ol></li><li>遇到括号时：<ol><li>如果是左括号“(”，则直接压入 s1</li><li>如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃</li></ol></li><li>重复步骤 2 至 5，直到表达式的最右边</li><li>将 s1 中剩余的运算符依次弹出并压入 s2</li><li>依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</li></ol><ul><li>总结：其实就是<strong>根据运算的优先级来将每一部分的操作符放到俩操作数的后面</strong>，比如A*(B+C)+D，优先级最高的是小括号，所以先转换成A*(BC+)+D，然后乘法优先级比较高，把乘号放到俩操作数的后面，即(ABC+*)+D，最后只剩下加法运算了，把加号放到俩操作数后面，即ABC+*D+，这样就得到后缀表达式了，从过程中可以看到，<strong>每次都是选优先级最高的一部分，将其操作符放到它对应的俩操作数的后面</strong>。</li></ul><h3 id="转换举例"><a href="#转换举例" class="headerlink" title="转换举例"></a>转换举例</h3><ul><li><p>将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106232317323.png" alt="image-20221106232317323"></p></li><li><p>因此结果为 :”1 2 3 + 4 × + 5 -“</p></li></ul><h3 id="代码示例-12"><a href="#代码示例-12" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="KMP算法介绍"><a href="#KMP算法介绍" class="headerlink" title="KMP算法介绍"></a>KMP算法介绍</h2><ul><li>KMP 是一个<strong>解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法</strong>。</li><li>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法.</li><li>KMP 方法算法就<strong>利用之前判断过信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间</strong>。</li><li>参考资料：<a href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html">https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</a></li></ul><h2 id="KMP算法思路分析"><a href="#KMP算法思路分析" class="headerlink" title="KMP算法思路分析"></a>KMP算法思路分析</h2><ul><li><p>举例来说，有一个字符串 Str1 &#x3D; “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 &#x3D;“ABCDABD”？</p><ol><li><p>首先，用 Str1 的第一个字符和 Str2 的第一个字符去比较，不符合，关键词向后移动一位：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094748049.png" alt="image-20221114094748049"></p></li><li><p>重复第一步，还是不符合，再后移：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094819926.png" alt="image-20221114094819926"></p></li><li><p>一直重复，直到 Str1 有一个字符与 Str2 的第一个字符符合为止：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094849647.png" alt="image-20221114094849647"></p></li><li><p>接着比较字符串和搜索词的下一个字符，还是符合：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094908612.png" alt="image-20221114094908612"></p></li><li><p>遇到 Str1 有一个字符与 Str2 对应的字符不符合：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094927607.png" alt="image-20221114094927607"></p></li><li><p>这时候，想到的是继续遍历 Str1 的下一个字符，重复第 1 步，如下图所示。(其实是很不明智的，因为此时 BCD 已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP 算法的想法是，<strong>设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率</strong>。)</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095220382.png" alt="image-20221114095220382"></p></li><li><p>怎么做到把刚刚重复的步骤省略掉？可以对 Str2 计算出一张《部分匹配表》，这张表的产生在后面介绍：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095249922.png" alt="image-20221114095249922"></p></li><li><p>已知空格与 D 不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符 B 对应的”部分匹配值”为 2，因此按照下面的公式算出向后移动的位数：<strong>移动位数 &#x3D; 已匹配的字符数 - 对应的部分匹配值</strong>，因为 6 - 2 等于 4，所以将搜索词向后移动 4 位：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095501622.png" alt="image-20221114095501622"></p></li><li><p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为 2（”AB”），对应的”部分匹配值”为 0。所以，移动位数 &#x3D; 2 - 0，结果为 2，于是将搜索词向后移 2 位：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095519913.png" alt="image-20221114095519913"></p></li><li><p>因为空格与 A 不匹配，str1的指针继续后移一位：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114100150053.png" alt="image-20221114100150053"></p></li><li><p>逐位比较，直到发现 C 与 D 不匹配。于是，移动位数 &#x3D; 6 - 2，继续将搜索词向后移动 4 位：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095539523.png" alt="image-20221114095539523"></p></li><li><p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 &#x3D; 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095654873.png" alt="image-20221114095654873"></p></li></ol></li></ul><h2 id="部分匹配表（next）是如何产生的？"><a href="#部分匹配表（next）是如何产生的？" class="headerlink" title="部分匹配表（next）是如何产生的？"></a>部分匹配表（next）是如何产生的？</h2><ul><li><p>先介绍介绍前缀和后缀是什么：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114100319241.png" alt="image-20221114100319241"></p></li><li><p>实际上<strong>部分匹配值就是从数组头到当前位置这个左闭右开区间（我喜欢这样表示）所表示的字符串的最长公共前后缀，当比较到当前位置产生失配之后，当前位置的指针可以根据当前位置的部分匹配值来进行相应的移动，从而节省开销</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230213100055868.png" alt="image-20230213100055868"></p></li><li><p>知道怎么得到next值了，那么落实到代码上应该怎么写呢？首先我们考虑前两个元素，明显它们的值都为0（前后缀不能完全重合），但是为了判断后面的一种情况，我们将第一个元素的值规定为-1，然后我们考虑后面的元素，每当遍历到一个元素，我们都看它前面的那个元素，因为它的next值和它本身无关，<strong>如果当前元素前面那个元素和它的next值指向的那个元素相同的话，那么当前元素的next值应该是当前元素前面那个元素的next值加一（为什么？因为当前元素前一个元素的next值的指向还有另一个含义，那就是最长公共前后缀的那个前缀的后面一个元素，如果当前元素的前一个元素和那个元素匹配的话，说明公共前后缀的长度可以扩大1）</strong>；<strong>如果当前元素前面那个元素和它的next值指向的那个元素不相同的话，那么就继续利用next数组进行迭代，每次迭代都是到达当前元素的next指向的位置，直到到达一个地方使得当前元素前一个元素和迭代到的元素相同，那么当前元素的next值就是迭代到的那个元素的next值+1（为什么？还是那个道理，这样做还是为了找到一个和当前元素相同的且正好可以和原最长公共前后缀组成更长的公共前后缀的元素）</strong></p></li><li><p>其实只要理解了next值的三个含义之后，别的也就顺理成章了：</p><ol><li>next值的第一个含义不用多说，就是<strong>从开头到当前元素的前一个元素这个模式串子串的最长公共前后缀的长度</strong>。</li><li>next值的第二个含义是作为下标的含义，<strong>next值对应的下标是从开头到当前元素的前一个元素这个模式串子串的最长公共前后缀的那个前缀的后一个元素</strong>，如果当前元素和next指向的那个元素相等的话，说明之前求出的前缀和那个元素能结合成一个更长的前缀，也说明之前求出的后缀和当前元素的前一个元素能结合成一个更长的后缀，并且这个更长的后缀和那个更长的前缀相同，那么就说明可以形成更长的公共前后缀，这就是为什么要找和当前元素前一个元素相同的元素，并且每次找到之后都要将其的next值加一之后赋值给当前元素的next值了。</li><li>next值的第三个含义也是作为下标的含义，<strong>next值对应的下标是当前元素产生失配之后指针应该回溯到的位置</strong>，这个位置从上面那一条能知道，这个位置是是从开头到当前元素的前一个元素这个模式串子串的最长公共前后缀的那个前缀的后一个元素，将指针回溯到这里是因为如果失配元素前面的子串能和目标串的某个子串匹配，那么模式串这个子串的前缀和目标串的那个子串的后缀可能是有重合的部分的，而<strong>失配元素的next值正好揭示了这个重合部分的大小，所以回溯到那个地方是利用公共前后缀防止重复比较元素</strong>。</li></ol></li><li><p>其实细节还是很多的，<strong>细节1在于next数组的第一个元素应为-1（这个值是为了方便后面对一个特殊情况进行判断），第二个元素的值应为0（如果存在的话）</strong>，这个套定义的话也好理解，主要就是那个-1是为了在后面出现因当前元素前面一个元素和next值指向的元素不同而进行next值迭代的时候判断没有任何元素和当前元素的前一个元素相等的情况；<strong>细节2在于next数组应该比模式串的长度长1个单位</strong>，因为每个元素代表的是从开头到它前一个元素的最长公共前后缀的长度，所以最后一个元素代表的是整个模式串的最长公共前后缀的长度，如果没有最后一位，数据就会缺失；<strong>细节3在于模式串当前元素失配的时候，应该将模式串的指针回溯到失配元素的next值处，此时如果next值是-1，应该进行特殊处理</strong>，因为如果失配元素前面的子串能和目标串的某个子串匹配，那么模式串这个子串的前缀和目标串的那个子串的后缀可能是有重合的部分的，而失配元素的next值正好揭示了这个重合部分的大小，所以要这样进行回溯，是利用了公共前后缀防止重复比较元素，特判-1是因为之前将next数组的第一个元素初始化成了-1以方便处理一种特殊情况，所以这个元素不能用来回溯指针，所以特判一下。</p></li><li><p>还有个细节没想明白，那就是为什么进行next迭代的时候要跳着迭代而不是顺序迭代？不怕跳过的内容中存在答案吗？</p></li></ul><h2 id="代码示例-13"><a href="#代码示例-13" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li><p>力扣上有不少题对于理解KMP算法的原理有很好的作用，这里列出几道，首先就是LeetCode 718. 最长重复子数组，<strong>把下面代码的KMP部分中的i换成0就是普通的KMP了</strong>，这题不过是KMP了多次罢了，不过这个解法不是这个题的最优解：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230212225330655.png" alt="image-20230212225330655"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1==<span class="literal">null</span>||nums2==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums1.length&lt;nums2.length)&#123;<span class="comment">//始终让nums1的长度更长</span></span><br><span class="line">            <span class="type">int</span>[] temp = nums1;</span><br><span class="line">            nums1 = nums2;</span><br><span class="line">            nums2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最后的答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums2.length;++i)&#123;<span class="comment">//第一层循环遍历nums2的开头元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">idx1</span> <span class="operator">=</span> <span class="number">0</span>,idx2 = i;</span><br><span class="line">            <span class="comment">//下面就是拿完整的nums1和以第i个元素为开头的nums2做KMP，过程中尝试更新最后的答案</span></span><br><span class="line">            <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[nums2.length-idx2+<span class="number">1</span>];<span class="comment">//首先就是声明next数组，我习惯next数组的元素表示从开头的元素到当前元素前一个元素这一段的最长公共前后缀的长度，这样在当前元素失配的时候可以通过访问当前元素的next值来回溯指针，所以next数组的长度应该比模式串长1</span></span><br><span class="line">            <span class="comment">//第一个元素应该被初始化为-1（方便之后判断特定情况），第二个元素应该被初始化为0（如果存在的话）</span></span><br><span class="line">            next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//然后就是计算next数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;next.length;++j)&#123;<span class="comment">//由于前两个值是默认，所以直接从第三个值开始</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextPos</span> <span class="operator">=</span> next[j-<span class="number">1</span>];<span class="comment">//先记录下当前元素前一个元素的next值，然后迭代它</span></span><br><span class="line">                <span class="keyword">while</span>(nextPos!=-<span class="number">1</span>&amp;&amp;nums2[idx2+j-<span class="number">1</span>]!=nums2[idx2+nextPos])&#123;<span class="comment">//这个就是一直找和当前元素前面那个元素相等的元素位置，如果找到nextPos为-1，说明没有和当前元素前面那个元素相等的元素</span></span><br><span class="line">                    nextPos = next[nextPos];<span class="comment">//迭代的方式比较特殊，每次迭代都会走向当前nextPost的next值处的元素，因为这个next还表示最长公共前后缀中的前缀的后一个元素，这样找就是为了找到一个和当前元素相同的且正好可以和原最长公共前后缀组成更长的公共前后缀的元素</span></span><br><span class="line">                &#125;</span><br><span class="line">                next[j] = nextPos+<span class="number">1</span>;<span class="comment">//当前元素的next值就是找到的和它相等的那个元素的next值+1或者是没有找到和它相等的元素，此时是-1+1=0也符合条件。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (idx1&lt;nums1.length)&#123;<span class="comment">//KMP算法</span></span><br><span class="line">                <span class="keyword">if</span>(nums1[idx1]==nums2[idx2])&#123;<span class="comment">//如果指针指向的两个元素相同</span></span><br><span class="line">                    <span class="comment">//两个指针一直同时向前走直到两个指针指向的元素不同或者指针越界</span></span><br><span class="line">                    <span class="keyword">while</span> (idx1&lt;nums1.length&amp;&amp;idx2&lt;nums2.length&amp;&amp;nums1[idx1]==nums2[idx2])&#123;</span><br><span class="line">                        idx1++;</span><br><span class="line">                        idx2++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans = Math.max(ans,idx2-i);<span class="comment">//尝试更新答案</span></span><br><span class="line">                    <span class="keyword">if</span>(ans==nums2.length) <span class="keyword">return</span> ans;<span class="comment">//小优化，答案最大就是nums2的长度，所以得到之后可以直接返回</span></span><br><span class="line">                    <span class="keyword">if</span>(next[idx2-i]!=-<span class="number">1</span>) idx2=i+next[idx2-i];<span class="comment">//模式串指针回溯，回溯到当前值的next值处，因为前面的已经被匹配过了，无需重复匹配</span></span><br><span class="line">                    <span class="keyword">else</span> idx2 = i;<span class="comment">//这是个特殊情况，如果当前元素的next值为-1，说明第一位就失配，指针就不用动了</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(idx2!=i)&#123;<span class="comment">//如果指针指向的两个元素不相同并且模式串的指针不在最前面</span></span><br><span class="line">                    <span class="comment">//那么进行指针回溯</span></span><br><span class="line">                    <span class="keyword">if</span>(next[idx2-i]!=-<span class="number">1</span>) idx2=i+next[idx2-i];</span><br><span class="line">                    <span class="keyword">else</span> idx2 = i;<span class="comment">//这是个特殊情况，如果当前元素的next值为-1，说明第一位就失配，指针就不用动了</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果指针指向的两个元素不相同并且模式串的指针在最前面</span></span><br><span class="line">                    idx1++;<span class="comment">//那直接让目标串的指针往后走就行了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="弗洛伊德-Floyd-算法"><a href="#弗洛伊德-Floyd-算法" class="headerlink" title="弗洛伊德(Floyd)算法"></a>弗洛伊德(Floyd)算法</h1><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><ul><li>和 Dijkstra 算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名</li><li>弗洛伊德算法(Floyd)<strong>计算图中各个顶点之间的最短路径</strong></li><li>迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。</li><li>弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。</li><li>也就是说<strong>弗洛伊德算法是多源最短路算法</strong>。</li></ul><h2 id="算法思路分析"><a href="#算法思路分析" class="headerlink" title="算法思路分析"></a>算法思路分析</h2><ul><li>其实比较简单，就是<strong>搞三层循环，其中两层循环遍历任意两个节点，剩下的一层循环遍历除了那俩节点外的节点作为那两个节点之间的中转站尝试将那两个节点之间的距离进行”松弛“</strong>，三层循环过后得到的二维数据的结果就是所有节点到其他节点的最短路径。</li></ul><h2 id="代码示例-14"><a href="#代码示例-14" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="弗洛伊德-Floyd-判圈算法（龟兔赛跑算法）"><a href="#弗洛伊德-Floyd-判圈算法（龟兔赛跑算法）" class="headerlink" title="弗洛伊德(Floyd)判圈算法（龟兔赛跑算法）"></a>弗洛伊德(Floyd)判圈算法（龟兔赛跑算法）</h1><h2 id="算法介绍-1"><a href="#算法介绍-1" class="headerlink" title="算法介绍"></a>算法介绍</h2><ul><li>就是判断一个数据结构比如链表、图中有没有环，用的是快慢指针的方法，<strong>慢指针一次走一步，快指针一次走两步，由于数据结构中存在环，所以快慢指针一定会再次相遇，如果快慢指针相遇说明数据结构中存在环</strong>。</li><li>如果想要进一步找到环的入口怎么办，只需要<strong>将慢指针重新放到开头，然后快慢指针都一次走一步，下一次它们相遇的时候就是环的入口的位置</strong>。</li></ul><h2 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230101103607210.png" alt="image-20230101103607210"></p><h2 id="代码示例-15"><a href="#代码示例-15" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li><p>Leetcode142 环形链表Ⅱ：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230101111214834.png" alt="image-20230101111214834"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//特判两种情况</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head.next,fast = head.next.next;<span class="comment">//初始化快慢指针，慢指针步长为1，快指针步长为2</span></span><br><span class="line">        <span class="keyword">while</span> (slow!=fast&amp;&amp;slow!=<span class="literal">null</span>&amp;&amp;fast!=<span class="literal">null</span>)&#123;<span class="comment">//快慢指针移动，直至相遇（有环的时候）或走到null（无环的时候）</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//这个要判断一下，因为连着两次next，第一次next完可能是个null</span></span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(slow==fast&amp;&amp;slow!=<span class="literal">null</span>)&#123;<span class="comment">//如果不在null处相遇，说明有环</span></span><br><span class="line">            slow = head;<span class="comment">//将慢指针放到头上</span></span><br><span class="line">            <span class="keyword">while</span> (slow!=fast)&#123;<span class="comment">//然后让快慢指针步长都为1继续开始走，直到相遇，相遇的地方就是环的入口</span></span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;<span class="comment">//返回环的入口</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//如果没有相遇，说明没有环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="快慢指针找到链表中点"><a href="#快慢指针找到链表中点" class="headerlink" title="快慢指针找到链表中点"></a>快慢指针找到链表中点</h1><h2 id="算法介绍-2"><a href="#算法介绍-2" class="headerlink" title="算法介绍"></a>算法介绍</h2><ul><li>就是通过快慢指针的特性来找到链表的中点，<strong>慢指针步长为1，快指针步长为2，这样在快指针走到尾的时候，慢指针正好处于链表中点的位置</strong>。</li><li>可以利用这个特性来实现链表归并排序中的找中点的操作。</li></ul><h2 id="代码示例-16"><a href="#代码示例-16" class="headerlink" title="代码示例"></a>代码示例</h2><h1 id="前后指针找链表的倒数第k个元素"><a href="#前后指针找链表的倒数第k个元素" class="headerlink" title="前后指针找链表的倒数第k个元素"></a>前后指针找链表的倒数第k个元素</h1><h2 id="算法介绍-3"><a href="#算法介绍-3" class="headerlink" title="算法介绍"></a>算法介绍</h2><ul><li>目的是要找一个链表的倒数第k个元素，然后如果平常做的话，要先遍历一遍链表得到链表长度之后再找倒数第k个元素，但是我们完全可以用前后指针来把遍历链表得到链表长度这一步优化掉。</li><li>怎么做呢？我们可以<strong>让一个指针先出发，走k步之后第二个指针再出发，这样两个指针之间就差着k的距离了，当先出发的指针到达链表尾部null的时候，第二个指针指向的元素就是倒数第k个元素</strong>。</li></ul><h2 id="代码示例-17"><a href="#代码示例-17" class="headerlink" title="代码示例"></a>代码示例</h2><h1 id="Boyer-Moore投票算法"><a href="#Boyer-Moore投票算法" class="headerlink" title="Boyer-Moore投票算法"></a>Boyer-Moore投票算法</h1><h2 id="算法介绍-4"><a href="#算法介绍-4" class="headerlink" title="算法介绍"></a>算法介绍</h2><ul><li><p>这算法也叫摩尔投票算法，是从一个无序的投票集合中找出最多的那个票。</p></li><li><p>具体见下题：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221211114712980.png" alt="image-20221211114712980"></p></li></ul><h2 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h2><ul><li>其实就是一个<strong>同类相容，异类相杀</strong>的场景，可以想象这样一个场景，有一个山顶有很多军队想要占领，如果第一个人到达了山顶，由于此时山顶没有军队占领，所以那个人就把自己所在的军队的旗帜插到山顶了以表示现在这个山顶归那个军队所有，然后山顶继续上人，如果下一个人是和自己一个军队的，那么他们就可以相容，山顶还是那个军队的；如果下一个人不是和自己一个军队的，那么目前山顶上的人会出来一个人和那个异类拼杀直至同归于尽，直到山顶上没人了，下一个到达山顶的人可以把自己所在军队的旗帜替换掉之前的旗帜，山顶的归属权发生变化，就这样一致进行下去，最后旗帜在山顶上的军队获得那个山顶的所有权。</li><li>我们需要一个<strong>变量winner来标识目前山顶归谁所有</strong>，然后需要一个<strong>变量count来标识目前山顶归属军队在山顶的人数，如果新来了同类就++，如果新来了异类就–，如果count等于0了，说明山顶没人了，那么山顶就会在下一个人到来的时候更换归属者</strong>，最后winner的值就是最后山顶的归属者，也就是票数最多的候选人。</li></ul><h2 id="算法证明-1"><a href="#算法证明-1" class="headerlink" title="算法证明"></a>算法证明</h2><h2 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h2><ul><li>摩尔投票算法有很好的时空复杂度，它只需遍历一次投票集合，所以**时间复杂度是O(n)<strong>的，它只需要额外开两个int型变量，所以</strong>空间复杂度是O(1)**的。</li></ul><h2 id="代码示例-18"><a href="#代码示例-18" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li><p>算法介绍中的那个题的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">winner</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>) winner = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==winner) count++;</span><br><span class="line">            <span class="keyword">else</span> count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> winner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="有限状态自动机"><a href="#有限状态自动机" class="headerlink" title="有限状态自动机"></a>有限状态自动机</h1><h1 id="Brian-Kernighan-算法"><a href="#Brian-Kernighan-算法" class="headerlink" title="Brian Kernighan 算法"></a>Brian Kernighan 算法</h1><h2 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>是个位运算的结论，就是<strong>x&amp;(x-1)的结果和让x的最低位的1变成0的结果相同</strong>，如果让x&amp;&#x3D;x-1就相当于把x的最低位的1去掉了，在很多地方有用（比如比特位计数）。</li></ul><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><ul><li><p>求汉明距离，可以用这个算法来进行优化：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221228095807579.png" alt="image-20221228095807579"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution26</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x^y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp!=<span class="number">0</span>)&#123;<span class="comment">//循环次数就是temp中1的个数</span></span><br><span class="line">            temp&amp;=temp-<span class="number">1</span>;<span class="comment">//BK算法，每次都让temp少了最低位的一个1</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="使用位运算做加法"><a href="#使用位运算做加法" class="headerlink" title="使用位运算做加法"></a>使用位运算做加法</h1><h2 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>就是不使用加减乘除四则运算，只利用位运算的特性来做加法运算。</li><li>结论就是<strong>两个数的按位异或相当于两个数的不进位加法</strong>，<strong>两个数按位与并向左移动一位得到的结果的二进制上的1仅是两个数相加后的进位</strong>。</li><li>从上面的结论中我们<strong>可以通过计算得到两个数的不进位加法值和进位数据</strong>，可以<strong>先计算得到两者的进位数据，然后通过不进位加法得到进位后的数据，通过多次迭代（应对连进好几位的情况）直到没有进位之后再做最后一次不进位加法就能得到加法最终的结果</strong>。</li></ul><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (b!=<span class="number">0</span>)&#123;<span class="comment">//直到没有进位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> (a&amp;b)&lt;&lt;<span class="number">1</span>;<span class="comment">//仅得到进位数据，得到的数的二进制表示上的1就是要往那个地方进一位</span></span><br><span class="line">            a = a^b;<span class="comment">//仅为不进位加法</span></span><br><span class="line">            b = temp;<span class="comment">//用于下次进位加法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用位运算做模运算"><a href="#使用位运算做模运算" class="headerlink" title="使用位运算做模运算"></a>使用位运算做模运算</h1><h2 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>也是一个位运算的结论，就是**如果n是2的整数次幂，那么num%n可以被转化为num&amp;(n-1)**，这也是hashmap中寻找存放元素位置时使用的策略，因为这样的位运算比直接使用%进行运算效率要好，hashmap存放元素时，首先根据hashCode()函数求得元素的哈希值，然后通过抖动函数对哈希值进行处理，目的是为了让哈希值尽可能平均一下，减少哈希碰撞，最后就是使用hash&amp;(n-1)来计算元素应该存放的位置，n就是hashmap的链表数组的长度，为了使用这个特性，hashmap的链表数组长度总是2的整数次幂，并且每次扩容都是将链表数组的长度乘2.</li></ul><h1 id="四平方和定理"><a href="#四平方和定理" class="headerlink" title="四平方和定理"></a>四平方和定理</h1><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h1 id="非线性结构转线性结构"><a href="#非线性结构转线性结构" class="headerlink" title="非线性结构转线性结构"></a>非线性结构转线性结构</h1><ul><li><p>有些时候我们希望将非线性结构转成线性结构以达成某些目的，最常见的就是二叉树的顺序存储，这个在之前的堆中写过了，这里不再赘述，我想说的是，<strong>有时我们没有必要真的把非线性结构转换成线性结构，而是在逻辑层面上建立起这样的关系，建立关系最常用的工具就是HashMap</strong>，比如<strong>我想用二叉树的节点在顺序结构中的下标，那么我没有必要真的把它放到顺序结构中，而是可以通过HashMap建立起节点和下标的映射，然后通过它的父节点的下标计算出本节点的下标</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230204105352758.png" alt="image-20230204105352758"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//特殊情况</span></span><br><span class="line">        HashMap&lt;TreeNode,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//里面是节点和顺序存储下节点对应的下标的映射</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; qu = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//队列</span></span><br><span class="line">        qu.add(root);<span class="comment">//root入队</span></span><br><span class="line">        map.put(root,<span class="number">0</span>);<span class="comment">//root的编号是0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最后结果</span></span><br><span class="line">        <span class="keyword">while</span> (!qu.isEmpty())&#123;<span class="comment">//bfs</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> qu.size();<span class="comment">//获取队列的size，下面进行层次遍历要用</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>,right = -<span class="number">1</span>;<span class="comment">//分别代表本层最左边那个元素的编号和本层最右边那个元素的编号</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;<span class="comment">//层次遍历</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> qu.poll();<span class="comment">//出队</span></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;<span class="comment">//不用考虑null节点，因为每个节点的编号计算不依赖与null节点</span></span><br><span class="line">                    qu.add(node.left);<span class="comment">//入队</span></span><br><span class="line">                    map.put(node.left,map.get(node)*<span class="number">2</span>+<span class="number">1</span>);<span class="comment">//计算出当前节点的左节点在顺序存储中的下标</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    qu.add(node.right);</span><br><span class="line">                    map.put(node.right,map.get(node)*<span class="number">2</span>+<span class="number">2</span>);<span class="comment">//计算出当前节点的右节点在顺序存储中的下标</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) left = map.get(node);<span class="comment">//记录下第一个节点的编号</span></span><br><span class="line">                <span class="keyword">if</span>(i==size-<span class="number">1</span>) right = map.get(node);<span class="comment">//记录下最后一个节点的编号</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,right-left+<span class="number">1</span>);<span class="comment">//尝试更新答案</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到了二叉树顺序存储的思想，每个节点在顺序存储下都有自己的编号，一层的宽度就是最后一个元素的编号减去第一个元素的编号再加1。进行层次遍历，每遍历完一层就尝试更新答案，由于<strong>元素的编号只和自己的父节点有关</strong>，所以使用这个思路的话，null节点就不用在层次遍历中考虑了，因为非null节点的编号计算并不依赖于null节点。<br>那么怎么把二叉树表示成一个顺序结构呢，我们可以<strong>只在逻辑上把二叉树表示成一个顺序结构，也就是使用HashMap，记录二叉树节点和顺序结构中二叉树节点的下标的映射，之后我们就能通过这个hashmap来得到某个节点在顺序结构中的编号了</strong>。</p></li></ul><h1 id="上下车问题"><a href="#上下车问题" class="headerlink" title="上下车问题"></a>上下车问题</h1><h2 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h2><ul><li>这个问题就是，<strong>给出所有乘客的上车时间和下车时间，求同一时刻车上最多的乘客人数</strong>。</li></ul><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ul><li><strong>不用在意是谁上下车，只需要注意什么时候上下车即可</strong>。</li><li>可以<strong>遍历所有时间，遍历到上车时间，车上的人就++；遍历到下车时间，车上的人就–，每次车上的人++的时候都要尝试更新车上人数最大值max</strong>。</li><li>具体实现方式可以<strong>分别对上车时间的集合和下车时间的集合进行排序</strong>，然后<strong>使用双指针+二路归并算法的思路来从逻辑上遍历上车时间集合和下车时间集合组合成的有序集合</strong>，遍历到上车时间就让车上的人数++并尝试更新车上人数的最大值max，遍历到下车时间就让车上的人数–。</li><li>通过这个问题可以在以后见到和时间相关的问题的时候留个心眼，可以尝试按照时间轴进行遍历，说不定会有新的思路。</li></ul><h2 id="具体问题"><a href="#具体问题" class="headerlink" title="具体问题"></a>具体问题</h2><ul><li><p>LeetCode 253. 会议室Ⅱ：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230130101107904.png" alt="image-20230130101107904"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMeetingRooms</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] begin = <span class="keyword">new</span> <span class="title class_">int</span>[intervals.length];<span class="comment">//会议开始时间的集合</span></span><br><span class="line">        <span class="type">int</span>[] end = <span class="keyword">new</span> <span class="title class_">int</span>[intervals.length];<span class="comment">//会议结束时间的集合</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最后答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;intervals.length;++i)&#123;<span class="comment">//给begin和end赋值</span></span><br><span class="line">            begin[i] = intervals[i][<span class="number">0</span>];</span><br><span class="line">            end[i] = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(begin);<span class="comment">//给begin排序</span></span><br><span class="line">        Arrays.sort(end);<span class="comment">//给end排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">beginI</span> <span class="operator">=</span> <span class="number">0</span>,endI = <span class="number">0</span>;<span class="comment">//双指针分别指向begin和end的开头</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用来统计某一时刻正在使用的会议室的数量</span></span><br><span class="line">        <span class="keyword">while</span> (beginI&lt;intervals.length&amp;&amp;endI&lt;intervals.length)&#123;<span class="comment">//二路归并算法的思想，逻辑上是将begin和end组合成了一个有序集合然后遍历</span></span><br><span class="line">            <span class="keyword">if</span>(begin[beginI]&lt;end[endI])&#123;<span class="comment">//如果遍历到会议开始时间，那就开个会议室</span></span><br><span class="line">                temp++;<span class="comment">//正在开会的会议室数量++</span></span><br><span class="line">                beginI++;<span class="comment">//begin往后走</span></span><br><span class="line">                <span class="keyword">if</span>(temp&gt;ans) ans = temp;<span class="comment">//尝试更新答案</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//遍历到会议结束时间，关一个会议室，不用纠结元素相同的问题，稍微想想就知道这一点对最后的结果无影响</span></span><br><span class="line">                temp--;<span class="comment">//正在开会的会议室数量--</span></span><br><span class="line">                endI++;<span class="comment">//end往后走</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//temp += intervals.length-beginI;//最后处理一下剩余的会议开始时间，不处理也行，因为总会有会议的结束时间比所有会议的开始时间都要晚</span></span><br><span class="line">        <span class="comment">//if(temp&gt;ans) ans = temp;</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h1><ul><li><p>最简单的方法就是使用一个栈来模拟括号的匹配，不再赘述。</p></li><li><p>实际上还可以把栈优化掉，将括号的匹配进一步抽象，可以<strong>定义两个变量分别表示左右括号的数量，然后遍历括号序列，每当遍历到左括号，记录左括号数量的变量就++；每当遍历到右括号，如果左括号数量不为空，那么左括号的数量就–，如果左括号数量为空，那么右括号数量就++，如果最后两个变量都是0，那么括号匹配，否则，两个变量加起来就是失配的括号数量</strong>。这样做不仅可以优化空间，还可以处理中间夹杂着其他字符的情况，用这种方式处理，中间夹杂着的其他字符不影响括号的匹配。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><ul><li>如果要想使用正则表达式匹配一些在正则表达式中有特定含义的字符（比如：\、*、.等），要使用反斜杠‘\’来对这些字符进行转义，不过要注意，<strong>反斜杠本身也是一个在正则表达式中有特定含义的字符，所以它本身也需要一个反斜杠来进行转义</strong>。</li></ul><h2 id="匹配-‘-‘-字符"><a href="#匹配-‘-‘-字符" class="headerlink" title="匹配 ‘ . ‘ 字符"></a>匹配 ‘ . ‘ 字符</h2><ul><li>今天用到Java String中的split方法来着，我的本意是以’ . ‘字符为分割符来对字符串进行分割，所以我就传了个”.”参数，但是分割的结果不尽人意，后来我才意识到，<strong>split方法要求传入的是一个正则表达式，而’ . ‘字符在正则表达式中是个特殊字符，所以我们应该使用反斜杠’&#39;来对它进行转义，但是反斜杠在正则表达式中也是一个特殊字符，所以反斜杠本身也需要被转义，所以如果要想匹配’.’字符，正则表达式应该写为：”\\.”</strong></li></ul><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h2 id="简单拓扑排序"><a href="#简单拓扑排序" class="headerlink" title="简单拓扑排序"></a>简单拓扑排序</h2><h3 id="算法介绍-5"><a href="#算法介绍-5" class="headerlink" title="算法介绍"></a>算法介绍</h3><ul><li><p>拓扑排序就是<strong>用来计算一些具有先决条件的事情的执行顺序的算法</strong>，最经典的例子就是大学里修课程，每门课程可能有先决条件，也就是说可能你必须要修掉这门课程的先决条件的课程，你才能修这门课程：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230110092904231.png" alt="image-20230110092904231"></p></li><li><p>我们可以<strong>根据这些事件的关系，来画出一个有向无环图来表示他们之间的执行顺序</strong>，这个有向无环图被称为<strong>AOV网</strong>，如果在AOV网中a指向b，那么说明b的先决条件就是a，也就是说，在最后得到的序列中，a必须在b的前面：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230110093122193.png" alt="image-20230110093122193"></p></li><li><p>而简单拓扑排序只是<strong>要求我们最后将一种执行事件的顺序计算出来</strong>，没有一些额外的要求，比较复杂一点的拓扑排序可能会有额外的一些要求，比如求选修某课程所需的最短事件等，包括还有一些AOV网中的边带有权值，关于这些比较复杂的情况，写在后面，这里就只讨论最简单的拓扑排序。</p></li><li><p>从上面的描述中我们很容易得知，<strong>只有有向无环图（DAG）才会有拓扑排序，非DAG图没有拓扑排序的概念</strong>，因为如果得到的AOV网有环，很明显在那个环里的事件都不会得到执行。</p></li><li><p>再来看看对拓扑排序比较准确的描述：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230110093800562.png" alt="image-20230110093800562"></p></li></ul><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><ul><li><p>对于AOV网我们只需要：</p><ol><li>找到所有无入度的顶点，任选其中一点写入排序队列。</li><li>在AOV网中删除刚才写入排序队列的顶点，并将它的边也一同删除。</li><li>重复1、2步操作直到AOV网为空。</li></ol><p>然后我们就得到了一个排序队列，这个排序队列实际上就是AOV网对应的一种拓扑排序的结果。</p><p>整个流程和bfs很像，可以用bfs实现，当节点入度为0时才能加入队列中参与bfs，每次都将poll出来的元素指向的那些元素的入度减1来表示从AOV网中将poll出来的元素移除。</p></li><li><p>还可以用栈+dfs倒推（之后理解理解再来补）</p></li></ul><h3 id="代码示例-19"><a href="#代码示例-19" class="headerlink" title="代码示例"></a>代码示例</h3><ul><li><p>LeetCode 207. 课程表：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230110105510020.png" alt="image-20230110105510020"></p><p>可以用拓扑排序的思路+bfs实现，只有当一个节点的入度为0的时候才能被放到队列中进行bfs，每次都让poll出来的元素指向的那些元素的入度–，因为相当于从AOV网中删除了poll出来的元素，如果一个节点到最后了入度也没能减为0，说明它在一个环中，也就说明对应的AOV网无法完成拓扑排序，即无法完成所有课程的学习。</p><p>按理说拓扑排序最后需要得到一个序列，但是这个题中可以做个优化，不统计序列，只统计序列中元素的数量，因为最后只需要判断是否可以完成拓扑序列，也就是只需要判断序列中元素的数量是否等于给出的元素数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//维护每个节点指向的那些节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;++i)&#123;</span><br><span class="line">            temp.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];<span class="comment">//统计各节点的入度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;++i)&#123;<span class="comment">//初始化各节点的关系和入度</span></span><br><span class="line">            temp.get(prerequisites[i][<span class="number">0</span>]).add(prerequisites[i][<span class="number">1</span>]);</span><br><span class="line">            indegree[prerequisites[i][<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; qu = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//bfs用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//统计可以被加入队列中进行bfs的节点数，如果到最后sum的数量和numCourse不相同，说明到最后有些节点也无法被加入到队列中，说明他们到最后入度也没有归零，说明他们是在一个环中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;indegree.length;++i)&#123;<span class="comment">//给qu初始化</span></span><br><span class="line">            <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)&#123;<span class="comment">//入度为0才能被加入队列进行bfs</span></span><br><span class="line">                qu.offer(i);</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!qu.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;++i) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> qu.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> a : temp.get(head)) &#123;</span><br><span class="line">                    indegree[a]--;<span class="comment">//相当于把head移除，所以head指向的元素入度都--</span></span><br><span class="line">                    <span class="keyword">if</span> (indegree[a]==<span class="number">0</span>) &#123;<span class="comment">//只有当入度为0的时候才能被加入队列进行bfs</span></span><br><span class="line">                        qu.offer(a);</span><br><span class="line">                        sum++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum==numCourses;<span class="comment">//如果sum==numCourse说明无环，所有的节点的入度最后都能归零</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h1><h2 id="算法介绍-6"><a href="#算法介绍-6" class="headerlink" title="算法介绍"></a>算法介绍</h2><ul><li>Manacher 算法是在线性时间内求解最长回文子串的算法。</li></ul><h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><ul><li>就是从一组数据中找出给定的数据。</li></ul><h2 id="线性查找算法"><a href="#线性查找算法" class="headerlink" title="线性查找算法"></a>线性查找算法</h2><h3 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>就是遍历一遍数据，找到了对应元素就记下来，没啥好介绍的。</li></ul><h3 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>就是遍历一遍数据，找到了对应元素就记下来，没啥思想。</li></ul><h3 id="代码示例-20"><a href="#代码示例-20" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-11 15:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinearSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入集合中的数据个数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入集合中的数据，数据之间用空格分隔：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要查找的数据：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]==target)&#123;</span><br><span class="line">                System.out.println(target+<span class="string">&quot;第一次在集合中出现位置的下标是：&quot;</span>+i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(target+<span class="string">&quot;在集合中不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分-折半-查找算法"><a href="#二分-折半-查找算法" class="headerlink" title="二分(折半)查找算法"></a>二分(折半)查找算法</h2><h3 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>使用<strong>二分查找的前提是数据有序</strong>，然后<strong>每次找数据中间的数，然后根据那个数和要找的数之间的关系来决定继续向左还是向右进行查找</strong>。</li></ul><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107090928743.png" alt="image-20221107090928743"></p><h3 id="对于中间值下标计算的优化"><a href="#对于中间值下标计算的优化" class="headerlink" title="对于中间值下标计算的优化"></a>对于中间值下标计算的优化</h3><ul><li>上面计算中间值的下标mid用的是(left+right)&#x2F;2这个表达式，然而这个表达式实际上不够安全，<strong>如果left和right是两个非常大的数，那么left+right这一操作可能造成数值溢出</strong>。</li><li>鉴于上面的问题，我们可以<strong>将计算中间值下标mid用到的表达式换成left+(right-left)&#x2F;2</strong>，这样由于之前的两个大数的加法转换成了两个大数的减法，所以杜绝了正常数据下数值溢出的问题。</li></ul><h3 id="代码示例-21"><a href="#代码示例-21" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-11 15:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入集合中的数据个数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入集合中的数据，数据有序并且数据之间用空格分隔：&quot;</span>);<span class="comment">//二分查找的数组必须有序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要查找的数据：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//左边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n-<span class="number">1</span>;<span class="comment">//右边界</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;<span class="comment">//这里的等号是必要的，因为按照下面的写法，当两个下标重合的时候，重合处的元素还没有被判断过</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;<span class="comment">//这样写是为了在数据很大的情况下不至于造成算数溢出</span></span><br><span class="line">            <span class="keyword">if</span>(target==num[mid])&#123;<span class="comment">//找到了</span></span><br><span class="line">                System.out.println(target+<span class="string">&quot;在集合中出现位置对应的下标是：&quot;</span>+mid);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;num[mid])&#123;<span class="comment">//target比num[mid]小说明target在前半段</span></span><br><span class="line">                right = mid-<span class="number">1</span>;<span class="comment">//向前折半，注意这里由于是mid-1，所以下一轮的right是还没有被查过的，此时如果下一轮left和right重合了，还要再走一轮查重合的那个元素，所以在循环中的那个等号是必要的</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;num[mid])&#123;<span class="comment">//target比num[mid]大说明target在后半段</span></span><br><span class="line">                left = mid+<span class="number">1</span>;<span class="comment">//向后折半，注意这里由于是mid+1，所以下一轮的left是还没有被查过的，此时如果下一轮left和right重合了，还要再走一轮查重合的那个元素，所以在循环中的那个等号是必要的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(target+<span class="string">&quot;在集合中不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插值查找算法"><a href="#插值查找算法" class="headerlink" title="插值查找算法"></a>插值查找算法</h2><h3 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li><p><strong>如果要查找的元素位于数据的头部或者尾部左右，使用二分查找的话效率会比较低</strong>，因为每次不管数据在什么部分，对于数据的分割总是二分，这样我们就思考，<strong>如果有一种查找方式可以在每次分割数据的时候根据要找的数据的值来自适应地向最有可能存在目标数据的区间去寻找就好了</strong>，这就是插值查找算法的基本思路。</p></li><li><p>插值查找算法类似于二分查找，不同的是<strong>插值查找每次从自适应 mid 处开始查找</strong>。</p></li></ul><h3 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li><p>其思想就是<strong>利用一个插值参数代替二分查找计算中间值表达式的1&#x2F;2</strong>，而这个插值参数是自适应的，也就是说这个插值参数揭示了要找的元素最有可能出现在哪一部分，我的数学不是很好，看着应该是利用了比例。</p></li><li><p>将折半查找中的求 mid 索引的公式进行修改 , low 表示左边索引 left，high 表示右边索引 right，key 就是我们想要找的数据：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107092311759.png" alt="image-20221107092311759"></p></li><li><p>**int mid &#x3D; low + (high - low) * (key - arr[low]) &#x2F; (arr[high] - arr[low])**这就是插值索引mid的计算方法。</p></li></ul><h3 id="插值查找算法举例"><a href="#插值查找算法举例" class="headerlink" title="插值查找算法举例"></a>插值查找算法举例</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107092649559.png" alt="image-20221107092649559"></p><h3 id="插值查找注意事项"><a href="#插值查找注意事项" class="headerlink" title="插值查找注意事项"></a>插值查找注意事项</h3><ul><li>对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快。</li><li>关键字分布不均匀的情况下，该方法不一定比折半查找要好。</li></ul><h3 id="代码示例-22"><a href="#代码示例-22" class="headerlink" title="代码示例"></a>代码示例</h3><ul><li><p>和二分查找差不多，只是索引mid的计算方法变了而已：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-11 15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterpolationSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入集合中的数据个数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入集合中的数据，数据有序并且数据之间用空格分隔：&quot;</span>);<span class="comment">//插值查找的数组必须有序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要查找的数据：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//左边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n-<span class="number">1</span>;<span class="comment">//右边界</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;<span class="comment">//这里的等号是必要的，因为按照下面的写法，当两个下标重合的时候，重合处的元素还没有被判断过</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)*((target-num[left])/(num[right]-num[left]));<span class="comment">//插值看上去好像是表示某个比例，同理，这样写不至于算术溢出</span></span><br><span class="line">            <span class="keyword">if</span>(target==num[mid])&#123;<span class="comment">//找到了</span></span><br><span class="line">                System.out.println(target+<span class="string">&quot;在集合中出现位置对应的下标是：&quot;</span>+mid);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;num[mid])&#123;<span class="comment">//target比num[mid]小说明target在前段</span></span><br><span class="line">                right = mid-<span class="number">1</span>;<span class="comment">//向前折，注意这里由于是mid-1，所以下一轮的right是还没有被查过的，此时如果下一轮left和right重合了，还要再走一轮查重合的那个元素，所以在循环中的那个等号是必要的</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;num[mid])&#123;<span class="comment">//target比num[mid]大说明target在后段</span></span><br><span class="line">                left = mid+<span class="number">1</span>;<span class="comment">//向后折，注意这里由于是mid+1，所以下一轮的left是还没有被查过的，此时如果下一轮left和right重合了，还要再走一轮查重合的那个元素，所以在循环中的那个等号是必要的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(target+<span class="string">&quot;在集合中不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="斐波那契-黄金分割-查找算法"><a href="#斐波那契-黄金分割-查找算法" class="headerlink" title="斐波那契(黄金分割)查找算法"></a>斐波那契(黄金分割)查找算法</h2><h3 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li>黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是 0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不到的效果。</li><li>斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值0.618</li><li>也就是说<strong>找目标值的时候用到的所以是利用斐波那契数列两个相邻数的比例计算出来的</strong>。（怎么感觉这种查找这么玄学。。。）</li></ul><h3 id="算法思想-7"><a href="#算法思想-7" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li><p>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位于黄金分割点附近，即 <strong>mid&#x3D;low+F(k-1)-1（F 代表斐波那契数列）</strong>，如下图所示：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107093420069.png" alt="image-20221107093420069"></p></li><li><p>对F(k-1)-1的理解：</p><ol><li>由斐波那契数列 F[k]&#x3D;F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）&#x3D;（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：<strong>只要顺序表的长度为 F[k]-1，则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段，即如上图所示。从而中间位置为 mid&#x3D;low+F(k-1)-1</strong>。</li><li>类似的，每一子段也可以用相同的方式分割</li><li>但顺序表长度 n 不一定刚好等于 F[k]-1，所以<strong>需要将原来的顺序表长度 n 增加至 F[k]-1</strong>。这里的<strong>k 值只要能使得 F[k]-1 恰好大于或等于 n 即可</strong>，由以下代码得到,顺序表长度增加后，<strong>新增的位置（从 n+1 到 F[k]-1 位置），都赋为 n 位置的值即可</strong>。</li></ol></li><li></li></ul><h3 id="代码示例-23"><a href="#代码示例-23" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"># 数据结构-树</span><br><span class="line"></span><br><span class="line">## 二叉树</span><br><span class="line"></span><br><span class="line">### 为什么需要树这种数据结构</span><br><span class="line"></span><br><span class="line">- **数组存储方式**的分析：</span><br><span class="line"></span><br><span class="line">  - **优点**：通过下标方式访问元素，速度快。对于有序数组，还可使用**二分查找提高检索速度**。</span><br><span class="line"></span><br><span class="line">  - **缺点**：如果要检索具体某个值，或者**插入值(按一定顺序)会整体移动，效率较低**。</span><br><span class="line"></span><br><span class="line">    ![image-<span class="number">20221107201028421</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107201028421.png)</span></span><br><span class="line"></span><br><span class="line">- **链式存储方式**的分析：</span><br><span class="line"></span><br><span class="line">  - **优点**：在一定程度上对数组存储方式有优化(比如：**插入**一个数值节点，只需要将插入节点，链接到链表中即可，**删除效率也很好**)。</span><br><span class="line"></span><br><span class="line">  - **缺点**：**在进行检索时，效率仍然较低**，比如(检索某个值，需要从头节点开始遍历)</span><br><span class="line"></span><br><span class="line">    ![image-<span class="number">20221107201236741</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107201236741.png)</span></span><br><span class="line"></span><br><span class="line">- **树存储方式**的分析</span><br><span class="line"></span><br><span class="line">  - 能提高数据存储，读取的效率, 比如**利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度**。</span><br><span class="line"></span><br><span class="line">    ![image-<span class="number">20221107201333513</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107201333513.png)</span></span><br><span class="line"></span><br><span class="line">### 树示意图</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20221111195315513</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111195315513.png)</span></span><br><span class="line"></span><br><span class="line">### 树的常用术语</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20221111195347117</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111195347117.png)</span></span><br><span class="line"></span><br><span class="line">- 节点：就是树的节点</span><br><span class="line">- 根节点：就是最顶上那个节点</span><br><span class="line">- 父节点：指向这个节点的节点是这个节点的父节点</span><br><span class="line">- 子节点：被指向的节点是指向它的那个节点的子节点</span><br><span class="line">- 叶子节点：没有子节点的节点</span><br><span class="line">- 节点的权：就是节点的值</span><br><span class="line">- 路径：一个节点的路径就是从根节点找到该节点的路线</span><br><span class="line">- 层：横着看是一层，从根节点途经相同步数能到达的节点在同一层中</span><br><span class="line">- 子树：在二叉树中一个节点只有两个子树，分别是左子树和右子树，左右子树都是由是左右节点直接或间接的子节点来构成的</span><br><span class="line">- 树的高度：就是树的最大层数</span><br><span class="line">- 森林：多棵子树构成森林</span><br><span class="line"></span><br><span class="line">### 二叉树的概念</span><br><span class="line"></span><br><span class="line">- 树有很多种，**每个节点最多只能有两个子节点**的一种形式称为二叉树。</span><br><span class="line"></span><br><span class="line">- 二叉树的子节点分为左节点和右节点</span><br><span class="line"></span><br><span class="line">- 示意图：</span><br><span class="line"></span><br><span class="line">  ![image-<span class="number">20221111201052749</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201052749.png)</span></span><br><span class="line"></span><br><span class="line">- 如果该二叉树的**所有叶子节点都在最后一层，并且结点总数= <span class="number">2</span>^n -<span class="number">1</span> , n 为层数**，则我们称为**满二叉树**。</span><br><span class="line"></span><br><span class="line">  ![image-<span class="number">20221111201131764</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201131764.png)</span></span><br><span class="line"></span><br><span class="line">- 如果该二叉树的**所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续**，我们称为**完全二叉树**。更通俗一点的解释就是：**去掉最后一层是满二叉树，倒数第一层的节点全部紧靠在左边**。</span><br><span class="line"></span><br><span class="line">  ![image-<span class="number">20221111201217766</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201217766.png)</span></span><br><span class="line"></span><br><span class="line">### 二叉树遍历的说明</span><br><span class="line"></span><br><span class="line">- 我们可以使用**层序、前序、中序和后序**等对二叉树进行遍历。</span><br><span class="line">- 前序遍历：先输出父节点，再遍历左子树和右子树</span><br><span class="line">- 中序遍历：先遍历左子树，再输出父节点，再遍历右子树</span><br><span class="line">- 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点</span><br><span class="line">- 小结: 看输出父节点的顺序，就能确定是前序，中序还是后序</span><br><span class="line"></span><br><span class="line">### 二叉树遍历步骤</span><br><span class="line"></span><br><span class="line">![image-<span class="number">20221111201731060</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201731060.png)</span></span><br><span class="line"></span><br><span class="line">### 二叉树查找指定节点</span><br><span class="line"></span><br><span class="line">- 思路分析图解：</span><br><span class="line"></span><br><span class="line">  ![image-<span class="number">20221111201900016</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201900016.png)</span></span><br><span class="line"></span><br><span class="line">### 二叉树删除节点</span><br><span class="line"></span><br><span class="line">- 思路分析图解：</span><br><span class="line"></span><br><span class="line">  ![image-<span class="number">20221111201942720</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201942720.png)</span></span><br><span class="line"></span><br><span class="line">- 注意这里的删除思路是针对普通二叉树来说的，后面的排序二叉树、平衡二叉树等的删除思路和普通二叉树不同，后面会详细介绍。</span><br><span class="line"></span><br><span class="line">## 顺序存储二叉树</span><br><span class="line"></span><br><span class="line">- 堆这个数据结构会用到顺序存储二叉树</span><br><span class="line"></span><br><span class="line">### 顺序存储二叉树的概念</span><br><span class="line"></span><br><span class="line">- 基本说明：从数据存储来看，数组存储方式和树的存储方式可以相互转换，即**数组可以转换成树，树也可以转换成数组**，看下面的示意图：</span><br><span class="line"></span><br><span class="line">  ![image-<span class="number">20221112112821494</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221112112821494.png)</span></span><br><span class="line"></span><br><span class="line">- 要求：在遍历数组 arr 时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历。</span><br><span class="line"></span><br><span class="line">- 顺序存储二叉树的特点：</span><br><span class="line"></span><br><span class="line">  <span class="number">1.</span> 顺序二叉树通常**只考虑完全二叉树**</span><br><span class="line">  <span class="number">2.</span> 第 n 个元素的**左子节点为 <span class="number">2</span> * n + <span class="number">1</span>**</span><br><span class="line">  <span class="number">3.</span> 第 n 个元素的**右子节点为 <span class="number">2</span> * n + <span class="number">2</span>**</span><br><span class="line">  <span class="number">4.</span> 第 n 个元素的**父节点为 (n-<span class="number">1</span>) / <span class="number">2</span>**</span><br><span class="line">  <span class="number">5.</span> n : 表示二叉树中的第几个元素(按 <span class="number">0</span> 开始编号如图所示)</span><br><span class="line"></span><br><span class="line">### 顺序存储二叉树的遍历</span><br><span class="line"></span><br><span class="line">- 其实思路和非顺序存储二叉树的遍历相同，也是递归，只不过就是访问左子节点和访问右子节点的方式变了一下，之前是通过指针访问，现在是通过下标访问。</span><br><span class="line"></span><br><span class="line">- 代码示例：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@create</span> 2022-11-12 11:39</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderTreeTraverse</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">          <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">          System.out.println(<span class="string">&quot;请输入树的节点数量（包括空节点）：&quot;</span>);</span><br><span class="line">          <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">          <span class="type">int</span>[] tree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">          System.out.println(<span class="string">&quot;请按层序输入树的节点权值，空节点用-1代替：&quot;</span>);</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">              tree[i] = scanner.nextInt();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">&quot;前序遍历的结果为：&quot;</span>);</span><br><span class="line">          before(tree,<span class="number">0</span>);</span><br><span class="line">          System.out.println();</span><br><span class="line">          System.out.println(<span class="string">&quot;中序遍历的结果为：&quot;</span>);</span><br><span class="line">          mid(tree,<span class="number">0</span>);</span><br><span class="line">          System.out.println();</span><br><span class="line">          System.out.println(<span class="string">&quot;后序遍历的结果为：&quot;</span>);</span><br><span class="line">          after(tree,<span class="number">0</span>);</span><br><span class="line">          System.out.println();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(<span class="type">int</span>[] tree,<span class="type">int</span> now)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(now&gt;=tree.length)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(tree[now]!=-<span class="number">1</span>)<span class="comment">//如果不是空节点就输出</span></span><br><span class="line">              System.out.print(tree[now]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">          before(tree,now*<span class="number">2</span>+<span class="number">1</span>);<span class="comment">//向左遍历</span></span><br><span class="line">          before(tree,now*<span class="number">2</span>+<span class="number">2</span>);<span class="comment">//向右遍历</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mid</span><span class="params">(<span class="type">int</span>[] tree,<span class="type">int</span> now)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(now&gt;=tree.length)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          mid(tree,now*<span class="number">2</span>+<span class="number">1</span>);<span class="comment">//向左遍历</span></span><br><span class="line">          <span class="keyword">if</span>(tree[now]!=-<span class="number">1</span>)<span class="comment">//如果不是空节点就输出</span></span><br><span class="line">              System.out.print(tree[now]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">          mid(tree,now*<span class="number">2</span>+<span class="number">2</span>);<span class="comment">//向右遍历</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(<span class="type">int</span>[] tree,<span class="type">int</span> now)</span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(now&gt;=tree.length)&#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          after(tree,now*<span class="number">2</span>+<span class="number">1</span>);<span class="comment">//向左遍历</span></span><br><span class="line">          after(tree,now*<span class="number">2</span>+<span class="number">2</span>);<span class="comment">//向右遍历</span></span><br><span class="line">          <span class="keyword">if</span>(tree[now]!=-<span class="number">1</span>)<span class="comment">//如果不是空节点就输出</span></span><br><span class="line">              System.out.print(tree[now]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h2><ul><li>在普通的非顺序存储的二叉树中，所有的没有两个子节点的节点会有空闲的指针没有被利用，<strong>线索二叉树做的实际上就是利用二叉树中空闲的指针再表示一些信息，从而使得在之后的操作中受益</strong>。比如树的Morris遍历，实际上就是利用了左子树最右节点的空闲指针从而使得遍历起来更加方便。</li></ul><h3 id="线索二叉树基本介绍"><a href="#线索二叉树基本介绍" class="headerlink" title="线索二叉树基本介绍"></a>线索二叉树基本介绍</h3><ul><li>n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)&#x3D;n+1】 个空指针域。<strong>利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”）</strong></li><li>这种<strong>加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)<strong>。根据线索性质的不同，线索二叉树可分为</strong>前序</strong>线索二叉树、<strong>中序</strong>线索二叉树和<strong>后序</strong>线索二叉树三种</li><li>一个结点的前一个结点，称为<strong>前驱结点</strong></li><li>一个结点的后一个结点，称为<strong>后继结点</strong></li></ul><h3 id="将二叉树线索化的流程"><a href="#将二叉树线索化的流程" class="headerlink" title="将二叉树线索化的流程"></a>将二叉树线索化的流程</h3><ul><li><p>将二叉树线索化实际上就是<strong>将特定遍历顺序中对应节点的前驱和后继记录到对应节点的空闲指针上去</strong>。所以根据遍历顺序的不同，线索二叉树可以分为前序、中序、后序线索二叉树三种，这些都是对于线索二叉树这个抽象的实现，实际上你也可以用别的方式实现不同的线索二叉树。</p></li><li><p>需要两个节点指针，其中一个<strong>node用来指向遍历到的节点</strong>，另外一个<strong>pre用来指向遍历到的节点的前一个遍历到的节点</strong>。<strong>设置当前节点的前驱节点需要让node对应节点（当前节点）的左指针指向pre对应的节点；设置当前节点的后继节点需要继续遍历到下一个节点（此时node指向了下一个遍历的节点，pre指向了当前节点）让pre对应节点（当前节点）的右指针指向node对应的节点</strong>。</p></li><li><p>中序线索二叉树示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221112122030580.png" alt="image-20221112122030580"></p><p>说明：当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况:</p><ol><li>left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点。</li><li>right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向的是后继节点。</li></ol></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  ```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 遍历线索化二叉树</span><br><span class="line"></span><br><span class="line">- 因为**线索化后，各个结点指向有变化，因此原来的遍历方式不能使用**，这时需要使用新的方式遍历线索化二叉树，各个节点**可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率**。 遍历的次序应当和线索化所用的遍历次序保持一致。</span><br><span class="line"></span><br><span class="line">- 代码示例：</span><br><span class="line"></span><br><span class="line">  ```java</span><br></pre></td></tr></table></figure></li></ul><h2 id="二叉排序-查找-树"><a href="#二叉排序-查找-树" class="headerlink" title="二叉排序(查找)树"></a>二叉排序(查找)树</h2><h3 id="先看一个需求"><a href="#先看一个需求" class="headerlink" title="先看一个需求"></a>先看一个需求</h3><ul><li>给你一个数列 (7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加</li></ul><h3 id="解决方案分析"><a href="#解决方案分析" class="headerlink" title="解决方案分析"></a>解决方案分析</h3><ul><li>使用数组：<ul><li>数组未排序：优点：接在数组尾添加，速度快。 缺点：查找速度慢。</li><li>数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。</li></ul></li><li>使用链式存储-链表：不管链表是否有序，查找速度都慢；添加数据速度比数组快，不需要数据整体移动。</li><li>使用二叉排序树：既可以保证较快的查找速度，也可以保证较高的插入效率。</li></ul><h3 id="二叉排序树介绍"><a href="#二叉排序树介绍" class="headerlink" title="二叉排序树介绍"></a>二叉排序树介绍</h3><ul><li><p><strong>二叉排序树：BST (Binary Sort(Search) Tree)</strong>, 对于二叉排序树的任何一个非叶子节点，<strong>要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大</strong>。从更宏观的角度来看，<strong>任何一个非叶子节点的左子树的所有值都比该节点小，右子树的所有值都比该节点大</strong>。</p></li><li><p>特别说明：<strong>如果有相同的值，可以将和父节点相同的节点放在左子节点或右子节点都可以</strong>。</p></li><li><p>针对前面的数据(7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113092545691.png" alt="image-20221113092545691"></p></li></ul><h3 id="二叉排序树的创建和插入节点"><a href="#二叉排序树的创建和插入节点" class="headerlink" title="二叉排序树的创建和插入节点"></a>二叉排序树的创建和插入节点</h3><ul><li><p>二叉排序树创建的时候，<strong>对于每个要插入的节点，都要先和根节点比较，比根节点小的话就往左走，比根节点大的话就往右走，然后继续和左子节点或者右子节点比较，重复上述操作直到找到空位置进行插入</strong>。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  ```</span><br><span class="line"></span><br><span class="line">### 二叉排序树查找节点</span><br><span class="line"></span><br><span class="line">- **从根节点开始，如果要查找的节点比当前节点要小，就向左找；如果要查找的节点比当前节点要大，就向右找，重复上述操作直到找到或者没找到**。没啥好说的</span><br><span class="line"></span><br><span class="line">- 代码示例：</span><br><span class="line"></span><br><span class="line">  ```java</span><br></pre></td></tr></table></figure></li></ul><h3 id="二叉排序树删除节点"><a href="#二叉排序树删除节点" class="headerlink" title="二叉排序树删除节点"></a>二叉排序树删除节点</h3><ul><li><p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑（以上面的数据为例）：</p><ol><li>删除叶子节点 (比如：2, 5, 9, 12)</li><li>删除只有一颗子树的节点 (比如：1)</li><li>删除有两颗子树的节点. (比如：7, 3，10 )</li></ol></li><li><p><strong>删除叶子节点的时候，只需要将其父节点对应的指针置空即可</strong>，没什么好说的；</p></li><li><p><strong>删除只有一颗子树的节点的时候，将其父节点的对应指针指向该节点的子节点即可</strong>，也就是要保证该节点的子树不会随着该节点的删除而丢失；</p></li><li><p><strong>删除有两棵子树的节点的时候</strong>，这种情况比较复杂但也比较巧妙，我们<strong>需要找到该节点的左子树的最大的节点或者右子树最小的节点，将找到的符合条件的节点的值赋值给该节点，然后对找到的那个符合条件的那个节点执行删除操作。由于找到的那个节点是左&#x2F;右子树的最值，根据二叉排序树的特性，它一定是叶节点，所以根据叶节点的删除方式对其删除即可</strong>。感慨一句，真是挺巧妙的，把删除非叶节点转换成了删除叶节点同时还保证了二叉排序树的结构。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h2 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h2><ul><li><strong>平衡二叉树本身就是一种特殊的二叉排序树，它身上有二叉排序树的所有特性</strong>。</li></ul><h3 id="通过一个案例来认识二叉排序树可能存在的问题"><a href="#通过一个案例来认识二叉排序树可能存在的问题" class="headerlink" title="通过一个案例来认识二叉排序树可能存在的问题"></a>通过一个案例来认识二叉排序树可能存在的问题</h3><ul><li>给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在。</li><li>如果让1作为根节点的话，后面所有的元素依次递增，也就是说后面的每一个元素都会是前一个元素的右子节点，这样的一颗<strong>二叉排序树实际上就退化成链表了，查询速度明显降低</strong>，数据一旦大起来，这样的性能折损显然是我们不能接受的。</li><li>就算不是上面这种非常极端的情况，平常也会出现<strong>二叉排序树的其中某些路径的深度很深的情况，那么查询这个路径上的节点的时候效率就会较低</strong>。</li><li>鉴于上面这种情况的存在，我们需要使用平衡二叉树来解决这种问题。</li></ul><h3 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul><li><p>平衡二叉树也叫<strong>平衡二叉搜索树（Self-balancing binary search tree）</strong>又被称为 AVL 树， 可以<strong>保证查询效率较高</strong>。</p></li><li><p>平衡二叉树具有以下特点：<strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树</strong>。平衡二叉树的常用实现方法有<strong>红黑树、AVL、替罪羊树、Treap、伸展树等</strong>。</p></li><li><p>平衡二叉树举例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113103456817.png" alt="image-20221113103456817"></p><p>最右边的二叉树不是平衡二叉树，因为根节点的左右子树的高度差为2（一个是2一个是0），大于1，不符合平衡二叉树的定义。</p></li></ul><h3 id="平衡二叉树左旋转"><a href="#平衡二叉树左旋转" class="headerlink" title="平衡二叉树左旋转"></a>平衡二叉树左旋转</h3><ul><li><p>如果要是<strong>树的最右路径（一直往右走）长度过长的话，我们就需要对整棵树进行左旋转来尝试将最右路径的长度变短</strong>。</p></li><li><p>由于在创建和维护平衡二叉树的时候，每次插入一个新的节点都会触发判断平衡二叉树是否需要进行旋转，所以<strong>最多会出现高度差为2的不平衡</strong>，所以只需要针对这种情况设计旋转的过程即可。</p></li><li><p>左旋转通过<strong>将最右路径的高度分一个单位给最左路径来将最右路径的高度降低</strong>，这种方式通常通过将根节点分到左边，将根节点的右子节点提升为根节点来实现。</p></li><li><p>具体步骤就是：<strong>创建一个新节点，值等于根节点的右节点的值，新节点的左指针指向根节点，右指针指向根节点的右节点的右节点，然后让根节点的右节点指向根节点的右节点的左节点</strong>。</p></li><li><p>上面的操作实际上就是<strong>让新节点替代了根节点的右节点变成了整个树的根节点，根节点的右节点由于失去引用被回收了，从整体上看就相当于最右路径向左转了一下</strong>，由于二叉排序树的性质，根节点的右节点的左子树的所有值肯定是比根节点的右节点的值要小的，那么根节点的右节点提升为根节点的话，根节点的右节点的左子树肯定要放到提升为根节点的那个节点的左边，同时由于二叉排序树的性质，根节点的右节点的左子树的所有值肯定比原来的根节点的值要大，原来的根节点降低为新根节点的左节点，同时空闲出来了右指针，所以可以把原根节点的右节点的左子树放到平衡后的原根节点的右指针上。</p></li><li><p>思路分析图解：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113111118855.png" alt="image-20221113111118855"></p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h3 id="平衡二叉树右旋转"><a href="#平衡二叉树右旋转" class="headerlink" title="平衡二叉树右旋转"></a>平衡二叉树右旋转</h3><ul><li><p>如果要是<strong>树的最左路径（一直往左走）长度过长的话，我们就需要对整棵树进行右旋转来尝试将最左路径的长度变短</strong>。</p></li><li><p>由于在创建和维护平衡二叉树的时候，每次插入一个新的节点都会触发判断平衡二叉树是否需要进行旋转，所以<strong>最多会出现高度差为2的不平衡</strong>，所以只需要针对这种情况设计旋转的过程即可。</p></li><li><p>右旋转通过<strong>将最左路径的高度分一个单位给最右路径来将最左路径的高度降低</strong>，这种方式通常通过将根节点分到右边，将根节点的左子节点提升为根节点来实现。</p></li><li><p>具体步骤就是：<strong>创建一个新节点，值等于根节点的左节点的值，新节点的右指针指向根节点，左指针指向根节点的左节点的左节点，然后让根节点的左节点指向根节点的左节点的右节点</strong>。</p></li><li><p>上面的操作实际上就是<strong>让新节点替代了根节点的左节点变成了整个树的根节点，根节点的左节点由于失去引用被回收了，从整体上看就相当于最左路径向右转了一下</strong>，由于二叉排序树的性质，根节点的左节点的右子树的所有值肯定是比根节点的左节点的值要大的，那么根节点的左节点提升为根节点的话，根节点的左节点的右子树肯定要放到提升为根节点的那个节点的右边，同时由于二叉排序树的性质，根节点的左节点的右子树的所有值肯定比原来的根节点的值要小，原来的根节点降低为新根节点的右节点，同时空闲出来了左指针，所以可以把原根节点的左节点的右子树放到平衡后的原根节点的左指针上。</p></li><li><p>思路分析图解：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113111357063.png" alt="image-20221113111357063"></p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h3 id="平衡二叉树双旋转"><a href="#平衡二叉树双旋转" class="headerlink" title="平衡二叉树双旋转"></a>平衡二叉树双旋转</h3><ul><li><p>如果要是<strong>树的非最左最右路径过长的话，单用一次或右旋转或左旋转无法将树调整为平衡二叉树</strong>，这种时候就需要使用双旋转，核心思路就是<strong>先把长出来的部分转移到最左或者最右路径上，这一步通常需要一个旋转操作来实现，然后再进行左旋转或者右旋转</strong>。</p></li><li><p><strong>当根节点左子树的高度大于右子树且高度差大于1的时候，理应发生右旋转</strong>，但是<strong>如果根节点的左子树的右子树的高度大于根节点的左子树的左子树，一次右旋转无法将其调整为平衡二叉树</strong>，这时我们就需要<strong>先对根节点的左子树做一次左旋转，将高出来的高度旋转到最左路径上，然后就可以通过右旋转进行调整了</strong>。</p></li><li><p><strong>当根节点右子树的高度大于左子树且高度差大于1的时候，理应发生左旋转</strong>，但是<strong>如果根节点的右子树的左子树的高度大于根节点的右子树的右子树，一次左旋转无法将其调整为平衡二叉树</strong>，这时我们就需要<strong>先对根节点的右子树做一次右旋转，将高出来的高度旋转到最右路径上，然后就可以通过左旋转进行调整了</strong>。</p></li><li><p>思路分析图解：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113113223559.png" alt="image-20221113113223559"></p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h1 id="数据结构-多路查找树"><a href="#数据结构-多路查找树" class="headerlink" title="数据结构-多路查找树"></a>数据结构-多路查找树</h1><h2 id="多叉树与B树"><a href="#多叉树与B树" class="headerlink" title="多叉树与B树"></a>多叉树与B树</h2><h3 id="二叉树的问题分析"><a href="#二叉树的问题分析" class="headerlink" title="二叉树的问题分析"></a>二叉树的问题分析</h3><ul><li><p>二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113114141432.png" alt="image-20221113114141432"></p></li><li><p>二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如 1 亿)， 就存在如下问题：</p><ol><li>在构建二叉树时，需要多次进行 i&#x2F;o 操作(海量数据存在数据库或文件中)，<strong>节点海量，构建二叉树时，对速度有影响</strong>。</li><li><strong>节点海量，也会造成二叉树的高度很大，会降低操作速度</strong>。</li></ol></li></ul><h3 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h3><ul><li><p>在二叉树中，每个节点有数据项，最多有两个子节点。<strong>如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）</strong>。</p></li><li><p>后面我们讲解的 2-3 树，2-3-4 树就是多叉树，<strong>多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化</strong>。</p></li><li><p>多叉树示例（下面的2-3树就是一棵多叉树）：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113114500386.png" alt="image-20221113114500386"></p></li></ul><h3 id="B树的基本介绍"><a href="#B树的基本介绍" class="headerlink" title="B树的基本介绍"></a>B树的基本介绍</h3><ul><li><p>B树<strong>通过重新组织节点，降低树的高度，并且通过减少I&#x2F;O读写次数来提升效率</strong>。</p></li><li><p>B树示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113114712207.png" alt="image-20221113114712207"></p></li><li><p>如图<strong>B树通过重新组织节点，降低了树的高度</strong>。</p></li><li><p><strong>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页（页的大小通常为4k），这样每个节点只需要一次I&#x2F;O就可以完全载入</strong>。</p></li><li><p>将树的度 M 设置为 1024，在 600 亿个元素中最多只需要 4 次 I&#x2F;O 操作就可以读取到想要的元素, <strong>B 树(B+)广泛应用于文件存储系统以及数据库系统中</strong>。</p></li><li><p>B树是个相对抽象的概念，2-3树、2-3-4树都是B树的一种实现。</p></li></ul><h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><h3 id="2-3树是最简单的B树结构"><a href="#2-3树是最简单的B树结构" class="headerlink" title="2-3树是最简单的B树结构"></a>2-3树是最简单的B树结构</h3><ul><li>2-3树具有如下特点：<ol><li>2-3 树的<strong>所有叶子节点都在同一层.(只要是 B 树都满足这个条件)</strong></li><li><strong>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点</strong>.</li><li><strong>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</strong>.</li><li>2-3 树是<strong>由二节点和三节点构成</strong>的树。</li></ol></li></ul><h3 id="2-3树应用案例"><a href="#2-3树应用案例" class="headerlink" title="2-3树应用案例"></a>2-3树应用案例</h3><ul><li><p>将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成 2-3 树，并保证数据插入的大小顺序：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114090342074.png" alt="image-20221114090342074"></p></li></ul><h3 id="2-3树节点插入规则"><a href="#2-3树节点插入规则" class="headerlink" title="2-3树节点插入规则"></a>2-3树节点插入规则</h3><ol><li>2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件)</li><li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li><li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</li><li>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，<strong>先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面 3 个条件</strong>。</li><li><strong>对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则，除此之外，三节点内部的两个元素也应该是有序的</strong>。</li></ol><h3 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h3><ul><li><p>除了 23 树，还有 234 树等，概念和 23 树类似，也是一种 B 树。 如图:</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114092600003.png" alt="image-20221114092600003"></p></li></ul><h2 id="B树、B-树和B-树"><a href="#B树、B-树和B-树" class="headerlink" title="B树、B+树和B*树"></a>B树、B+树和B*树</h2><h3 id="B树的介绍"><a href="#B树的介绍" class="headerlink" title="B树的介绍"></a>B树的介绍</h3><ul><li><p><strong>B-tree 树即 B 树，B 即 Balanced，平衡的意思</strong>。有人把 B-tree 翻译成 B-树，容易让人产生误解。会以为 B-树是一种树，而 B 树又是另一种树。实际上，<strong>B-tree 就是指的 B 树</strong>。</p></li><li><p>前面已经介绍了 2-3 树和 2-3-4 树，他们就是 B 树(英语：B-tree 也写成 B-树)，这里我们再做一个说明，我们在学习 Mysql 时，经常听到说某种类型的索引是基于 B 树或者 B+树的，如图:</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114092747019.png" alt="image-20221114092747019"></p></li><li><p>对B树的说明：</p><ol><li><strong>B树的阶：节点的最多子节点个数</strong>。比如 2-3 树的阶是 3，2-3-4 树的阶是 4</li><li>B-树的搜索，<strong>从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</strong>。</li><li>关键字集合分布在整颗树中, 即<strong>叶子节点和非叶子节点都存放数据</strong>。</li><li><strong>搜索有可能在非叶子结点结束</strong></li><li>其<strong>搜索性能等价于在关键字全集内做一次二分查找</strong></li></ol></li></ul><h3 id="B-树的介绍"><a href="#B-树的介绍" class="headerlink" title="B+树的介绍"></a>B+树的介绍</h3><ul><li><p>B+树是B树的变体，也是一种多路搜索树：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114093141034.png" alt="image-20221114093141034"></p></li><li><p>对B+树的说明：</p><ol><li>B+树的搜索与 B 树也基本相同，区别是<strong>B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</strong>。</li><li><strong>所有关键字都出现在叶子结点的链表中</strong>（即<strong>数据只能在叶子节点</strong>【也叫<strong>稠密索引</strong>】），且<strong>链表中的关键字(数据)恰好是有序的</strong>。</li><li><strong>不可能在非叶子结点命中</strong></li><li><strong>非叶子结点相当于是叶子结点的索引（稀疏索引）</strong>，<strong>叶子结点相当于是存储（关键字）数据的数据层</strong></li><li>更<strong>适合文件索引系统</strong></li><li>B 树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.</li></ol></li></ul><h3 id="B-树的介绍-1"><a href="#B-树的介绍-1" class="headerlink" title="B*树的介绍"></a>B*树的介绍</h3><ul><li><p>B*树是 B+树的变体，<strong>在B+树的非根和非叶子结点再增加指向兄弟的指针</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114093538855.png" alt="image-20221114093538855"></p></li><li><p>对B*树的说明：</p><ol><li>B*树定义了<strong>非叶子结点关键字个数至少为(2&#x2F;3)*M</strong>，即<strong>块的最低使用率为 2&#x2F;3</strong>，而<strong>B+树的块的最低使用率为的1&#x2F;2</strong>。</li><li>从第 1 个特点我们可以看出，<strong>B*树分配新结点的概率比B+树要低，空间使用率更高</strong>。</li></ol></li></ul><h1 id="数据结构-并查集"><a href="#数据结构-并查集" class="headerlink" title="数据结构-并查集"></a>数据结构-并查集</h1><h2 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li>并查集作为一种简洁而优雅的树形数据结构，主要用于解决一些<strong>元素分组</strong>的问题，它<strong>管理着一系列不相交的集合</strong>，并支持两种操作：<ol><li><strong>合并（Union）</strong>：把两个不相交的集合合并为一个集合。</li><li><strong>查询（Find）</strong>：查询两个元素是否在同一个集合中。</li></ol></li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li><p>在最基础的应用中，抽象后的点集都是按顺序的数字，此时我们只<strong>需要一个一维数组f来表示元素之间的关系</strong>，如果<strong>f[i]&#x3D;j说明i的父节点是j</strong>，那么它们肯定有相同的根节点，也就是说明i和j是属于同一组的，在这个一维数组中，<strong>两者拥有相同根节点的元素都是属于同一组的</strong>。</p></li><li><p>对于一维数组f的初始化，应该<strong>把每个元素的值初始化成它的下标，表示刚开始的时候所有元素彼此独立</strong>，互相之间没有从属关系，所以<strong>如果后面出现一个元素的值为它的下标，说明它是独立的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//并查集数组,f[i]=j说明i的父亲节点是j</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化每个节点都是独立的，即他们的father都是自己</span></span><br><span class="line">    f[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>首先来看<strong>查询（Find）操作</strong>，这个操作的最终目的是查询两个元素是否在同一个集合中，那么我们不妨<strong>把这个操作的粒度降低，让每次Find操作都查询一个元素的根节点，这样可以在后续编码时带来更高的灵活性</strong>，判定两个元素是否同一组就是判断两个元素的根节点是否相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] f,<span class="type">int</span> v)</span>&#123;<span class="comment">//找一个元素的根节点</span></span><br><span class="line">        <span class="keyword">return</span> f[v]==v?v:(f[v] = find(f,f[v]));<span class="comment">//如果该点独立，直接返回;如果该点不独立,往后找根节点，顺便进行路径压缩</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们<strong>通过递归去找元素对应的根节点</strong>，实际上<strong>在递归的过程中做了一个路径压缩的优化</strong>，路径压缩就是说<strong>把递归过程中经过的所有节点的父节点都变成它们的根节点，这样做可以使后面再次查找这条递归链上元素根节点的时间复杂度降低，由于递归过程中经过的节点拥有相同的根节点，所以保证了该操作的正确性</strong>。</p></li><li><p>再来看<strong>合并（Union）操作</strong>，这个操作的目的是<strong>如果两个元素本来不是同一组的，那么就将两个元素合并到同一组中</strong>，反映到数据结构上就是让一个元素变成另外一个元素的父亲。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] f,<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;<span class="comment">//合并操作，其中可以做优化：直接把两者的根节点合并</span></span><br><span class="line">        <span class="keyword">return</span> (u = find(f,u))==(v = find(f,v))?<span class="literal">false</span>:(f[v]=u)==u;<span class="comment">//先找到各自的根，然后比较，如果相同说明已经合并无需再合并，返回false；如果不相同就合并，返回true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>本来是让其中一个元素的根节点合并到另外一个元素上面的，但是上面的代码中也做了一个优化，那就是<strong>直接把两者的根节点合并，可以缩短递归链的长度，优化时间复杂度</strong>。</p></li></ul><h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><ul><li><p>如果我们把并查集的元素都拿出来，然后用有向边从子元素连接到父元素来表示他们之间的父子关系，那么我们得到一个有向图，在上面的并查集中，有向边是没有权值的，它仅表示一种关系。但是<strong>在带权并查集中，元素和元素之间的有向边是有权值的，所以带权并查集除了有一个维护元素的父元素的数组之外，还有一个维护元素和父元素之间的有向边的权值的数组，具体这个权值的定义需要结合具体情况进行定义</strong>。</p></li><li><p>带权并查集的其中一个<strong>难点在于如何在进行路径压缩的时候正确维护权值数组</strong>，因为进行路径压缩的时候，节点之间的关系会进行改变，所以大部分情况下我们需要根据具体情况来判断如何正确维护权值数组才能使得权值数组是有效的。</p></li><li><p>如果我们想将一个非线性结构的元素放到并查集中怎么办？可以<strong>维护一个map来做元素和并查集数组下标的映射</strong>。</p></li><li><p>在思考如何正确维护权值数组的时候，可以<strong>将并查集当成一个有向图，用纸笔进行推导，这样比较容易得出结论</strong>。</p></li><li><p>代码示例，下面这个题维护权值数组的方式可以看官方题解，是有推导的：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230127104534916.png" alt="image-20230127104534916"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="type">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">equationSize</span> <span class="operator">=</span> equations.size();</span><br><span class="line">        <span class="comment">//并查集的大小开两倍的equationSize是因为在最极端的情况下，equation中所有元素都不同，所以这里考虑的是上界</span></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">unionFind</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(<span class="number">2</span>*equationSize);</span><br><span class="line">        <span class="comment">//由于并查集的底层是用数组实现的，所以需要这个map用于映射不同的元素在并查集中的数组中的位置</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//在并查集数组中的位置从0开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;equationSize;++i)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> equations.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> equations.get(i).get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//将其中以前没有加入并查集的元素加入并查集，体现在把元素映射到并查集数组的下标上</span></span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(s1))&#123;</span><br><span class="line">                map.put(s1,id++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(s2))&#123;</span><br><span class="line">                map.put(s2,id++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//两个元素在一组中，我们需要用并查集维护他们的关系和权值，这个权值就是子元素/父元素的值</span></span><br><span class="line">            unionFind.union(map.get(s1),map.get(s2),values[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">queriesSize</span> <span class="operator">=</span> queries.size();</span><br><span class="line">        <span class="type">double</span>[] ans = <span class="keyword">new</span> <span class="title class_">double</span>[queriesSize];<span class="comment">//答案数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;queriesSize;++i)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> queries.get(i).get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//获取两个元素在并查集中的位置</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">id1</span> <span class="operator">=</span> map.get(s1);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">id2</span> <span class="operator">=</span> map.get(s2);</span><br><span class="line">            <span class="keyword">if</span>(id1==<span class="literal">null</span>||id2==<span class="literal">null</span>)&#123;<span class="comment">//如果两个元素中任何一个元素在并查集中不存在，那么答案都是无法计算的，返回-1.0d</span></span><br><span class="line">                ans[i] = -<span class="number">1.0d</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果两个元素都在并查集中存在，那么我们可以直接从并查集中获取答案</span></span><br><span class="line">                ans[i] = unionFind.getAns(id1,id2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;<span class="comment">//带权并查集</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] parent;<span class="comment">//维护父子关系</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">double</span>[] weight;<span class="comment">//维护当前元素指向其父节点的权值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="built_in">this</span>.weight = <span class="keyword">new</span> <span class="title class_">double</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) &#123;<span class="comment">//初始化父子关系数组，每个元素的父亲先设置成是自己，针对这题，权值的意思是子元素除以父元素所以权值都先初始化为1</span></span><br><span class="line">                parent[i] = i;</span><br><span class="line">                weight[i] = <span class="number">1.0d</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">double</span> value)</span>&#123;<span class="comment">//并查集的合并操作</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);<span class="comment">//找x的根节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);<span class="comment">//找y的根节点</span></span><br><span class="line">            <span class="keyword">if</span>(rootX!=rootY)&#123;<span class="comment">//如果x和y的根节点不相同，说明我们可以进行合并操作，如果相同说明他们已经合并过了，不用再合并了</span></span><br><span class="line">                parent[rootX] = rootY;<span class="comment">//将x的根节点的父亲设置为y的根节点</span></span><br><span class="line">                weight[rootX] = weight[y]*value/weight[x];<span class="comment">//维护并查集的权值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;<span class="comment">//并查集的查操作</span></span><br><span class="line">            <span class="keyword">if</span>(x != parent[x])&#123;<span class="comment">//如果当前元素的父亲不是自己，那么就要找当前元素的根节点顺便进行路径压缩</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">origin</span> <span class="operator">=</span> parent[x];<span class="comment">//先记录下当前元素的父节点，因为之后的路径压缩会改变当前元素的父节点</span></span><br><span class="line">                parent[x] = find(parent[x]);<span class="comment">//路径压缩</span></span><br><span class="line">                weight[x] *= weight[origin];<span class="comment">//维护被压缩的路径上的权值，从下面压缩上去的权值是路径中的权值之积</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAns</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;<span class="comment">//得到x/y的答案</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);<span class="comment">//找到x的根节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);<span class="comment">//找到y的根节点</span></span><br><span class="line">            <span class="keyword">if</span>(rootX == rootY)&#123;<span class="comment">//如果x和y的根节点相同，说明可以通过下面这个式子得到答案</span></span><br><span class="line">                <span class="keyword">return</span> weight[x]/weight[y];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果x和y的根节点不相同，那么说明我们无法通过给的条件得到答案，返回-1.0d</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1.0d</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="数据结构-稀疏数组（Sparsearray）"><a href="#数据结构-稀疏数组（Sparsearray）" class="headerlink" title="数据结构-稀疏数组（Sparsearray）"></a>数据结构-稀疏数组（Sparsearray）</h1><h2 id="需求场景示例"><a href="#需求场景示例" class="headerlink" title="需求场景示例"></a>需求场景示例</h2><ul><li><p>编写一个五子棋程序，有存盘退出的功能和续上盘的功能。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031201730800.png" alt="image-20221031201730800"></p></li><li><p>问题分析：要想实现这些功能，就需要对棋局进行持久化，而大部分情况下棋局对应的二维数组都是比较稀疏的，因此有很多没有意义的数据，这些没有意义的数据如果做持久化，就会对空间产生额外的消耗，因此为了应对这种情况，我们<strong>可以使用稀疏数组来对数组进行存储，在特定情况下使用可以减少空间的开销</strong>。</p></li></ul><h2 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p></li><li><p>稀疏数组的处理方法是:</p><ol><li>在稀疏数组的<strong>第一个元素中存放原数组的行数、列数、元素数</strong>。</li><li>在稀疏数组<strong>除了第一个元素后面的每一个空间中记录原数组的一个元素所在的行数、列数和值</strong>。</li></ol></li><li><p>稀疏数组举例说明：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031202328310.png" alt="image-20221031202328310"></p></li></ul><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><ul><li><p>使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)</p></li><li><p>把稀疏数组存盘，并且可以重新恢复原来的二维数组。</p></li><li><p>整体思路分析：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031202449600.png" alt="image-20221031202449600"></p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.sparsearray;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// 创建一个原始的二维数组 11 * 11</span></span><br><span class="line"><span class="comment">// 0: 表示没有棋子， 1 表示 黑子 2 表蓝子</span></span><br><span class="line"><span class="type">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">chessArr1[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 输出原始的二维数组</span></span><br><span class="line">System.out.println(<span class="string">&quot;原始的二维数组~~&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr1) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将二维数组 转 稀疏数组的思</span></span><br><span class="line"><span class="comment">// 1. 先遍历二维数组 得到非 0 数据的个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 创建对应的稀疏数组</span></span><br><span class="line"><span class="type">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 给稀疏数组赋值</span></span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"><span class="comment">// 遍历二维数组，将非 0 的值存放到 sparseArr 中</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//count 用于记录是第几个非 0 数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出稀疏数组的形式</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;得到稀疏数组为~~~~&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;%d\t%d\t%d\t\n&quot;</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//将稀疏数组 --》 恢复成 原始的二维数组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2 = int[11][11]</span></span><br><span class="line"><span class="comment">   2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line"><span class="type">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"><span class="comment">//2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;恢复后的二维数组&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr2) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line">System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="数据结构-单调队列（Monotone-Queue）"><a href="#数据结构-单调队列（Monotone-Queue）" class="headerlink" title="数据结构-单调队列（Monotone Queue）"></a>数据结构-单调队列（Monotone Queue）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>通过一道题来引出这个数据结构：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221222203612061.png" alt="image-20221222203612061"></p></li><li><p>上面这个题呢，在解决的过程中我们就非常可以体会到单调队列的原理、适用场景以及实现单调队列的底层逻辑，所以很适合用来入门单调队列。</p></li><li><p>单调队列通常和滑动窗口结合来解决一些最值问题。</p></li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>顾名思义，单调队列，队列不是关键，单调才是关键，<strong>单调意味着队列中的数字排列是非上升或非下降的</strong>，除了这个特性之外，别的和普通的队列别无二致。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>单调队列<strong>一般都是用双端队列实现</strong>（下面以不递增的单调队列为例，不递减的反过来就行），每次向单调队列中push元素的时候都要从后面开始依次让小于该元素的元素出队，直到队尾元素大于等于该元素，此时才能将该元素push进去，这样做的目的是为了维持队列的单调性。</li><li>别的操作就和普通的双端队列一样了。</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>那么我们知道了单调队列的定义和实现之后，我们应该如何去应用它呢，这时我们回看上面的那个题，题目要求三个操作的均摊复杂度是O(1)，那么我们可以考虑维护一个单调队列，<strong>每次向普通队列中添加元素，就对应着也给单调队列添加相同的元素</strong>，<strong>单调队列通过相应的操作来调整自身以满足“单调”的条件</strong>，在<strong>查找最大值的时候实际上只要把单调队列的队首元素返回即可，因为它是单调的</strong>，如果我们规定它的规则是不递增，那么队首元素就是普通队列中的最大值。在<strong>做元素出队操作的时候，除了要让普通队列的元素出队之外还应该判断一下单调队列是否满足元素出队的条件</strong>，如果出队的元素正好是单调队列的队首元素，这说明普通队列的这个元素出队后，最大值不一定还是这个值了，这个时候单调队列队首的元素就应该出队，防止错误的最值影响到普通队列后面的元素。</li><li>为什么像上面那样做可以解决问题呢，因为<strong>每当普通队列push元素的时候，这个元素很有可能对某个长度的队列的最大值有影响，而且这个影响一直持续到第一个大于等于它的那个地方</strong>，比如6，1，2，3这个队列，如果我要向其中push一个4，这个4虽然对当前的最大值没有影响，但是它会对6pop之后的队列的最大值产生影响，这个影响是一直延续到第一个大于等于4的值也就是6那里的，在6之前，队列的最大值不受4的影响，但是在6没了之后的队列最大值就会受4的影响，所以单调队列插入4的时候会将3，2，1从后面pop掉，目的就是为了让4这个部分队列的最大值影响到它该影响到的地方，这样6pop掉后，单调队列的6肯定也pop掉了，此时求最大值，我们只需要将队列中的新首部4返回即可，如果要pop1，那千万别把单调队列中的4pop掉，因为4还会对pop掉1之后的队列产生影响，但是注意这个影响的也不是后面全部的队列，如果要是普通队列pop到了4，那么单调队列就应该将4pop掉，防止4影响到再后面的队列。</li></ul><h2 id="代码示例-24"><a href="#代码示例-24" class="headerlink" title="代码示例"></a>代码示例</h2><ul><li><p>就是上面那个题的代码，可以用来理解单调队列的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; qu = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//普通队列</span></span><br><span class="line">    Deque&lt;Integer&gt; monotoneQu = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//单调队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxQueue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max_value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(qu.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> monotoneQu.getFirst();<span class="comment">//求最大值可以直接返回单调队列的头</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        qu.addLast(value);</span><br><span class="line">        <span class="keyword">while</span> (!monotoneQu.isEmpty()&amp;&amp;monotoneQu.getLast()&lt;value)&#123;<span class="comment">//向单调队列中添加元素的时候要让队列尾部不满足单调条件的元素从尾部出队直到将目标元素入队后队列是单调的或者队列为空，然后再将目标元素入队</span></span><br><span class="line">            monotoneQu.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        monotoneQu.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(qu.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>((<span class="type">int</span>)qu.getFirst()==(<span class="type">int</span>)monotoneQu.getFirst())&#123;<span class="comment">//如果要是普通队列中要pop的元素和单调队列的头相同，说明这个元素的影响力已经到尽头了，它无权影响后面的队列了，所以要随着普通队列一起pop掉；但是如果要是普通队列要pop的元素和单调队列的头不同，说明单调队列的头元素的影响力还能再存在一段时间，这种情况下就不用pop单调队列。</span></span><br><span class="line">            monotoneQu.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> qu.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.max_value();</span></span><br><span class="line"><span class="comment"> * obj.push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p>还有另外一个结合了滑动窗口的题，把那个的代码也放这儿吧：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221222214301014.png" alt="image-20221222214301014"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="literal">null</span>||nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=k-<span class="number">1</span>;<span class="comment">//滑动窗口的左右指针</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length-k+<span class="number">1</span>];<span class="comment">//答案数组</span></span><br><span class="line">        Deque&lt;Integer&gt; monotone = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//单调队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;++i)&#123;<span class="comment">//先把第一个窗口预处理掉</span></span><br><span class="line">            <span class="comment">//还是单调队列添加元素的流程</span></span><br><span class="line">            <span class="keyword">while</span> (!monotone.isEmpty()&amp;&amp;monotone.getLast()&lt;nums[i]) monotone.removeLast();</span><br><span class="line">            monotone.addLast(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//答案数组的索引</span></span><br><span class="line">        <span class="comment">//处理第一个答案值</span></span><br><span class="line">        <span class="keyword">if</span>(nums[left]==monotone.getFirst()) ans[idx++] = monotone.removeFirst();</span><br><span class="line">        <span class="keyword">else</span> ans[idx++] = monotone.getFirst();</span><br><span class="line">        <span class="keyword">while</span> (right+<span class="number">1</span>&lt;nums.length)&#123;<span class="comment">//滑动窗口</span></span><br><span class="line">            right++;<span class="comment">//窗口右端点右滑</span></span><br><span class="line">            <span class="comment">//还是单调队列添加元素的流程</span></span><br><span class="line">            <span class="keyword">while</span> (!monotone.isEmpty()&amp;&amp;monotone.getLast()&lt;nums[right]) monotone.removeLast();</span><br><span class="line">            monotone.addLast(nums[right]);</span><br><span class="line">            left++;<span class="comment">//窗口左端点右滑</span></span><br><span class="line">            <span class="comment">//窗口更新，更新答案数组</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left]==monotone.getFirst()) ans[idx++] = monotone.removeFirst();</span><br><span class="line">            <span class="keyword">else</span> ans[idx++] = monotone.getFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="数据结构-单调栈（Monotone-Stack）"><a href="#数据结构-单调栈（Monotone-Stack）" class="headerlink" title="数据结构-单调栈（Monotone Stack）"></a>数据结构-单调栈（Monotone Stack）</h1><h1 id="数据结构-优先队列（Priority-Queue）"><a href="#数据结构-优先队列（Priority-Queue）" class="headerlink" title="数据结构-优先队列（Priority Queue）"></a>数据结构-优先队列（Priority Queue）</h1><h1 id="数据结构-前缀树（Trie）"><a href="#数据结构-前缀树（Trie）" class="headerlink" title="数据结构-前缀树（Trie）"></a>数据结构-前缀树（Trie）</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul><li>是一种搜索引擎（比如baidu、google）、数据检索引擎（比如elasticsearch等）经常使用的数据结构，可以大大优化检索数据的效率。</li><li>如果说要实现一个数据结构，能将word存放到其中，并且要能查找指定的word是否在那个数据结构中存在，并且还能查找指定的prefix也就是前缀是否在那个数据结构中存在，我们首先可以想到用数组来存放这些word，可是这样做有很多的问题，首先就是添加word的时候，由于数组在分配空间后长度是不可变的，所以在超出数组空间的情况下添加word是O(N)复杂度的，N是数组中的元素数量，这也是添加操作的最坏时间复杂度，平时就是O(1)；在检索word的时候，我们需要不断对比数组中的元素和word，这样如果有相同前缀的字符串，那么重复遍历前缀所造成的时间损耗是没必要的，检索prefix也是同理。</li><li>针对上面这些问题，我们可以将word存放在Trie中，其原理就是<strong>将所有的word的单个字符按照树形结构存储，前一个字符是后一个字符的父节点</strong>，这样我们就<strong>可以重复利用那些有着相同前缀的word的前缀所占的存储空间，而且在检索的时候也能优化掉判断重复前缀的时间</strong>。从这里也能看出来这个数据结构为啥叫前缀树，就是因为充分利用字符串的前缀在空间和时间上都做了优化，提升了数据检索的效率。</li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ul><li>要想实现Trie，<strong>首先就要定义它的节点类</strong>，节点类中应该包含：<ol><li><strong>该节点的值</strong>，可以用char类型来定义。</li><li><strong>该节点是否为某个word的结束节点</strong>，用这个属性来判断某个word是否在Trie中存在，可以用boolean类型来定义。</li><li><strong>该节点的子节点，可以用HashMap来定义</strong>，优化检索效率。</li><li>……</li></ol></li><li>定义完节点类，我们就可以<strong>定义Trie类</strong>了，Trie类包括：<ol><li>该<strong>Trie的根节点，根节点不存储数据</strong>，只是作为检索的root。</li><li><strong>插入word</strong>的方法，插入就是从root开始沿着已经有的字符节点往下找，没有的字符节点就new，有的就跳过，<strong>最后一个节点的isEnd属性要置为true</strong>。</li><li><strong>查找word</strong>的方法，就是从root开始沿着对应的字符往下找，<strong>直到找到最后一个字符，并且这个字符节点的isEnd应该为true</strong>，这点很重要，如果找到了最后一个节点，但是isEnd属性不为true，说明这个word不存在Trie中。</li><li><strong>查找prefix</strong>的方法，<strong>从root开始找，直到找到最后一个字符，不用判断isEnd的值</strong>，因为只是要找个前缀。</li><li>……</li></ol></li></ul><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><ul><li><p>LeetCode 208. 实现Trie(前缀树)：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230112103631899.png" alt="image-20230112103631899"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">char</span> val;<span class="comment">//前缀树节点的值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> isEnd;<span class="comment">//该节点是否是存储的某个单词的结尾，用这个属性来判断前缀树中是否存在某单词</span></span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Character,Node&gt; children;<span class="comment">//该节点的孩子节点，用hashmap提高检索效率。可以懒加载这个属性</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">char</span> val,<span class="type">boolean</span> isEnd)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.isEnd = isEnd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>((<span class="type">char</span>)<span class="number">0</span>,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.children!=<span class="literal">null</span> &amp;&amp; node.children.containsKey(word.charAt(i)))&#123;<span class="comment">//如果children存在并且其中存在目标字符</span></span><br><span class="line">                node = node.children.get(word.charAt(i));<span class="comment">//node直接到下一个节点</span></span><br><span class="line">                <span class="keyword">if</span>(i==word.length()-<span class="number">1</span>)&#123;<span class="comment">//如果当前是word的最后一个元素</span></span><br><span class="line">                    node.isEnd = <span class="literal">true</span>;<span class="comment">//那么让node的isEnd为true表示将该word存放进了trie中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果children为null或者其中不存在目标字符</span></span><br><span class="line">                <span class="keyword">if</span>(node.children==<span class="literal">null</span>) node.children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//如果children为空就new，这是懒加载的做法</span></span><br><span class="line">                <span class="comment">//向当前节点的子节点添加新的字符，顺便判断这个字符是不是word的最后一个字符，如果是就把isEnd置为true以表示将该word存放进了trie</span></span><br><span class="line">                node.children.put(word.charAt(i),<span class="keyword">new</span> <span class="title class_">Node</span>(word.charAt(i),i==word.length()-<span class="number">1</span>?<span class="literal">true</span>:<span class="literal">false</span>));</span><br><span class="line">                <span class="comment">//node到下一个节点</span></span><br><span class="line">                node = node.children.get(word.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.children!=<span class="literal">null</span> &amp;&amp; node.children.containsKey(word.charAt(i)))&#123;<span class="comment">//如果children存在并且其中存在目标字符</span></span><br><span class="line">                node = node.children.get(word.charAt(i));<span class="comment">//node向下走</span></span><br><span class="line">                <span class="keyword">if</span>(i==word.length()-<span class="number">1</span>)&#123;<span class="comment">//如果当前字符是最后一个字符，直接返回node.isEnd表示是否存在该word</span></span><br><span class="line">                    <span class="keyword">return</span> node.isEnd;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果children为null或者其中不存在目标字符</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//找不到返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//为了过编译</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prefix.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.children!=<span class="literal">null</span> &amp;&amp; node.children.containsKey(prefix.charAt(i)))&#123;<span class="comment">//如果children存在并且其中存在目标字符</span></span><br><span class="line">                node = node.children.get(prefix.charAt(i));<span class="comment">//node向下走</span></span><br><span class="line">                <span class="keyword">if</span>(i==prefix.length()-<span class="number">1</span>)&#123;<span class="comment">//如果当前字符是最后一个字符，直接返回true表示存在该prefix</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果children为null或者其中不存在目标字符</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//找不到返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//查找的过程没有返回说明不存在prefix</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p>todo</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h1&gt;&lt;h2 id=&quot;常用排序算法的总结和</summary>
      
    
    
    
    
    <category term="算法" scheme="https://konjacor.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="https://konjacor.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用操作</title>
    <link href="https://konjacor.github.io/2022/09/14/Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>https://konjacor.github.io/2022/09/14/Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</id>
    <published>2022-09-14T03:18:47.000Z</published>
    <updated>2022-12-20T12:11:43.197Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="解压目标到另外一个文件夹"><a href="#解压目标到另外一个文件夹" class="headerlink" title="解压目标到另外一个文件夹"></a>解压目标到另外一个文件夹</h2><ul><li><p><strong>tar -zxvf 文件名 -C 文件夹路径</strong>，一定要加-C来说明要解压到指定目录</p></li><li><p>示例：<strong>tar -zxvf redis-6.0.6.tar.gz -C ..&#x2F;redis</strong></p></li></ul><h2 id="永久关闭防火墙"><a href="#永久关闭防火墙" class="headerlink" title="永久关闭防火墙"></a>永久关闭防火墙</h2><ul><li><strong>systemctl disable firewalld</strong></li></ul><h2 id="查找含有某字符串的进程"><a href="#查找含有某字符串的进程" class="headerlink" title="查找含有某字符串的进程"></a>查找含有某字符串的进程</h2><ul><li><strong>ps -ef | grep redis</strong></li></ul><h2 id="CentOS中暂时修改gcc的版本"><a href="#CentOS中暂时修改gcc的版本" class="headerlink" title="CentOS中暂时修改gcc的版本"></a>CentOS中暂时修改gcc的版本</h2><ul><li><p>使用这个命令之前需要进行安装操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install centos-release-scl scl-utils-build #SCL(Software Collections)是一个CentOS/RHEL Linux平台的软件多版本共存解决方案，为RHEL/CentOS  Linux用户提供一种方便、安全地安装和使用应用程序和运行时环境的多个版本的方式，同时避免把系统搞乱。</span><br><span class="line">yum install -y devtoolset-8-toolchain #安装工具集</span><br></pre></td></tr></table></figure></li><li><p>然后使用<strong>scl enable devtoolset-8 bash</strong>会将gcc的版本暂时设置为8.*，在终端会话结束时恢复。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h1&gt;&lt;h2 id=&quot;解压目标到另外一个文</summary>
      
    
    
    
    
    <category term="linux" scheme="https://konjacor.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>算法刷题心得</title>
    <link href="https://konjacor.github.io/2022/09/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/"/>
    <id>https://konjacor.github.io/2022/09/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/</id>
    <published>2022-09-13T11:12:44.000Z</published>
    <updated>2022-12-23T02:09:40.626Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="2022-x2F-9-x2F-13-一维数组专题"><a href="#2022-x2F-9-x2F-13-一维数组专题" class="headerlink" title="2022&#x2F;9&#x2F;13 一维数组专题"></a>2022&#x2F;9&#x2F;13 一维数组专题</h1><ul><li>其实今天的题都是很基础的题，但是其中有一道题确实是让我懂了一点新的东西，下面就给出这道题。</li></ul><h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220913204141478.png" alt="image-20220913204141478"></p><ul><li><p>看一眼数据量，可以跑O(n^2)的算法，而且目测如果对二维数组的第一维进行排序后会更好做一点，排序之后用两个变量left和right记录一次合并的左端点和右端点，直到遇到不进行合并的集合，然后把当前的left和right作为一组数据加入到最后的数据集中，再更新left和right为当前集合的左右端点，然后继续往后遍历，遍历到最后推出循环后还要再记录一次答案，因为最后那个答案还没收录进答案中。</p></li><li><p>这当中要注意，每次做完合并之后都要把当前位置的数组的右端点设置为right的值，因为后面的数组是要和前面合并后的大数组进行比较的，大数组咱又不好拿出来，只好用部分替代整体，反正只用到了大数组的右端点。</p></li><li><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length==<span class="number">0</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        ArrayList&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> left=intervals[<span class="number">0</span>][<span class="number">0</span>],right=intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=idx;i&lt;intervals.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>]&lt;=intervals[i-<span class="number">1</span>][<span class="number">1</span>])&#123;</span><br><span class="line">                right = Math.max(intervals[i][<span class="number">1</span>],intervals[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                intervals[i][<span class="number">1</span>] = right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left,right&#125;);</span><br><span class="line">                left = intervals[i][<span class="number">0</span>];</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;left,right&#125;);</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> ans_i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] a : list)&#123;</span><br><span class="line">            ans[ans_i][<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">            ans[ans_i++][<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="创建匿名数组并赋值"><a href="#创建匿名数组并赋值" class="headerlink" title="创建匿名数组并赋值"></a>创建匿名数组并赋值</h3><ul><li>要这样写(示例)：**new int[]{1,2,3}**，要注意中括号里不能填具体的长度。</li></ul><h3 id="定义数组并初始化的两种方式"><a href="#定义数组并初始化的两种方式" class="headerlink" title="定义数组并初始化的两种方式"></a>定义数组并初始化的两种方式</h3><ol><li>int[] a &#x3D; new int[]{1,2,3};</li><li>int[] a &#x3D; {1,2,3};</li></ol><h3 id="以多维数组中的其中一维给多维数组排序"><a href="#以多维数组中的其中一维给多维数组排序" class="headerlink" title="以多维数组中的其中一维给多维数组排序"></a>以多维数组中的其中一维给多维数组排序</h3><ul><li><p>主要是用到了Comparator类的方法、lambda表达式和函数式接口的相关知识，我看了看Comparator的源码也没看出多少道道来，之后再分析吧，下面是以第一维给二维数组排序的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(intervals, Comparator.comparingInt(a -&gt; a[<span class="number">0</span>]));</span><br></pre></td></tr></table></figure></li></ul><h2 id="罕见的定义数组的方式"><a href="#罕见的定义数组的方式" class="headerlink" title="罕见的定义数组的方式"></a>罕见的定义数组的方式</h2><ul><li>今天还真是长见识了。。。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220913205514046.png" alt="image-20220913205514046"></p><h1 id="2022-x2F-10-x2F-4-Morris遍历"><a href="#2022-x2F-10-x2F-4-Morris遍历" class="headerlink" title="2022&#x2F;10&#x2F;4 Morris遍历"></a>2022&#x2F;10&#x2F;4 Morris遍历</h1><ul><li>搞了二叉树的简单题，用递归倒是随便写，用非递归想要尝试尝试昨天新学的Morris遍历来优化空间复杂度，所以就尝试写了写试试。</li></ul><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221004204500176.png" alt="image-20221004204500176"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221004204516138.png" alt="image-20221004204516138"></p><ul><li><p>思路主要就是<strong>同时从两个方向来遍历，不过由于是轴对称，所以遍历时候的左右优先级要对称而非相同</strong>，剩下的就是看代码怎么写了，写了一手Morris，没有很细致的进行优化，重点都写注释里了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution125</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    TreeNode left,right,mostRight,mostLeft;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//特殊情况</span></span><br><span class="line">        left = root.left;right = root.right;<span class="comment">//left遍历左子树，right遍历右子树，由于判断的是轴对称，所有左子树遍历的时候左子树优先，右子树遍历的时候右子树优先，或者是采用其他的轴对称遍历方式。</span></span><br><span class="line">        <span class="keyword">while</span> (left!=<span class="literal">null</span>&amp;&amp;right!=<span class="literal">null</span>)&#123;<span class="comment">//每次循环都是一次访问到下一个节点的操作，如果循环退出说明至少有一方走到了null(即那一方遍历完了)</span></span><br><span class="line">            <span class="keyword">if</span>(left.val!=right.val)&#123;<span class="comment">//判断遍历到的位置的值是否相等，如果不相等就可以直接判断为非轴对称</span></span><br><span class="line">                ans = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mostRight=left.left;mostLeft = right.right;<span class="comment">//左子树要找最右边的节点，右子树要找最左边的节点（都是找他们那棵树上最后访问到的节点）</span></span><br><span class="line">            <span class="keyword">if</span>(mostRight!=<span class="literal">null</span>&amp;&amp;mostLeft!=<span class="literal">null</span>) &#123;<span class="comment">//有左子树/右子树的情况，要找最右/最左的节点（即最晚遍历到的节点），来设置线索</span></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="literal">null</span> &amp;&amp; mostRight.right != left) &#123;<span class="comment">//找最右边的节点</span></span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (mostLeft.left != <span class="literal">null</span> &amp;&amp; mostLeft.left != right)&#123;<span class="comment">//找最左边的节点</span></span><br><span class="line">                    mostLeft = mostLeft.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(mostRight.right==<span class="literal">null</span>)&#123;<span class="comment">//没有线索，说明没有遍历过左子树，故设置线索为当前节点后向左遍历</span></span><br><span class="line">                    mostRight.right = left;</span><br><span class="line">                    left = left.left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//有线索，说明遍历过左子树了，故洗掉线索然后向右遍历</span></span><br><span class="line">                    mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                    left = left.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(mostLeft.left==<span class="literal">null</span>)&#123;<span class="comment">//没有线索，说明没有遍历过右子树，故设置线索为当前节点后向右遍历</span></span><br><span class="line">                    mostLeft.left = right;</span><br><span class="line">                    right = right.right;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//有线索，说明遍历过右子树了，故洗掉线索然后向左遍历</span></span><br><span class="line">                    mostLeft.left = <span class="literal">null</span>;</span><br><span class="line">                    right = right.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//没有左子树/右子树的情况,直接向右/左转移</span></span><br><span class="line">                <span class="keyword">if</span>(mostRight!=mostLeft)&#123;<span class="comment">//由于至少有一方为null，所以如果两者不相等，可以直接判定不是轴对称</span></span><br><span class="line">                    ans = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left = left.right;</span><br><span class="line">                right = right.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left!=right)&#123;<span class="comment">//最后做个判断，如果这俩相等说明是同时遍历完的，如果不相等说明有一边先遍历完了，就不是轴对称了。</span></span><br><span class="line">            ans = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>感觉这个算法要是理解了本质的话不算难，写起来也挺顺手的，算法的详细信息见《数据结构与算法》博客。</p></li></ul><h1 id="2022-x2F-10-x2F-5-知两种顺序的遍历结果重建二叉树"><a href="#2022-x2F-10-x2F-5-知两种顺序的遍历结果重建二叉树" class="headerlink" title="2022&#x2F;10&#x2F;5 知两种顺序的遍历结果重建二叉树"></a>2022&#x2F;10&#x2F;5 知两种顺序的遍历结果重建二叉树</h1><h2 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h2><ul><li><p>这题主要考察对二叉树中序遍历和后序遍历的理解，<strong>后序遍历的最后一个元素一定是这个二叉树的顶点，知道顶点之后，去中序遍历中找到顶点所在的位置，顶点左边是左子树的遍历结果，顶点右边是右子树的遍历结果，分别再对两边的遍历结果递归执行上面的操作即可</strong>。</p></li><li><p>其中要注意由于中序遍历和后序遍历都遵循着<strong>先遍历左子树再遍历右子树</strong>的原则，所以右子树的遍历结果都出现在遍历结果比较偏后的部分，所以<strong>后序遍历结果的倒数第二个元素是顶点的右子树的顶点，同理，后序遍历结果的倒数第三个元素是顶点的右子树的右子树的顶点，但是想要通过后序遍历结果找到左子树的顶点需要有一个右子树数量的偏移量，偏移一次之后再以步长为1向前访问就能依次访问到所有左子树的顶点了</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005233039617.png" alt="image-20221005233039617"></p></li><li><p>详细信息写在代码的注释中了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode ans;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();<span class="comment">//新建个树</span></span><br><span class="line">        dfs(inorder,postorder,postorder.length-<span class="number">1</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] subTree,<span class="type">int</span>[] postorder,<span class="type">int</span> postorder_i,TreeNode now)</span>&#123;<span class="comment">//subTree是当前子树，now是当前正在构建的节点，postorder_i是当前子树的顶点在postorder中的索引</span></span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(subTree));</span></span><br><span class="line">        <span class="keyword">if</span>(subTree.length==<span class="number">1</span>) &#123;<span class="comment">//如果当前子树只有一个节点，那么这个节点在要构建的树上是个叶节点，直接赋值然后返回</span></span><br><span class="line">            now.val = subTree[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;subTree.length;++i)&#123;<span class="comment">//在当前子树的中序遍历中找到顶点的索引进行下一步dfs</span></span><br><span class="line">            <span class="keyword">if</span>(subTree[i]==postorder[postorder_i])&#123;<span class="comment">//找到了顶点</span></span><br><span class="line">                <span class="comment">//System.out.println(subTree[i]);</span></span><br><span class="line">                now.val = subTree[i];<span class="comment">//给当前正在构建的节点赋值</span></span><br><span class="line">                <span class="keyword">if</span>(subTree.length&gt;i+<span class="number">1</span>) &#123;<span class="comment">//如果满足这个条件说明这个节点还有右节点，因为中序遍历数组的顶点右边还有遍历记录</span></span><br><span class="line">                    now.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();<span class="comment">//新建右节点，待会儿当参数传进去</span></span><br><span class="line">                    dfs(Arrays.copyOfRange(subTree, i + <span class="number">1</span>, subTree.length), postorder, postorder_i - <span class="number">1</span>, now.right);<span class="comment">//将右边的遍历结果当成一个树继续dfs，postorder由于是后序遍历结果，所以右子树的遍历结果在偏后边，所以往前访问一个即是新的树的顶点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>) &#123;<span class="comment">//如果满足这个条件说明这个节点还有左节点，因为中序遍历数组的顶点左边还有遍历记录</span></span><br><span class="line">                    now.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();<span class="comment">//新建右节点，待会儿当参数传进去</span></span><br><span class="line">                    dfs(Arrays.copyOfRange(subTree, <span class="number">0</span>, i), postorder, postorder_i - <span class="number">1</span>-(subTree.length-(i+<span class="number">1</span>)), now.left);<span class="comment">//将左边的遍历结果当成一个树继续dfs，postorder由于是后序遍历结果，所以左子树的遍历结果在偏前边，所以往前访问的时候要跳过右子树的节点才是新的树的顶点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h2><ul><li><p>类比上面那个，顺序啥的换一下就行了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221005233327985.png" alt="image-20221005233327985"></p></li><li><p>注释还都是用的上面那个的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode ans;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();<span class="comment">//新建个树</span></span><br><span class="line">        dfs(inorder,preorder,<span class="number">0</span>,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] subTree,<span class="type">int</span>[] preorder,<span class="type">int</span> preorder_i,TreeNode now)</span>&#123;<span class="comment">//subTree是当前子树，now是当前正在构建的节点，postorder_i是当前子树的顶点在postorder中的索引</span></span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(subTree));</span></span><br><span class="line">        <span class="keyword">if</span>(subTree.length==<span class="number">1</span>) &#123;<span class="comment">//如果当前子树只有一个节点，那么这个节点在要构建的树上是个叶节点，直接赋值然后返回</span></span><br><span class="line">            now.val = subTree[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;subTree.length;++i)&#123;<span class="comment">//在当前子树的中序遍历中找到顶点的索引进行下一步dfs</span></span><br><span class="line">            <span class="keyword">if</span>(subTree[i]==preorder[preorder_i])&#123;<span class="comment">//找到了顶点</span></span><br><span class="line">                <span class="comment">//System.out.println(subTree[i]);</span></span><br><span class="line">                now.val = subTree[i];<span class="comment">//给当前正在构建的节点赋值</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>) &#123;<span class="comment">//如果满足这个条件说明这个节点还有左节点，因为中序遍历数组的顶点左边还有遍历记录</span></span><br><span class="line">                    now.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();<span class="comment">//新建右节点，待会儿当参数传进去</span></span><br><span class="line">                    dfs(Arrays.copyOfRange(subTree, <span class="number">0</span>, i), preorder, preorder_i + <span class="number">1</span>, now.left);<span class="comment">//将左边的遍历结果当成一个树继续dfs，postorder由于是后序遍历结果，所以左子树的遍历结果在偏前边，所以往前访问的时候要跳过右子树的节点才是新的树的顶点</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(subTree.length&gt;i+<span class="number">1</span>) &#123;<span class="comment">//如果满足这个条件说明这个节点还有右节点，因为中序遍历数组的顶点右边还有遍历记录</span></span><br><span class="line">                    now.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();<span class="comment">//新建右节点，待会儿当参数传进去</span></span><br><span class="line">                    dfs(Arrays.copyOfRange(subTree, i + <span class="number">1</span>, subTree.length), preorder, preorder_i +<span class="number">1</span>+(i-<span class="number">0</span>), now.right);<span class="comment">//将右边的遍历结果当成一个树继续dfs，postorder由于是后序遍历结果，所以右子树的遍历结果在偏后边，所以往前访问一个即是新的树的顶点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2022-x2F-10-x2F-10-二叉树的最近公共祖先-LCA"><a href="#2022-x2F-10-x2F-10-二叉树的最近公共祖先-LCA" class="headerlink" title="2022&#x2F;10&#x2F;10 二叉树的最近公共祖先(LCA)"></a>2022&#x2F;10&#x2F;10 二叉树的最近公共祖先(LCA)</h1><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010195910781.png" alt="image-20221010195910781"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221010195928345.png" alt="image-20221010195928345"></p><h2 id="递归解决"><a href="#递归解决" class="headerlink" title="递归解决"></a>递归解决</h2><ul><li><p>由于这个题指定了这个树是二叉树，每个节点的度小于等于2，所以我们可以利用递归进行解题，思路就是<strong>利用递归的先自顶向下，再自底向上的特性</strong>，在<strong>自顶向下的时候寻找目标节点</strong>，在<strong>自底向上的时候将答案带回</strong>。</p></li><li><p>每到一个节点都向左右方向递归，如果<strong>遇到null或者p或者q就进行返回，记录左右递归的结果</strong>，<strong>如果两者都为null，那就返回null</strong>，说明这个子树中没有目标值；<strong>如果两者都不为null，那就返回当前节点</strong>，因为两者都不为null说明分别在左右两边找到了目标值，那么当前节点就是他们的公共祖先，由于递归的返回阶段是自底向上的，所以可以确定当前节点就是他们的最近公共祖先；<strong>如果两者中其中一个为null，那么就返回那个不为null的值</strong>，这样可以保证答案或者找到的节点送到上层。</p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>||cur == p||cur == q) <span class="keyword">return</span> cur;<span class="comment">//找到节点或者到头了，就返回当前节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(cur.left,p,q);<span class="comment">//向左递归</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(cur.right,p,q);<span class="comment">//向右递归</span></span><br><span class="line">        <span class="comment">//向上传null或者是找到的p/q</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="comment">//左右都不为null，说明当前节点是最近公共祖先，将当前节点向上传</span></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="非递归解决"><a href="#非递归解决" class="headerlink" title="非递归解决"></a>非递归解决</h2><ul><li><p>非递归的方法不仅可以解决二叉树的LCA问题，<strong>对于任何树的LCA问题都能解决</strong>，具有普适性。</p></li><li><p>首先我们<strong>需要一个方法来取得当前节点在树中的深度</strong>，然后<strong>遍历树直到将两个目标节点遍历完，记录下两个节点深度，然后比较两个节点的深度，将比较深的那个节点的指针向上移动直到和另外一个节点处于同一层，然后将两个节点指针同时向上移动直到两个节点指针碰头，此时两个节点指针指向的节点就是两个目标节点的最近公共祖先</strong>。</p></li><li><p>优化方面可以<strong>考虑向上移动的时候使用倍增</strong>。</p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><h1 id="2022-x2F-10-x2F-11-二叉树的序列化和反序列化"><a href="#2022-x2F-10-x2F-11-二叉树的序列化和反序列化" class="headerlink" title="2022&#x2F;10&#x2F;11 二叉树的序列化和反序列化"></a>2022&#x2F;10&#x2F;11 二叉树的序列化和反序列化</h1><h2 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011212529671.png" alt="image-20221011212529671"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221011212544238.png" alt="image-20221011212544238"></p><ul><li><p>看到这题的时候实际上就是有两种思路，<strong>第一种使用层序遍历并还原</strong>的方式，但是处理其中的null相对比较复杂，不如<strong>第二种使用递归遍历并还原的方式</strong>，使用先序遍历或者中序遍历或者后序遍历<strong>记录下含有null的字符串</strong>，解析的时候再用相同的遍历顺序构建树即可，注意做好特殊情况的处理。</p></li><li><p>受之前知两种顺序的遍历结果重建二叉树那题的影响，搞得我以为必须要两种遍历结果才能还原二叉树，实际上对于不含null的遍历结果确实是这样的，因为只知道一种遍历结果无法准确定位空节点，但是<strong>对于含有所有null的遍历结果，只知道它是怎样的遍历顺序，就能用同样的顺序重建二叉树，因为其中的null保证了你可以准确知道空节点的位置</strong>。</p></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfsBefore(root);</span><br><span class="line">        <span class="comment">//dfsMid(root);</span></span><br><span class="line"><span class="comment">//        char[] shift = new char[temp.size()];</span></span><br><span class="line"><span class="comment">//        int i=0;</span></span><br><span class="line"><span class="comment">//        for(int num:temp)&#123;</span></span><br><span class="line"><span class="comment">//            shift[i++] = (char)num;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> temp.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(data.equals(<span class="string">&quot;[null]&quot;</span>)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(data);</span><br><span class="line">        data = data.substring(<span class="number">1</span>,data.length()-<span class="number">1</span>);</span><br><span class="line">        String[] dataArray = data.split(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">        buildTree(dataArray,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfsBefore</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">            temp.add(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.add(cur.val);</span><br><span class="line">        dfsBefore(cur.left);</span><br><span class="line">        dfsBefore(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildTree</span><span class="params">(String[] data,TreeNode cur)</span>&#123;<span class="comment">//前序重建二叉树</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=data.length)&#123;<span class="comment">//没有节点了就返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.val = Integer.parseInt(data[i]);<span class="comment">//给当前节点赋值</span></span><br><span class="line">        <span class="keyword">if</span>(!data[i+<span class="number">1</span>].equals(<span class="string">&quot;null&quot;</span>))&#123;<span class="comment">//下一个元素（即左儿子）如果不为空就开空间然后往下递归。</span></span><br><span class="line">            i++;</span><br><span class="line">            cur.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">            buildTree(data,cur.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> i++;<span class="comment">//左儿子为空就不开空间跳过</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=data.length)&#123;<span class="comment">//防止下面访问数组越界，再检查一遍</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!data[i+<span class="number">1</span>].equals(<span class="string">&quot;null&quot;</span>))&#123;<span class="comment">//下一个元素（即右儿子）如果不为空就开空间然后往下递归。</span></span><br><span class="line">            i++;</span><br><span class="line">            cur.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">            buildTree(data,cur.right);</span><br><span class="line">        &#125;<span class="keyword">else</span> i++;<span class="comment">//右儿子为空就不开空间跳过。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec deser = new Codec();</span></span><br><span class="line"><span class="comment">// TreeNode ans = deser.deserialize(ser.serialize(root));</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="2022-x2F-10-x2F-17-旋转矩阵-amp-交换两数的原地算法"><a href="#2022-x2F-10-x2F-17-旋转矩阵-amp-交换两数的原地算法" class="headerlink" title="2022&#x2F;10&#x2F;17 旋转矩阵&amp;交换两数的原地算法"></a>2022&#x2F;10&#x2F;17 旋转矩阵&amp;交换两数的原地算法</h1><h2 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221017210609463.png" alt="image-20221017210609463"></p><ul><li><p>可以<strong>将旋转操作转换为先对角线翻转然后再水平翻转</strong>，但是怎么做到原地算法呢？这就涉及到一个很巧妙的<strong>原地将两个变量的值做交换的算法</strong>了，这个算法充分利用到了两数之和的性质，算法描述如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************交换a和b的值************************/</span></span><br><span class="line">a += b;</span><br><span class="line">b = a - b;</span><br><span class="line">a -= b;</span><br></pre></td></tr></table></figure></li><li><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="comment">//对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;matrix.length;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;matrix[i].length;++j)&#123;</span><br><span class="line">                matrix[i][j] += matrix[j][i];</span><br><span class="line">                matrix[j][i] = matrix[i][j] - matrix[j][i];</span><br><span class="line">                matrix[i][j] -= matrix[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//水平翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;matrix.length;++k)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,j=matrix[k].length-<span class="number">1</span>;i&lt;j;++i,--j)&#123;</span><br><span class="line">                matrix[k][i] += matrix[k][j];</span><br><span class="line">                matrix[k][j] = matrix[k][i] - matrix[k][j];</span><br><span class="line">                matrix[k][i] -= matrix[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2022-x2F-10-x2F-25-阶乘后的零"><a href="#2022-x2F-10-x2F-25-阶乘后的零" class="headerlink" title="2022&#x2F;10&#x2F;25 阶乘后的零"></a>2022&#x2F;10&#x2F;25 阶乘后的零</h1><h2 id="阶乘后的零"><a href="#阶乘后的零" class="headerlink" title="阶乘后的零"></a>阶乘后的零</h2><ul><li>又是个数学题。。。</li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221026110923001.png" alt="image-20221026110923001"></p><ul><li><p>先来考虑什么情况下才会在末尾贡献0，很明显，<strong>只有2、5两个因子相乘的时候才会在结尾贡献0</strong>，而5因子一定比2因子要少，所以只需要找这个阶乘中有几个5因子就知道末尾有几个零了。</p></li><li><p>由于阶乘的乘法运算的顺序是按照数字顺序且步长为1的，所以参照<strong>自然数中每过5个数就可以分解出一个5因子，n的阶乘中第一轮分解出来的5因子的个数就是n&#x2F;5</strong>，让n&#x3D;n&#x2F;5，从现在开始n就指代这一轮分解出来的5因子的个数了，<strong>分解出来的每个含有5因子的数，每隔5个又会分解出来一个5因子，这个对应的就是那些是25的倍数的数</strong>，以此类推，直到无法再分解出5因子来了，表现为n&#x3D;0。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans += n/<span class="number">5</span>;<span class="comment">//每隔五个数就有一个因子5</span></span><br><span class="line">            n /= <span class="number">5</span>;<span class="comment">//选出有因子5的数中每隔五个数又有一个因子5</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;2022-x2F-9-x2F-13-一维数组专题&quot;&gt;&lt;a href=&quot;#2022-x2F-9-x2F-13-一维数组专题&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="算法" scheme="https://konjacor.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="刷题" scheme="https://konjacor.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门</title>
    <link href="https://konjacor.github.io/2022/09/11/SpringBoot%E5%85%A5%E9%97%A8/"/>
    <id>https://konjacor.github.io/2022/09/11/SpringBoot%E5%85%A5%E9%97%A8/</id>
    <published>2022-09-11T09:22:45.000Z</published>
    <updated>2022-12-20T12:11:43.200Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="Spring-与-SpringBoot"><a href="#Spring-与-SpringBoot" class="headerlink" title="Spring 与 SpringBoot"></a>Spring 与 SpringBoot</h1><h2 id="Spring能做什么"><a href="#Spring能做什么" class="headerlink" title="Spring能做什么"></a>Spring能做什么</h2><h3 id="Spring的能力"><a href="#Spring的能力" class="headerlink" title="Spring的能力"></a>Spring的能力</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221123164723364.png" alt="image-20221123164723364"></p><h3 id="Spring的生态"><a href="#Spring的生态" class="headerlink" title="Spring的生态"></a>Spring的生态</h3><ul><li>详情可见：<strong><a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></strong></li><li>覆盖了：web开发、数据访问、安全控制、分布式、消息服务、移动开发、批处理……</li></ul><h3 id="Spring5重大升级"><a href="#Spring5重大升级" class="headerlink" title="Spring5重大升级"></a>Spring5重大升级</h3><h4 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h4><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221123165218680.png" alt="image-20221123165218680"></p><h4 id="内部源码设计"><a href="#内部源码设计" class="headerlink" title="内部源码设计"></a>内部源码设计</h4><ul><li>基于Java8的一些新特性，如：接口的默认实现，重新设计源码架构等。</li></ul><h2 id="为什么用SpringBoot"><a href="#为什么用SpringBoot" class="headerlink" title="为什么用SpringBoot"></a>为什么用SpringBoot</h2><ul><li>Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.即能快速创建出生产级别的Spring应用。</li></ul><h3 id="SpringBoot的优点"><a href="#SpringBoot的优点" class="headerlink" title="SpringBoot的优点"></a>SpringBoot的优点</h3><ul><li>Create stand-alone Spring applications 创建独立Spring应用</li><li>Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files) 内嵌web服务器</li><li>Provide opinionated ‘starter’ dependencies to simplify your build configuration 自动starter依赖，简化构建配置</li><li>Automatically configure Spring and 3rd party libraries whenever possible 自动配置Spring以及第三方功能</li><li>Provide production-ready features such as metrics, health checks, and externalized configuration 提供生产级别的监控、健康检查及外部化配置</li><li>Absolutely no code generation and no requirement for XML configuration 无代码生成、无需编写XML</li><li>SpringBoot是整合Spring技术栈的一站式框架</li><li>SpringBoot是简化Spring技术栈的快速开发脚手架</li></ul><h3 id="SpringBoot的缺点"><a href="#SpringBoot的缺点" class="headerlink" title="SpringBoot的缺点"></a>SpringBoot的缺点</h3><ul><li>人称版本帝，迭代快，需要时刻关注变化。</li><li>封装太深，内部原理复杂，不容易精通。</li></ul><h2 id="时代背景"><a href="#时代背景" class="headerlink" title="时代背景"></a>时代背景</h2><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><ul><li><p><a href="https://martinfowler.com/articles/microservices.html">James Lewis and Martin Fowler (2014)</a>  提出微服务完整概念。<a href="https://martinfowler.com/microservices/">https://martinfowler.com/microservices/</a></p><blockquote><p>In short, the <strong>microservice architectural style</strong> is an approach to developing a single application as a <strong>suite of small services</strong>, each <strong>running in its own process</strong> and communicating with <strong>lightweight</strong> mechanisms, often an <strong>HTTP</strong> resource API. These services are <strong>built around business capabilities</strong> and <strong>independently deployable</strong> by fully <strong>automated deployment</strong> machinery. There is a <strong>bare minimum of centralized management</strong> of these services, which may be <strong>written in different programming languages</strong> and use different data storage technologies.– <a href="https://martinfowler.com/articles/microservices.html">James Lewis and Martin Fowler (2014)</a></p></blockquote></li><li><p>微服务是一种架构风格</p></li><li><p>一个应用拆分为一组小型服务</p></li><li><p>每个服务运行在自己的进程内，也就是可独立部署和升级</p></li><li><p>服务之间使用轻量级HTTP交互</p></li><li><p>服务围绕业务功能拆分</p></li><li><p>可以由全自动部署机制独立部署</p></li><li><p>去中心化，服务自治。服务可以使用不同的语言、不同的存储技术</p></li></ul><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><ul><li>分布式系统是<strong>多个服务器通过网络互联而构建的松耦合系统</strong>：<img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221123170745193.png" alt="image-20221123170745193"></li></ul><h4 id="分布式的困难"><a href="#分布式的困难" class="headerlink" title="分布式的困难"></a>分布式的困难</h4><ul><li>远程调用</li><li>服务发现</li><li>负载均衡</li><li>服务容错</li><li>配置管理</li><li>服务监控</li><li>链路追踪</li><li>日志管理</li><li>任务调度</li><li>……</li></ul><h4 id="分布式的解决"><a href="#分布式的解决" class="headerlink" title="分布式的解决"></a>分布式的解决</h4><ul><li><p>SpringBoot+SpringCloud</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221123190035913.png" alt="image-20221123190035913"></p></li></ul><h3 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h3><ul><li>原生应用如何上云。-Cloud Native</li></ul><h4 id="上云的困难"><a href="#上云的困难" class="headerlink" title="上云的困难"></a>上云的困难</h4><ul><li>服务自愈</li><li>弹性伸缩</li><li>服务隔离</li><li>自动化部署</li><li>灰度发布</li><li>流量治理</li><li>……</li></ul><h2 id="如何学习SpringBoot"><a href="#如何学习SpringBoot" class="headerlink" title="如何学习SpringBoot"></a>如何学习SpringBoot</h2><h3 id="官网文档架构"><a href="#官网文档架构" class="headerlink" title="官网文档架构"></a>官网文档架构</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221123190342774.png" alt="image-20221123190342774"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221123190358243.png" alt="image-20221123190358243"></p><ul><li><p>查看版本新特性：<a href="https://github.com/spring-projects/spring-boot/wiki#release-notes">https://github.com/spring-projects/spring-boot/wiki#release-notes</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221123190453858.png" alt="image-20221123190453858"></p></li></ul><h1 id="SpringBoot2入门"><a href="#SpringBoot2入门" class="headerlink" title="SpringBoot2入门"></a>SpringBoot2入门</h1><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><ul><li>Java 8 &amp; 兼容java14 .</li><li>Maven 3.3+</li><li>idea 2019.1.2</li></ul><h2 id="maven配置文件设置"><a href="#maven配置文件设置" class="headerlink" title="maven配置文件设置"></a>maven配置文件设置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><ul><li>需求：浏览发送&#x2F;hello请求，响应Hello，Spring Boot 2</li></ul><h3 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h3><ul><li>在IDEA中创建maven工程</li></ul><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建主程序"><a href="#创建主程序" class="headerlink" title="创建主程序"></a>创建主程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主程序类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span>：这是一个SpringBoot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写业务"><a href="#编写业务" class="headerlink" title="编写业务"></a>编写业务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handle01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, Spring Boot 2!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li>直接运行main方法</li></ul><h3 id="简化配置"><a href="#简化配置" class="headerlink" title="简化配置"></a>简化配置</h3><ul><li><p>可以将配置写到自己在Resources中创建的application.properties中，写在其中的配置对整个应用都生效：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8888</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="简化部署"><a href="#简化部署" class="headerlink" title="简化部署"></a>简化部署</h3><ul><li>可以在项目的pom文件中添加以下插件，这样把项目打成jar包后直接在目标服务器执行即可。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="了解自动配置原理"><a href="#了解自动配置原理" class="headerlink" title="了解自动配置原理"></a>了解自动配置原理</h1><h2 id="SpringBoot特点"><a href="#SpringBoot特点" class="headerlink" title="SpringBoot特点"></a>SpringBoot特点</h2><h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><ul><li><p>父项目做依赖管理（话说这个不是maven工程的特点嘛）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">依赖管理</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">他的父项目</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">几乎声明了所有开发中常用的依赖的版本号,自动版本仲裁机制</span><br></pre></td></tr></table></figure></li><li><p>开发导入starter场景启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、见到很多 spring-boot-starter-* ： *就某种场景</span><br><span class="line">2、只要引入starter，这个场景的所有常规需要的依赖我们都自动引入</span><br><span class="line">3、SpringBoot所有支持的场景</span><br><span class="line">https://docs.spring.io/spring-boot/docs/current/reference/html/using-spring-boot.html#using-boot-starter</span><br><span class="line">4、见到的  *-spring-boot-starter： 第三方为我们提供的简化开发的场景启动器。</span><br><span class="line">5、所有场景启动器最底层的依赖</span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>无需关注版本号，自动版本仲裁：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、引入依赖默认都可以不写版本</span><br><span class="line">2、引入非版本仲裁的jar，要写版本号。</span><br></pre></td></tr></table></figure></li><li><p>可以修改默认版本号：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、查看spring-boot-dependencies里面规定当前依赖的版本 用的 key。</span><br><span class="line">2、在当前项目里面重写配置</span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><ul><li><p>自动配置好Tomcat：手动引入Tomcat依赖，SpringBoot会帮我们自动配置好Tomcat。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>自动配置好SpringMVC：</p><ul><li>引入SpringMVC全套组件</li><li>自动配好SpringMVC常用组件（功能）。</li></ul></li><li><p>自动配好Web常见功能，如：字符编码问题：</p><ul><li>SpringBoot帮我们配置好了所有web开发的常见场景</li></ul></li><li><p>具有默认的包结构：</p><ul><li><p><strong>主程序所在包及其下面的所有子包里面的组件都会被默认扫描进来</strong></p></li><li><p>无需以前的包扫描配置</p></li><li><p>想要改变扫描路径，可以在主程序的注解中添加参数显式指定@SpringBootApplication(scanBasePackages&#x3D;<strong>“路径”</strong>)或者使用@ComponentScan(<strong>“路径”</strong>)注解指定扫描路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">等同于</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;默认路径&quot;)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>各种配置拥有默认值：</p><ul><li><strong>默认配置最终都是映射到某个类上</strong>，如：MultipartProperties</li><li><strong>配置文件的值最终会绑定每个类上，这个类会在容器中创建对象</strong></li></ul></li><li><p>按需加载所有自动配置项：</p><ul><li>非常多的starter</li><li><strong>引入了哪些场景这个场景的自动配置才会开启</strong></li><li>SpringBoot所有的<strong>自动配置功能都在 spring-boot-autoconfigure 包里面</strong></li></ul></li><li><p>还有很多自动配置方面的特性，这里就不继续往下写了。</p></li></ul><h2 id="容器功能"><a href="#容器功能" class="headerlink" title="容器功能"></a>容器功能</h2><h3 id="组件添加"><a href="#组件添加" class="headerlink" title="组件添加"></a>组件添加</h3><h4 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h4><ul><li><p><strong>被这个注解修饰的类会被springboot识别为配置类，在其中做操作相当于在配置文件中做配置</strong>。</p></li><li><p>这个注解可以在<strong>Full模式和Lite模式</strong>中选其一使用。</p></li><li><p>配置类组件之间无依赖关系用Lite模式加速容器启动过程，减少判断；配置类组件之间有依赖关系，方法会被调用得到之前单实例组件，用Full模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#############################Configuration使用示例######################################################</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、配置类里面使用<span class="doctag">@Bean</span>标注在方法上给容器注册组件，默认也是单实例的</span></span><br><span class="line"><span class="comment"> * 2、配置类本身也是组件</span></span><br><span class="line"><span class="comment"> * 3、proxyBeanMethods：代理bean的方法</span></span><br><span class="line"><span class="comment"> *      Full(proxyBeanMethods = true)、【保证每个<span class="doctag">@Bean</span>方法被调用多少次返回的组件都是单实例的】</span></span><br><span class="line"><span class="comment"> *      Lite(proxyBeanMethods = false)【每个<span class="doctag">@Bean</span>方法被调用多少次返回的组件都是新创建的】</span></span><br><span class="line"><span class="comment"> *      组件依赖必须使用Full模式默认。其他默认是否Lite模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span> <span class="comment">//告诉SpringBoot这是一个配置类 == 配置文件，这是使用的Lite模式，不使用代理检查Bean是否已经存在，直接用到的时候new。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Full:外部无论对配置类中的这个组件注册方法调用多少次获取的都是之前注册容器中的单实例对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件。以方法名作为组件的id。返回类型就是组件类型。返回的值，就是组件在容器中的实例</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user01</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">zhangsan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//user组件依赖了Pet组件</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Pet <span class="title function_">tomcatPet</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pet</span>(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">################################<span class="meta">@Configuration</span>测试代码如下########################################</span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.atguigu.boot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1、返回我们IOC容器</span></span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、查看容器里面的组件</span></span><br><span class="line">        String[] names = run.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、从容器中获取组件</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">tom01</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Pet</span> <span class="variable">tom02</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;组件：&quot;</span>+(tom01 == tom02));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、com.atguigu.boot.config.MyConfig$$EnhancerBySpringCGLIB$$51f1e1ca@1654a892</span></span><br><span class="line">        <span class="type">MyConfig</span> <span class="variable">bean</span> <span class="operator">=</span> run.getBean(MyConfig.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果@Configuration(proxyBeanMethods = true)代理对象调用方法。SpringBoot总会检查这个组件是否在容器中有。</span></span><br><span class="line">        <span class="comment">//保持组件单实例</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> bean.user01();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> bean.user01();</span><br><span class="line">        System.out.println(user == user1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user01</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;user01&quot;</span>, User.class);</span><br><span class="line">        <span class="type">Pet</span> <span class="variable">tom</span> <span class="operator">=</span> run.getBean(<span class="string">&quot;tom&quot;</span>, Pet.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;用户的宠物：&quot;</span>+(user01.getPet() == tom));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Bean、-Component、-Controller、-Service、-Repository"><a href="#Bean、-Component、-Controller、-Service、-Repository" class="headerlink" title="@Bean、@Component、@Controller、@Service、@Repository"></a>@Bean、@Component、@Controller、@Service、@Repository</h4><ul><li>这些都是<strong>用来向spring容器中注册组件的注解</strong>，他们的作用基本相同，但是为了体现我们项目的层次规范，我们用不同的注解来注册不同层的组件。</li><li><strong>@Bean</strong>：@Bean 需要在配置类中使用，即类上需要加上@Component或者@Configuration注解， 通常加上@Configuration。这个注解用来修饰方法，表示一个方法实例化、配置或者初始化一个Spring ioc容器管理的新对象。</li><li><strong>@Component</strong>：用来修饰类，表示被注解的类会被ComponentScan扫描，然后被注册到spring ioc容器中。</li><li><strong>@Controller</strong>：和@Component效果相同，只不过我们通常用它来修饰控制器类或者表现层组件。</li><li><strong>@Service</strong>：和@Component效果相同，只不过我们通常用它来修饰业务层的组件。</li><li><strong>@Repository</strong>：和@Component效果相同，只不过我们通常用它来修饰持久层的组件。</li></ul><h4 id="ComponentScan、-Import"><a href="#ComponentScan、-Import" class="headerlink" title="@ComponentScan、@Import"></a>@ComponentScan、@Import</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;Spring-与-SpringBoot&quot;&gt;&lt;a href=&quot;#Spring-与-SpringBoot&quot; class=&quot;headerlink&quot; title=&quot;Spring </summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://konjacor.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://konjacor.github.io/2022/09/11/Spring/"/>
    <id>https://konjacor.github.io/2022/09/11/Spring/</id>
    <published>2022-09-11T09:22:29.000Z</published>
    <updated>2022-12-20T12:11:43.200Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="Spring5框架概述"><a href="#Spring5框架概述" class="headerlink" title="Spring5框架概述"></a>Spring5框架概述</h1><ul><li>Spring是轻量级的开源的JavaEE框架</li><li>Spring可以解决企业应用开发的复杂性</li><li>Spring有两个核心部分：<strong>IOC 和 AOP</strong><ul><li>IOC：即<strong>控制反转</strong>，把创建对象的过程交给Spring进行管理</li><li>AOP：即<strong>面向切面编程</strong>，能够不修改源代码而对其功能进行增强</li></ul></li><li>Spring的特点：<ol><li>方便解耦，简化开发</li><li>支持aop编程</li><li>方便程序测试</li><li>方便和其他框架进行整合</li><li>方便进行事务操作</li><li>降低API的开发难度</li></ol></li><li>以下的内容选取Spring的版本是5.x</li></ul><h1 id="Spring5入门案例"><a href="#Spring5入门案例" class="headerlink" title="Spring5入门案例"></a>Spring5入门案例</h1><h2 id="下载Spring5"><a href="#下载Spring5" class="headerlink" title="下载Spring5"></a>下载Spring5</h2><ol><li><p>使用Spring的最新稳定版（Lastest Stable）：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126191152434.png" alt="image-20221126191152434"></p></li><li><p>下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/">https://repo.spring.io/release/org/springframework/spring/</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126191224742.png" alt="image-20221126191224742"></p></li></ol><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><ul><li><p>打开idea工具，创建普通java工程：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126191350331.png" alt="image-20221126191350331"></p></li></ul><h2 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h2><ul><li><p>导入Spring5相关jar包，主要是导入几个核心的包，以及关于日志的一个包：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126191551005.png" alt="image-20221126191551005"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126191610031.png" alt="image-20221126191610031"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126191620655.png" alt="image-20221126191620655"></p></li></ul><h2 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><ul><li><p>创建一个普通类，在这个类中创建普通方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;add......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建Spring配置文件"><a href="#创建Spring配置文件" class="headerlink" title="创建Spring配置文件"></a>创建Spring配置文件</h2><ul><li><p>创建Spring配置文件，<strong>在配置文件配置刚才创建的对象，配置之后这个类创建对象的过程就被委托给Spring了，Spring会在需要的时候创建对象</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126191949719.png" alt="image-20221126191949719"></p></li><li><p>Spring配置文件使用xml格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置 User 对象创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul><li><p>编写测试代码进行测试，注意这里获取刚才创建类的对象是先读取了刚才写的配置文件生成ApplicationContext对象，然后再利用ApplicationContext对象获取对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//1 加载 spring 配置文件</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line"><span class="comment">//2 获取配置创建的对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">System.out.println(user);</span><br><span class="line">user.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126192309190.png" alt="image-20221126192309190"></p></li></ul><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="概念和原理"><a href="#概念和原理" class="headerlink" title="概念和原理"></a>概念和原理</h2><h3 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h3><ol><li><strong>控制反转</strong>，<strong>把对象创建和对象之间的调用过程，交给Spring进行管理</strong>。</li><li>使用IOC的目的：为了<strong>降低客户端代码和客户端使用到的包中类的对象的耦合度</strong>。</li><li>上面的案例的实现就是利用到了IOC。</li></ol><h2 id="IOC容器相关接口"><a href="#IOC容器相关接口" class="headerlink" title="IOC容器相关接口"></a>IOC容器相关接口</h2><ol><li><p>IOC思想基于IOC容器实现，<strong>IOC容器底层就是对象工厂</strong>。</p></li><li><p>Spring提供IOC容器实现的两种方式（两个接口）：</p><ul><li><strong>BeanFactory</strong>：IOC容器的基本实现，是<strong>Spring内部的使用接口，不提供给开发人员进行使用</strong>。使用这个接口，<strong>加载配置文件的时候不会创建对象，在获取对象的时候才去创建对象</strong>。</li><li><strong>ApplicationContext</strong>：<strong>BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用</strong>。使用这个接口，<strong>加载配置文件的时候就会把在配置文件中注册的对象进行创建</strong>。</li></ul></li><li><p>ApplicationContext接口有实现类：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126193548520.png" alt="image-20221126193548520"></p></li></ol><h2 id="Bean管理的概念"><a href="#Bean管理的概念" class="headerlink" title="Bean管理的概念"></a>Bean管理的概念</h2><h3 id="什么是Bean管理"><a href="#什么是Bean管理" class="headerlink" title="什么是Bean管理"></a>什么是Bean管理</h3><ul><li>Spring管理Bean指的是两个操作：<ol><li>Spring创建Bean对象</li><li>Spring向Bean对象中注入属性</li></ol></li><li>Bean管理操作有两种方式：<ol><li>基于xml配置文件方式实现</li><li>基于注解方式实现</li></ol></li></ul><h2 id="基于xml的方式实现Bean管理"><a href="#基于xml的方式实现Bean管理" class="headerlink" title="基于xml的方式实现Bean管理"></a>基于xml的方式实现Bean管理</h2><h2 id="基于注解的方式实现Bean管理"><a href="#基于注解的方式实现Bean管理" class="headerlink" title="基于注解的方式实现Bean管理"></a>基于注解的方式实现Bean管理</h2><h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><ol><li>注解<strong>是代码的特殊标记</strong>，<strong>格式为：@注解名称(属性名称&#x3D;属性值，属性名称&#x3D;属性值……)</strong></li><li><strong>注解可以作用在类、方法、属性上面</strong></li><li>使用注解实现Bean管理的目的：简化xml配置（不得不说，配置xml太繁琐了）</li></ol><h3 id="Spring针对Bean管理中创建对象的操作提供的注解"><a href="#Spring针对Bean管理中创建对象的操作提供的注解" class="headerlink" title="Spring针对Bean管理中创建对象的操作提供的注解"></a>Spring针对Bean管理中创建对象的操作提供的注解</h3><ol><li><strong>@Component</strong></li><li><strong>@Service</strong></li><li><strong>@Controller</strong></li><li><strong>@Repository</strong></li><li>上面的四个注解功能是一样的，都是<strong>写在类上面，能够被ComponentScan扫描到，被扫描到之后将会把被注解的类注册到IOC容器中</strong>，但是<strong>为了保证项目的层次结构清晰明了，我们对不同层的Bean进行注册的时候，应该使用该层对应的注解</strong>，比如业务层注册Bean就应该使用@Service，控制层注册Bean就应该使用@Controller，持久层注册Bean就应该使用@Repository。</li></ol><h3 id="Spring针对Bean管理中注入属性的操作提供的注解"><a href="#Spring针对Bean管理中注入属性的操作提供的注解" class="headerlink" title="Spring针对Bean管理中注入属性的操作提供的注解"></a>Spring针对Bean管理中注入属性的操作提供的注解</h3><ol><li><p><strong>@Autowired</strong>：根据类型进行注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">//定义 dao 类型属性</span></span><br><span class="line"><span class="comment">//不需要添加 set 方法</span></span><br><span class="line"><span class="comment">//添加注入属性注解</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line">userDao.add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Qualifier</strong>：根据名称进行注入，需要一个名为value的参数，可以和@Autowired搭配进行使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义 dao 类型属性</span></span><br><span class="line"><span class="comment">//不需要添加 set 方法</span></span><br><span class="line"><span class="comment">//添加注入属性注解</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="comment">//根据类型进行注入</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;userDaoImpl1&quot;)</span></span><br><span class="line"><span class="comment">//根据名称进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Resource</strong>：带名称参数name使用就是根据名称进行注入，不带名称参数name使用就是根据类型进行注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Resource //根据类型进行注入</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;userDaoImpl1&quot;)</span></span><br><span class="line"><span class="comment">//根据名称进行注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure></li><li><p><strong>@Value</strong>：注入普通类型的属性，需要一个名为value的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;abc&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure></li></ol><h3 id="基于注解的方式实现对象的创建"><a href="#基于注解的方式实现对象的创建" class="headerlink" title="基于注解的方式实现对象的创建"></a>基于注解的方式实现对象的创建</h3><ol><li><p>引入依赖：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221126195059119.png" alt="image-20221126195059119"></p></li><li><p>开启组件扫描，<strong>组件扫描会扫描指定的包及其子包，扫描到被标识为Bean的类，会将其加入注册到IOC容器中</strong>（这里我有个问题，扫描到的时候会直接创建对象吗？还是说等使用的时候再创建相应的对象？），这里是使用xml配置的方式开启组件扫描，这一步也可以用注解进行实现。</p></li><li><p>创建类，在类上面添加注解将其标识为Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在注解里面 value 属性值可以省略不写，</span></span><br><span class="line"><span class="comment">//默认值是类名称，首字母小写</span></span><br><span class="line"><span class="comment">//UserService -- userService</span></span><br><span class="line"><span class="meta">@Component(value = &quot;userService&quot;)</span></span><br><span class="line"><span class="comment">//&lt;bean id=&quot;userService&quot; class=&quot;..&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>详细配置组件扫描的参数：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--示例 1</span></span><br><span class="line"><span class="comment">use-default-filters=&quot;false&quot; 表示现在不使用默认 filter，自己配置 filter</span></span><br><span class="line"><span class="comment">context:include-filter ，设置扫描哪些内容</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--示例 2</span></span><br><span class="line"><span class="comment">下面配置扫描包所有内容</span></span><br><span class="line"><span class="comment">context:exclude-filter： 设置哪些内容不进行扫描</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>基于注解方式实现属性注入：第一步 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解；第二步 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">//定义 dao 类型属性</span></span><br><span class="line"><span class="comment">//不需要添加 set 方法</span></span><br><span class="line"><span class="comment">//添加注入属性注解</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;service add.......&quot;</span>);</span><br><span class="line">userDao.add();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完全注解开发：上面的实现中还设计到xml配置文件的编写，这样实际上是比较不方便的，但是<strong>xml配置文件也可以用注解来实现</strong>，可以使用**@Configuration<strong>注解，</strong>被这个注解修饰的类会作为配置类，替代 xml 配置文件，在这个类上做的操作就相当于在之前的xml文件中做的配置**，这样整个实现就是完全基于注解的了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">//被这个注解修饰的类会作为配置类，替代 xml 配置文件，在这个类上做的操作就相当于在之前的xml文件中做的配置</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)</span><span class="comment">//配置组件扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试类进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testService2</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//加载配置类</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>,</span><br><span class="line">UserService.class);</span><br><span class="line">System.out.println(userService);</span><br><span class="line">    userService.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><ul><li><p>AOP即是<strong>面向切面（方面）编程</strong>，利用AOP可以<strong>对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率</strong>。</p></li><li><p>对于面向切面编程比较通俗的描述是：<strong>不通过修改源代码的方式，在主干功能里面添加新功能</strong>。</p></li><li><p>使用登录例子来说明AOP：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221127195023595.png" alt="image-20221127195023595"></p></li></ul><h2 id="AOP的底层原理"><a href="#AOP的底层原理" class="headerlink" title="AOP的底层原理"></a>AOP的底层原理</h2><ul><li>AOP的底层使用的是动态代理，有两种动态代理，分别是<strong>JDK动态代理和CGLIB动态代理</strong>。</li></ul><h3 id="被增强的类实现了接口的情况使用JDK动态代理"><a href="#被增强的类实现了接口的情况使用JDK动态代理" class="headerlink" title="被增强的类实现了接口的情况使用JDK动态代理"></a>被增强的类实现了接口的情况使用JDK动态代理</h3><ul><li><p>创建接口实现类代理对象，增强类的方法：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221127195703994.png" alt="image-20221127195703994"></p></li></ul><h3 id="被增强的类没实现接口的情况使用CGLIB动态代理"><a href="#被增强的类没实现接口的情况使用CGLIB动态代理" class="headerlink" title="被增强的类没实现接口的情况使用CGLIB动态代理"></a>被增强的类没实现接口的情况使用CGLIB动态代理</h3><ul><li><p>创建子类的代理对象增强类的方法：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221127195742084.png" alt="image-20221127195742084"></p></li></ul><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><h3 id="使用JDK动态代理，使用Proxy类里面的方法创建代理对象"><a href="#使用JDK动态代理，使用Proxy类里面的方法创建代理对象" class="headerlink" title="使用JDK动态代理，使用Proxy类里面的方法创建代理对象"></a>使用JDK动态代理，使用Proxy类里面的方法创建代理对象</h3><ul><li><p>用到的类在这儿：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221127201557295.png" alt="image-20221127201557295"></p></li><li><p>调用newProxyInstance方法来创建代理对象：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221127201704106.png" alt="image-20221127201704106"></p><p>这个方法有三个参数：</p><p>第一个参数是类加载器</p><p>第二个参数是增强方法所在的类实现的接口，支持多个接口</p><p>第三个参数是InvocationHandler这个接口的实现类，创建代理对象，写增强的部分</p></li></ul><h3 id="编写JDK动态代理的代码"><a href="#编写JDK动态代理的代码" class="headerlink" title="编写JDK动态代理的代码"></a>编写JDK动态代理的代码</h3><ol><li><p>创建接口，定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建接口实现类，实现方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(String id)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Proxy类创建接口代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKProxy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建接口实现类代理对象</span></span><br><span class="line">Class[] interfaces = &#123;UserDao.class&#125;;</span><br><span class="line"><span class="comment">//Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() &#123;</span></span><br><span class="line"><span class="comment">//@Override</span></span><br><span class="line"><span class="comment">//public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span></span><br><span class="line"><span class="comment">//return null;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//&#125;);</span></span><br><span class="line"><span class="type">UserDaoImpl</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line"><span class="type">UserDao</span> <span class="variable">dao</span> <span class="operator">=</span> (UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces,<span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(userDao));</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> dao.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建代理对象代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"><span class="comment">//1 把创建的是谁的代理对象，把谁传递过来</span></span><br><span class="line"><span class="comment">//有参数构造传递</span></span><br><span class="line"><span class="keyword">private</span> Object obj;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.obj = obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//增强的逻辑</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">//方法之前</span></span><br><span class="line">System.out.println(<span class="string">&quot;方法之前执行....&quot;</span>+method.getName()+<span class="string">&quot; :传递的参数...&quot;</span>+ Arrays.toString(args));</span><br><span class="line"><span class="comment">//被增强的方法执行</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line"><span class="comment">//方法之后</span></span><br><span class="line">System.out.println(<span class="string">&quot;方法之后执行....&quot;</span>+obj);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="AOP常用术语"><a href="#AOP常用术语" class="headerlink" title="AOP常用术语"></a>AOP常用术语</h2><h3 id="连接点"><a href="#连接点" class="headerlink" title="连接点"></a>连接点</h3><ul><li><strong>类里面那些可以被增强的方法称为连接点</strong>。</li></ul><h3 id="切入点"><a href="#切入点" class="headerlink" title="切入点"></a>切入点</h3><ul><li><strong>实际被真正增强的方法称为切入点</strong>。</li></ul><h3 id="增强（通知）"><a href="#增强（通知）" class="headerlink" title="增强（通知）"></a>增强（通知）</h3><ul><li><strong>实际增强的逻辑部分称为增强（通知）</strong>。</li><li>增强（通知）有多种类型：<strong>前置增强（通知）、后置增强（通知）、环绕增强（通知）、异常增强（通知）、最终增强（通知）</strong>。</li></ul><h3 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h3><ul><li>是一种动作，就是<strong>把增强（通知）应用到切入点的过程</strong>。</li></ul><h2 id="AOP操作的准备工作"><a href="#AOP操作的准备工作" class="headerlink" title="AOP操作的准备工作"></a>AOP操作的准备工作</h2><ul><li><p><strong>Spring框架一般都是基于AspectJ实现AOP操作，但是AspectJ不是Spring的组成部分</strong>，它是一个独立的AOP框架，一般我们把AspectJ和Spring框架一起使用，进行AOP操作。</p></li><li><p>基于AspectJ实现AOP操作有两种方式：<strong>第一种是基于xml配置文件实现，第二种是基于注解方式实现，第二种方式是我们普遍采用的方式</strong>。</p></li><li><p>在项目工程里面引入AOP相关依赖：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221128110244039.png" alt="image-20221128110244039"></p></li><li><p><strong>切入点表达式</strong>：</p><p>切入点表达式的作用：<strong>表示对哪个类里面的哪个方法进行增强</strong>。</p><p>语法结构：<strong>execution ( [权限修饰符] [返回类型] [类全路径] [方法名称] ( [参数列表] ) )</strong></p><p>举例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强 </p><p>execution(* com.atguigu.dao.BookDao.add(..))<br>举例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强<br>execution(* com.atguigu.dao.BookDao.* (..))</p><p>举例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强<br>execution(* com.atguigu.dao.*.* (..))</p></li></ul><h2 id="基于AspectJ相关注解实现AOP操作"><a href="#基于AspectJ相关注解实现AOP操作" class="headerlink" title="基于AspectJ相关注解实现AOP操作"></a>基于AspectJ相关注解实现AOP操作</h2><ol><li><p>创建类，在类里面定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;add.......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建增强类（编写增强逻辑）</p><ul><li><p>在增强类里面创建方法，<strong>可以让不同方法代表不同的增强（通知）类型</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;<span class="comment">//前置通知</span></span><br><span class="line">System.out.println(<span class="string">&quot;before......&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>进行增强（通知）的配置：</p><ul><li><p>在spring的配置文件中<strong>开启注解扫描</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.spring5.aopanno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用注解注册User和UserProxy对象</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221128111224087.png" alt="image-20221128111224087"></p></li><li><p><strong>在增强类上面添加注解@Aspect表示生成代理对象</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在spring配置文件中<strong>开启Aspect生成代理对象的功能</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启 Aspect 生成代理对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置不同类型的增强（通知）：</p><ul><li><p>在增强类的里面，<strong>在作为增强（通知）方法上面添加增强（通知）类型注解，使用切入点表达式配置</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line"><span class="comment">//前置通知</span></span><br><span class="line"><span class="comment">//@Before 注解表示作为前置通知</span></span><br><span class="line"><span class="meta">@Before(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;before.........&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后置通知（返回通知）</span></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(*com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;afterReturning.........&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终通知</span></span><br><span class="line"><span class="meta">@After(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;after.........&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异常通知</span></span><br><span class="line"><span class="meta">@AfterThrowing(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;afterThrowing.........&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//环绕通知</span></span><br><span class="line"><span class="meta">@Around(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;环绕之前.........&quot;</span>);</span><br><span class="line"><span class="comment">//被增强的方法执行</span></span><br><span class="line">proceedingJoinPoint.proceed();</span><br><span class="line">System.out.println(<span class="string">&quot;环绕之后.........&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>相同的切入点抽取</strong>：</p><ul><li><p>可以<strong>在类上使用@Pointcut(value &#x3D; 切入点表达式)来将被修饰的类作为切入点表达式的别名，以后可以直接使用”类名()”的形式来代指对应的切入点表达式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相同切入点抽取</span></span><br><span class="line"><span class="meta">@Pointcut(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointdemo</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置通知</span></span><br><span class="line"><span class="comment">//@Before 注解表示作为前置通知</span></span><br><span class="line"><span class="meta">@Before(value = &quot;pointdemo()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;before.........&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>有多个增强类对同一个方法进行增强，可以<strong>设置增强类的优先级</strong>：</p><ul><li><p><strong>在增强类上面添加注解@Order(数字类型值)，数字类型值越小优先级越高</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(1)</span> <span class="comment">//提问：这个注解可以应用在增强方法上吗？如果不能，那么对于被这个增强类增强的多个类对这个类分别有不同的优先级要求该怎么办？还是说不可能出现这种情况？</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonProxy</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>完全使用注解开发：</p><ul><li><p>创建配置类，不需要创建xml配置文件，<strong>使用@EnableAspectJAutoProxy(proxyTargetClass &#x3D; true)来开启 Aspect 生成代理对象的功能</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigAop</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="基于配置文件中AspectJ的相关配置实现AOP操作"><a href="#基于配置文件中AspectJ的相关配置实现AOP操作" class="headerlink" title="基于配置文件中AspectJ的相关配置实现AOP操作"></a>基于配置文件中AspectJ的相关配置实现AOP操作</h2><h1 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h1><h2 id="概念和准备"><a href="#概念和准备" class="headerlink" title="概念和准备"></a>概念和准备</h2><h3 id="什么是JDBCTemplate"><a href="#什么是JDBCTemplate" class="headerlink" title="什么是JDBCTemplate"></a>什么是JDBCTemplate</h3><ul><li>Spring框架对JDBC进行了封装，使用JDBCTemplate方便对数据库进行操作。</li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><p>引入相关jar包：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221129103952874.png" alt="image-20221129103952874"></p></li><li><p>在spring配置文件中配置数据库连接池：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///user_db&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置JDBCTemplate对象，注入DataSource：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JdbcTemplate 对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注入 dataSource--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建service类，创建dao接口实现类，在dao类中注入JDBCTemplate对象：</p><p>配置文件中开启组件扫描：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Service类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"><span class="comment">//注入 dao</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dao接口实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"><span class="comment">//注入 JdbcTemplate</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="JDBCTemplate操作数据库"><a href="#JDBCTemplate操作数据库" class="headerlink" title="JDBCTemplate操作数据库"></a>JDBCTemplate操作数据库</h2><h3 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h3><ol><li><p>创建对应数据库表的实体类：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221129104705354.png" alt="image-20221129104705354"></p></li><li><p>编写service和dao：</p><ul><li><p>调用JDBCTemplate对象里面的update方法实现添加操作，在dao接口的实现类中对数据库进行添加操作：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221129105140096.png" alt="image-20221129105140096"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"><span class="comment">//注入 JdbcTemplate</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"><span class="comment">//添加的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Book book)</span> &#123;</span><br><span class="line"><span class="comment">//1 创建 sql 语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_book values(?,?,?)&quot;</span>;</span><br><span class="line"><span class="comment">//2 调用方法实现</span></span><br><span class="line">Object[] args = &#123;book.getUserId(), book.getUsername(), book.getUstatus()&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql,args);</span><br><span class="line">System.out.println(update);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJdbcTemplate</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line"><span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;bookService&quot;</span>,BookService.class);</span><br><span class="line"><span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">book.setUserId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">book.setUsername(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">book.setUstatus(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">bookService.addBook(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221129104920764.png" alt="image-20221129104920764"></p></li></ol><h3 id="修改和删除操作"><a href="#修改和删除操作" class="headerlink" title="修改和删除操作"></a>修改和删除操作</h3><ul><li><p>修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateBook</span><span class="params">(Book book)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_book set username=?,ustatus=? where user_id=?&quot;</span>;</span><br><span class="line">Object[] args = &#123;book.getUsername(), book.getUstatus(),book.getUserId()&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, args);</span><br><span class="line">System.out.println(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String id)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from t_book where user_id=?&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> jdbcTemplate.update(sql, id);</span><br><span class="line">System.out.println(update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查询返回某个值"><a href="#查询返回某个值" class="headerlink" title="查询返回某个值"></a>查询返回某个值</h3><ul><li><p>场景：查询表里面有多少条记录，返回的是某个值</p></li><li><p>使用JDBCTemplate实现查询返回某个值的代码：<br><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221129105851998.png" alt="image-20221129105851998"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询表记录数</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">selectCount</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from t_book&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, Integer.class);</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查询返回对象"><a href="#查询返回对象" class="headerlink" title="查询返回对象"></a>查询返回对象</h3><ul><li><p>场景：查询图书详情</p></li><li><p>使用JDBCTemplate实现查询返回对象：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221129110122369.png" alt="image-20221129110122369"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询返回对象</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">findBookInfo</span><span class="params">(String id)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_book where user_id=?&quot;</span>;</span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line"><span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Book&gt;(Book.class), id);</span><br><span class="line"><span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查询返回集合"><a href="#查询返回集合" class="headerlink" title="查询返回集合"></a>查询返回集合</h3><ul><li><p>场景：查询图书列表分页</p></li><li><p>使用JDBCTemplate实现查询返回集合：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221129110640049.png" alt="image-20221129110640049"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询返回集合</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">findAllBook</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from t_book&quot;</span>;</span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">List&lt;Book&gt; bookList = jdbcTemplate.query(sql, <span class="keyword">new</span></span><br><span class="line"><span class="title class_">BeanPropertyRowMapper</span>&lt;Book&gt;(Book.class));</span><br><span class="line"><span class="keyword">return</span> bookList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><ul><li><p>批量操作：操作表里面多条记录</p></li><li><p>JDBCTemplate实现批量添加操作：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221129110903601.png" alt="image-20221129110903601"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量添加</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchAddBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into t_book values(?,?,?)&quot;</span>;</span><br><span class="line"><span class="type">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量添加测试</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Object[] o1 = &#123;<span class="string">&quot;3&quot;</span>,<span class="string">&quot;java&quot;</span>,<span class="string">&quot;a&quot;</span>&#125;;</span><br><span class="line">Object[] o2 = &#123;<span class="string">&quot;4&quot;</span>,<span class="string">&quot;c++&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line">Object[] o3 = &#123;<span class="string">&quot;5&quot;</span>,<span class="string">&quot;MySQL&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;</span><br><span class="line">batchArgs.add(o1);</span><br><span class="line">batchArgs.add(o2);</span><br><span class="line">batchArgs.add(o3);</span><br><span class="line"><span class="comment">//调用批量添加</span></span><br><span class="line">bookService.batchAdd(batchArgs);</span><br></pre></td></tr></table></figure></li><li><p>JDBCTemplate实现批量修改操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量修改</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchUpdateBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_book set username=?,ustatus=? where user_id=?&quot;</span>;</span><br><span class="line"><span class="type">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量修改</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Object[] o1 = &#123;<span class="string">&quot;java0909&quot;</span>,<span class="string">&quot;a3&quot;</span>,<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">Object[] o2 = &#123;<span class="string">&quot;c++1010&quot;</span>,<span class="string">&quot;b4&quot;</span>,<span class="string">&quot;4&quot;</span>&#125;;</span><br><span class="line">Object[] o3 = &#123;<span class="string">&quot;MySQL1111&quot;</span>,<span class="string">&quot;c5&quot;</span>,<span class="string">&quot;5&quot;</span>&#125;;</span><br><span class="line">batchArgs.add(o1);</span><br><span class="line">batchArgs.add(o2);</span><br><span class="line">batchArgs.add(o3);</span><br><span class="line"><span class="comment">//调用方法实现批量修改</span></span><br><span class="line">bookService.batchUpdate(batchArgs);</span><br></pre></td></tr></table></figure></li><li><p>JDBCTemplate实现批量删除操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量删除</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batchDeleteBook</span><span class="params">(List&lt;Object[]&gt; batchArgs)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from t_book where user_id=?&quot;</span>;</span><br><span class="line"><span class="type">int</span>[] ints = jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//批量删除</span></span><br><span class="line">List&lt;Object[]&gt; batchArgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Object[] o1 = &#123;<span class="string">&quot;3&quot;</span>&#125;;</span><br><span class="line">Object[] o2 = &#123;<span class="string">&quot;4&quot;</span>&#125;;</span><br><span class="line">batchArgs.add(o1);</span><br><span class="line">batchArgs.add(o2);</span><br><span class="line"><span class="comment">//调用方法实现批量删除</span></span><br><span class="line">bookService.batchDelete(batchArgs);</span><br></pre></td></tr></table></figure></li></ul><h1 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h1><h2 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><ul><li>事务<strong>是数据库操作最基本的单元</strong>，事务<strong>是逻辑上的一组操作</strong>，其<strong>具有原子性</strong>，<strong>要么都成功，如果其中有一个操作失败那么所有的操作都会失败</strong>。</li><li>典型场景：银行转账，a转账100给b，a会少100而b会多100，转账这个操作实际上就是一个事务，a少100和b多100要么都成功，如果a没有少100或者b没有多100，事务都会失败，然后回滚，如果事务没有原子性，很明显像上面这种场景下就没有办法保证转账的安全性了。</li></ul><h3 id="事务的四个特性（ACID）"><a href="#事务的四个特性（ACID）" class="headerlink" title="事务的四个特性（ACID）"></a>事务的四个特性（ACID）</h3><ul><li><strong>原子性（Atomicity）</strong>：<strong>一系列操作，要么都成功，要么都失败</strong>。</li><li><strong>一致性（Consistency）</strong>：一致性是指事务<strong>必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态</strong>。以上面的转账操作为例就是，这100元不能凭空消失，必须在a和b两者之一的手中。</li><li><strong>隔离性（Isolation）</strong>：<strong>多个并发的事务之间应该相互隔离，不能相互干扰</strong>。</li><li><strong>持久性（Durability）</strong>：<strong>一个事务一旦提交，对于数据库中的数据的改变是永久性的</strong>，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li></ul><h2 id="搭建事务的操作环境"><a href="#搭建事务的操作环境" class="headerlink" title="搭建事务的操作环境"></a>搭建事务的操作环境</h2><ul><li><p>以上面的转账场景为例子，需要实现的结构大致如下图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221130170842331.png" alt="image-20221130170842331"></p></li></ul><ol><li><p>创建数据库表，添加记录：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221130170943485.png" alt="image-20221130170943485"></p></li><li><p>创建service，搭建dao，完成对象创建和注入关系：</p><ul><li><p><strong>service注入dao，在dao注入JDBCTemplate，在JDBCTemplate注入DataSource</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">//注入 dao</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在dao创建两个方法：多钱和少钱的方法（分成两个方法主要是为了<strong>遵守单一职责原则</strong>），在service创建转账的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//lucy 转账 100 给 mary</span></span><br><span class="line"><span class="comment">//少钱</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduceMoney</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_account set money=money-? where username=?&quot;</span>;</span><br><span class="line">jdbcTemplate.update(sql,<span class="number">100</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//多钱</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMoney</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update t_account set money=money+? where username=?&quot;</span>;</span><br><span class="line">jdbcTemplate.update(sql,<span class="number">100</span>,<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">//注入 dao</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//转账的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accountMoney</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//lucy 少 100</span></span><br><span class="line">userDao.reduceMoney();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//mary 多 100</span></span><br><span class="line">userDao.addMoney();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面代码，如果正常执行没有问题的，但是如果代码执行过程中出现异常的话：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221130231843794.png" alt="image-20221130231843794"></p><p>如果中间没有出现异常的话，转账的流程是正确的，但是<strong>由于中间出现了一个异常，所以后面加钱的操作就无法执行了，这样就不满足一致性了，因为100块钱凭空消失了，并不是从一个一致性的状态转移道另外一个一致性状态了，这样的情况肯定是我们不想看到的</strong>，那么上面的问题该如何解决呢？可以<strong>使用事务进行解决</strong>，因为<strong>事务天生自带四个特性，中间出现异常之后由于事务的原子性，整个操作会回滚，虽然转账也没有成功，但是保证了一致性，100块钱没有凭空消失，这样的结果是我们可以接受的</strong>。</p></li><li><p>对上面的操作进行事务操作的理论流程：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221130232519954.png" alt="image-20221130232519954"></p></li></ol><h2 id="Spring事务管理介绍"><a href="#Spring事务管理介绍" class="headerlink" title="Spring事务管理介绍"></a>Spring事务管理介绍</h2><ul><li><p><strong>事务应该添加到JavaEE三层结构里面的Service层（业务逻辑层）中</strong></p></li><li><p>利用Spring进行事务管理操作有两种方式：<strong>编程式事务管理和声明式事务管理</strong>，后者是我们普遍使用的。</p></li><li><p>声明式事务管理有两种实现方式：可以<strong>基于注解方式实现（这也是普遍使用的方式）</strong>，也可以<strong>基于xml配置文件方式实现</strong>。</p></li><li><p>利用Spring进行声明式事务管理，<strong>底层使用到了AOP的原理</strong>。</p></li><li><p>Spring事务管理的API：</p><ul><li><p><strong>Spring提供了一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221130233116323.png" alt="image-20221130233116323"></p></li></ul></li></ul><h2 id="注解声明式事务管理（基于注解实现事务操作）"><a href="#注解声明式事务管理（基于注解实现事务操作）" class="headerlink" title="注解声明式事务管理（基于注解实现事务操作）"></a>注解声明式事务管理（基于注解实现事务操作）</h2><ol><li><p>在Spring配置文件中<strong>配置事务管理器</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在Spring配置文件中<strong>开启事务注解</strong>：</p><ul><li><p>在Spring配置文件<strong>引入名称空间tx</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>开启事务注解</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启事务注解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-</span></span></span><br><span class="line"><span class="tag"><span class="attr">manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>在service类上面（或者service类里面的方法上面）添加事务注解：</p><ul><li><p><strong>@Transactional，这个注解可以添加到类上面，也可以添加方法上面</strong></p></li><li><p>如果把这个注解添加类上面，这个类里面所有的方法都添加事务</p></li><li><p>如果把这个注解添加方法上面，为这个方法添加事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="声明式事务管理参数配置"><a href="#声明式事务管理参数配置" class="headerlink" title="声明式事务管理参数配置"></a>声明式事务管理参数配置</h2><ul><li><p>在service类上面添加注解**@Transactional**，在这个注解里面可以配置事务相关参数：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221201103415495.png" alt="image-20221201103415495"></p></li></ul><h3 id="propagation参数设置事务传播行为"><a href="#propagation参数设置事务传播行为" class="headerlink" title="propagation参数设置事务传播行为"></a>propagation参数设置事务传播行为</h3><ul><li><p><strong>有多个事务的方法直接进行调用，这个过程中事务是如何进行管理的？事务的传播行为就是来指定这个问题的解决方案的</strong>，这个问题有多种解决方案，通过设置这个参数来使用最符合场景的解决方案。</p></li><li><p><strong>事务方法：含有对数据库表数据进行变化的操作的方法</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221201104343196.png" alt="image-20221201104343196"></p></li><li><p><strong>Spring框架事务传播行为有七种</strong>，可以结合它们的特性和具体场景来选择使用哪种：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221201104621016.png" alt="image-20221201104621016"></p></li><li><p>参数的设置方式如下，实参是相应常量类中的常量：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221201105014480.png" alt="image-20221201105014480"></p></li></ul><h3 id="isolation参数设置事务隔离级别"><a href="#isolation参数设置事务隔离级别" class="headerlink" title="isolation参数设置事务隔离级别"></a>isolation参数设置事务隔离级别</h3><ul><li><p>事务有一个特性称为隔离性，这个隔离性也就是让多个事务操作之间不会互相产生影响，在实际应用中，如果不考虑事务的隔离性的话就会产生很多的问题。</p></li><li><p>其中有三种问题是事务的隔离级别不够造成的，它们分别是：<strong>脏读、不可重复读、虚（幻）读</strong></p></li><li><p><strong>脏读</strong>：即<strong>一个未提交事务读取到另一个未提交事务的数据</strong>，在下面的例子中事务A读取到了事务B中的还未进行提交的<strong>脏数据</strong>60000，而之后事务B进行了回滚，数据还是5000，这样就导致事务A读取到的数据是错误的。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221201110004055.png" alt="image-20221201110004055"></p></li><li><p><strong>不可重复读</strong>：即<strong>一个事务范围内两个相同的查询却返回了不同数据，这是由于查询时系统中其他事务修改的提交而引起的</strong>，比如下面这个例子，事务A进行了两次查询，第一次查询到的是5000，但是在第二次查询之前，事务B提交了修改数据的操作，事务A第一次读到的数据就被修改了，此时事务A再读一次，结果就和第一次读的时候的结果不同了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221203113144852.png" alt="image-20221203113144852"></p></li><li><p><strong>虚（幻）读</strong>：即<strong>一个事务进行多次相同条件的查询或修改时出现了原本不存在的数据或者原本存在的数据消失了，就像是产生幻觉一样，这通常是由于在当前事务的多个操作之间有别的事务添加或删除了一条或多条记录造成的</strong>，<strong>其定义和不可重复读有些相似，只不过造成不可重复读的是记录的修改，而造成幻读的是记录的添加和删除</strong>。比如事务A按照某个条件进行了一次查询，在事务A想要第二次查询的时候，事务B提交了一个增加数据的操作，这样事务A第二次查询出来的内容就和第一次查询出来的内容不同了。</p></li><li><p>对于以上三种读问题，我们可以通过设置参数isolation（即事物的隔离级别）来进行解决，但是要注意，<strong>事务的隔离级别越高，事务的读写性能就越低，因为是通过加锁来实现的嘛</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221203114513492.png" alt="image-20221203114513492"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221203114530378.png" alt="image-20221203114530378"></p></li></ul><h3 id="timeout参数设置超时时间"><a href="#timeout参数设置超时时间" class="headerlink" title="timeout参数设置超时时间"></a>timeout参数设置超时时间</h3><ul><li><strong>设置了超时时间之后，事务需要在指定的时间内进行提交，如果在指定的时间内事务没有进行提交，那么事务会进行回滚</strong>。</li><li><strong>这个参数的默认值是-1，也就是永不超时</strong>；设置的时间是<strong>以秒为单位</strong>的。</li></ul><h3 id="readOnly参数设置是否只读"><a href="#readOnly参数设置是否只读" class="headerlink" title="readOnly参数设置是否只读"></a>readOnly参数设置是否只读</h3><ul><li><strong>读就是查询操作</strong>，写就是添加、修改、删除操作</li><li><strong>readOnly的默认值是false，表示可以进行所有crud操作</strong></li><li><strong>将readOnly的值设置为true后，事务就只能进行查询操作</strong></li></ul><h3 id="rollbackFor参数设置哪些异常回滚"><a href="#rollbackFor参数设置哪些异常回滚" class="headerlink" title="rollbackFor参数设置哪些异常回滚"></a>rollbackFor参数设置哪些异常回滚</h3><ul><li>设置<strong>出现哪些异常后进行事务回滚</strong></li></ul><h3 id="noRollbackFor参数设置哪些异常不回滚"><a href="#noRollbackFor参数设置哪些异常不回滚" class="headerlink" title="noRollbackFor参数设置哪些异常不回滚"></a>noRollbackFor参数设置哪些异常不回滚</h3><ul><li>设置<strong>出现哪些异常之后不进行事务回滚</strong></li></ul><h2 id="XML声明式事务管理（基于XML配置文件实现事务操作）"><a href="#XML声明式事务管理（基于XML配置文件实现事务操作）" class="headerlink" title="XML声明式事务管理（基于XML配置文件实现事务操作）"></a>XML声明式事务管理（基于XML配置文件实现事务操作）</h2><h2 id="完全注解声明式事务管理"><a href="#完全注解声明式事务管理" class="headerlink" title="完全注解声明式事务管理"></a>完全注解声明式事务管理</h2><ul><li><p>创建配置类，使用配置类替代xml配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.atguigu&quot;)</span><span class="comment">//组件扫描</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span><span class="comment">//开启事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxConfig</span> &#123;</span><br><span class="line"><span class="comment">//创建数据库连接池</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DruidDataSource <span class="title function_">getDruidDataSource</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">dataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">dataSource.setUrl(<span class="string">&quot;jdbc:mysql:///user_db&quot;</span>);</span><br><span class="line">dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建 JdbcTemplate 对象</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> JdbcTemplate <span class="title function_">getJdbcTemplate</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line"><span class="comment">//到 ioc 容器中根据类型找到 dataSource</span></span><br><span class="line"><span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line"><span class="comment">//注入 dataSource</span></span><br><span class="line">jdbcTemplate.setDataSource(dataSource);</span><br><span class="line"><span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建事务管理器</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">getDataSourceTransactionManager</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line"><span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">transactionManager.setDataSource(dataSource);</span><br><span class="line"><span class="keyword">return</span> transactionManager;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Spring5框架新功能"><a href="#Spring5框架新功能" class="headerlink" title="Spring5框架新功能"></a>Spring5框架新功能</h1><h2 id="代码上的修改"><a href="#代码上的修改" class="headerlink" title="代码上的修改"></a>代码上的修改</h2><ul><li>整个Spring5框架的代码基于Java8，运行时兼容JDK9，许多不建议使用的类和方法在代码库中删除了。</li></ul><h2 id="通用的日志封装"><a href="#通用的日志封装" class="headerlink" title="通用的日志封装"></a>通用的日志封装</h2><ul><li><p>Spring5框架自带了通用的日志封装</p></li><li><p>Spring5已经移除Log4jConfigListener，官方<strong>建议使用Log4j2</strong></p></li><li><p>Spring5框架整合Log4j2：</p><ol><li><p>引入jar包：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221206162148512.png" alt="image-20221206162148512"></p></li><li><p>创建log4j2.xml配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span></span></span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt;</span></span><br><span class="line"><span class="comment">ALL --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Configuration 后面的 status 用于设置 log4j2 自身内部的信息输出，可以不设置，</span></span><br><span class="line"><span class="comment">当设置成 trace 时，可以看到 log4j2 内部各种详细输出--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--先定义所有的 appender--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--输出日志信息到控制台--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--控制日志输出的格式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--然后定义 logger，只有定义 logger 并引入的 appender，appender 才会生效--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--root：用于指定项目的根日志，如果没有单独指定 Logger，则会使用 root 作为</span></span><br><span class="line"><span class="comment">默认的日志输出--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="核心容器支持-Nullable注解"><a href="#核心容器支持-Nullable注解" class="headerlink" title="核心容器支持@Nullable注解"></a>核心容器支持@Nullable注解</h2><ul><li><p>@Nullable注解<strong>可以使用在方法、属性、参数上面，表示方法返回值、属性值、参数值可以为空</strong>。</p></li><li><p>@Nullable注解用在方法上面，表示方法返回值可以为空：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221206162703285.png" alt="image-20221206162703285"></p></li><li><p>@Nullable注解用在方法参数前面，表示方法参数可以为空：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221206162757312.png" alt="image-20221206162757312"></p></li><li><p>@Nullable注解使用在属性上面，表示属性值可以为空：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221206162843955.png" alt="image-20221206162843955"></p></li></ul><h2 id="核心容器支持函数式风格（GenericApplicationContext）"><a href="#核心容器支持函数式风格（GenericApplicationContext）" class="headerlink" title="核心容器支持函数式风格（GenericApplicationContext）"></a>核心容器支持函数式风格（GenericApplicationContext）</h2><ul><li><p>下面是一个用函数式风格创建对象交给Spring进行管理的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数式风格创建对象，交给 spring 进行管理</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGenericApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//1 创建 GenericApplicationContext 对象</span></span><br><span class="line"><span class="type">GenericApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class="line"><span class="comment">//2 调用 context 的方法对象注册</span></span><br><span class="line">context.refresh();</span><br><span class="line">context.registerBean(<span class="string">&quot;user1&quot;</span>,User.class,() -&gt; <span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">    <span class="comment">//3 获取在 spring 注册的对象</span></span><br><span class="line"><span class="comment">// User user = (User)context.getBean(&quot;com.atguigu.spring5.test.User&quot;);</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)context.getBean(<span class="string">&quot;user1&quot;</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="支持整合JUnit5"><a href="#支持整合JUnit5" class="headerlink" title="支持整合JUnit5"></a>支持整合JUnit5</h2><ul><li><p>整合JUnit4：</p><ol><li><p>引入Spring相关针对测试的依赖：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221206164908060.png" alt="image-20221206164908060"></p></li><li><p>创建测试类，使用注解方式完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span><span class="comment">//单元测试框架</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean1.xml&quot;)</span><span class="comment">//加载配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JTest4</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">userService.accountMoney();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>整合JUnit5：</p><ol><li><p>引入JUnit5的jar包：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221206165041897.png" alt="image-20221206165041897"></p></li><li><p>创建测试类，使用注解完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(SpringExtension.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:bean1.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JTest5</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">userService.accountMoney();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用一个<strong>复合注解@SpringJUnitConfig</strong>来替代上面两个注解完成整合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(locations = &quot;classpath:bean1.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JTest5</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">userService.accountMoney();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="WebFlux"><a href="#WebFlux" class="headerlink" title="WebFlux"></a>WebFlux</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;Spring5框架概述&quot;&gt;&lt;a href=&quot;#Spring5框架概述&quot; class=&quot;headerlink&quot; title=&quot;Spring5框架概述&quot;&gt;&lt;/a&gt;Spring</summary>
      
    
    
    
    
    <category term="Spring" scheme="https://konjacor.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis入门</title>
    <link href="https://konjacor.github.io/2022/09/08/Mybatis%E5%85%A5%E9%97%A8/"/>
    <id>https://konjacor.github.io/2022/09/08/Mybatis%E5%85%A5%E9%97%A8/</id>
    <published>2022-09-08T14:25:24.000Z</published>
    <updated>2023-03-04T09:03:51.896Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><ol><li>获取参数用${}不会自动加单引号，获取参数用#{}会自动加单引号</li></ol><h1 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h1><h2 id="MyBatis历史"><a href="#MyBatis历史" class="headerlink" title="MyBatis历史"></a>MyBatis历史</h2><ul><li><strong>MyBatis最初是Apache的一个开源项目iBatis</strong>, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github。</li><li>iBatis一词来源于“internet”和“abatis”的组合，是一个<strong>基于Java的持久层框架</strong>。 iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）。</li></ul><h2 id="MyBatis特性"><a href="#MyBatis特性" class="headerlink" title="MyBatis特性"></a>MyBatis特性</h2><ol><li>MyBatis 是支持<strong>定制化 SQL</strong>、<strong>存储过程</strong>以及<strong>高级映射</strong>的优秀的持久层框架</li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li><li>MyBatis可以使用<strong>简单的XML或注解</strong>用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录</li><li>MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架</li></ol><h2 id="MyBatis下载"><a href="#MyBatis下载" class="headerlink" title="MyBatis下载"></a>MyBatis下载</h2><ul><li><p>下载地址：<a href="https://github.com/mybatis/mybatis-3">https://github.com/mybatis/mybatis-3</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220916105207380.png" alt="image-20220916105207380"></p></li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220916105221318.png" alt="image-20220916105221318"></p><h2 id="SpringBoot整合MyBatis"><a href="#SpringBoot整合MyBatis" class="headerlink" title="SpringBoot整合MyBatis"></a>SpringBoot整合MyBatis</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><ul><li><p>Spring Boot 整合 MyBatis 的第一步，就是在项目的 pom.xml 中引入 mybatis-spring-boot-starter 的依赖，示例代码如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入 mybatis-spring-boot-starter 的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="配置MyBatis"><a href="#配置MyBatis" class="headerlink" title="配置MyBatis"></a>配置MyBatis</h3><ul><li><p>在 Spring Boot 的配置文件（application.properties&#x2F;yml）中对 MyBatis 进行配置，例如指定 mapper.xml 的位置、实体类的位置、是否开启驼峰命名法等等，示例代码如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###################################### MyBatis 配置######################################</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment"># 指定 mapper.xml 的位置</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span></span><br><span class="line">  <span class="comment">#扫描实体类的位置,在此处指明扫描实体类的包，在 mapper.xml 中就可以不写实体类的全路径名</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.konjacer.service.bean</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#默认开启下划线映射驼峰，可以不用设置该属性</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span>  </span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：使用 MyBatis 时，必须配置数据源信息，例如数据库 URL、数据库用户型、数据库密码和数据库驱动等。</p></blockquote><h3 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h3><h3 id="创建Mapper接口"><a href="#创建Mapper接口" class="headerlink" title="创建Mapper接口"></a>创建Mapper接口</h3><blockquote><p>当 mapper 接口较多时，我们可以在 Spring Boot 主启动类或者配置类上使用 @MapperScan 注解扫描指定包下的 mapper 接口，而不再需要在每个 mapper 接口上都标注@Mapper 注解。</p></blockquote><h3 id="创建Mapper映射文件"><a href="#创建Mapper映射文件" class="headerlink" title="创建Mapper映射文件"></a>创建Mapper映射文件</h3><ul><li>在配置文件 application.properties&#x2F;yml 通过 mybatis.mapper-locations 指定的位置中创建 UserMapper.xml</li><li>使用 Mapper 进行开发时，需要遵循以下规则：<ol><li>mapper 映射文件中 namespace 必须与对应的 mapper 接口的完全限定名一致。</li><li>mapper 映射文件中 statement 的 id 必须与 mapper 接口中的方法的方法名一致。</li><li>mapper 映射文件中 statement 的 parameterType 指定的类型必须与 mapper 接口中方法的参数类型一致。</li><li>mapper 映射文件中 statement 的 resultType 指定的类型必须与 mapper 接口中方法的返回值类型一致。</li></ol></li></ul><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><ul><li><p>MyBatis 针对实际实际业务中使用最多的“增删改查”操作，分别提供了以下注解来替换 mapper 映射文件，简化配置：</p><ol><li>@Select</li><li>@Insert</li><li>@Update</li><li>@Delete</li></ol></li><li><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where user_name = #&#123;userName,jdbcType=VARCHAR&#125; and password = #&#123;password,jdbcType=VARCHAR&#125;&quot;)</span></span><br><span class="line">    List&lt;User&gt; <span class="title function_">getByUserNameAndPassword</span><span class="params">(User user)</span>;</span><br><span class="line">    <span class="meta">@Delete(&quot;delete from user where id = #&#123;id,jdbcType=INTEGER&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteByPrimaryKey</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user ( user_id, user_name, password, email)&quot; +</span></span><br><span class="line"><span class="meta">            &quot;values ( #&#123;userId,jdbcType=VARCHAR&#125;, #&#123;userName,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, #&#123;email,jdbcType=VARCHAR&#125;)&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(User record)</span>;</span><br><span class="line">    <span class="meta">@Update(&quot; update user&quot; +</span></span><br><span class="line"><span class="meta">            &quot;    set user_id = #&#123;userId,jdbcType=VARCHAR&#125;,\n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;      user_name = #&#123;userName,jdbcType=VARCHAR&#125;,\n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;      password = #&#123;password,jdbcType=VARCHAR&#125;,\n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;      email = #&#123;email,jdbcType=VARCHAR&#125;\n&quot; +</span></span><br><span class="line"><span class="meta">            &quot;    where id = #&#123;id,jdbcType=INTEGER&#125;&quot;)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateByPrimaryKey</span><span class="params">(User record)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意事项：mapper 接口中的任何一个方法，都只能使用一种配置方式，即注解和 mapper 映射文件二选一，但不同方法之间，这两种方式则可以混合使用，例如方法 1 使用注解方式，方法 2 使用 mapper 映射文件方式。</p></li><li><p>我们可以根据 SQL 的复杂程度，选择不同的方式来提高开发效率：</p><ul><li>如果<strong>没有复杂的连接查询，我们可以使用注解的方式来简化配置</strong>（不过这个可以被MyBatisPlus的基本功能实现代替）；</li><li>如果<strong>涉及的 sql 较为复杂时，则使用 XML （mapper 映射文件）的方式更好一些</strong>。</li></ul></li></ul><h2 id="和其他持久化层技术对比"><a href="#和其他持久化层技术对比" class="headerlink" title="和其他持久化层技术对比"></a>和其他持久化层技术对比</h2><ul><li><p>JDBC</p><ol><li>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤</li><li>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见</li><li>代码冗长，开发效率低</li></ol></li><li><p>Hibernate 和 JPA</p><ol><li>操作简便，开发效率高</li><li>程序中的长难复杂 SQL 需要绕过框架</li><li>内部自动生产的 SQL，不容易做特殊优化</li><li>基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。</li><li>反射操作太多，导致数据库性能下降</li></ol></li><li><p>MyBatis</p><ol><li>轻量级，性能出色</li><li>SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据</li><li>开发效率稍逊于Hibernate，但是完全能够接受</li></ol></li></ul><h1 id="搭建MyBatis"><a href="#搭建MyBatis" class="headerlink" title="搭建MyBatis"></a>搭建MyBatis</h1><h2 id="示例开发环境"><a href="#示例开发环境" class="headerlink" title="示例开发环境"></a>示例开发环境</h2><ul><li>IDE：idea 2019.2</li><li>构建工具：maven 3.5.4</li><li>MySQL版本：MySQL 5.7</li><li>MyBatis版本：MyBatis 3.5.7</li></ul><h2 id="创建Maven工程"><a href="#创建Maven工程" class="headerlink" title="创建Maven工程"></a>创建Maven工程</h2><ul><li><p>打包方式jar：<code>&lt;packaging&gt;jar&lt;/packaging&gt;</code></p></li><li><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mybatis核心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="创建MyBatis的核心配置文件"><a href="#创建MyBatis的核心配置文件" class="headerlink" title="创建MyBatis的核心配置文件"></a>创建MyBatis的核心配置文件</h2><ul><li><p>习惯上命名为<strong>mybatis-config.xml</strong>，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。</p></li><li><p><strong>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息</strong></p></li><li><p>核心配置文件存放的位置是src&#x2F;main&#x2F;resources目录下</p></li><li><p>配置示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置连接数据库的环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/MyBatis&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="创建mapper接口"><a href="#创建mapper接口" class="headerlink" title="创建mapper接口"></a>创建mapper接口</h2><ul><li><p>MyBatis中的mapper接口<strong>相当于以前的dao</strong>。但是区别在于，mapper仅仅是接口，我们不需要提供实现类。底层估计是用到了<strong>cglib代理</strong>。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加用户信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="创建MyBatis的映射文件"><a href="#创建MyBatis的映射文件" class="headerlink" title="创建MyBatis的映射文件"></a>创建MyBatis的映射文件</h2><ul><li><p>相关概念：ORM（Object Relationship Mapping）对象关系映射。</p><ol><li>对象：Java的实体类对象</li><li>关系：关系型数据库</li><li>映射：二者之间的对应关系</li></ol></li><li><table><thead><tr><th>Java概念</th><th>数据库概念</th></tr></thead><tbody><tr><td>类</td><td>表</td></tr><tr><td>属性</td><td>字段&#x2F;列</td></tr><tr><td>对象</td><td>记录&#x2F;行</td></tr></tbody></table></li><li><p>映射文件的命名规则：<strong>表所对应的实体类的类名+Mapper.xml</strong><br>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml，因此一个映射文件对应一个实体类，对应一张表的操作MyBatis映射文件用于编写SQL，访问以及操作表中的数据，MyBatis映射文件存放的位置是src&#x2F;main&#x2F;resources&#x2F;mappers目录下</p></li><li><p>MyBatis中可以面向接口操作数据，要保证两个一致：</p><ol><li><strong>mapper接口的全类名和映射文件的命名空间（namespace）保持一致</strong></li><li>mapper接口中方法的<strong>方法名和映射文件中编写SQL的标签的id属性保持一致</strong></li></ol></li><li><p>代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--int insertUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,&#x27;张三&#x27;,&#x27;123&#x27;,23,&#x27;女&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="通过junit测试功能"><a href="#通过junit测试功能" class="headerlink" title="通过junit测试功能"></a>通过junit测试功能</h2><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取MyBatis的核心配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SqlSessionFactoryBuilder对象</span></span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line"><span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务</span></span><br><span class="line"><span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession();</span></span><br><span class="line"><span class="comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过代理模式创建UserMapper接口的代理实现类对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insertUser();</span><br><span class="line"></span><br><span class="line"><span class="comment">//sqlSession.commit();</span></span><br><span class="line">System.out.println(<span class="string">&quot;结果：&quot;</span>+result);</span><br></pre></td></tr></table></figure></li><li><p>SqlSession：代表<strong>Java程序和数据库之间的会话</strong>。（HttpSession是Java程序和浏览器之间的会话）</p></li><li><p>SqlSessionFactory：是“生产”SqlSession的“工厂”。</p></li><li><p>用到了工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。</p></li></ul><h2 id="加入log4j日志功能"><a href="#加入log4j日志功能" class="headerlink" title="加入log4j日志功能"></a>加入log4j日志功能</h2><ul><li><p>加入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>加入log4j的配置文件（log4j的配置文件名为log4j.xml，存放的位置是src&#x2F;main&#x2F;resources目录下）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">log4j</span>:configuration <span class="keyword">SYSTEM</span> <span class="string">&quot;log4j.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;Encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ConversionPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \n&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="日志的级别"><a href="#日志的级别" class="headerlink" title="日志的级别"></a>日志的级别</h3><ul><li>FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试)  从左到右打印的内容越来越详细</li></ul><h1 id="核心配置文件详解"><a href="#核心配置文件详解" class="headerlink" title="核心配置文件详解"></a>核心配置文件详解</h1><ul><li><p>核心配置文件中的标签必须按照固定的顺序书写：properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers? 如果不按照这个顺序书写的话就会报错。</p></li><li><p>示例配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//MyBatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">typeAlias：设置某个具体的类型的别名</span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">type：需要设置别名的类型的全类名</span></span><br><span class="line"><span class="comment">alias：设置此类型的别名，若不设置此属性，该类型拥有默认的别名，即类名且不区分大小写</span></span><br><span class="line"><span class="comment">若设置此属性，此时该类型的别名只能使用alias所设置的值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&gt;&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;abc&quot;&gt;</span></span><br><span class="line"><span class="comment">&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.bean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">environments：设置多个连接数据库的环境</span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">default：设置默认使用的环境的id</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">environment：设置具体的连接数据库的环境信息</span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">transactionManager：设置事务管理方式</span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;</span></span><br><span class="line"><span class="comment">type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理</span></span><br><span class="line"><span class="comment">type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">dataSource：设置数据源</span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span></span><br><span class="line"><span class="comment">type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建</span></span><br><span class="line"><span class="comment">type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建</span></span><br><span class="line"><span class="comment">type=&quot;JNDI&quot;：调用上下文中的数据源</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置驱动类的全类名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置连接数据库的连接地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置连接数据库的用户名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置连接数据库的密码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">以包为单位，将包下所有的映射文件引入核心配置文件</span></span><br><span class="line"><span class="comment">注意：此方式必须保证mapper接口和mapper映射文件必须在相同的包下</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="MyBatis的增删改查"><a href="#MyBatis的增删改查" class="headerlink" title="MyBatis的增删改查"></a>MyBatis的增删改查</h1><ul><li>这里的例子是在mapper接口对应的xml文件中进行配置，<strong>一般会将mapper中的方法签名复制到对应的xml文件中当作注释来辅助配置的编写</strong>，除了在配置文件中进行配置外也可以使用注解进行开发。</li></ul><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><ul><li><p>示例代码：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><ul><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span>&gt;</span></span><br><span class="line">delete from t_user where id = 7</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int updateUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">update t_user set username=&#x27;ybc&#x27;,password=&#x27;123&#x27; where id = 6</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="查询一个实体类对象"><a href="#查询一个实体类对象" class="headerlink" title="查询一个实体类对象"></a>查询一个实体类对象</h2><ul><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserById();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where id = 2</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="查询集合"><a href="#查询集合" class="headerlink" title="查询集合"></a>查询集合</h2><ul><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><p>查询的标签select必须设置属性<strong>resultType或resultMap</strong>，用于设置实体类和数据库表的映射关系，设置了这个mybatis才直到要把查出来的东西以什么样的规则放到哪里。</p><ul><li>resultType：自动映射，用于属性名和表中字段名一致的情况，mybatis会把查出来的记录的字段按照名称（或是一定的映射关系，如下划线和驼峰之间的映射）对设置的实体类中的属性进行赋值。<strong>注意：就算是查询结果有多条，也不能声明其类型为list，只需让方法的返回值为List即可，因为这个属性的作用是指定映射关系，所以无论返回值有多少，我们应该在其中声明需要进行映射的实体类而不是其容器。</strong></li><li>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</li></ul></li><li><p><strong>当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常<br>TooManyResultsException</strong>；但是若查询的数据只有一条，可以使用实体类或集合作为返回值</p></li></ol><h1 id="MyBatis获取参数值的两种方式（重点）"><a href="#MyBatis获取参数值的两种方式（重点）" class="headerlink" title="MyBatis获取参数值的两种方式（重点）"></a>MyBatis获取参数值的两种方式（重点）</h1><ul><li>MyBatis获取参数值的两种方式：**${}** 和 <strong>#{}<strong>，${}的本质就是</strong>字符串拼接</strong>，#{}的本质就是<strong>占位符赋值</strong></li><li><strong>${}<strong>使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号，</strong>不会自动添加单引号</strong>；但是**#{}<strong>使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以</strong>自动添加单引号**。</li></ul><h2 id="单个字面量类型的参数"><a href="#单个字面量类型的参数" class="headerlink" title="单个字面量类型的参数"></a>单个字面量类型的参数</h2><ul><li>若mapper接口中的方法参数为单个的字面量类型此时可以使用${}和#{}在大括号中间指定<strong>以任意的名称</strong>获取参数的值，注意${}需要手动加单引号</li></ul><h2 id="多个字面量类型的参数"><a href="#多个字面量类型的参数" class="headerlink" title="多个字面量类型的参数"></a>多个字面量类型的参数</h2><ul><li>若mapper接口中的方法参数为多个时，此时MyBatis会<strong>自动将这些参数放在一个map集合中，以arg0,arg1…为键，以参数为值；以param1,param2…为键，以参数为值</strong>；因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</li></ul><h2 id="map集合类型的参数"><a href="#map集合类型的参数" class="headerlink" title="map集合类型的参数"></a>map集合类型的参数</h2><ul><li>若mapper接口中的方法需要的参数为多个时，此时可以<strong>手动创建map集合并将其作为参数传入mapper中的方法中</strong>，将这些数据放在map中只需要<strong>通过${}和#{}访问map集合的键</strong>就可以获取相对应的值，注意${}需要手动加单引号</li></ul><h2 id="实体类类型的参数"><a href="#实体类类型的参数" class="headerlink" title="实体类类型的参数"></a>实体类类型的参数</h2><ul><li>若mapper接口中的方法参数为实体类对象时此时可以<strong>使用${}和#{}，通过访问实体类对象中的属性名</strong>获取属性值，注意${}需要手动加单引号</li></ul><h2 id="使用-Param标识参数"><a href="#使用-Param标识参数" class="headerlink" title="使用@Param标识参数"></a>使用@Param标识参数</h2><ul><li>可以<strong>通过@Param注解标识mapper接口中的方法参数</strong>，此时会将这些参数放在map集合中，<strong>以@Param注解的value属性值为键，以参数为值；以param1,param2…为键，以参数为值</strong>；只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</li><li>实际情况下mapper中的方法参数有很多种情况，<strong>推荐都使用@Param注解对参数进行标识来实现一种统一的访问形式</strong>。</li></ul><h1 id="MyBatis的各种查询功能的实现"><a href="#MyBatis的各种查询功能的实现" class="headerlink" title="MyBatis的各种查询功能的实现"></a>MyBatis的各种查询功能的实现</h1><h2 id="查询一个实体类对象-1"><a href="#查询一个实体类对象-1" class="headerlink" title="查询一个实体类对象"></a>查询一个实体类对象</h2><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据用户id查询用户信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserById(@Param(&quot;id&quot;) int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="查询一个list集合"><a href="#查询一个list集合" class="headerlink" title="查询一个list集合"></a>查询一个list集合</h2><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询所有用户信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUserList</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="查询单个数据"><a href="#查询单个数据" class="headerlink" title="查询单个数据"></a>查询单个数据</h2><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询用户的总记录数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* 在MyBatis中，对于Java中常用的类型都设置了类型别名</span></span><br><span class="line"><span class="comment">* 例如：java.lang.Integer--&gt;int|integer</span></span><br><span class="line"><span class="comment">* 例如：int--&gt;_int|_integer</span></span><br><span class="line"><span class="comment">* 例如：Map--&gt;map,List--&gt;list</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int getCount();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;_integer&quot;</span>&gt;</span></span><br><span class="line">select count(id) from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="查询一条数据为map集合"><a href="#查询一条数据为map集合" class="headerlink" title="查询一条数据为map集合"></a>查询一条数据为map集合</h2><ul><li>通过Map&lt;String,Object&gt;类型来接受查出来的记录，MyBatis会自动将转换后的字段名为key，字段对应的值为value存放到map中，不和List一样，<strong>map类型需要在resultType属性中进行声明</strong>，因为<strong>map本身就表示一种处理映射关系的方式，可以作为一种规则被提供</strong>，还是那句话，<strong>resultType和resultMap是为了指定映射的方式，因此在填这个属性的时候一定要先想一想自己填的这个是否能为MyBatis准确地提供一种映射方式</strong>，不然你懵机器也懵。</li></ul><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><ul><li>代码示例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询所有用户信息为map集合</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><ul><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询所有用户信息为map集合</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并</span></span><br><span class="line"><span class="comment">且最终要以一个map的方式返回数据，此时需要通过<span class="doctag">@MapKey</span>注解设置map集合的键，值是每条数据所对应的</span></span><br><span class="line"><span class="comment">map集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">结果：</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">1=&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span></span><br><span class="line"><span class="comment">2=&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span></span><br><span class="line"><span class="comment">3=&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="特殊SQL的执行"><a href="#特殊SQL的执行" class="headerlink" title="特殊SQL的执行"></a>特殊SQL的执行</h1><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 测试模糊查询</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> mohu</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">testMohu</span><span class="params">(<span class="meta">@Param(&quot;mohu&quot;)</span> String mohu)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; testMohu(@Param(&quot;mohu&quot;) String mohu);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;testMohu&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27; 会有sql注入的风险，不推荐使用--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;)--&gt;</span></span><br><span class="line">select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;<span class="comment">&lt;!--推荐使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 批量删除</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> ids</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteMore</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> String ids)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteMore(@Param(&quot;ids&quot;) String ids);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMore&quot;</span>&gt;</span></span><br><span class="line">delete from t_user where id in ($&#123;ids&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="动态设置表名"><a href="#动态设置表名" class="headerlink" title="动态设置表名"></a>动态设置表名</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 动态设置表名，查询所有的用户信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> tableName</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getAllUser</span><span class="params">(<span class="meta">@Param(&quot;tableName&quot;)</span> String tableName)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getAllUser(@Param(&quot;tableName&quot;) String tableName);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from $&#123;tableName&#125;<span class="comment">&lt;!--注意表名是没有单引号的，所以这个地方不适合用#&#123;&#125;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="添加功能获取自增的主键"><a href="#添加功能获取自增的主键" class="headerlink" title="添加功能获取自增的主键"></a>添加功能获取自增的主键</h2><ul><li>有表：t_clazz(clazz_id,clazz_name)和t_student(student_id,student_name,clazz_id)</li><li>要求：<ol><li>添加班级信息</li><li>获取新添加的班级的id</li><li>为班级分配学生，即将某学的班级id修改为新添加的班级的id</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 添加用户信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* useGeneratedKeys：设置使用自增的主键</span></span><br><span class="line"><span class="comment">* keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参</span></span><br><span class="line"><span class="comment">数user对象的某个属性中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="自定义映射resultMap"><a href="#自定义映射resultMap" class="headerlink" title="自定义映射resultMap"></a>自定义映射resultMap</h1><h2 id="resultMap处理字段和属性的映射关系"><a href="#resultMap处理字段和属性的映射关系" class="headerlink" title="resultMap处理字段和属性的映射关系"></a>resultMap处理字段和属性的映射关系</h2><ul><li><p>若<strong>字段名和实体类中的属性名不一致或是不能通过特定的映射方式（如下划线映射驼峰）进行映射</strong>，则可以通过resultMap设置自定义映射。</p></li><li><p>实例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">resultMap：设置自定义映射</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">id：表示自定义映射的唯一标识</span></span><br><span class="line"><span class="comment">type：查询的数据要映射的实体类的类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">子标签：</span></span><br><span class="line"><span class="comment">id：设置主键的映射关系</span></span><br><span class="line"><span class="comment">result：设置普通字段的映射关系</span></span><br><span class="line"><span class="comment">association：设置多对一的映射关系</span></span><br><span class="line"><span class="comment">collection：设置一对多的映射关系</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">属性：</span></span><br><span class="line"><span class="comment">property：设置映射关系中实体类中的属性名</span></span><br><span class="line"><span class="comment">column：设置映射关系中表中的字段名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;user_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--List&lt;User&gt; testMohu(@Param(&quot;mohu&quot;) String mohu);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;testMohu&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt;</span></span><br><span class="line">select id,user_name,password,age,sex from t_user where user_name like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰），此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系：</p><ol><li>可以通过<strong>为字段起别名</strong>的方式，保证和实体类中的属性名保持一致</li><li>可以在MyBatis的核心配置文件中设置一个全局配置信息<strong>mapUnderscoreToCamelCase&#x3D;true</strong>，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为<br>userName</li></ol></li></ul><h2 id="多对一映射处理"><a href="#多对一映射处理" class="headerlink" title="多对一映射处理"></a>多对一映射处理</h2><ul><li>要求查询员工信息以及员工所对应部门的信息，员工和员工所属部门是多对一的关系。</li><li>其中这个<strong>“一”可以在resultMap中用association表示</strong>。</li></ul><h3 id="单步查询并用级联方式处理映射关系"><a href="#单步查询并用级联方式处理映射关系" class="headerlink" title="单步查询并用级联方式处理映射关系"></a>单步查询并用级联方式处理映射关系</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empDeptMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.dname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDeptByEid(@Param(&quot;eid&quot;) int eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByEid&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empDeptMap&quot;</span>&gt;</span></span><br><span class="line">select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did = dept.did where emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用association处理映射关系"><a href="#使用association处理映射关系" class="headerlink" title="使用association处理映射关系"></a>使用association处理映射关系</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empDeptMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDeptByEid(@Param(&quot;eid&quot;) int eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByEid&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empDeptMap&quot;</span>&gt;</span></span><br><span class="line">select emp.*,dept.* from t_emp emp left join t_dept dept on emp.did = dept.did where emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="分步查询"><a href="#分步查询" class="headerlink" title="分步查询"></a>分步查询</h3><ul><li><p>这样做往往效率比较高</p></li><li><p>首先查询员工信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 通过分步查询查询员工信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> eid</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Emp <span class="title function_">getEmpByStep</span><span class="params">(<span class="meta">@Param(&quot;eid&quot;)</span> <span class="type">int</span> eid)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empDeptStepMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">select：设置分步查询，查询某个属性的值的sql的标识（namespace.sqlId）</span></span><br><span class="line"><span class="comment">column：将sql以及查询结果中的某个字段设置为分步查询的条件</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.atguigu.MyBatis.mapper.DeptMapper.getEmpDeptByStep&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="comment">&lt;!--在这里配置了下一步要进行的查询语句，查询出来的内容会被映射到这个association中--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpByStep(@Param(&quot;eid&quot;) int eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByStep&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empDeptStepMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后根据员工所对应的部门id查询部门信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分步查询的第二步：根据员工所对应的did查询部门信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> did</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Dept <span class="title function_">getEmpDeptByStep</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> <span class="type">int</span> did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Dept getEmpDeptByStep(@Param(&quot;did&quot;) int did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpDeptByStep&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line">select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="一对多映射处理"><a href="#一对多映射处理" class="headerlink" title="一对多映射处理"></a>一对多映射处理</h2><ul><li><p>要求查询部门信息以及部门中的所有员工信息，部门和部门下的员工是一对多的关系。</p></li><li><p>这个“多”可以在resultMap中用collection表示</p></li></ul><h3 id="单步查询并使用collection处理映射关系"><a href="#单步查询并使用collection处理映射关系" class="headerlink" title="单步查询并使用collection处理映射关系"></a>单步查询并使用collection处理映射关系</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据部门id查新部门以及部门中的员工信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> did</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Dept <span class="title function_">getDeptEmpByDid</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> <span class="type">int</span> did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptEmpMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">ofType：设置collection标签所处理的集合属性中存储数据的类型</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptEmpByDid(@Param(&quot;did&quot;) int did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptEmpByDid&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;deptEmpMap&quot;</span>&gt;</span></span><br><span class="line">select dept.*,emp.* from t_dept dept left join t_emp emp on dept.did = emp.did where dept.did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="分步查询-1"><a href="#分步查询-1" class="headerlink" title="分步查询"></a>分步查询</h3><ul><li><p>这样做往往效率比较高</p></li><li><p>首先查询部门信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 分步查询部门和部门中的员工</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> did</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Dept <span class="title function_">getDeptByStep</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> <span class="type">int</span> did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptEmpStep&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;eager&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.atguigu.MyBatis.mapper.EmpMapper.getEmpListByDid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptByStep(@Param(&quot;did&quot;) int did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptByStep&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;deptEmpStep&quot;</span>&gt;</span></span><br><span class="line">select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>根据部门id查询部门中的所有员工</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 根据部门id查询员工信息</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> did</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;Emp&gt; <span class="title function_">getEmpListByDid</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> <span class="type">int</span> did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpListByDid(@Param(&quot;did&quot;) int did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpListByDid&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="分步查询的优点"><a href="#分步查询的优点" class="headerlink" title="分步查询的优点"></a>分步查询的优点</h2><ul><li><p>可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：</p><ol><li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载</li><li>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载</li></ol></li><li><p>设置完以上的配置后，就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时<strong>可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载</strong>，<strong>fetchType&#x3D;”lazy(延迟加载)|eager(立即加载)”</strong></p></li></ul><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><ul><li>Mybatis框架的动态SQL技术是一种<strong>根据特定条件动态拼装SQL语句的功能</strong>，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题。</li></ul><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><ul><li><p>if标签<strong>可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</strong>。</p></li><li><p>要注意可能会出现冗余的关键字影响mybatis解析代码。</p></li><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpListByMoreTJ(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpListByMoreTJ&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where 1=1<span class="comment">&lt;!--防止出现冗余的and--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != &#x27;&#x27; and ename != null&quot;</span>&gt;</span></span><br><span class="line">and ename = #&#123;ename&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != &#x27;&#x27; and age != null&quot;</span>&gt;</span></span><br><span class="line">and age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != &#x27;&#x27; and sex != null&quot;</span>&gt;</span></span><br><span class="line">and sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><ul><li><p>是消除冗余的关键字的另外一种可行的方式</p></li><li><p>where和if一般结合使用：</p><ol><li>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字</li><li>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and去</li><li><strong>where标签不能去掉条件最后多余的and</strong></li></ol></li><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpListByMoreTJ2&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != &#x27;&#x27; and ename != null&quot;</span>&gt;</span></span><br><span class="line">ename = #&#123;ename&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != &#x27;&#x27; and age != null&quot;</span>&gt;</span></span><br><span class="line">and age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != &#x27;&#x27; and sex != null&quot;</span>&gt;</span></span><br><span class="line">and sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><ul><li><p>trim用于<strong>去掉或者添加标签中的内容</strong>，常用属性：</p><ol><li>prefix：在trim标签中的内容的前面添加某些内容</li><li>prefixOverrides：在trim标签中的内容的前面去掉某些内容</li><li>suffix：在trim标签中的内容的后面添加某些内容</li><li>suffixOverrides：在trim标签中的内容的后面去掉某些内容</li></ol></li><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpListByMoreTJ&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != &#x27;&#x27; and ename != null&quot;</span>&gt;</span></span><br><span class="line">ename = #&#123;ename&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != &#x27;&#x27; and age != null&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != &#x27;&#x27; and sex != null&quot;</span>&gt;</span></span><br><span class="line">sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h2><ul><li><p>choose、when、otherwise类似于if…else if…else</p></li><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpListByChoose(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpListByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;ename != &#x27;&#x27; and ename != null&quot;</span>&gt;</span></span><br><span class="line">ename = #&#123;ename&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;age != &#x27;&#x27; and age != null&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sex != &#x27;&#x27; and sex != null&quot;</span>&gt;</span></span><br><span class="line">sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;email != &#x27;&#x27; and email != null&quot;</span>&gt;</span></span><br><span class="line">email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><ul><li><p>常用属性：</p><ol><li>collection：设置要循环的数组或集合</li><li>item：表示集合或数组中的每一个数据</li><li>separator：设置循环体之间的分隔符</li><li>open：设置foreach标签中的内容的开始符</li><li>close：设置foreach标签中的内容的结束符</li></ol></li><li><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertMoreEmp(List&lt;Emp&gt; emps);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertMoreEmp&quot;</span>&gt;</span></span><br><span class="line">insert into t_emp values</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">(null,#&#123;emp.ename&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null)</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--int deleteMoreByArray(int[] eids);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMoreByArray&quot;</span>&gt;</span></span><br><span class="line">delete from t_emp where</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;eids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span>&gt;</span></span><br><span class="line">eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--int deleteMoreByArray(int[] eids);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMoreByArray&quot;</span>&gt;</span></span><br><span class="line">delete from t_emp where eid in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;eids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">#&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h2><ul><li><p>sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入</p></li><li><p>代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span></span><br><span class="line">    eid,ename,age,sex,did</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> from t_emp</span><br></pre></td></tr></table></figure></li></ul><h1 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h1><h2 id="MyBatis的一级缓存"><a href="#MyBatis的一级缓存" class="headerlink" title="MyBatis的一级缓存"></a>MyBatis的一级缓存</h2><ul><li><p>一级缓存是SqlSession级别的，<strong>通过同一个SqlSession查询的数据会被缓存</strong>，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问。</p></li><li><p>使一级缓存失效的四种情况（还是挺容易想到的）：</p><ol><li>不同的SqlSession对应不同的一级缓存</li><li>同一个SqlSession但是查询条件不同</li><li>同一个SqlSession两次查询期间执行了任何一次增删改操作</li><li>同一个SqlSession两次查询期间手动清空了缓存</li></ol></li></ul><h2 id="MyBatis的二级缓存"><a href="#MyBatis的二级缓存" class="headerlink" title="MyBatis的二级缓存"></a>MyBatis的二级缓存</h2><ul><li><p>二级缓存是SqlSessionFactory级别，<strong>通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存</strong>；此后若再次执行相同的查询语句，结果就会从缓存中获取</p></li><li><p>二级缓存开启的条件：</p><ol><li>在核心配置文件中，设置<strong>全局配置属性cacheEnabled&#x3D;”true”<strong>，</strong>默认为true</strong>，不需要设置</li><li>在映射文件中设置标签&lt;cache &#x2F;&gt;</li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型<strong>必须实现序列化的接口</strong></li></ol></li><li><p>使二级缓存失效的情况：<strong>两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</strong></p></li></ul><h2 id="二级缓存的相关配置"><a href="#二级缓存的相关配置" class="headerlink" title="二级缓存的相关配置"></a>二级缓存的相关配置</h2><ul><li><p>在mapper配置文件中添加的cache标签可以设置一些属性：</p><ol><li><p>eviction属性：缓存回收策略</p><p><strong>LRU（Least Recently Used）</strong> – 最近最少使用的：移除最长时间不被使用的对象。<br><strong>FIFO（First in First out）</strong> – 先进先出：按对象进入缓存的顺序来移除它们。<br><strong>SOFT – 软引用</strong>：移除基于垃圾回收器状态和软引用规则的对象。<br><strong>WEAK – 弱引用</strong>：更积极地移除基于垃圾收集器状态和弱引用规则的对象。<br><strong>默认的是 LRU</strong>。</p></li><li><p>flushInterval属性：刷新间隔，单位毫秒<br><strong>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新</strong></p></li><li><p>size属性：引用数目，正整数<br>代表<strong>缓存最多可以存储多少个对象</strong>，太大容易导致内存溢出</p></li><li><p>readOnly属性：只读，true&#x2F;false<br>true：只读缓存；<strong>会给所有调用者返回缓存对象的相同实例</strong>。因此<strong>这些对象不能被修改</strong>。这提供了很重要的<strong>性能优势</strong>。<br>false：读写缓存；会<strong>返回缓存对象的拷贝（通过序列化）</strong>。这会<strong>慢一些</strong>，但是<strong>安全</strong>，因此默认是false。</p></li></ol></li></ul><h2 id="MyBatis缓存查询的顺序"><a href="#MyBatis缓存查询的顺序" class="headerlink" title="MyBatis缓存查询的顺序"></a>MyBatis缓存查询的顺序</h2><ul><li><strong>先查询二级缓存</strong>，因为<strong>二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用</strong>。</li><li>如果二级缓存没有命中，再查询一级缓存</li><li>如果一级缓存也没有命中，则查询数据库</li><li><strong>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</strong></li></ul><h2 id="整合第三方缓存EHCache"><a href="#整合第三方缓存EHCache" class="headerlink" title="整合第三方缓存EHCache"></a>整合第三方缓存EHCache</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mybatis EHCache整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- slf4j日志门面的一个具体实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="各jar包的功能"><a href="#各jar包的功能" class="headerlink" title="各jar包的功能"></a>各jar包的功能</h3><table><thead><tr><th>jar包名称</th><th>作用</th></tr></thead><tbody><tr><td>mybatis-ehcache</td><td>Mybatis和EHCache的整合包</td></tr><tr><td>ehcache</td><td>EHCache核心包</td></tr><tr><td>slf4j-api</td><td>SLF4J日志门面包</td></tr><tr><td>logback-classic</td><td>支持SLF4J门面接口的一个具体实现</td></tr></tbody></table><h3 id="创建EHCache的配置文件ehcache-xml"><a href="#创建EHCache的配置文件ehcache-xml" class="headerlink" title="创建EHCache的配置文件ehcache.xml"></a>创建EHCache的配置文件ehcache.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;../config/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 磁盘保存路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;D:\atguigu\ehcache&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">maxElementsOnDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="设置二级缓存的类型"><a href="#设置二级缓存的类型" class="headerlink" title="设置二级缓存的类型"></a>设置二级缓存的类型</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="加入logback日志"><a href="#加入logback日志" class="headerlink" title="加入logback日志"></a>加入logback日志</h3><ul><li><p>存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。创建<strong>logback的配置文件logback.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定日志输出的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 日志输出的格式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread][%logger][%msg]%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 根据特殊需求指定局部日志级别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.crowd.mapper&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="EHCache配置文件说明"><a href="#EHCache配置文件说明" class="headerlink" title="EHCache配置文件说明"></a>EHCache配置文件说明</h3><table><thead><tr><th>属性名</th><th>是否必须</th><th>作用</th></tr></thead><tbody><tr><td>maxElementsInMemory</td><td>是</td><td>在内存中缓存的element的最大数目</td></tr><tr><td>maxElementsOnDisk</td><td>是</td><td>在磁盘上缓存的element的最大数目，若是0表示无穷大</td></tr><tr><td>eternal</td><td>是</td><td>设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断</td></tr><tr><td>overflowToDisk</td><td>是</td><td>设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上</td></tr><tr><td>timeToIdleSeconds</td><td>否</td><td>当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大</td></tr><tr><td>timeToLiveSeconds</td><td>否</td><td>缓存element的有效生命期，默认是0.,也就是element存活时间无穷大</td></tr><tr><td>diskSpoolBufferSizeMB</td><td>否</td><td>DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区</td></tr><tr><td>diskPersistent</td><td>否</td><td>在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。</td></tr><tr><td>diskExpiryThreadIntervalSeconds</td><td>否</td><td>磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作</td></tr><tr><td>memoryStoreEvictionPolicy</td><td>否</td><td>当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出）</td></tr></tbody></table><h1 id="MyBatis的逆向工程"><a href="#MyBatis的逆向工程" class="headerlink" title="MyBatis的逆向工程"></a>MyBatis的逆向工程</h1><ul><li>正向工程：<strong>先创建Java实体类，由框架负责根据实体类生成数据库表</strong>。Hibernate是支持正向工程的。</li><li>逆向工程：<strong>先创建数据库表，由框架负责根据数据库表</strong>，反向生成如下资源：<ol><li>Java实体类</li><li>Mapper接口</li><li>Mapper映射文件</li></ol></li></ul><h2 id="创建逆向工程的步骤"><a href="#创建逆向工程的步骤" class="headerlink" title="创建逆向工程的步骤"></a>创建逆向工程的步骤</h2><h3 id="添加依赖和插件"><a href="#添加依赖和插件" class="headerlink" title="添加依赖和插件"></a>添加依赖和插件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 依赖MyBatis核心包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 构建过程中用到的插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">&lt;!-- 插件的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                </span><br><span class="line"><span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                </span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建MyBatis的核心配置文件-1"><a href="#创建MyBatis的核心配置文件-1" class="headerlink" title="创建MyBatis的核心配置文件"></a>创建MyBatis的核心配置文件</h3><ul><li>前面写过了</li></ul><h3 id="创建逆向工程的配置文件"><a href="#创建逆向工程的配置文件" class="headerlink" title="创建逆向工程的配置文件"></a>创建逆向工程的配置文件</h3><ul><li><p>文件名必须是：<strong>generatorConfig.xml</strong></p></li><li><p>代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span> </span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">targetRuntime: 执行生成的逆向工程的版本</span></span><br><span class="line"><span class="comment">MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span></span><br><span class="line"><span class="comment">MyBatis3: 生成带条件的CRUD（奢华尊享版）</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库的连接信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- javaBean的生成策略--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.bean&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\resources&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mapper接口的生成策略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 逆向分析的表 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_emp&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Emp&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_dept&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Dept&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="执行MBG插件的generate目标"><a href="#执行MBG插件的generate目标" class="headerlink" title="执行MBG插件的generate目标"></a>执行MBG插件的generate目标</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220923211033152.png" alt="image-20220923211033152"></p><ul><li><p>效果：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220923211049760.png" alt="image-20220923211049760"></p></li></ul><h2 id="QBC查询"><a href="#QBC查询" class="headerlink" title="QBC查询"></a>QBC查询</h2><ul><li><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMBG</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is).openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="type">EmpExample</span> <span class="variable">empExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmpExample</span>();</span><br><span class="line"><span class="comment">//创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系</span></span><br><span class="line">empExample.createCriteria().andEnameLike(<span class="string">&quot;a&quot;</span>).andAgeGreaterThan(<span class="number">20</span>).andDidIsNotNull();</span><br><span class="line"><span class="comment">//将之前添加的条件通过or拼接其他条件</span></span><br><span class="line">empExample.or().andSexEqualTo(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">List&lt;Emp&gt; list = mapper.selectByExample(empExample);</span><br><span class="line"><span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">System.out.println(emp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h1><h2 id="分页插件配置步骤"><a href="#分页插件配置步骤" class="headerlink" title="分页插件配置步骤"></a>分页插件配置步骤</h2><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置分页插件"><a href="#配置分页插件" class="headerlink" title="配置分页插件"></a>配置分页插件</h3><ul><li><p>在MyBatis的核心配置文件中配置插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置分页插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="分页插件的使用"><a href="#分页插件的使用" class="headerlink" title="分页插件的使用"></a>分页插件的使用</h2><ul><li><p>在<strong>查询功能之前</strong>使用**PageHelper.startPage(int pageNum, int pageSize)**开启分页功能：</p><ol><li>pageNum：表示当前页的页码</li><li>pageSize：表示每页显示的条数</li></ol></li><li><p>在<strong>查询获取list集合之后</strong>，使用**PageInfo&lt;T&gt; pageInfo &#x3D; new PageInfo&lt;&gt;(List&lt;T&gt; list, int navigatePages)**获取分页相关数据：</p><ol><li>list：分页之后的数据</li><li>navigatePages：导航分页的页码数</li></ol></li><li><p>分页相关数据示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PageInfo&#123;</span><br><span class="line">pageNum=8, pageSize=4, size=2, startRow=29, endRow=30, total=30, pages=8,</span><br><span class="line">list=Page&#123;count=true, pageNum=8, pageSize=4, startRow=28, endRow=32, total=30,pages=8, reasonable=false, pageSizeZero=false&#125;,</span><br><span class="line">prePage=7, nextPage=0, isFirstPage=false, isLastPage=true, hasPreviousPage=true,hasNextPage=false, navigatePages=5,navigateFirstPage4, navigateLastPage8,</span><br><span class="line">navigatepageNums=[4, 5, 6, 7, 8]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分页数据中的常用数据，可以通过这些数据的组合来渲染页面：</p><ol><li>pageNum：当前页的页码</li><li>pageSize：每页显示的条数</li><li>size：当前页显示的真实条数</li><li>total：总记录数</li><li>pages：总页数</li><li>prePage：上一页的页码</li><li>nextPage：下一页的页码</li><li>isFirstPage&#x2F;isLastPage：是否为第一页&#x2F;最后一页</li><li>hasPreviousPage&#x2F;hasNextPage：是否存在上一页&#x2F;下一页</li><li>navigatePages：导航分页的页码数</li><li>navigatePageNums：导航分页的页码，如[12,3,4,5]</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;ol&gt;
&lt;li&gt;获取参数用${}不会自动加单引号，获取参数用#{}会自动加单引号&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;MyBatis简介&quot;&gt;&lt;a href=&quot;#MyBatis简介&quot; </summary>
      
    
    
    
    
    <category term="Mybatis" scheme="https://konjacor.github.io/tags/Mybatis/"/>
    
  </entry>
  
</feed>

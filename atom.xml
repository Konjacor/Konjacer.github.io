<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤舟</title>
  <icon>https://www.gravatar.com/avatar/e5611663fc514deb557f849c3a23baeb</icon>
  <subtitle>静静地漂泊在思绪的海洋中</subtitle>
  <link href="https://konjacor.github.io/atom.xml" rel="self"/>
  
  <link href="https://konjacor.github.io/"/>
  <updated>2024-03-17T13:38:18.388Z</updated>
  <id>https://konjacor.github.io/</id>
  
  <author>
    <name>Konjacer</name>
    <email>1175590069@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>离散数学</title>
    <link href="https://konjacor.github.io/2024/03/15/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    <id>https://konjacor.github.io/2024/03/15/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/</id>
    <published>2024-03-15T09:54:51.000Z</published>
    <updated>2024-03-17T13:38:18.388Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315180041113.png" alt="image-20240315180041113"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315175936713.png" alt="image-20240315175936713"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315181232808.png" alt="image-20240315181232808"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315184659066.png" alt="image-20240315184659066"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315185025999.png" alt="image-20240315185025999"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315191942509.png" alt="image-20240315191942509"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315192113429.png" alt="image-20240315192113429"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315193558265.png" alt="image-20240315193558265"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315231917392.png" alt="image-20240315231917392"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315232459878.png" alt="image-20240315232459878"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315232648175.png" alt="image-20240315232648175"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315232744096.png" alt="image-20240315232744096"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315232829215.png" alt="image-20240315232829215"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315233055632.png" alt="image-20240315233055632"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315233151676.png" alt="image-20240315233151676"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315233305082.png" alt="image-20240315233305082"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316161551993.png" alt="image-20240316161551993"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316161917839.png" alt="image-20240316161917839"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316162131407.png" alt="image-20240316162131407"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316162645324.png" alt="image-20240316162645324"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316163543001.png" alt="image-20240316163543001"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316163521560.png" alt="image-20240316163521560"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316163500333.png" alt="image-20240316163500333"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316170215343.png" alt="image-20240316170215343"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316170417821.png" alt="image-20240316170417821"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316172047930.png" alt="image-20240316172047930"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316172212659.png" alt="image-20240316172212659"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316172355853.png" alt="image-20240316172355853"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316172659260.png" alt="image-20240316172659260"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316172643017.png" alt="image-20240316172643017"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316173011058.png" alt="image-20240316173011058"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316173113373.png" alt="image-20240316173113373"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316174401170.png" alt="image-20240316174401170"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316174535522.png" alt="image-20240316174535522"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316174632818.png" alt="image-20240316174632818"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316174748114.png" alt="image-20240316174748114"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316175040442.png" alt="image-20240316175040442"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316175451764.png" alt="image-20240316175451764"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316175610039.png" alt="image-20240316175610039"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316175740842.png" alt="image-20240316175740842"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316213857712.png" alt="image-20240316213857712"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316214116350.png" alt="image-20240316214116350"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316214355207.png" alt="image-20240316214355207"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316214443304.png" alt="image-20240316214443304"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316214818141.png" alt="image-20240316214818141"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316214856758.png" alt="image-20240316214856758"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316215639223.png" alt="image-20240316215639223"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316220124839.png" alt="image-20240316220124839"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316220415477.png" alt="image-20240316220415477"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316220602403.png" alt="image-20240316220602403"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240316220704219.png" alt="image-20240316220704219"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317165900898.png" alt="image-20240317165900898"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317170031496.png" alt="image-20240317170031496"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317170306425.png" alt="image-20240317170306425"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317170435734.png" alt="image-20240317170435734"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317170722485.png" alt="image-20240317170722485"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317171119989.png" alt="image-20240317171119989"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317171319000.png" alt="image-20240317171319000"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317171649454.png" alt="image-20240317171649454"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317173459214.png" alt="image-20240317173459214"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317173642279.png" alt="image-20240317173642279"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317173930399.png" alt="image-20240317173930399"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317174135984.png" alt="image-20240317174135984"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317174214666.png" alt="image-20240317174214666"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317193823089.png" alt="image-20240317193823089"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317194021310.png" alt="image-20240317194021310"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317194152860.png" alt="image-20240317194152860"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317194425193.png" alt="image-20240317194425193"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317194820572.png" alt="image-20240317194820572"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317195002297.png" alt="image-20240317195002297"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317195232905.png" alt="image-20240317195232905"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317195437180.png" alt="image-20240317195437180"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317195758982.png" alt="image-20240317195758982"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317200017969.png" alt="image-20240317200017969"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317200148844.png" alt="image-20240317200148844"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317200318444.png" alt="image-20240317200318444"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317202755524.png" alt="image-20240317202755524"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317203007945.png" alt="image-20240317203007945"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317203136296.png" alt="image-20240317203136296"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317203253315.png" alt="image-20240317203253315"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317203632225.png" alt="image-20240317203632225"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317203807023.png" alt="image-20240317203807023"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317204247008.png" alt="image-20240317204247008"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317212828155.png" alt="image-20240317212828155"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317212957977.png" alt="image-20240317212957977"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317213150887.png" alt="image-20240317213150887"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317213252268.png" alt="image-20240317213252268"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317213441485.png" alt="image-20240317213441485"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240317213759394.png" alt="image-20240317213759394"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;p&gt;&lt;img src=&quot;https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240315180</summary>
      
    
    
    
    
    <category term="离散数学" scheme="https://konjacor.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>毕业设计开发日志</title>
    <link href="https://konjacor.github.io/2024/01/07/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <id>https://konjacor.github.io/2024/01/07/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</id>
    <published>2024-01-07T15:06:39.000Z</published>
    <updated>2024-04-18T08:51:52.537Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>我准备写一个比较实用的开源软件作为我的毕业设计，选题是即时通讯和信息发布系统。</li><li>我做这个毕业设计的目的不单单只是为了完成任务，更是为了完整地复习和巩固自己学过的关于网络空间安全和软件工程的知识，所以我决定将我做这个软件的过程记录下来，以便日后进行复习。</li><li>由于在考研过程中我读了一遍南京大学的软件工程教材——《软件工程与计算 卷2 软件开发的技术基础》，对那本教材比较熟悉，所以我决定以那个教材的软件开发过程为主要参考来进行开发。</li><li>在之前做项目的过程中，我常常觉得疑惑，自己所做的工作究竟是软件开发中的哪一个环节呢？这一环节的前面和后面又要做什么工作呢？应该如何开始做一个项目呢？应该如何有效率地管理一个项目呢？这些问题时常会出现在我的脑海中，我相信在做毕业设计的过程中我会更加深入地了解这些问题。</li><li>如果说之前做项目时是锻炼了自己对于业务的抽象能力以及在微观层面上的逻辑和编程能力，那么这个毕设项目就是在此基础上让我能从宏观的角度来把握一个软件的完整开发流程，而这正是我所缺少的。</li></ul><h1 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><h2 id="系统用户"><a href="#系统用户" class="headerlink" title="系统用户"></a>系统用户</h2><h2 id="用户访谈要点"><a href="#用户访谈要点" class="headerlink" title="用户访谈要点"></a>用户访谈要点</h2><h2 id="项目实践过程"><a href="#项目实践过程" class="headerlink" title="项目实践过程"></a>项目实践过程</h2><ul><li><p>下图是一个比较标准的项目实践过程，以后开发项目的时候可以以这个过程作为参考：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240117203010424.png" alt="image-20240117203010424"></p></li></ul><h2 id="团队结构的选择"><a href="#团队结构的选择" class="headerlink" title="团队结构的选择"></a>团队结构的选择</h2><ul><li>不用选，因为就我一个人</li></ul><h2 id="团队章程"><a href="#团队章程" class="headerlink" title="团队章程"></a>团队章程</h2><h2 id="基线"><a href="#基线" class="headerlink" title="基线"></a>基线</h2><ul><li><p>因为工作协同是配置管理的出发点，所以某个制品只有进入工作协同中时才能算作是配置项。例如，在需求开发过程中的需求文档还没有得到各方的认同，所以不会被作为设计、测试等后续工作的基础，这个时候的需求文档不是配置项，不会纳入正式的配置管理，对它的修改不需要进行变更控制。但是如果需求开发过程结束，经过评审建立了正式的需求文档，这时它就会被正式地传递给设计人员和测试人员，作为后续开发工作的基础，这时的需求文档就是配置项，需要纳人配置管理，只有通过正式的变更控制过程才能修改它的内容。</p></li><li><p>经过了评审和验证，可以作为后续开发工作基础而进入协同工作过程，需要纳入配置管理和执行变更控制的制品称为该配置项的基线(baseline)。也就是说，基线的建立意味着一个里程碑，标志着产生基线制品活动的成功结束和后续协同开发活动的开始。</p></li><li><p>[IEEE610.12-1990]将基线定义为：“已经经过正式评审的规格说明或制品，可以作为进一步开发的基础，并且只有通过正式的变更控制过程才能变更。”</p></li><li><p>基线建立之后的配置项被统一存储到存储库中，在配置管理工具的帮助下进行配置管理，如下图所示。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240117205418306.png" alt="image-20240117205418306"></p></li></ul><h2 id="选择配置管理工具"><a href="#选择配置管理工具" class="headerlink" title="选择配置管理工具"></a>选择配置管理工具</h2><ul><li>选git</li></ul><h2 id="软件的基本结构"><a href="#软件的基本结构" class="headerlink" title="软件的基本结构"></a>软件的基本结构</h2><ul><li>分为三个部分，首先就是spring boot写两部分的后端为两个前端提供服务，然后一个是移动端客户端用来使用主要服务，再者是网页端客户端给管理员用来进行管理。</li></ul><h1 id="需求开发"><a href="#需求开发" class="headerlink" title="需求开发"></a>需求开发</h1><h2 id="常见的需求分析模型"><a href="#常见的需求分析模型" class="headerlink" title="常见的需求分析模型"></a>常见的需求分析模型</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240201172427165.png" alt="image-20240201172427165"></p><ul><li>每一种需求模型解决不同的问题，每完成一个需求模型，需求整体就越明确。</li></ul><h2 id="结构化分析"><a href="#结构化分析" class="headerlink" title="结构化分析"></a>结构化分析</h2><ul><li><p>结构化分析的简单过程如下图所示：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240201172720464.png" alt="image-20240201172720464"></p></li></ul><h3 id="数据流图-DFD"><a href="#数据流图-DFD" class="headerlink" title="数据流图(DFD)"></a>数据流图(DFD)</h3><h4 id="表示方式"><a href="#表示方式" class="headerlink" title="表示方式"></a>表示方式</h4><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240201175850341.png" alt="image-20240201175850341"></p><h4 id="含义描述"><a href="#含义描述" class="headerlink" title="含义描述"></a>含义描述</h4><ul><li>外部实体是指处于待构建软件系统之外的人、组织、设备或者其他软件系统，它们不受系统的控制，开发者不能以任何方式操纵它们。在数据流图中需要进行建模的外部实体是那些和待构建软件系统之间存在着数据交互的外部实体，它们从待构建软件系统中获取数据或者为待构建软件系统提供数据，即它们是待构建软件系统的数据源或者数据目的地。</li><li>过程是指施加于数据的动作或者行为，它们使得数据发生变化，包括被转换、被存储或者被分布。过程是系统中发生的数据处理行为，它可能是由软件系统控制的，也可能是由人.工执行的，它重视数据发生变化的效果而不是其执行者。所以在建模的时候，人们会将现有系统中的人工处理任务也作为系统行为的一部分描述为过程，并将这些部分作为重点关注部分，以期在新的系统中实现自动化支持。</li><li>数据流是指数据的运动，它是系统与其环境之间或者系统内两个过程之间的通信形式。DFD的数据流是必须和过程产生关联的，它要么是过程的数据输入，要么是过程的数据输出。</li><li>数据存储是软件系统需要在内部收集、保存，以供日后使用的数据集合。如果说数据流描述的是运动的数据,那么数据存储描述的就是静止的数据。</li><li>需要指出的是，数据存储区的数据流入和流出通常表示实际的数据流入和流出。因此，如果流入和流出存储区的数据流包含与存储区相同的信息，则不用为数据流专门指定名称。但是如果流入或流出存储区的数据流包含存储区中信息的子集，就必须指定这个数据流的名称。</li></ul><h4 id="画图规则"><a href="#画图规则" class="headerlink" title="画图规则"></a>画图规则</h4><ol><li>过程是对数据的处理，必须有输入，也必须有输出，而且输入数据集和输出数据集应该存在差异。</li><li>数据流是必须和过程产生关联的，它要么是过程的数据输入，要么是过程的数据输出。</li><li>DFD中所有的对象都应该有一个可以唯一标识自己的名称。过程使用动词，外部实体、数据流和数据存储使用名词。</li></ol><h4 id="DFD图示例（非上下文图和0层图）"><a href="#DFD图示例（非上下文图和0层图）" class="headerlink" title="DFD图示例（非上下文图和0层图）"></a>DFD图示例（非上下文图和0层图）</h4><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240207215836075.png" alt="image-20240207215836075"></p><h4 id="DFD的分层结构"><a href="#DFD的分层结构" class="headerlink" title="DFD的分层结构"></a>DFD的分层结构</h4><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240201180636674.png" alt="image-20240201180636674"></p><ul><li>利用过程具有不同抽象层次表述能力的特点，依据过程的功能分解结构，建立层次式的DFD描述。</li><li>上下文图只有一个过程，0层图概述所有功能，N层图对0层图中的过程进行进一步分解，尽量让外部实体不出现在N层图中。</li><li>过程分解的平衡原则：在过程分解过程中，最重要的是要保证分解的平衡性。平衡性是保证分解过程不会出现需求偏差的方法，它要求DFD子图的输入流、输出流必须和父过程的输入流、输出流保持一致。</li></ul><h3 id="实体关系图-ERD"><a href="#实体关系图-ERD" class="headerlink" title="实体关系图(ERD)"></a>实体关系图(ERD)</h3><h4 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h4><ul><li><p>ER图有很多种表示方法，下面是一个我感觉比较直观的表示方法——James Martin表示法：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240207215412386.png" alt="image-20240207215412386"></p></li></ul><h4 id="含义描述-1"><a href="#含义描述-1" class="headerlink" title="含义描述"></a>含义描述</h4><ul><li><p>参与关系的每个实体都<strong>针对关系拥有最大基数和最小基数</strong>。</p></li><li><p>最大基数是指:对关系中任意的其他实体实例，该实体可能参与关系的最大数量。在最大基数为“1”时，实体在关系中的最大基数会被标记为“One”。在最大基数超过“1”时，实体在关系中的最大基数会被标记为“Many”。</p></li><li><p>最小基数是指:对关系中任意的其他实体实例,该实体可能参与关系的最小数量。在最小基数为“0”时，实体在关系中的最小基数被标记为“Optional”。在最小基数为“1”时，实体在关系中的最小基数会被标记为“Mandatory”。</p></li><li><p>例如，在“会员-购买记录”关系中，对于任意一个会员，最大可能有多个购买记录，最小可能有0个购买记录;对于任意一个购买记录，最大可以由1个会员执行，最小也要由1个会员执行：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240207215717985.png" alt="image-20240207215717985"></p></li></ul><h4 id="ERD图示例"><a href="#ERD图示例" class="headerlink" title="ERD图示例"></a>ERD图示例</h4><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240207215806774.png" alt="image-20240207215806774"></p><h2 id="面向对象分析"><a href="#面向对象分析" class="headerlink" title="面向对象分析"></a>面向对象分析</h2><h2 id="画完er图"><a href="#画完er图" class="headerlink" title="画完er图"></a>画完er图</h2><h2 id="navicat中根据er图建表"><a href="#navicat中根据er图建表" class="headerlink" title="navicat中根据er图建表"></a>navicat中根据er图建表</h2><h2 id="创建新模块etopia"><a href="#创建新模块etopia" class="headerlink" title="创建新模块etopia"></a>创建新模块etopia</h2><h2 id="用代码生成器生成代码"><a href="#用代码生成器生成代码" class="headerlink" title="用代码生成器生成代码"></a>用代码生成器生成代码</h2><h3 id="集成Spring-Security的项目前端报401-权限问题"><a href="#集成Spring-Security的项目前端报401-权限问题" class="headerlink" title="集成Spring Security的项目前端报401(权限问题)"></a>集成Spring Security的项目前端报401(权限问题)</h3><ul><li><p>这是因为集成Spring Security后启动项目，系统会在原有的过滤器链中添加一个用于权限认证的过滤器，如果没有设置默认的账号密码，系统会自动生成一个密码，默认用户为user，在前端发请求时需要在http报文中的Authorization中设置Username和Password字段才能通过那个过滤器。</p></li><li><p>如果不想用系统自动生成的账号和密码可以在配置文件中自行设置<code>spring.security.user.name和spring.security.user.password</code>属性。</p></li><li><p>如果不想走新增的那个过滤器，首先新建一个MyAccessDeniedHandler类，然后在SecurityConfig中设置忽略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title class_">AccessDeniedHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AccessDeniedException e)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">        httpServletResponse.setHeader(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> httpServletResponse.getWriter();</span><br><span class="line">        out.write(<span class="string">&quot;&#123;\&quot;status\&quot;:\&quot;error\&quot;,\&quot;msg\&quot;:\&quot;权限不足，请联系管理员!\&quot;&#125;&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccessDeniedHandler accessDeniedHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//         任意请求允许无授权访问</span></span><br><span class="line">        http.authorizeRequests().anyRequest().permitAll();</span><br><span class="line">        http.csrf().disable().exceptionHandling().accessDeniedHandler(accessDeniedHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据库表不要使用read作为字段名"><a href="#数据库表不要使用read作为字段名" class="headerlink" title="数据库表不要使用read作为字段名"></a>数据库表不要使用read作为字段名</h3><ul><li>read是mysql的一个关键字，用这个作为字段名后面处理很麻烦，特别是使用mybatisplus这种，出了错很难排查。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;我准备写一个比较实用的开源软件作为</summary>
      
    
    
    
    
    <category term="毕业设计" scheme="https://konjacor.github.io/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>编译原理</title>
    <link href="https://konjacor.github.io/2023/12/29/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    <id>https://konjacor.github.io/2023/12/29/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</id>
    <published>2023-12-29T10:15:55.000Z</published>
    <updated>2023-12-29T10:16:38.687Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

</summary>
      
    
    
    
    
    <category term="编译原理" scheme="https://konjacor.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>英语作文</title>
    <link href="https://konjacor.github.io/2023/12/02/%E8%8B%B1%E8%AF%AD%E4%BD%9C%E6%96%87/"/>
    <id>https://konjacor.github.io/2023/12/02/%E8%8B%B1%E8%AF%AD%E4%BD%9C%E6%96%87/</id>
    <published>2023-12-02T05:59:03.000Z</published>
    <updated>2024-03-28T14:56:42.554Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="大作文"><a href="#大作文" class="headerlink" title="大作文"></a>大作文</h1><h2 id="静态图开头"><a href="#静态图开头" class="headerlink" title="静态图开头"></a>静态图开头</h2><h3 id="带具体内容的版本"><a href="#带具体内容的版本" class="headerlink" title="带具体内容的版本"></a>带具体内容的版本</h3><p>  The <u>pie</u> chart above clearly illustrates the percentages of <u>residents’ exercising ways in a certain city</u>. As is revealed in the graph,we may draw the conclusion that the percentage of <u>exercising alone</u> takes up approximately <u>54.3%</u>,the highest among all the <u>four</u> categories. Next coms <u>the way of exercising with friends</u>,accounting for about <u>47.7%</u>. By contrast,<u>the way of exercising with families and taking part in group activities</u> make up <u>23.9%</u> and <u>15.8%</u> respectively.</p><p>​From my perspective,the phenomenon reflected by the <u>pie</u> chart above can be traced back to several major contributors summarized as follows. First and foremost,                     . Furthermore,                       . Last but not least,          .</p><h3 id="不带具体内容的版本"><a href="#不带具体内容的版本" class="headerlink" title="不带具体内容的版本"></a>不带具体内容的版本</h3><p>​The ____ chart above clearly illustrates the percentages of ____. As is revealed in the graph,we may draw the conclusion that the percentage of ____ takes up approximately ____,the highest among all the ____ categories. Next coms ____,accounting for about <strong><strong>. By contrast,</strong></strong> and ____ make up ____ and ____ respectively.</p><p>​From my perspective,the phenomenon reflected by the ____ chart above can be traced back to several major contributors summarized as follows. First and foremost,                     . Furthermore,                       . Last but not least,          .</p><h2 id="动态图开头"><a href="#动态图开头" class="headerlink" title="动态图开头"></a>动态图开头</h2><h3 id="带具体内容的版本-1"><a href="#带具体内容的版本-1" class="headerlink" title="带具体内容的版本"></a>带具体内容的版本</h3><p>​The <u>line</u> graph above clearly illustrates that <u>the numbers of museums in China and their visitors</u> underwent an enormous change from <u>2013</u> to <u>2015</u>. As is revealed in the graph,we may draw the conclusion that <u>the number of museums</u> <u>markedly jumped</u> from <u>6370</u> to <u>7811</u>,a <u>rise</u> of nearly <u>1500</u>. At the same time,there has been a <u>gradual increase</u> of <u>the number of visitors for them</u> from about <u>416 million</u> to about <u>469 million</u>,an <u>increase</u> of about <u>50 million</u>.</p><p>​From my perspective,the tendency reflected by the <u>line</u> chart above can be traced back to several major contributors summarized as follows. First and foremost,                     . Furthermore,                       . Last but not least,          .</p><h3 id="不带具体内容的版本-1"><a href="#不带具体内容的版本-1" class="headerlink" title="不带具体内容的版本"></a>不带具体内容的版本</h3><p>​The ____ graph above clearly illustrates that ____ underwent an enormous change from ____ to ____. As is revealed in the graph,we may draw the conclusion that ____ markedly jumped  from ____ to ____,a rise of nearly ____. At the same time,there has been a gradual increase of ____ from about ____ to about ____,an ____ of about ____.</p><p>​From my perspective,the tendency reflected by the ____ chart above can be traced back to several major contributors summarized as follows. First and foremost,                     . Furthermore,                       . Last but not least,          .</p><h2 id="论述部分"><a href="#论述部分" class="headerlink" title="论述部分"></a>论述部分</h2><h3 id="句型"><a href="#句型" class="headerlink" title="句型"></a>句型</h3><p>下面这些东西作文里都来上点儿</p><ul><li>主动句</li><li>被动句</li><li>强调句</li><li>倒装句</li><li>插入语</li><li>非谓语作定语</li><li>非谓语作状语</li><li>定语从句</li><li>状语从句（作为一个….&#x2F;随着….）</li></ul><h3 id="短语"><a href="#短语" class="headerlink" title="短语"></a>短语</h3><table><thead><tr><th>汉语</th><th>英语</th></tr></thead><tbody><tr><td>适应全球化的需求</td><td>meet the demand of globalization</td></tr><tr><td>以惊人的速度</td><td>at an incredible speed</td></tr><tr><td>趋于饱和</td><td>tend to saturate</td></tr><tr><td>双刃剑</td><td>double-edged sword</td></tr><tr><td>事实上…</td><td>the fact remains that…</td></tr><tr><td>使…充满…</td><td>imbue…with…</td></tr><tr><td>避开…的弊端</td><td>sidestep the potential drawbacks of…</td></tr><tr><td>利用…</td><td>take advantage of…</td></tr><tr><td>对…满意</td><td>be satisfied with…&#x2F;be content with…</td></tr><tr><td>40多岁的人</td><td>people in their forties</td></tr><tr><td>超过50岁的人</td><td>people over 50 years old</td></tr><tr><td>承担着…的压力</td><td>be under pressure to do something</td></tr><tr><td>等等</td><td>and so on</td></tr><tr><td>把…从…转换成…</td><td>shift…from…to…</td></tr><tr><td>倾向于做某事</td><td>be inclined to do something</td></tr><tr><td>鉴于，考虑到…</td><td>in view of…</td></tr><tr><td>深信…</td><td>be convinced that…</td></tr><tr><td>不得不承担来自于…的责任</td><td>have to undertake a lot of responsibilities from…</td></tr><tr><td>…应该做…</td><td>be supposed to do&#x2F;it is advisable for sb to do</td></tr><tr><td>对…更加重视</td><td>pay more attention to…</td></tr><tr><td>为了…</td><td>in order to…</td></tr><tr><td>…的目的</td><td>the aim&#x2F;purpose of…</td></tr><tr><td>恰恰相反</td><td>on the contrary</td></tr><tr><td>相比之下</td><td>by contrast</td></tr><tr><td>很容易受到…的影响</td><td>be particularly susceptible to…</td></tr><tr><td>旨在做某事</td><td>aim at doing something&#x2F;aim to do something</td></tr><tr><td>一些…</td><td>a range of…</td></tr><tr><td>日益增长的压力</td><td>ever-increasing pressure</td></tr><tr><td>考虑到…</td><td>take…into consideration&#x2F;take…into account</td></tr><tr><td>我们可以预计…</td><td>we may predict that…</td></tr><tr><td>随着校园生活节奏的加快和日益增加的压力</td><td>with the quickening pace and ever-increasing pressure of campus life</td></tr><tr><td>…在未来十年将持续增长</td><td>…will keep growing in the forthcoming decade</td></tr><tr><td>某人在…方面的关注&#x2F;关心</td><td>sb’s concern on…</td></tr><tr><td>随着中国经济的繁荣和近几十年来人们收入的增加</td><td>with the prosperity of economy in China and the increase of people’s income in recent decades</td></tr><tr><td>很多人</td><td>a large number of people</td></tr><tr><td>而不是…</td><td>instead of…&#x2F;rather than…</td></tr><tr><td>力图做某事，为争取…而努力</td><td>in a bid to do…</td></tr><tr><td>拓展人际关系</td><td>develop interpersonal relationship</td></tr><tr><td>越来越多的人</td><td>people in mounting numbers&#x2F;people in expanding numbers</td></tr><tr><td>相比于B更喜欢A</td><td>prefer A to B</td></tr><tr><td>高度重视…</td><td>attach utmost significance to(介词)…</td></tr><tr><td>对…有巨大的好处</td><td>have huge benefits for…</td></tr><tr><td>把…逐渐灌输到…中</td><td>instill…into…</td></tr><tr><td>培养…的热情</td><td>foster enthusiasm for…</td></tr><tr><td>一代身体健康且具备体育精神的公民</td><td>a generation of healthy and sportsmanlike citizens</td></tr><tr><td>总之</td><td>in conclusion&#x2F;to sum up&#x2F;generally speaking</td></tr><tr><td>与此同时</td><td>in the meantime&#x2F;at the same time</td></tr><tr><td>电子商务和网上购物的普及</td><td>the popularity of electronic commerce and online shopping</td></tr><tr><td>为…打下了基础</td><td>have laid the foundation for…</td></tr><tr><td>随着快递业务日趋成熟以及相关法律法规的完善</td><td>as the express delivery business is becoming increasingly mature and relevant laws and regulations are improved</td></tr><tr><td>对…持怀疑态度</td><td>be skeptical about…</td></tr><tr><td>到目前为止</td><td>hitherto&#x2F;so far</td></tr><tr><td>跨越长距离</td><td>across vast distances</td></tr><tr><td>中国经济的繁荣</td><td>the prosperity of China’s economy</td></tr><tr><td>准备做某事</td><td>get prepared to do…</td></tr><tr><td>拥抱这一不可逆转的趋势</td><td>embrace this irreversible trend</td></tr><tr><td>在…方面变得异常活跃</td><td>have become particularly active in…</td></tr><tr><td>使得对…的需求增长</td><td>have led to an increased demand for…</td></tr><tr><td>高素质的工程师</td><td>qualified engineer</td></tr><tr><td>此外</td><td>furthermore&#x2F;in addition&#x2F;additionally&#x2F;besides</td></tr><tr><td>整体上</td><td>on the whole</td></tr><tr><td>跟上…的节奏</td><td>keep pace with…</td></tr><tr><td>迫使…去…&#x2F;…不得不…</td><td>oblige…to do…</td></tr><tr><td>为…做好更好的准备</td><td>get better prepared for…</td></tr><tr><td>社会的快速发展</td><td>the speedy development of our society</td></tr><tr><td>问题的另一方面</td><td>on the other side of the coin</td></tr><tr><td>引起，导致</td><td>bring about</td></tr><tr><td>提出(问题)，养育</td><td>bring up</td></tr><tr><td>…必须做某事</td><td>it is necessary for … to do …</td></tr><tr><td>采取有效的措施做某事</td><td>take effective measures to do…</td></tr><tr><td>失控</td><td>get out of hand</td></tr><tr><td>就业市场上需要的既有理论知识又有实践技能的专业</td><td>majors for which both theoretical knowledge and practical skills will be demanded in the job market</td></tr><tr><td>被…要求</td><td>be demanded for…</td></tr><tr><td>兼职工作</td><td>part-time job&#x2F;temporary job</td></tr><tr><td>全职工作</td><td>full-time job</td></tr><tr><td>有做某事的潜力</td><td>have the potential to do…</td></tr><tr><td>会对…产生负面影响</td><td>have the potential to negatively affect…&#x2F;can adversely affect…</td></tr><tr><td>消耗他们的精力</td><td>drain their energy</td></tr><tr><td>（以…方式）有害于…，对…不利</td><td>be detrimental to…（by…）&#x2F;be harmful to</td></tr><tr><td>破坏他们的学习动力</td><td>damage their incentive to study</td></tr><tr><td>尽管（介词）</td><td>despite</td></tr><tr><td>检验一种可能的职业方向</td><td>test out a possible career direction</td></tr><tr><td>优先选择…，更愿意…</td><td>give preference to…&#x2F;prefer to do…</td></tr><tr><td>在…之间保持平衡</td><td>maintain a balance between … and …</td></tr><tr><td>…能够做某事</td><td>…be able to do…</td></tr><tr><td>使…能够做某事</td><td>enable…to do…</td></tr><tr><td>（经过努力）获得…</td><td>secure…</td></tr><tr><td>一定会做某事</td><td>be certain to do…</td></tr><tr><td>产生积极的影响</td><td>yield a positive impact</td></tr><tr><td>提供丰富的选择机会</td><td>offer a rich variety of many options</td></tr><tr><td>高度发达的交通系统</td><td>well-developed transportation system</td></tr><tr><td>无论是…还是…</td><td>whether … or …</td></tr><tr><td>去向，行踪</td><td>whereabout</td></tr><tr><td>在某个城市</td><td>in a certain city</td></tr><tr><td>遭受，经受巨大的变化</td><td>undergo an enormous change</td></tr><tr><td>…之际</td><td>when it comes time for … to do …</td></tr><tr><td>减轻，减缓，减少</td><td>alleviation</td></tr><tr><td>贫困人口比例</td><td>poverty headcount ratio</td></tr><tr><td>相关部门</td><td>the relevant authorities&#x2F;concerned departments</td></tr><tr><td>非常重视…</td><td>put great emphasis on…</td></tr><tr><td>基础设施建设</td><td>the establishment of infrastructure</td></tr><tr><td>有效缩小了…和…之间的差距</td><td>have effectively bridged the gap between … and …</td></tr><tr><td>归因于…</td><td>be attributed to…&#x2F;be ascribed to…</td></tr><tr><td>中国经济的快速发展</td><td>China’s speedy economic development</td></tr><tr><td>实现了…的诺言</td><td>have fulfilled its promise of…</td></tr><tr><td>不言而喻</td><td>it goes without saying that…</td></tr><tr><td>改革开放</td><td>reform and opening-up</td></tr><tr><td>根本原因</td><td>the fundamental contributor</td></tr><tr><td>为普通百姓创造了大量的就业机会</td><td>create ample job opportunities for ordinary people</td></tr><tr><td>尤其</td><td>especially</td></tr><tr><td>增建了大量基础设施</td><td>have substantially increased infrastructure facilities</td></tr><tr><td>休闲公园</td><td>recreational park</td></tr><tr><td>满足…的需求</td><td>satisfy the requirement of…</td></tr><tr><td>尽管如此</td><td>even so</td></tr><tr><td>对…造成，引起…</td><td>pose…to…</td></tr><tr><td>值得一提的是</td><td>it is worth mentioning that…</td></tr><tr><td>对…的渴望</td><td>the desire for…</td></tr><tr><td>正在面临，遭受…</td><td>be suffering…</td></tr><tr><td>锻炼总是让他们更强壮、更精力充沛</td><td>exercise never fails to make them stronger and more energetic</td></tr><tr><td>就我而言</td><td>as far as I am concerned</td></tr><tr><td>我对…有特殊的兴趣</td><td>I have a peculiar interest in…</td></tr><tr><td>作为…的一种形式</td><td>as a form of…</td></tr><tr><td>让我感到更健康而且更有活力</td><td>make me feel healthier and more vigorous</td></tr><tr><td>我从不…，也不…</td><td>I never…，nor do(部分倒装) I…</td></tr><tr><td>熬夜</td><td>stay up late&#x2F;burning the midnight oil</td></tr><tr><td>保持均衡饮食</td><td>keep a balanced diet</td></tr><tr><td>对生活的乐观态度</td><td>an optimistic attitude toward life</td></tr><tr><td>所有这些锻炼可以保证我有健康的体魄和快乐的生活</td><td>all these practices guarantee a healthy body and a happy life</td></tr><tr><td>努力做到</td><td>strive to do…</td></tr><tr><td>来自世界各地</td><td>from various parts of the world</td></tr><tr><td>不同文化背景的人们</td><td>people from diverse cultural backgrounds</td></tr><tr><td>例如</td><td>for instance&#x2F;for example</td></tr><tr><td>开阔人们的视野</td><td>widen one’s horizons</td></tr><tr><td>促进相互理解</td><td>enhance mutual understanding</td></tr><tr><td>扩大我们的认知范围</td><td>expand our scope of knowledge</td></tr><tr><td>我们已经更好地了解了世界</td><td>we have come to know the world better</td></tr><tr><td>一直在做某事</td><td>have been doing…</td></tr><tr><td>带动了地方经济的发展并促进了商业交流</td><td>boost local economy and promote commercial exchanges</td></tr><tr><td>对…来说做…是必要的</td><td>it is crucial for…to do…</td></tr><tr><td>提升国际地位</td><td>upgrade international position</td></tr><tr><td>促进国际理解以消除偏见</td><td>promote global understanding to remove prejudice and bias</td></tr><tr><td>充分利用…</td><td>make good use of…</td></tr><tr><td>想要做某事</td><td>would like to do…</td></tr><tr><td>高等教育</td><td>higher education</td></tr><tr><td>人们越来越意识到…的重要性</td><td>people are becoming increasingly aware of the necessity of…</td></tr><tr><td>对…有着重大贡献</td><td>have made great contributions to…</td></tr><tr><td>坚定不移的，毫不动摇的</td><td>unwavering</td></tr><tr><td>在各个方面都取得了显著的进步</td><td>have led to significant advancements in all aspects&#x2F;in multiple regards</td></tr><tr><td>确保所有公民都可以获得…</td><td>ensure that all citizens have access to…</td></tr><tr><td>在…方面的成功</td><td>success in…</td></tr><tr><td>已经在不同领域产生了深远的影响</td><td>have made far-reaching impacts on different sectors</td></tr><tr><td>是经济可持续发展的根本</td><td>be essential to a sustainable economy</td></tr><tr><td>培养高级人才和专家</td><td>bring up advanced talents and experts</td></tr><tr><td>2023年的第一季度</td><td>first quarter of 2023</td></tr><tr><td>与上年同期数字相比的</td><td>year-on-year</td></tr><tr><td>被盛赞</td><td>be highly spoken of</td></tr><tr><td>值得我们认真关注</td><td>deserve our serious concern</td></tr><tr><td>…最严重的危害</td><td>the most serious harm of…</td></tr><tr><td>心理健康</td><td>mental fitness</td></tr><tr><td>大多数的…</td><td>the majority of…</td></tr><tr><td>扎根于…</td><td>root in…</td></tr><tr><td>沉迷于…</td><td>indulge in…</td></tr><tr><td>生理健康</td><td>physical health</td></tr><tr><td>引起很多不适反应</td><td>arouse many uncomfortable feelings</td></tr><tr><td>废寝忘食</td><td>lack of sleep and always forget to have dinner</td></tr><tr><td>变得暴躁</td><td>get irritable</td></tr><tr><td>饱受营养不良的折磨</td><td>suffer from severe malnutrition</td></tr><tr><td>所有这些事实都表明…</td><td>all these facts indicate that…</td></tr><tr><td>…是时候做…了</td><td>it is time for…to do…</td></tr><tr><td>在外表或才华方面及其出色</td><td>excel in appearance or talent</td></tr><tr><td>…的形象</td><td>the image of…</td></tr><tr><td>无与伦比的能力</td><td>unparalleled skills</td></tr><tr><td>被…热情追捧</td><td>be passionately adored by…</td></tr><tr><td>一夜成名</td><td>win their fame overnigh</td></tr><tr><td>引发了对…的全国范围的激烈辩论</td><td>provoke noisy nationwide debates on…</td></tr><tr><td>对…产生深刻影响</td><td>exert a profound influence for…</td></tr><tr><td>大量的…</td><td>a great deal of…</td></tr><tr><td>努力去做某事</td><td>endeavor to do…</td></tr><tr><td>危及我们的学习或工作效率</td><td>endanger the efficiency of our study or work</td></tr><tr><td>榜样</td><td>role model</td></tr><tr><td>我们将拥有一个更加积极且富有成效的生活</td><td>we will lead a more positive and fruitful life</td></tr><tr><td>指引我们的人生</td><td>direct our way of life</td></tr><tr><td>似乎，好像</td><td>as if</td></tr><tr><td>说明文字，字幕</td><td>caption</td></tr><tr><td>实施，完成</td><td>carry out</td></tr><tr><td>毕竟</td><td>after all</td></tr><tr><td>在…领域</td><td>in the field of…</td></tr><tr><td>接管</td><td>take over</td></tr><tr><td>退化</td><td>regress</td></tr><tr><td>不管</td><td>no matter</td></tr><tr><td>我坚持认为</td><td>I cling to the idea that…</td></tr><tr><td>维护</td><td>maintenance</td></tr><tr><td>赶上，跟上</td><td>catch up with</td></tr><tr><td>高估</td><td>overestimation</td></tr><tr><td>做…超出了它的能力</td><td>it is beyond its abilities to do…</td></tr></tbody></table><h2 id="结尾部分"><a href="#结尾部分" class="headerlink" title="结尾部分"></a>结尾部分</h2><h3 id="总结型结尾"><a href="#总结型结尾" class="headerlink" title="总结型结尾"></a>总结型结尾</h3><ol><li>Taking all these contributors into consideration,we can come to the conclusion that this established trend is positive and therefore acceptable. Accordingly,let us get prepared to embrace this irreversible trend.</li><li>Taking all these contributors into consideration,I am convinced that ____.</li></ol><h3 id="预测型结尾"><a href="#预测型结尾" class="headerlink" title="预测型结尾"></a>预测型结尾</h3><ol><li>Taking all these contributors into consideration,we may predict that with <strong><strong>,</strong></strong> will ____.</li></ol><h3 id="如果型结尾"><a href="#如果型结尾" class="headerlink" title="如果型结尾"></a>如果型结尾</h3><ol><li>If ____ could <strong><strong>,I am sure that</strong></strong>.</li></ol><h1 id="考研复试英语"><a href="#考研复试英语" class="headerlink" title="考研复试英语"></a>考研复试英语</h1><ul><li>下面是考研复试的英语部分的相关内容，为了方便就和考研作文整合到一起了。</li></ul><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><ul><li>Good morning&#x2F;afternoon. I am glad to be here for this interview. First let me introduce myself. My name is Wei Chuanru,22, my Number is…(编号). I come from Zibo,a city of Shandong Province. I am a senior now and I will graduate from Information Science and Engineering department of Shandong Normal University this year. In the past one year,I have been preparing for the postgraduate examination. Now all my hard work has got a result since I have a chance to be interviewed by you.</li><li>表达高兴，介绍，名字，年龄，编号，家乡，现在是大四学生，即将毕业于，过去一年准备考试，现在收获因为何</li><li>I am open-minded,quick in thought and very fond of software engineering. In my spare time,I have broad interests like many other youngers,such as reading relevant books and watching videos about my major. Frequently I exchange with other people by making comments online. Besides,I always record my opinions 、thoughts and some knowledge in my blog to facilitate the communication between me and my classmates.</li><li>我思想开放，思维迅速，非常喜欢软工。空闲时间兴趣读书看相关视频，经常和别人在网上交换看法，记录观点、想法、知识到博客上以方便和别人交流</li><li>In addition,during my college years,I was once a member of our software lab. So,as a developer in lab,I have a comparative good command of constructing simple application program. I am able to resolve questions quickly by myself because I am skillful in searching for relevant information in Internet.</li><li>大学时期，是实验室成员，对于构建简单应用相对熟练，能快速解决问题，因为有在网上搜索相关问题的技巧</li><li>Furthermore,I actively participated in relevant competitions in university and achieved certain results. And recently I did an internship at Zibo Seeyon software corporation which benefited me a lot.</li><li>在大学积极参与竞赛并获得一些奖项，最近在公司实习获益良多</li><li>I always believe that one will easily lag behind unless he keeps on learning. So, if I am given a chance to study in Nankai University,I will spare no effort to master a good command of advanced content of software engineering.</li><li>除非一个人保持学习，不然他会轻易落后，如果我能进，我将不遗余力掌握软工进阶内容</li><li>That’s all. Thank you for listening.</li><li>以上，感谢聆听</li></ul><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="介绍类-介绍一下你的家乡？"><a href="#介绍类-介绍一下你的家乡？" class="headerlink" title="介绍类-介绍一下你的家乡？"></a>介绍类-介绍一下你的家乡？</h3><h4 id="提问方式"><a href="#提问方式" class="headerlink" title="提问方式"></a>提问方式</h4><ul><li>What is your <strong>hometown</strong> like?</li><li>Please tell me something about your hometown.</li><li>Could you briefly <strong>introduce</strong> your hometown?</li></ul><h4 id="回答方式"><a href="#回答方式" class="headerlink" title="回答方式"></a>回答方式</h4><ul><li>是什么：My hometown is in Zibo，Shandong Province. It is a beautiful city with delicious food and rich culture.</li><li>好处：My hometown <strong>provides me with</strong> an unforgettable childhood. <strong>Under</strong> the education <strong>of</strong> the schools and teachers in my hometown, <strong>I grew up into an optimistic person with good learning and practical abilities</strong>.</li><li>怎么做：<strong>I will continue to be strict with myself and work hard to be an excellent postgraduate</strong>.</li></ul><h3 id="介绍类-介绍一下你的家人？"><a href="#介绍类-介绍一下你的家人？" class="headerlink" title="介绍类-介绍一下你的家人？"></a>介绍类-介绍一下你的家人？</h3><h4 id="提问方式-1"><a href="#提问方式-1" class="headerlink" title="提问方式"></a>提问方式</h4><ul><li>Could you tell me something about your <strong>family</strong>?</li><li>Could you briefly <strong>introduce</strong> your family?</li></ul><h4 id="回答方式-1"><a href="#回答方式-1" class="headerlink" title="回答方式"></a>回答方式</h4><ul><li>是什么：There are four people in my family: my dad,my mom,my younger brother and me. My dad and my mom are freelancers now.</li><li>好处：My parents <strong>provide me with</strong> a good family atmosphere. <strong>Under</strong> the care and education <strong>of</strong> my parents, <strong>I grew up into an optimistic person with good learning and practical abilities</strong>.</li><li>怎么做：<strong>I will continue to be strict with myself and work hard to be an excellent postgraduate</strong>.</li></ul><h3 id="介绍类-介绍一下你的兴趣爱好？"><a href="#介绍类-介绍一下你的兴趣爱好？" class="headerlink" title="介绍类-介绍一下你的兴趣爱好？"></a>介绍类-介绍一下你的兴趣爱好？</h3><h4 id="提问方式-2"><a href="#提问方式-2" class="headerlink" title="提问方式"></a>提问方式</h4><ul><li>Do you have any <strong>hobbies</strong>?</li><li>What are you <strong>interested</strong> in?</li><li>What do you usually do in your <strong>spare time</strong>?</li></ul><h4 id="回答方式-2"><a href="#回答方式-2" class="headerlink" title="回答方式"></a>回答方式</h4><ul><li>是什么：In my free time,I <strong>really enjoy</strong> reading books.</li><li>好处：Reading books <strong>provides me with</strong> a lot of joy. <strong>Under the influence of</strong> reading,<strong>I grew up into an optimistic person with good learning and practical abilities</strong>.</li><li>怎么做：<strong>I will continue to be strict with myself and work hard to be an excellent postgraduate</strong>.</li></ul><h3 id="介绍类-介绍一下你的本科学校？"><a href="#介绍类-介绍一下你的本科学校？" class="headerlink" title="介绍类-介绍一下你的本科学校？"></a>介绍类-介绍一下你的本科学校？</h3><h4 id="提问方式-3"><a href="#提问方式-3" class="headerlink" title="提问方式"></a>提问方式</h4><ul><li>Please give a brief <strong>introduction</strong> of your <strong>college</strong>.</li><li>Please briefly introduce your <strong>undergraduate school</strong>.</li></ul><h4 id="回答方式-3"><a href="#回答方式-3" class="headerlink" title="回答方式"></a>回答方式</h4><ul><li>是什么：I am now studying at Shandong Normal University.</li><li>好处：It <strong>provides me with</strong> a good learning atmosphere. So I <strong>really enjoy</strong> the past four years I spent there. <strong>Under the</strong> guidance <strong>of</strong> my teachers,<strong>I am equipped with good learning and practical abilities</strong>.</li><li>怎么做：<strong>I will continue to be strict with myself and work hard to be an excellent postgraduate</strong>.</li></ul><h3 id="介绍类-介绍一下喜欢的本科课程"><a href="#介绍类-介绍一下喜欢的本科课程" class="headerlink" title="介绍类-介绍一下喜欢的本科课程"></a>介绍类-介绍一下喜欢的本科课程</h3><h4 id="提问方式-4"><a href="#提问方式-4" class="headerlink" title="提问方式"></a>提问方式</h4><ul><li>What is your <strong>favorite course</strong> in <strong>college&#x2F;undergraduate period</strong>?</li><li>Tell us something about your <strong>specialized courses</strong> in college</li></ul><h4 id="回答方式-4"><a href="#回答方式-4" class="headerlink" title="回答方式"></a>回答方式</h4><ul><li>是什么：My favorite course in college is Data Structure.</li><li>好处：<strong>I really enjoy</strong> it because It <strong>provides me with</strong> a new perspective towards my major. <strong>Under the</strong> influence <strong>of</strong> this course, <strong>I am equipped with good learning and practical abilities</strong>.</li><li>怎么做：<strong>I will continue to be strict with myself and work hard to be an excellent postgraduate</strong>.</li></ul><h3 id="介绍类-介绍一下你的优点？"><a href="#介绍类-介绍一下你的优点？" class="headerlink" title="介绍类-介绍一下你的优点？"></a>介绍类-介绍一下你的优点？</h3><h4 id="提问方式-5"><a href="#提问方式-5" class="headerlink" title="提问方式"></a>提问方式</h4><ul><li>What are your <strong>strengths&#x2F;advantages&#x2F;strong points&#x2F;merits</strong>?</li><li>What do you think about your <strong>strengths&#x2F;advantages&#x2F;strong points&#x2F;merits</strong>?</li></ul><h4 id="回答方式-5"><a href="#回答方式-5" class="headerlink" title="回答方式"></a>回答方式</h4><ul><li>是什么：I am a action-motivated person. I think it is my greatest advantage.</li><li>好处：This strength <strong>makes me</strong> brave to face the difficulties in study and life. Accordingly, I have made some achievements, and <strong>I am equipped with good learning and practical abilities</strong>.</li><li>怎么做：<strong>I will continue to develop my strengths, correct my weaknesses, and strive for greater improvements</strong>.</li></ul><h3 id="介绍类-介绍一下你的缺点？"><a href="#介绍类-介绍一下你的缺点？" class="headerlink" title="介绍类-介绍一下你的缺点？"></a>介绍类-介绍一下你的缺点？</h3><h4 id="提问方式-6"><a href="#提问方式-6" class="headerlink" title="提问方式"></a>提问方式</h4><ul><li>What are your <strong>weaknesses&#x2F;weak points&#x2F;disadvantages&#x2F;defects</strong>?</li><li>What do you think about your <strong>weaknesses&#x2F;weak points&#x2F;disadvantages&#x2F;defects</strong>?</li></ul><h4 id="回答方式-6"><a href="#回答方式-6" class="headerlink" title="回答方式"></a>回答方式</h4><ul><li>是什么：Sometimes I am a stubborn person. I think it is my weakness.</li><li>好处：It <strong>makes me</strong> take some detours when I deal with the difficulties in study and life. But <strong>under the</strong> help <strong>of</strong> my teachers and friends,I am trying to correct it.</li><li>怎么做：<strong>I will continue to develop my strengths, correct my weaknesses, and strive for greater improvements</strong>.</li></ul><h3 id="原因类-为什么考研？"><a href="#原因类-为什么考研？" class="headerlink" title="原因类-为什么考研？"></a>原因类-为什么考研？</h3><h4 id="提问方式-7"><a href="#提问方式-7" class="headerlink" title="提问方式"></a>提问方式</h4><ul><li>Why do you choose to pursue a <strong>master’s degree</strong>?</li><li>Why do you want to go to a <strong>graduate school</strong>?</li><li>Why do you want to be a <strong>postgraduate</strong>?</li></ul><h4 id="回答方式-7"><a href="#回答方式-7" class="headerlink" title="回答方式"></a>回答方式</h4><ul><li>态度：<strong>I made the decision to</strong> pursue a master’s degree <strong>after careful consideration</strong>.</li><li>原因：<strong>For one thing</strong>, I want to have an in-depth study on my dream major. <strong>For another</strong>, a master’s degree can make me more competitive in society.</li><li>怎么做：<strong>I have been working hard to realize my dream over the last year and I will continue to be strict with myself in the future</strong>.</li></ul><h3 id="原因类-为什么考我们学校？"><a href="#原因类-为什么考我们学校？" class="headerlink" title="原因类-为什么考我们学校？"></a>原因类-为什么考我们学校？</h3><h4 id="提问方式-8"><a href="#提问方式-8" class="headerlink" title="提问方式"></a>提问方式</h4><ul><li>Why did you <strong>choose our university</strong>?</li><li>Why did you <strong>apply for our university</strong>?</li></ul><h4 id="回答方式-8"><a href="#回答方式-8" class="headerlink" title="回答方式"></a>回答方式</h4><ul><li>态度：<strong>I made the decision to</strong> apply for Nankai University <strong>after careful consideration</strong>.</li><li>原因：<strong>For one thing</strong>, Nankai University has mighty teaching staff for my major and enjoys a high reputation. <strong>For another</strong>, Tianjin is also one of my favorite cities.</li><li>怎么做：<strong>I have been working hard to realize my dream over the last year and I will continue to be strict with myself in the future</strong>.</li></ul><h3 id="原因类-为什么考这个专业（换成这个专业）？"><a href="#原因类-为什么考这个专业（换成这个专业）？" class="headerlink" title="原因类-为什么考这个专业（换成这个专业）？"></a>原因类-为什么考这个专业（换成这个专业）？</h3><h4 id="提问方式-9"><a href="#提问方式-9" class="headerlink" title="提问方式"></a>提问方式</h4><ul><li>Why do you <strong>change</strong> your <strong>major</strong> in the postgraduate study?</li><li>Why do you choose to <strong>switch</strong> your major?</li></ul><h4 id="回答方式-9"><a href="#回答方式-9" class="headerlink" title="回答方式"></a>回答方式</h4><ul><li>态度：<strong>I made the decision to</strong> change my major in the postgraduate period <strong>after careful consideration</strong>.</li><li>原因：<strong>For one thing</strong>,When I was a sophomore,I found myself interested in software engineering by reading some relevant books. <strong>For another</strong>, the future career paths of this major meet my employment expectations.</li><li>怎么做：<strong>I have been working hard to realize my dream over the last year and I will continue to be strict with myself in the future</strong>.</li></ul><h3 id="规划类-研究生阶段有什么规划？"><a href="#规划类-研究生阶段有什么规划？" class="headerlink" title="规划类-研究生阶段有什么规划？"></a>规划类-研究生阶段有什么规划？</h3><h4 id="提问方式-10"><a href="#提问方式-10" class="headerlink" title="提问方式"></a>提问方式</h4><ul><li>Can you talk about your <strong>plans</strong> in the postgraduate period？</li><li>What do you want to <strong>achieve</strong> during the postgraduate period？</li></ul><h4 id="回答方式-10"><a href="#回答方式-10" class="headerlink" title="回答方式"></a>回答方式</h4><ul><li>态度：<strong>If I am admitted,there are some goals I want to achieve in the</strong> postgraduate period.</li><li>原因：**Firstly,I will take all courses seriously and work hard to pass all exams. Besides that,**I will try to read vast relevant books and construct a few apps to improve my practical ability.</li><li>决心：<strong>In order to achieve these goals,I will continue to be strict with myself and work hard to be an excellent postgraduate</strong>.</li></ul><h3 id="规划类-是否计划读博？"><a href="#规划类-是否计划读博？" class="headerlink" title="规划类-是否计划读博？"></a>规划类-是否计划读博？</h3><h4 id="提问方式-11"><a href="#提问方式-11" class="headerlink" title="提问方式"></a>提问方式</h4><ul><li>Do you have any plans to <strong>apply for</strong> a <strong>PhD</strong>?</li><li>Have you thought of doing a <strong>PhD</strong>?</li></ul><h4 id="回答方式-11"><a href="#回答方式-11" class="headerlink" title="回答方式"></a>回答方式</h4><ul><li>态度：If there is an opportunity to do a PhD in the future, I will seriously take it into consideration.</li><li>原因：Before applying for a PhD,there are some goals I want to achieve in the postgraduate period. **Firstly,I will take all courses seriously and work hard to pass all exams. Besides that,**I will try to read vast relevant books and construct a few apps to improve my practical ability. After achieving these goals,I will consider whether to do a PhD carefully.</li><li>决心：<strong>In order to achieve these goals,I will continue to be strict with myself and work hard to be an excellent postgraduate</strong>.</li></ul><h3 id="做法类-如何处理压力？"><a href="#做法类-如何处理压力？" class="headerlink" title="做法类-如何处理压力？"></a>做法类-如何处理压力？</h3><h4 id="提问方式-12"><a href="#提问方式-12" class="headerlink" title="提问方式"></a>提问方式</h4><ul><li>How do you usually <strong>deal with</strong> your <strong>pressure</strong>?</li><li>What would you do when you <strong>have great pressure</strong>?</li><li>How do you <strong>cope with stress</strong>?</li></ul><h4 id="回答方式-12"><a href="#回答方式-12" class="headerlink" title="回答方式"></a>回答方式</h4><ul><li>态度：Sometimes,<strong>it is common to</strong> be stressful <strong>in our daily life. We should have confidence to handle it well</strong>.</li><li>做法：<strong>When I face</strong> stress, <strong>I usually</strong> confide in my friends. Sometimes I also stay alone to take some exercise to relieve my stress. <strong>Anyway, I won’t give up easily</strong>.</li><li>好处：<strong>By doing so, I can get relaxed and prepare for my next challenge with power and courage</strong>.</li></ul><h3 id="做法类-如何看待失败？"><a href="#做法类-如何看待失败？" class="headerlink" title="做法类-如何看待失败？"></a>做法类-如何看待失败？</h3><h4 id="提问方式-13"><a href="#提问方式-13" class="headerlink" title="提问方式"></a>提问方式</h4><ul><li>What would you do when you <strong>fail</strong> in doing something?</li><li>How do you <strong>cope&#x2F;deal with failure</strong>?</li></ul><h4 id="回答方式-13"><a href="#回答方式-13" class="headerlink" title="回答方式"></a>回答方式</h4><ul><li>态度：<strong>It is common to</strong> fail in something <strong>in our daily life. We should have confidence to handle it well</strong>.</li><li>做法：<strong>When I face</strong> failure, <strong>I usually</strong> reflect on why I had failed. Then I will draw some lessons from it and try again. <strong>Anyway, I won’t give up easily</strong>.</li><li>好处：<strong>By doing so, I can get relaxed and prepare for my next challenge with power and courage</strong>.</li></ul><h3 id="做法类-如何平衡学习和生活？"><a href="#做法类-如何平衡学习和生活？" class="headerlink" title="做法类-如何平衡学习和生活？"></a>做法类-如何平衡学习和生活？</h3><h4 id="提问方式-14"><a href="#提问方式-14" class="headerlink" title="提问方式"></a>提问方式</h4><ul><li>How do you get your study-life <strong>balance</strong>?</li><li>How do you <strong>keep a balance</strong> between <strong>study</strong> and <strong>life</strong>?</li></ul><h4 id="回答方式-14"><a href="#回答方式-14" class="headerlink" title="回答方式"></a>回答方式</h4><ul><li>态度：<strong>It is common to</strong> face difficulties in keeping a balance between study and life. <strong>We should have confidence to handle it well</strong>.</li><li>做法：<strong>When I face</strong> troubles in keeping a balance between them, <strong>I usually</strong> make a clear timetable and stick to my schedule. <strong>Anyway, I won’t give up easily</strong>.</li><li>好处：<strong>By doing so, I can get relaxed and prepare for my next challenge with power and courage</strong>.</li></ul><h3 id="做法类-没能考上研怎么办？"><a href="#做法类-没能考上研怎么办？" class="headerlink" title="做法类-没能考上研怎么办？"></a>做法类-没能考上研怎么办？</h3><h4 id="提问方式-15"><a href="#提问方式-15" class="headerlink" title="提问方式"></a>提问方式</h4><ul><li>Do you have any <strong>plans</strong> if you <strong>fail</strong> in this <strong>exam</strong>?</li><li>What would you do if you <strong>don’t</strong> get <strong>admitted</strong>&#x2F;get into <strong>graduate school</strong>?</li></ul><h4 id="回答方式-15"><a href="#回答方式-15" class="headerlink" title="回答方式"></a>回答方式</h4><ul><li>态度：<strong>It is common to</strong> fail in something <strong>in our daily life</strong>. <strong>We should have confidence to handle it well</strong>.</li><li>做法：If I don’t get admitted this time, I will reflect on why I had failed. Then I will draw some lessons from it and try again. <strong>Anyway, I won’t give up easily</strong>.</li><li>好处：<strong>By doing so, I can</strong> get some valuable experience <strong>and prepare for my next challenge with power and courage</strong>.</li></ul><h2 id="功能句"><a href="#功能句" class="headerlink" title="功能句"></a>功能句</h2><h3 id="请求重新说一遍问题"><a href="#请求重新说一遍问题" class="headerlink" title="请求重新说一遍问题"></a>请求重新说一遍问题</h3><ul><li>Sorry i didn’t get the meaning of this question，could you show me again？</li><li>Excuse me.I can’t quite follow you. Would you please say it again?</li></ul><h3 id="忘词时"><a href="#忘词时" class="headerlink" title="忘词时"></a>忘词时</h3><ul><li>Well ,let me see…</li></ul><h3 id="以反问的方式确定问题"><a href="#以反问的方式确定问题" class="headerlink" title="以反问的方式确定问题"></a>以反问的方式确定问题</h3><ul><li>Could I understand your question like this…？</li><li>I think you were asking me about….. Am I right？</li></ul><h3 id="表达时需要补充说明时的缓冲词"><a href="#表达时需要补充说明时的缓冲词" class="headerlink" title="表达时需要补充说明时的缓冲词"></a>表达时需要补充说明时的缓冲词</h3><ul><li>I mean…</li></ul><h2 id="专业相关的词句"><a href="#专业相关的词句" class="headerlink" title="专业相关的词句"></a>专业相关的词句</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;大作文&quot;&gt;&lt;a href=&quot;#大作文&quot; class=&quot;headerlink&quot; title=&quot;大作文&quot;&gt;&lt;/a&gt;大作文&lt;/h1&gt;&lt;h2 id=&quot;静态图开头&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="英语" scheme="https://konjacor.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>杂谈</title>
    <link href="https://konjacor.github.io/2023/08/31/%E6%9D%82%E8%B0%88/"/>
    <id>https://konjacor.github.io/2023/08/31/%E6%9D%82%E8%B0%88/</id>
    <published>2023-08-31T10:36:51.000Z</published>
    <updated>2024-04-09T05:07:54.831Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><ul><li>这个就相当于自己平时生活的时候想起来啥写点啥了，也没啥结构啥的，就是即兴，但是我之后会从中提取一些比较精华的内容写到专门的和那些内容有关的文章当中去。</li><li>然后具体哪一天突然想写点什么东西了我会用当天的日期做标题，然后自己想写点和某种主题相关的文字时，标题就和那个主题是相关的。</li></ul><h2 id="我为什么想要终身学习"><a href="#我为什么想要终身学习" class="headerlink" title="我为什么想要终身学习"></a>我为什么想要终身学习</h2><h3 id="往日之影"><a href="#往日之影" class="headerlink" title="往日之影"></a>往日之影</h3><ul><li><p>其实在几年之前我对学习这个事情的态度还是有那么点抵触情绪在里面的，具体就是体现在不太想去学习学校里的一些必修科目，或者是在学习这些科目的时候觉得自己耗费大量的精力在这上面收获不大，这大概也是受到一些网络上一些比较浮躁的文化的影响，再加上当时自己经历也少，高中压力也不小，自己也没学过马哲，没有办法也没有意识要去客观的深入思考一些问题，所以就只能像一个纸船一样随波逐流，看到别人说什么东西，自己就感觉“哦，我感觉好像确实也是这样的”，而不是去深入思考其中蕴含着的本质以及去客观思考那个人说的观点到底是不是正确的。</p></li><li><p>上面这样的我在现如今看来无异于被人轻易操纵的木偶，别人只需要付出很少的但是却极具技巧性的廉价代价就能在一定程度上转变你的思想，我非常讨厌这种感觉，这可能是基因决定的吧，但是有的时候自己意识不到自己处于这种状态之中，这种情况是最难受的，它可能在无形之中对你造成一些损害或者让你产生一些改变，而你过了很长时间意识到的时候，它已经对你产生了不可逆的影响了。所以我认为学习马哲还是相当重要的，最重要的是它能教会你一些社会运行的基本规律，这样遇到一些观点的时候，你就可以利用你学过的基础知识来去进行客观的评估了，当然这有点扯远了。</p></li><li><p>直到到了大学我才在一定程度上看清目前国内的一些情况包括整个世界的一些情况，当然这些认识还是受限于自己大学生的身份，没有更进一步的经历，你对整体形式的看法就一定会受限，因为缺少实践，你的理论和猜想无法得到证实，谈论它们也就没有了意义，这也是我在《学习的核心》一文中强调实践非常重要的原因之一，但是这相比于高中的时候是好多了，所以还是想记录一下，大不了等步入社会之后再回来进行修改嘛。</p></li><li></li><li><p>渐渐的自己也从之前对学习有那么一点抵触情绪变成了现在的非常热爱学习，因为我真正明确了自己想要什么，自己想要知道什么，自己以后想要做什么，欲望、好奇和理想是学习动力的一部分</p></li></ul><h3 id="生活之苦"><a href="#生活之苦" class="headerlink" title="生活之苦"></a>生活之苦</h3><ul><li>属于是还没走出社会就已经能预测到以后生活的苦了，从家长的只言片语中我也能感觉出来生活其实是不简单的一件事，尤其是你想组建一个家庭，你想让你的家庭感到幸福，这更是一件非常困难的事情</li></ul><h2 id="为什么我觉得考研这件事横竖都是赚"><a href="#为什么我觉得考研这件事横竖都是赚" class="headerlink" title="为什么我觉得考研这件事横竖都是赚"></a>为什么我觉得考研这件事横竖都是赚</h2><ul><li>我感觉很多身边的人对考研这个事情都非常的焦虑，总是在思考类似“自己考不上怎么办”这样的问题，然后自己花很长时间在思考这类问题上。其实我觉得这样的思考无可厚非，因为大家对于这样的大型考试肯定是或多或少都会有点焦虑的情绪在里面，这个我感觉应该是很难避免的，只要这种思考不要影响到日常的学习就行，但是这一点却很难做到，毕竟情绪这个东西，谁也说不好，说不定学着学着心态就爆炸了，所以说考研也是对心态的考研。</li><li>好吧又有点扯远了，重新说回这个导致焦虑的问题本身，我们不妨利用马哲的知识，从本质上思考一下，我们为什么会感觉到焦虑，我感觉大部分人应该是害怕自己考不上白白浪费一年的时间，实际上这样的想法在我看来是十分错误的，我们还是从本质上来思考考研这个过程，我们学到的内容其实不是最重要的，最重要的是你在学习过程中养成的学习思维等一些比较抽象的东西，这个我感觉很多人应该都知道，像是高中我们学的一些自然科学的知识，很多我们可能现在已经忘得差不多了，但是你能说学那些东西对我们来说没有意义吗，当然不能，凡事不能只看到结果，更要看到过程，在学习那些科目的过程中，我们养成了良好的科学思维，激发了我们的探究兴趣等，这些都在潜移默化中重塑着我们的思想观念和解决问题的切入点等。考研在这方面的体现比起高中有过之而无不及，考研所考的四门科目，政治教会我们用客观的眼光去解析世间万物，并且告诉我们世界运行的基本规律，我觉得这真的很cooooooool，因为我一直比较好奇世界到底是怎么运行的，当然学的这些理论还需要和自己的阅历相辅相成，而且这些知识对我们来说都是终身受益的；英语更不用说，如果想要谋求更进一步的发展，学好英语绝对是如虎添翼的，或许以后会有出国发展的机会，学英语是绝对不亏的；数学更是重量级，对我们逻辑思维的锻炼绝对是t0级别的存在，逻辑思维的重要性我觉得不用多说了，有更好的逻辑思维就说明你在遇到问题的时候有更大概率找到解决问题的方式；专业课的学习更多的是对自己大学所学的重新巩固的夯实，这些都是我们以后所依赖的根基。所以说考研的过程就好像一个巨大的脑力健身房，你在这个健身房中不断地锤炼自己的各项基本能力，把这些东西练成自己的肌肉记忆之后，你会发现你的层次会上升一个阶段，在面对一个问题的时候，你会下意识地给出别人给不出的解决方案，这种上升是自己内在力量的上升，它不借助于你是否考上了这一个结果而表达，也就是说，无论你考上还是没考上，你个人整体素质的提升是实实在在的，当然前提是你认真复习了，而这种提升才是我们真正想要得到的东西，学历也只是一个添头罢了，当然能拿到学历自然是最好。</li><li>所以说我认为完全没有必要为了自己可能考不上这样的问题去焦虑。因为考上考不上我们的核心能力都能有实打实的提高，这才应该是我们真正应该追求的东西，这才是考研的本质所在，所以考研这个事横竖都是赚。</li></ul><h2 id="无忧旋律"><a href="#无忧旋律" class="headerlink" title="无忧旋律"></a>无忧旋律</h2><p>- </p><h2 id="借力打力"><a href="#借力打力" class="headerlink" title="借力打力"></a>借力打力</h2><h2 id="表情面具"><a href="#表情面具" class="headerlink" title="表情面具"></a>表情面具</h2><ul><li>能不能用在脸上贴微型传感器的方式来实现表情控制，因为我感觉人脸的各种表情在很多地方存在特征点，比如皱眉的表情就可以在眉毛末端加上传感器，然后如果检测到两个传感器之间的距离缩小，那么就可以识别为皱眉；开心的表情可以在嘴角贴传感器；诸如此类。</li></ul><h2 id="工作ai"><a href="#工作ai" class="headerlink" title="工作ai"></a>工作ai</h2><ul><li>能不能自己实现一个可以帮自己处理任务的ai</li></ul><h2 id="弘德明志，博学笃行"><a href="#弘德明志，博学笃行" class="headerlink" title="弘德明志，博学笃行"></a>弘德明志，博学笃行</h2><h2 id="工业糖精动画"><a href="#工业糖精动画" class="headerlink" title="工业糖精动画"></a>工业糖精动画</h2><ul><li>说白了就是浮躁，在这个快节奏的时代，越来越多的人内心充满了浮躁，当这种人在动画或者别的什么领域中的受众占大部分时，资本就会去迎合他们以获取最大的利益，资本是不会给你讲道理的，他不会说：“啊，我感觉这样浮躁的作品不太好，所以我们不做了吧。”，不会的，它们只会做能获取最大利益的事情，所以在这里可以把资本这个东西看作是一个客观事物，明确这个事物的本质和根本属性就是只会最大限度地逐利，当明确好这个定义之后，实际上就能看出来，工业糖精的盛行其实和厂商关系不大，最主要还是和群众有关，所以解决这个问题的关键我认为是要倡导慢节奏风气并且在互联网上尽可能地向群众输出不那么短平快的慢节奏内容（这一点实际上是触动了某些资本的利益——比如一些通过有意识地潜移默化改变群众的生活习惯以迎合他们的产品性质的公司，所以绝对不会轻易地解决，而且群众的浮躁往往不止和他们在网上接触到的内容有关，很大程度上还和一个国家的意识形态、经济基础相关，比如说如果一个国家的人民的日均工作时长很长，那么大部分的人不会在空闲时间去做一些慢节奏的事情，所以想要从这个方面解决或者缓解这个问题牵涉到的东西太多难以下手），以及加强基础教育方面对反对浮躁心态的引导，我认为主要可以通过增加冥想、修心一类的课程来从小引导孩子们慢下来进行专注的思考。</li></ul><h2 id="消息app"><a href="#消息app" class="headerlink" title="消息app"></a>消息app</h2><ul><li>最上方banner图可以显示最新最热的活动</li><li>主体是群聊列表，支持创建临时群聊（用于活动、比赛等）</li></ul><h2 id="用着比较好用的软件、网站等"><a href="#用着比较好用的软件、网站等" class="headerlink" title="用着比较好用的软件、网站等"></a>用着比较好用的软件、网站等</h2><h3 id="开源的电子书阅读器koodo-reader"><a href="#开源的电子书阅读器koodo-reader" class="headerlink" title="开源的电子书阅读器koodo reader"></a>开源的电子书阅读器koodo reader</h3><h3 id="世界上最大的电子书图书馆Zlibrary"><a href="#世界上最大的电子书图书馆Zlibrary" class="headerlink" title="世界上最大的电子书图书馆Zlibrary"></a>世界上最大的电子书图书馆Zlibrary</h3><h3 id="画图神器开源软件drawio"><a href="#画图神器开源软件drawio" class="headerlink" title="画图神器开源软件drawio"></a>画图神器开源软件drawio</h3><h3 id="笔记神器typora"><a href="#笔记神器typora" class="headerlink" title="笔记神器typora"></a>笔记神器typora</h3><h2 id="要不要装一台NAS？或者自己搭建一台服务器？"><a href="#要不要装一台NAS？或者自己搭建一台服务器？" class="headerlink" title="要不要装一台NAS？或者自己搭建一台服务器？"></a>要不要装一台NAS？或者自己搭建一台服务器？</h2><h2 id="惊喜感的来源是“不按套路出牌”"><a href="#惊喜感的来源是“不按套路出牌”" class="headerlink" title="惊喜感的来源是“不按套路出牌”"></a>惊喜感的来源是“不按套路出牌”</h2><h2 id="幸福感的来源是“失而复得”"><a href="#幸福感的来源是“失而复得”" class="headerlink" title="幸福感的来源是“失而复得”"></a>幸福感的来源是“失而复得”</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;这个就相当于自己平</summary>
      
    
    
    
    
    <category term="杂谈" scheme="https://konjacor.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>软件工程与计算（卷二）-软件开发的技术基础</title>
    <link href="https://konjacor.github.io/2023/08/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97%EF%BC%88%E5%8D%B7%E4%BA%8C%EF%BC%89-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"/>
    <id>https://konjacor.github.io/2023/08/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97%EF%BC%88%E5%8D%B7%E4%BA%8C%EF%BC%89-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</id>
    <published>2023-08-10T08:06:03.000Z</published>
    <updated>2023-08-10T08:27:25.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分-软件工程概论"><a href="#第一部分-软件工程概论" class="headerlink" title="第一部分 软件工程概论"></a>第一部分 软件工程概论</h1><h2 id="第1章-软件工程基础"><a href="#第1章-软件工程基础" class="headerlink" title="第1章 软件工程基础"></a>第1章 软件工程基础</h2><h2 id="第2章-软件工程的发展"><a href="#第2章-软件工程的发展" class="headerlink" title="第2章 软件工程的发展"></a>第2章 软件工程的发展</h2><h1 id="第二部分-项目启动"><a href="#第二部分-项目启动" class="headerlink" title="第二部分 项目启动"></a>第二部分 项目启动</h1><h2 id="第3章-示例项目描述"><a href="#第3章-示例项目描述" class="headerlink" title="第3章 示例项目描述"></a>第3章 示例项目描述</h2><h2 id="第4章-项目管理基础"><a href="#第4章-项目管理基础" class="headerlink" title="第4章 项目管理基础"></a>第4章 项目管理基础</h2><h1 id="第三部分-需求开发阶段"><a href="#第三部分-需求开发阶段" class="headerlink" title="第三部分 需求开发阶段"></a>第三部分 需求开发阶段</h1><h2 id="第5章-软件需求基础"><a href="#第5章-软件需求基础" class="headerlink" title="第5章 软件需求基础"></a>第5章 软件需求基础</h2><h2 id="第6章-需求分析方法"><a href="#第6章-需求分析方法" class="headerlink" title="第6章 需求分析方法"></a>第6章 需求分析方法</h2><h2 id="第7章-需求文档化与验证"><a href="#第7章-需求文档化与验证" class="headerlink" title="第7章 需求文档化与验证"></a>第7章 需求文档化与验证</h2><h1 id="第四部分-软件设计"><a href="#第四部分-软件设计" class="headerlink" title="第四部分 软件设计"></a>第四部分 软件设计</h1><h2 id="第8章-软件设计基础"><a href="#第8章-软件设计基础" class="headerlink" title="第8章 软件设计基础"></a>第8章 软件设计基础</h2><h2 id="第9章-软件体系结构基础"><a href="#第9章-软件体系结构基础" class="headerlink" title="第9章 软件体系结构基础"></a>第9章 软件体系结构基础</h2><h2 id="第10章-软件体系结构设计与构建"><a href="#第10章-软件体系结构设计与构建" class="headerlink" title="第10章 软件体系结构设计与构建"></a>第10章 软件体系结构设计与构建</h2><h2 id="第11章-人机交互设计"><a href="#第11章-人机交互设计" class="headerlink" title="第11章 人机交互设计"></a>第11章 人机交互设计</h2><h2 id="第12章-详细设计的基础"><a href="#第12章-详细设计的基础" class="headerlink" title="第12章 详细设计的基础"></a>第12章 详细设计的基础</h2><h2 id="第13章-详细设计中的模块化与信息隐藏"><a href="#第13章-详细设计中的模块化与信息隐藏" class="headerlink" title="第13章 详细设计中的模块化与信息隐藏"></a>第13章 详细设计中的模块化与信息隐藏</h2><h2 id="第14章-详细设计中面向对象方法下的模块化"><a href="#第14章-详细设计中面向对象方法下的模块化" class="headerlink" title="第14章 详细设计中面向对象方法下的模块化"></a>第14章 详细设计中面向对象方法下的模块化</h2><h2 id="第15章-详细设计中面向对象方法下的信息隐藏"><a href="#第15章-详细设计中面向对象方法下的信息隐藏" class="headerlink" title="第15章 详细设计中面向对象方法下的信息隐藏"></a>第15章 详细设计中面向对象方法下的信息隐藏</h2><h2 id="第16章-详细设计的设计模式"><a href="#第16章-详细设计的设计模式" class="headerlink" title="第16章 详细设计的设计模式"></a>第16章 详细设计的设计模式</h2><h1 id="第五部分-软件构造、测试、交付与维护"><a href="#第五部分-软件构造、测试、交付与维护" class="headerlink" title="第五部分 软件构造、测试、交付与维护"></a>第五部分 软件构造、测试、交付与维护</h1><h2 id="第17章-软件构造"><a href="#第17章-软件构造" class="headerlink" title="第17章 软件构造"></a>第17章 软件构造</h2><h2 id="第18章-代码设计"><a href="#第18章-代码设计" class="headerlink" title="第18章 代码设计"></a>第18章 代码设计</h2><h2 id="第19章-软件测试"><a href="#第19章-软件测试" class="headerlink" title="第19章 软件测试"></a>第19章 软件测试</h2><h2 id="第20章-软件交付"><a href="#第20章-软件交付" class="headerlink" title="第20章 软件交付"></a>第20章 软件交付</h2><h2 id="第21章-软件维护与演化"><a href="#第21章-软件维护与演化" class="headerlink" title="第21章 软件维护与演化"></a>第21章 软件维护与演化</h2><h1 id="第六部分-软件过程模型与职业基础"><a href="#第六部分-软件过程模型与职业基础" class="headerlink" title="第六部分 软件过程模型与职业基础"></a>第六部分 软件过程模型与职业基础</h1><h2 id="第22章-软件开发过程模型"><a href="#第22章-软件开发过程模型" class="headerlink" title="第22章 软件开发过程模型"></a>第22章 软件开发过程模型</h2><h2 id="第23章-软件工程职业基础"><a href="#第23章-软件工程职业基础" class="headerlink" title="第23章 软件工程职业基础"></a>第23章 软件工程职业基础</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一部分-软件工程概论&quot;&gt;&lt;a href=&quot;#第一部分-软件工程概论&quot; class=&quot;headerlink&quot; title=&quot;第一部分 软件工程概论&quot;&gt;&lt;/a&gt;第一部分 软件工程概论&lt;/h1&gt;&lt;h2 id=&quot;第1章-软件工程基础&quot;&gt;&lt;a href=&quot;#第1章-软件工</summary>
      
    
    
    
    
    <category term="软件工程" scheme="https://konjacor.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://konjacor.github.io/2023/08/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://konjacor.github.io/2023/08/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-08-10T07:17:23.000Z</published>
    <updated>2023-08-10T08:03:35.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h1><h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h2><h2 id="操作系统的发展历程"><a href="#操作系统的发展历程" class="headerlink" title="操作系统的发展历程"></a>操作系统的发展历程</h2><h2 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h2><h2 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h2><h2 id="操作系统引导"><a href="#操作系统引导" class="headerlink" title="操作系统引导"></a>操作系统引导</h2><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h1 id="第二章-进程与线程"><a href="#第二章-进程与线程" class="headerlink" title="第二章 进程与线程"></a>第二章 进程与线程</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h1 id="第三章-内存管理"><a href="#第三章-内存管理" class="headerlink" title="第三章 内存管理"></a>第三章 内存管理</h1><h2 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h2><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><h1 id="第四章-文件管理"><a href="#第四章-文件管理" class="headerlink" title="第四章 文件管理"></a>第四章 文件管理</h1><h1 id="第五章-输入输出（I-x2F-O）管理"><a href="#第五章-输入输出（I-x2F-O）管理" class="headerlink" title="第五章 输入输出（I&#x2F;O）管理"></a>第五章 输入输出（I&#x2F;O）管理</h1><h2 id="I-x2F-O控制"><a href="#I-x2F-O控制" class="headerlink" title="I&#x2F;O控制"></a>I&#x2F;O控制</h2><h2 id="I-x2F-O核心子系统"><a href="#I-x2F-O核心子系统" class="headerlink" title="I&#x2F;O核心子系统"></a>I&#x2F;O核心子系统</h2><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-计算机系统概述&quot;&gt;&lt;a href=&quot;#第一章-计算机系统概述&quot; class=&quot;headerlink&quot; title=&quot;第一章 计算机系统概述&quot;&gt;&lt;/a&gt;第一章 计算机系统概述&lt;/h1&gt;&lt;h2 id=&quot;操作系统的基本概念&quot;&gt;&lt;a href=&quot;#操作系统的基本概</summary>
      
    
    
    
    
    <category term="操作系统" scheme="https://konjacor.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>考研进度</title>
    <link href="https://konjacor.github.io/2023/04/17/%E8%80%83%E7%A0%94%E8%BF%9B%E5%BA%A6/"/>
    <id>https://konjacor.github.io/2023/04/17/%E8%80%83%E7%A0%94%E8%BF%9B%E5%BA%A6/</id>
    <published>2023-04-17T10:47:53.000Z</published>
    <updated>2024-04-21T03:18:34.893Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="准备初试"><a href="#准备初试" class="headerlink" title="准备初试"></a>准备初试</h2><ul><li>3.16-4.16：复习完了高数二的基本知识。学习完了考研要考的英语语法，仍然以每日过一个单元的红宝书单词和不背单词app混合背单词。</li><li>4.17-5.13：复习完了线性代数的基本知识。实体书单词不再花时间背，因为软件上的单词每天要花我很长时间，争取在6.17日也就是六级考试之前过完一遍单词，软件上现在每天大约复习300个，学习100个。每日一句长难句。每日至少一篇阅读理解。在下一个阶段首要的任务是6.10号的蓝桥杯国赛需要适量刷算法，然后开始顺第二遍数学的内容并梳理笔记+anki+刷题，英语单词、长难句、阅读照旧，还有就是在刷完两三套真题之后去听听唐迟的阅读课。</li><li>话题词汇可能需要分类背一下；还有同义词近义词；《词汇的逻辑》这本书买吗？</li><li>整理每日一句长难句的书上的知识点；used to 过去常常做某事（暗含现在已经不在做了）</li><li>需要整理成anki的知识点：常见的奇偶函数p5、奇偶函数的四则运算p5、常见函数的周期p5、常见的有界函数p6</li><li>5.14-6.30：红宝书单词每个词至少背过了一遍，阅读一直在刷，线代的660刷完了，线性代数辅导讲义学完一半，高数开始强化阶段，软二看了一遍，数据结构看了一大半。</li><li>7.1-7.9：回家休息一段时间，期间还和家人去了北京玩。</li><li>7.10-8.10：每天在复习少量单词，英语开始刷三小门，线代强化完毕，数据结构复习了一遍，os复习了一遍，在看政治课，高数强化完大部分</li><li>8.10-9.10：仍然每天复习少量的单词，英语开始作文；高数强化完毕开始刷严选题，线代刷880；数据结构刷完题复习力扣算法，os刷完题，计算机网络刷完题，准备开始做历年期末题；政治看完马原，1000题同步做。</li><li>9.10-9.20：仍然每天复习少量的单词，但我感觉词组应该开始背了，英语网课所有板块完结，准备开始进一步刷题找手感+巩固语感，准备开始背诵作文；高数刷完一遍严选题，但是很多大题没思路空着，下一步就是对严选题进行改错+高数880基础部分+数2真题，线代继续880；专业课改c语言和数据结构了，看完了一遍谭浩强的c准备刷c的题；政治复习完了思修和史纲，准备开毛中特。</li><li>9.20-11.18：这可能是我考前最后一次写进度了，从这之后我会进入最后的冲刺阶段，然后自上次之后英语仍然每天保证复习少量单词，然后在11月中旬开始了英2真题二刷，从大概10月下旬开始的吧，就每天学习一篇作文，直到11月上旬开始每天自己写一篇作文，每天做一篇阅读理解或者完形填空，保证每天复习两篇之前学过的作文；然后就是数学，严选题的改错被搁置了，主要这段时间刷了一下十几年的真题，然后就是写了写李林880，有部分错还没改完，有部分题没做完，线代做完了880，下个阶段就做各种模拟卷吧，做完模拟卷之后再考虑把之前的错改改；专业课没啥好说的，基本就是每天做一点题保持手感；政治主要就是刷了两遍肖1000，然后做肖8，看背诵手册辅以一些anki资料，这个也没啥好说的。然后今天把没打完的游戏打完了，剩下的时间我就全力以赴吧，就剩一个月了，没啥好说的，等着考完试再做最后部分的补充和复盘吧。</li><li>11.18-12.22：最后这段时间英语的话也是每天练练阅读保持手感，然后每天背大作文的词组和小作文，每天背背单词，没啥好说的；然后就是数学，数学的话我刷了一些模拟题，主要是李林6套卷、李林4套卷、张宇8套卷，然后把之前剩下没刷的真题刷了刷，加上之前刷的真题一共刷了差不多18张吧，然后就是最后又复习了一下书上的基础知识；然后就是政治，政治就是每天用苍盾小程序刷套卷选择题，刷以前的错题啥的，然后论述题的话在肖四到了之后开始背肖四，不过这东西太难背了，我感觉我背书的效率很低，只能是记个大概，背不熟练；最后就是专业课，最后回归基础知识，看了看之前就不太熟练的内容，然后看了看王道书上的算法。</li></ul><h3 id="时间规划"><a href="#时间规划" class="headerlink" title="时间规划"></a>时间规划</h3><ul><li>我大概是把一天的学习时间分成三块，上午大概就是8点半起床背会儿单词，吃个面包，然后九点到自习室，学到中午十二点，三个来小时；中午吃了饭之后打会儿游戏，12点50睡觉；下午一点半起，背会儿单词，然后想玩游戏就玩半个小时游戏，可能两点到自习室或者两点半到自习室，然后学到大概五点半，学三个小时到三个半小时，然后五点半到六点半想吃东西就吃点东西，想打游戏就打会儿游戏；晚上六点半到十点或者十点半，学三个半小时或者四个小时；晚上回去之后打游戏，睡前背会儿单词，十二点睡觉，如果觉得明天起得来就多刷会儿手机十二点半睡觉或者一点睡觉（不过不推荐睡眠时间小于8小时，第二天真的很累）。综上所述，大概一天学9-11个小时吧，这是中后期的作息，前期每天可能也就6-8个小时。</li><li>然后周一到周五我大概率是全勤的。然后周六大概率会和舍友出去吃个饭，早上可能起来刷会儿手机直接吃饭去了，然后吃完饭回来很撑，中午睡一觉大概率睡到下午三点以后，就大概率又不太想去自习室了，晚上如果想去学就去学，不想去就玩游戏。周天大概率会学两块时间，具体哪两块不确定。</li><li>学习的时候一定要做到高效率且心无旁骛，不要想着游戏，一定要进入心流状态；玩的时候也要好好玩，不要想学习上的事情，这样才能放松身心备战下一次学习。</li></ul><h3 id="考试之前需要完成背诵的一些东西"><a href="#考试之前需要完成背诵的一些东西" class="headerlink" title="考试之前需要完成背诵的一些东西"></a>考试之前需要完成背诵的一些东西</h3><ul><li>c语言的运算符优先级</li><li>c语言的常用头文件和对应的函数</li><li>c语言常用函数的原型</li><li>c语言各变量所占空间</li><li>常用的词组和积累的生词</li><li>常用的泰勒公式，各等价无穷小，各定义，积累下来的公式等</li></ul><h2 id="初试结束"><a href="#初试结束" class="headerlink" title="初试结束"></a>初试结束</h2><ul><li>考完了，感觉24年的题比23年的题要难，总体发挥感觉中等偏下，然后考完试对对答案好了。</li><li>政治：单选好像没错，多选错了4个，客观题42分，主观题我感觉我写的一般，再加上天津旱区，算个20我感觉就很高了，一共62分。</li><li>英语2：完型错了3个以上，算5个2.5分，阅读错了4个8分，主观题算扣15分，最后是75左右。</li><li>数学2：错了三个选择15分，后面空着一个大题12分，算错了一个数不知道会扣几分，有个题的第二问还写错了，姑且算个115吧。</li><li>专业课：别的还挺有把握，但是一个程序设计题没写完，最后一个算法题没想出最优解，算个125好了。</li><li>一共就是62+75+115+125&#x3D;377，最后结果应该在370分上下，这放在去年估计够呛能上，希望今年分数线能够降降+扩招多点人。</li><li>南开大学去年的线不高，我这个分肯定能进复试，没啥好说的了，准备复试就好了。</li></ul><h2 id="初试成绩公布"><a href="#初试成绩公布" class="headerlink" title="初试成绩公布"></a>初试成绩公布</h2><ul><li>2024.2.26：出分了，难以置信，最后的总分竟然比自己估的高了四十多分，政治77，英语74，数学120，专业课141，总分412，也算是没辜负我这9个月的努力。</li><li>在学习这方面天道酬勤是对的，但是对于学习成效来说，大体上是由两个维度决定的，其中一个是学习效率，也就是说你能在单位时间内获取多少知识，另外一个就是学习时间，也就是你持续获取知识的时间长度。两者共同作用决定了最后的学习成效，如果学习效率不高但是学习时间长就会陷入劳累和焦虑中，如果再找不到原因所在，很有可能就会变得怨天尤人，心态会受到很大的影响，最后可能导致一蹶不振；同样的，如果学习效率高但是学习时间短就会没有足够的知识储备，到最后考试可能就不会取得一个好成绩。因此如果要想获取比较高的学习成效，就应该从这两个维度着手进行改善，如果能抓住要点进行改善，一定会有所改变，如果没有改变，说明还没抓到要点。</li></ul><h2 id="准备复试"><a href="#准备复试" class="headerlink" title="准备复试"></a>准备复试</h2><ul><li>我准备分为三块来进行准备，第一块就是leetcode，把以前刷过的题再用c语言刷一遍；第二块就是准备复试的笔试，学编译原理和复习其他科目（其中复试的笔试科目主要是计算机组成原理、操作系统、计算机网络、软件工程、离散数学、数据库系统原理、编译原理等）；最后第三块就是毕业设计的项目同步推进。</li><li>复试分为笔试、机试、面试，整个复试在最后的加权总分中占50%，其中笔试、机试、面试又分别占复试分数的30%、30%、40%，并且分别设有30、30、60的及格线，复试单科不及格或者复试总分没超过60都会被刷掉。</li></ul><h2 id="复试结束"><a href="#复试结束" class="headerlink" title="复试结束"></a>复试结束</h2><ul><li>拟录取了，准备最后再完善完善毕设，心情没有自己想象中的那么激动，甚至还有些空虚感，高考结束后，虽然自己考的很一般，但是还有朋友们一起玩，自己也感觉挺开心，考研结束后，朋友们都各自有事情在忙，大部分时间我都是自己一个人，我虽然知道以后应该做一些什么事情，但却不知道从何处下手。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;准备初试&quot;&gt;&lt;a href=&quot;#准备初试&quot; class=&quot;headerlink&quot; title=&quot;准备初试&quot;&gt;&lt;/a&gt;准备初试&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;3.16-4.16</summary>
      
    
    
    
    
    <category term="考研" scheme="https://konjacor.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
  </entry>
  
  <entry>
    <title>考研英语语法总结</title>
    <link href="https://konjacor.github.io/2023/04/17/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://konjacor.github.io/2023/04/17/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2023-04-17T10:47:40.000Z</published>
    <updated>2023-04-17T10:47:40.631Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>高等数学</title>
    <link href="https://konjacor.github.io/2023/04/17/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    <id>https://konjacor.github.io/2023/04/17/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/</id>
    <published>2023-04-17T03:28:35.000Z</published>
    <updated>2023-11-18T14:28:11.157Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><div class="row">    <embed src="/pdf/test/test.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="函数、极限、连续"><a href="#函数、极限、连续" class="headerlink" title="函数、极限、连续"></a>函数、极限、连续</h2><ul><li>函数的定义</li><li>反函数和原函数之间的关系</li><li>极限的定义</li><li>极限的局部有界性、保号性、极限和函数值之间的关系</li><li>基本极限</li><li>等价无穷小代换</li><li>有理运算法则</li><li>带皮亚诺余项的泰勒公式</li><li>夹逼准则</li><li>单调有界准则</li><li>定积分定义求数列极限</li><li>先斩后奏求数列极限</li><li>隐函数求导</li><li>参数方程求导</li><li>连续函数有界定理、最值定理、介值定理、零点定理</li></ul><h2 id="一元函数微分学"><a href="#一元函数微分学" class="headerlink" title="一元函数微分学"></a>一元函数微分学</h2><ul><li>可导的两种定义，一种适合用于求某点处的导数，另一种适合用于求导函数</li><li>可微的定义和其等价形式</li><li>连续、可导、可微之间的关系</li><li>罗尔定理</li><li>拉格朗日中值定理</li><li>柯西中值定理</li><li>带拉格朗日余项的泰勒公式</li><li>罗尔定理的推论</li><li>一元函数的极值的必要条件和充分条件（三个）</li><li>一元函数的拐点的必要条件和充分条件（三个）</li><li>求一元函数的最值（特殊点+线上极值）</li></ul><h2 id="一元函数积分学"><a href="#一元函数积分学" class="headerlink" title="一元函数积分学"></a>一元函数积分学</h2><ul><li>不定积分存在定理（记牢公式）</li><li>定积分存在定理</li><li>凑微分</li><li>换元</li><li>分部积分</li><li>多项式分式求积分</li><li>三角函数求积分（sin变号引起符号变化、cos变号引起符号变化、sin和cos都变号不引起符号变化、万能代换）</li><li>简单无理函数求积分</li><li>牛顿莱布尼茨公式求定积分</li><li>奇偶性求定积分</li><li>点火公式&#x2F;华里士公式</li><li>提x公式</li><li>几何意义求定积分</li><li>上下界不变的还原求定积分</li><li>求定积分前要保证被积函数不会变化</li><li>求定积分前要保证被积函数在上下界之间连续或有有限个第一类间断点</li><li>两类反常积分的定义</li><li>两类p积分</li><li>反常积分判敛散性（定义或极限法的比较形式）</li></ul><h2 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h2><ul><li>可分离变量</li><li>齐次</li><li>一阶线性</li><li>xy地位互换（区别于变量代换，只是看待问题的视角发生变化）</li><li>整体思想+换元</li><li>可降阶（无x 或 无y）</li><li>高阶齐次、非齐次线性微分方程解的结构和性质</li><li>高阶非齐次常系数线性微分方程的解法（特征方程+写出每个根对应的解）</li><li>高阶齐次常系数线性微分方程的解法（齐次通解+非齐次特解）</li><li>给出部分解得到原方程</li></ul><h2 id="多元函数微分学"><a href="#多元函数微分学" class="headerlink" title="多元函数微分学"></a>多元函数微分学</h2><ul><li>重极限的定义</li><li>重极限某一方向上的保号性</li><li>计算重极限（从次幂初步判断结果后：定一个方向或一组方向证不存在、无穷小量x有界变量、等价代换、有理运算法则、加绝对值放缩夹逼等）</li><li>偏导数的定义和几何意义</li><li>求偏导的方法</li><li>求偏积分的方法</li><li>全微分的定义和其4种等价形式</li><li>全微分形式的不变性</li><li>多元隐函数求导的三种方法（公式法、两边求偏导、两边求全微分）</li><li>重极限、偏导、全微分之间的关系</li><li>多元函数极值的定义</li><li>多元函数极值的充分条件和必要条件</li><li>拉格朗日乘数法求极值</li><li>多元函数求最值（特殊点+线上极值+面上极值）</li></ul><h2 id="二重积分"><a href="#二重积分" class="headerlink" title="二重积分"></a>二重积分</h2><ul><li>多重积分转累次积分</li><li>在直角坐标系上解累次积分</li><li>在极坐标系上解累次积分</li><li>学会列参数方程的累次积分</li><li>直角坐标系和极坐标系之间的转换</li><li>极坐标下用直角坐标（通过变量代换）解题</li><li>利用对称性和奇偶性</li><li>利用变量的轮换对称性（派生内容：变量代换的本质和变量的本质）</li><li>割补法计算对应积分区域的二重积分</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;



	&lt;div class=&quot;row&quot;&gt;
    &lt;embed src=&quot;/pdf/test/test.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;appl</summary>
      
    
    
    
    
    <category term="高等数学" scheme="https://konjacor.github.io/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>The core of studying</title>
    <link href="https://konjacor.github.io/2023/04/15/The-core-of-studying/"/>
    <id>https://konjacor.github.io/2023/04/15/The-core-of-studying/</id>
    <published>2023-04-15T09:45:49.000Z</published>
    <updated>2024-04-21T03:20:25.168Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="Focus-on-your-business"><a href="#Focus-on-your-business" class="headerlink" title="Focus on your business"></a>Focus on your business</h2><ul><li>Concentrate or fail.</li></ul><h2 id="Explore-the-essence-of-knowledge"><a href="#Explore-the-essence-of-knowledge" class="headerlink" title="Explore the essence of knowledge"></a>Explore the essence of knowledge</h2><ul><li>We can’t just focus on the surface of knowledge and should explore the essence of knowledge. So we should frequently speak “Why?” for that.</li></ul><h2 id="Associate-the-things-what-you-want-to-remember-with-another-things"><a href="#Associate-the-things-what-you-want-to-remember-with-another-things" class="headerlink" title="Associate the things what you want to remember with another things"></a>Associate the things what you want to remember with another things</h2><ul><li>Because the core of memory is association.</li></ul><h2 id="Abstract-questions-that-you-meet-to-a-specific-model"><a href="#Abstract-questions-that-you-meet-to-a-specific-model" class="headerlink" title="Abstract questions that you meet to a specific model"></a>Abstract questions that you meet to a specific model</h2><ul><li>Then,you can solve the question in your profound knowledge or the solution of similar model that you remembered before.</li><li>We should focus on improving our capacity of abstracting question, because it directly reflects our faculty of solving questions.</li><li>Build in Abstraction and Expand in detail.</li></ul><h2 id="Proper-amount-of-positive-feedback"><a href="#Proper-amount-of-positive-feedback" class="headerlink" title="Proper amount of positive feedback"></a>Proper amount of positive feedback</h2><ul><li>must ‘proper’</li></ul><h2 id="Repeat-again-and-again"><a href="#Repeat-again-and-again" class="headerlink" title="Repeat again and again"></a>Repeat again and again</h2><ul><li>Don’t repeat mechanically(without thought). You should repeat what you have learned with your thought, then you can progress.</li></ul><h2 id="学习的四大核心：专注、反复、抽象、实践"><a href="#学习的四大核心：专注、反复、抽象、实践" class="headerlink" title="学习的四大核心：专注、反复、抽象、实践"></a>学习的四大核心：专注、反复、抽象、实践</h2><ul><li>这四点是上述内容高度抽象化后的结果。</li></ul><h3 id="主要表现"><a href="#主要表现" class="headerlink" title="主要表现"></a>主要表现</h3><ul><li>“<strong>专注</strong>”毋庸置疑，是任何学习的基础，也就是说你需要全神贯注地对待你手头的任务。如果你觉得自己无法静下心来，可以试试我自创的“深潜”技能，也就是说首先你需要放空大脑，然后深呼吸，在吸气到最大限度的时候，维持一段时间，让自己有一点点缺氧的感觉，同时想象自己一头扎入到了冰冷的海水中不断下潜的感觉，认真感受自己周围刺骨的海水和在水中轻微缺氧的感觉，然后缓缓吐气，如果觉得自己还没有进入状态就再做几组，深潜可以让你快速地进入心流状态。这可能就是一种所谓的“routine”吧。要做到这一点，关键就是要戒浮躁，沉下心来，真正的慢下来，这也是我在考研中获得的提升，要想快速做完一件事情，那么首先要先慢下来。</li><li>“<strong>反复</strong>”是因为，事物的发展具有否定之否定规律，也就是是说事物的发展或者说我们对知识的认知，是螺旋上升的，螺旋表示事物要经过多次否定，也就是说我们会不断地否定我们之前的认知，上升则表示事物一定是在多次否定的过程中不断向前发展的，所以对于知识应该反复多次去记忆、理解，这样就会对它有新的认知。</li><li>“<strong>抽象</strong>”则是要求我们透过事物的现象看到其本质，并对具有相同本质的结构进行归纳整理，比如说我学了两个知识点，而这两个知识点中蕴含着相同的本质，其中体现出来的本质可能是多个，所以我就可以把这两个知识点挂到一个抽象图的那个或那些本质结点下面以和它们构成联系，这样慢慢地你就会发现你学过的知识形成了一张大网，你可以轻易地从其中的一个结点转移到和它相邻的其它结点，也就是说你可以轻易地从一个事物联想到和他相关的其他事物；并且你会得到一种透过现象看到事物本质的能力，而不是只拘泥于事物的表象。当然这几种能力都是需要刻意锻炼的，而且很长时间不用的话可能能力会下降，所以说思考的时候要有意识地去对思考地内容进行抽象，这样或许可以练成一种肌肉记忆。</li><li>“<strong>实践</strong>”是非常重要的一个步骤，它是将理论真正转化为现实的必需步骤，有的时候你可能自己听课，听别人讲，你可能会觉得“哇，他说的太有道理了，我觉得也是这样，我以后遇到问题也会想到这样去解决。”，实际上你以后遇到相同的问题未必就能想起来当时学习的解决方法，而刻意地去实践你所学过的知识，你就会感受到这个理论在应用的时候的各种细节，从而让你更好的把握这个理论的各个方面，如果你的“抽象”能力比较强的话，你会很快地抓住这个理论在实践方面的本质，从而将其加入到你的知识网中，下次遇到相似的问题的时候，你就会快速反应过来应该怎样予以解决。其中费曼学习法中强调的把知识讲给别人听本质上也是实践的一种形式，所以说我这里讲的实践还是比较宽泛的。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>以上四个方面是我在这几年进行学习的时候自己总结的一点心得，其实我感觉应该很多人在之前的高中甚至初中阶段就已经悟出来了，可能形式上和我写的不太一样，但是本质上应该大差不差。</li><li>但是奈何自己以前实在是不上进而且非常浮躁，没有养成一个良好的学习习惯，没有学会专注和深度思考，所以导致这些或许别人看来比较浅显的理论到现在才被我总结出来，所以也是深感惭愧，如果要是能重来，我一定会在初中就刻意地去养成一些学习习惯，养成专注和深度思考的习惯，这些都是能对整个人生起到非常大辅助作用的能力。</li><li>感觉这些内容和费曼学习法有很多重复的内容，等有时间了我再具体甄别这两者吧，争取能将两者融合到一起。</li></ul><h2 id="活用康奈尔笔记法"><a href="#活用康奈尔笔记法" class="headerlink" title="活用康奈尔笔记法"></a>活用康奈尔笔记法</h2><ul><li>也就是把一张纸分成左侧的索引栏，中间的内容栏和最下面的总结栏，我自己实际使用下来感觉还是相当不错的。</li><li>左侧的索引栏既可以当成内容大纲让你快速把握内容结构和快速定位内容，也可以当成背诵的题目，在需要背诵内容的时候，只需捂住内容区然后只看索引栏去回忆相关内容。</li><li>中间的内容栏就是记录具体的内容。</li><li>最下面的总结栏就是总结一下这页中记录的内容，在总结的过程中顺便还能锻炼一下学习四大核心之一的“抽象”技能。</li></ul><h2 id="客观分析高考失利的原因引以为戒"><a href="#客观分析高考失利的原因引以为戒" class="headerlink" title="客观分析高考失利的原因引以为戒"></a>客观分析高考失利的原因引以为戒</h2><ul><li>首先自然是<strong>对于基础知识的熟悉度不够</strong>，基础不牢靠，无法在解决问题的时候调用出相关的知识</li><li>再者是<strong>内心浮躁</strong>看不下去书，真正的进步是靠平时一步步的积累得到的，没有任何方法可以一步登天</li><li>还有就是<strong>对知识的抽象能力不够强</strong>，不应该拘泥于知识的表面，要看到知识的本质，并且将知识进行抽象，这样才可以以不变应万变</li><li>还有就是<strong>在归纳知识上花的有效时间不够多</strong>，应该学完新知识之后将新知识归纳成思维导图，这样在后续复习的时候可以做到缩短复习时间并且思维导图的方式可以清晰地表达出知识和知识之间的联系从而加深印象</li><li>再者就是<strong>精力不够集中</strong>，做什么事就应该一心一意去做，如果说我们的大脑是cpu，那么它同时只能处理一个进程，如果要处理别的进程，就要进行上下文切换，而这要消耗很多的大脑资源，使得大脑的工作效率降低。</li><li>还有就是<strong>对于知识的认知程度不高</strong>，实际上学习的过程不仅是我们对自身逻辑思维能力和思考记忆能力的提升，更是寻找自我存在的过程，学习的过程可以让我们找到自我，可以让我们距离真理更近，可以提升我们的涵养，可以充实我们的精神。</li><li>还有就是<strong>不合理的规划</strong>，实际上对于应试考试来说，我们应该合理地规划我们的学习计划，让我们在力所能及的范围内尽可能地完成学习任务，一定要注意力所能及。</li><li>还有就是<strong>行动力和自制力不强</strong>，做任何事情的基础都是能管理好自己的行动和欲望，做好规划之后就应该严格去执行，在执行的过程中不断地调整规划以达到更高地效率，在这一过程中要高度自律，如果你连自己都管理不好，更别妄言以后会有什么建树了。</li><li>还有就是<strong>没有清晰的自我认知</strong>，自我认知应该是在一次次的实践中总结出来的，实践的次数越多对自己的认知就越完善，如果对自己没有一个清晰的自我认知，那么在很多事情上就可能导致误判，会有很多严重的后果。</li><li>还有就是<strong>太想要走捷径</strong>，学习没有捷径可走，硬要说捷径的话那就是脚踏实地打好基础，在这基础之上再进行技巧性的训练。不要一开始就把精力过度花费在什么速成方法，什么秒杀方法上，如果这些东西真的有那么大的作用，那大家不用打基础了直接学这些就行了，这些东西适合基础好的时候，拿部分时间出来看看即可。永远要记住：学习无捷径，唯有脚踏实地；天上不会掉馅饼；如果你想快速做好一件事，那就应该先让自己慢下来。</li></ul><h2 id="关于学习成效"><a href="#关于学习成效" class="headerlink" title="关于学习成效"></a>关于学习成效</h2><ul><li>在学习这方面天道酬勤是对的，但是对于学习成效来说，大体上是由两个维度决定的，其中一个是<strong>学习效率</strong>，也就是说你能在单位时间内获取多少知识，另外一个就是<strong>学习时间</strong>，也就是你持续获取知识的时间长度。两者共同作用决定了最后的学习成效，如果学习效率不高但是学习时间长就会陷入劳累和焦虑中，如果再找不到原因所在，很有可能就会变得怨天尤人，心态会受到很大的影响，最后可能导致一蹶不振；同样的，如果学习效率高但是学习时间短就会没有足够的知识储备，到最后考试可能就不会取得一个好成绩。因此如果要想获取比较高的学习成效，就应该从这两个维度着手进行改善，如果能抓住要点进行改善，一定会有所改变，如果没有改变，说明还没抓到要点。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h2 id=&quot;Focus-on-your-business&quot;&gt;&lt;a href=&quot;#Focus-on-your-business&quot; class=&quot;headerlink&quot; title=&quot;F</summary>
      
    
    
    
    
    <category term="studying" scheme="https://konjacor.github.io/tags/studying/"/>
    
  </entry>
  
  <entry>
    <title>大三下决定考研之前的一点感想</title>
    <link href="https://konjacor.github.io/2023/03/12/%E5%A4%A7%E4%B8%89%E4%B8%8B%E5%86%B3%E5%AE%9A%E8%80%83%E7%A0%94%E4%B9%8B%E5%89%8D%E7%9A%84%E4%B8%80%E7%82%B9%E6%84%9F%E6%83%B3/"/>
    <id>https://konjacor.github.io/2023/03/12/%E5%A4%A7%E4%B8%89%E4%B8%8B%E5%86%B3%E5%AE%9A%E8%80%83%E7%A0%94%E4%B9%8B%E5%89%8D%E7%9A%84%E4%B8%80%E7%82%B9%E6%84%9F%E6%83%B3/</id>
    <published>2023-03-12T11:36:27.000Z</published>
    <updated>2024-04-09T05:04:10.283Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul><li>今天是2023年3月12日，我怀着复杂的心情决定要进行考研了，其实这个选择并不是我计划的首选项，我的首选项其实是本科就业的，但是在23届秋招的时候我尝试投了一些简历，大多都是石沉大海，看到这个结果的时候，我才意识到，在这里一纸学历对于进入公司门槛来说有多么重要以及现在互联网行业的内卷程度有多么激烈，面试准备得再好，没人约面，也只是空谈，更何况我感觉自己准备的还不是那么充分，所以想要进一步提升学历，再给自己一点时间。</li><li>其实这个时候我也可以赌，赌24届的秋招会开很多hc，但是我自己也对自己没什么底气，毕竟学历在这里摆着，除非你在别的方面的贡献能薄纱92选手，公司不傻，通过学历这种最简单粗暴的方式筛人是最好不过的，思来想去，还是决定不去赌这个概率，去考研的话，也全当实验一下自己最新的思考体系、学习英语和复习408了，至少我觉得这三个东西对我以后的发展还是很有帮助的。</li><li>其实想想也挺后悔的，后悔自己当初本科没能上个92，如果当时能上个92，现在我也不至于这么纠结了；后悔自己在高一高二没有打下良好的学科基础，在高一的时候我还非常怠惰，有些自负，虽然现在想起来完全不知道自己底气何在，当时甚至和同学吵架只为满足自己的好胜心，直到现在还很想和当时的同学说声抱歉；后悔自己在高三时候的错误路线，过度焦虑内耗，不去巩固基础反而去看那些秒杀诀窍什么的，成功没有捷径，唯有踏踏实实夯实基础然后再适当拔高，至少对我来说，还有一些原因就不说了。</li><li>但是这些也已经发生了，变成过往云烟了，现在后悔也毫无意义了，只能说当时学习的体系有点问题，在上了大学之后，我不敢说自己有多么努力，但是我觉得自己至少不怠惰，努力想要去争取更好的未来，课外学习、做项目、搞竞赛也都积极去尝试，虽说结果可能不太尽人意，人外有人，天外有天，内卷的漩涡中，没有人不在拼命挣扎，没有人敢说自己有多么多么努力，也没有人敢肯定自己以后一定能有多高的成就，这是个死局，只要你想往上爬，就无法挣脱它，这是由于中国的教育抓起来了，经济也起来了，越来越多的人能接触到高等教育了，再加上我们的人口基数，这样的结果也不奇怪，所以既然自己不想起点这么低，也就只能选择这条路了，但是可以预见的，这条路必定是充满坎坷的，希望我能熬过去吧。</li><li>既然决定了，那就把200%的精力放在上面，就业那条线就先不要管了，八股文、项目、算法啥的目前做到的阶段我在下面详细列举一下，这样可以在上岸之后把上下文恢复一下，重新投身到我喜欢的这个领域中，啊，我真的很喜欢后端开发，其中的设计模式的思想、后端严谨的结构、前辈们留下的代码和工具以及那种对项目的掌控感令人陶醉，让人很有深究下去的欲望。</li></ul><h1 id="我的经历"><a href="#我的经历" class="headerlink" title="我的经历"></a>我的经历</h1><ul><li>写写我这几年的经历吧，省的之后忘了。</li></ul><h2 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h2><ul><li>首先就是加入了acm队，打下了一些算法基础，拿了点蓝桥杯的小奖，也拿不上台面。</li><li>学了c++，写了点cpp的小软件（图书管理系统等），我的面向对象的思维就是从那时候开始的</li></ul><h2 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h2><ul><li>退了acm，我想学点别的东西，在同学的推荐下上了java的贼船，然后学javase、javaweb、jdbc、设计模式、spring、spring boot（没怎么学好）、maven等，基本上是根据网上的视频来的，然后做做学校里的小项目，那个实验室管理系统，然后大二好像就没什么好说的了，就是学技术+实践的时间段。</li><li>还搞了点机器人的水比赛</li><li>学了写小程序，还学了一些dart和flutter的内容</li><li>帮学校的图书馆完善了预约小程序</li></ul><h2 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h2><ul><li>现在是大三下学期，我即将开始考研，大三上学期的话就是巩固了一下java基础知识，学了学spring cloud，跟着网上做了一点分布式微服务的小项目。</li><li>准备考研初试</li></ul><h2 id="大四"><a href="#大四" class="headerlink" title="大四"></a>大四</h2><ul><li>大四上学期准备考研初试</li><li>大四下学期准备考研复试和写毕业设计</li></ul><h2 id="研一"><a href="#研一" class="headerlink" title="研一"></a>研一</h2><p>- </p><h1 id="当前的context"><a href="#当前的context" class="headerlink" title="当前的context"></a>当前的context</h1><h2 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h2><ul><li>基本上在javaguide上把自己接触过的内容看了一遍，然后补充的知识放在“综合知识整理”这个博文中了，我其实目标是将我所有学过的八股上会考的东西以及自己的理解整理到那个博文中的，但是现在看来，要搁置一段时间了，等着我考完研再回来吧，整理的时候记得参照那个博文和javaguide的内容来整理，javaguide应该是整理到第二个文章了。</li></ul><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ul><li>这个就是参照我的简历上的内容对那个实验室管理系统改造一下，到时候重新回来的时候做一下。</li><li>还有一个就是谷粒商城看到了p288，如果之后有兴趣可以补一下</li><li>还想做个rpc框架</li><li>还想写个有服务端和客户端的java小游戏，想用来锻炼一下设计模式思维。</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>这个我可能考研的时候也偶尔刷刷吧</li><li>目前是剑指offerⅠ刷了2遍，热门top100刷了一遍多一点</li><li>之后就再刷一遍剑指offerⅠ、剑指offerⅡ、top100、热门top100，刷算法题还挺有意思的</li></ul><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul><li>《Effective Java》看了一遍，还想再看一遍</li><li>《Head First 设计模式》看了一部分</li><li>《深入理解Java虚拟机》看了一部分，想要全部看完呜呜呜真的很有意思</li><li>《从根上理解MySQL》只看了索引的那一部分，真的不错，想全看完</li><li>《啊哈！算法！》这个是算法启蒙书，看了一遍</li><li>谭浩强的c++红书，看了一遍</li><li>《鸟哥的Linux私房菜》看了一点点</li><li>其他的就是一些课本了</li></ul><h1 id="考完研之后想做的事"><a href="#考完研之后想做的事" class="headerlink" title="考完研之后想做的事"></a>考完研之后想做的事</h1><ul><li>肯定是首先把context恢复一下，然后把context中的事情完成一下，项目做做、笔记整理一下、书看一下、算法刷一下、以前的知识复习一下</li><li>然后就是巩固一下java，把学的技术的原理都了解一下，阅读一下源码（JDK、Spring等）</li><li>学一下java的剩下的技术栈</li><li>然后就是掌握第二门语言，想掌握c++，go也行</li><li>然后就是想多参加几段实习</li><li>想看点黑书，来点优秀的国外原著，既能锻炼阅读能力又能夯实基础，一石二鸟</li><li>想学学博弈论</li><li>然后就是想学精通英语，挺喜欢英语的，想要学一下雅思，我想要流畅的口语和无障碍的阅读能力</li><li>想考高级软考，顺便还能巩固一下基础，架构师或者管理师都可以</li><li>想学学摄影和ps</li><li>想教几个学生</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><ul><li>没啥想说的了，既然决定了就拼尽全力不去想别的，使用自己的思想体系去把基础打牢、把知识学透、每天做好积累，最后的结果我相信不会太差的。</li><li>构建以抽象，扩展以细节</li><li>拟录取了，这段时间的感悟和成长什么的都写在这几篇博文中了（这篇、考研进度那篇、还有学习的核心那篇）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;今天是2023年3月12日，我怀着</summary>
      
    
    
    
    
    <category term="考研" scheme="https://konjacor.github.io/tags/%E8%80%83%E7%A0%94/"/>
    
    <category term="备忘录" scheme="https://konjacor.github.io/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://konjacor.github.io/2023/02/01/MySQL/"/>
    <id>https://konjacor.github.io/2023/02/01/MySQL/</id>
    <published>2023-02-01T06:31:52.000Z</published>
    <updated>2023-02-01T08:21:42.464Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><ul><li>索引是帮助MySQL高效获取数据的<strong>数据结构</strong></li><li>索引存储在文件系统中</li><li>索引的文件存储形式与存储引擎有关</li><li>索引文件的结构有多种：hash表、二叉树、B树、B+树</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;h2 id=&quot;索引是什么&quot;&gt;&lt;a href=&quot;#索</summary>
      
    
    
    
    
    <category term="关系型数据库" scheme="https://konjacor.github.io/tags/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="https://konjacor.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>综合知识整理</title>
    <link href="https://konjacor.github.io/2023/01/20/%E7%BB%BC%E5%90%88%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>https://konjacor.github.io/2023/01/20/%E7%BB%BC%E5%90%88%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</id>
    <published>2023-01-20T03:24:03.000Z</published>
    <updated>2024-01-16T02:34:07.316Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Java-语言有哪些特点"><a href="#Java-语言有哪些特点" class="headerlink" title="Java 语言有哪些特点?"></a>Java 语言有哪些特点?</h2><ol><li>简单易学；</li><li>面向对象（封装，继承，多态）；</li><li>平台无关性（ Java 虚拟机实现平台无关性）；</li><li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li><li>可靠性；</li><li>安全性；</li><li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li><li>编译与解释并存；</li></ol><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ul><li>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</li><li><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。</li><li>OS运行在硬件之上，JVM运行在OS之上。</li></ul><h2 id="JDK和JRE"><a href="#JDK和JRE" class="headerlink" title="JDK和JRE"></a>JDK和JRE</h2><ol><li>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</li><li>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</li><li>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</li></ol><h2 id="什么是字节码？采用字节码的好处是什么？"><a href="#什么是字节码？采用字节码的好处是什么？" class="headerlink" title="什么是字节码？采用字节码的好处是什么？"></a>什么是字节码？采用字节码的好处是什么？</h2><ul><li><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），<strong>它不面向任何特定的处理器，只面向虚拟机（也就是说字节码是跑在虚拟机上的）</strong>。Java 语言通过字节码的方式，<strong>在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点</strong>。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，<strong>由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行</strong>。</p></li><li><p>Java 程序从源代码到运行的过程如下图所示：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230218183516012.png" alt="image-20230218183516012"></p></li><li><p>我们需要格外注意的是 <code>.class-&gt;机器码</code> 这一步。在这一步 <strong>JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢</strong>。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。<strong>当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用</strong>。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 <strong>Java 是编译与解释共存的语言</strong> 。</p></li><li><p>JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。</p></li></ul><h2 id="为什么不全部使用AOT呢？"><a href="#为什么不全部使用AOT呢？" class="headerlink" title="为什么不全部使用AOT呢？"></a>为什么不全部使用AOT呢？</h2><ul><li>长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，<strong>CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了</strong>。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</li></ul><h2 id="为什么说Java语言“编译与解释并存”？"><a href="#为什么说Java语言“编译与解释并存”？" class="headerlink" title="为什么说Java语言“编译与解释并存”？"></a>为什么说Java语言“编译与解释并存”？</h2><ul><li>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</li></ul><h2 id="Oracle-JDK和OpenJDK"><a href="#Oracle-JDK和OpenJDK" class="headerlink" title="Oracle JDK和OpenJDK"></a>Oracle JDK和OpenJDK</h2><ul><li>OpenJDK开源；Oracle JDK闭源，11之后，个人使用免费，但是商用收费。</li><li>Oracle JDK 比 OpenJDK 更稳定</li><li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能</li></ul><h2 id="Java和C-的区别？"><a href="#Java和C-的区别？" class="headerlink" title="Java和C++的区别？"></a>Java和C++的区别？</h2><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全。</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</li></ul><h2 id="Java中的三种移位运算符"><a href="#Java中的三种移位运算符" class="headerlink" title="Java中的三种移位运算符"></a>Java中的三种移位运算符</h2><ul><li><code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。</li><li><code>&gt;&gt;</code> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。</li><li><code>&gt;&gt;&gt;</code> :无符号右移，忽略符号位，空位都以 0 补齐。</li><li>由于 <code>double</code>，<code>float</code> 在二进制中的表现比较特殊，因此不能来进行移位操作。</li><li>移位操作符实际上支持的类型只有<code>int</code>和<code>long</code>，编译器在对<code>short</code>、<code>byte</code>、<code>char</code>类型进行移位前，都会将其转换为<code>int</code>类型再操作。</li><li>如果移位的位数超过数值所占有的位数会怎样？</li><li>当 int 类型左移&#x2F;右移位数大于等于 32 位操作时，会先求余（%）后再进行左移&#x2F;右移操作。也就是说左移&#x2F;右移 32 位相当于不进行移位操作（32%32&#x3D;0），左移&#x2F;右移 42 位相当于左移&#x2F;右移 10 位（42%32&#x3D;10）。当 long 类型进行左移&#x2F;右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。</li></ul><h2 id="成员变量和局部变量的区别？"><a href="#成员变量和局部变量的区别？" class="headerlink" title="成员变量和局部变量的区别？"></a>成员变量和局部变量的区别？</h2><ul><li><strong>语法形式</strong> ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li><li><strong>存储方式</strong> ：从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li><strong>生存时间</strong> ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li><li><strong>默认值</strong> ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul><h2 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h2><ol><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ol><h2 id="重载和重写的区别？"><a href="#重载和重写的区别？" class="headerlink" title="重载和重写的区别？"></a>重载和重写的区别？</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul><li>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</li></ul><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><ul><li><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p></li><li><p><strong>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类</strong>。</p></li><li><p><strong>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明（此时两个重名的static方法没有任何关系）</strong>。</p></li><li><p>构造方法无法被重写</p></li><li><p><strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230218190352463.png" alt="image-20230218190352463"></p></li><li><p>方法的重写要遵循“<strong>两同两小一大</strong>”：</p><ul><li>“两同”即方法名相同、形参列表相同；</li><li>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</li><li>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul></li></ul><h2 id="可变长参数遇到方法重载怎么办？会优先匹配固定参数还是可变参数的方法呢？"><a href="#可变长参数遇到方法重载怎么办？会优先匹配固定参数还是可变参数的方法呢？" class="headerlink" title="可变长参数遇到方法重载怎么办？会优先匹配固定参数还是可变参数的方法呢？"></a>可变长参数遇到方法重载怎么办？会优先匹配固定参数还是可变参数的方法呢？</h2><ul><li>答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</li><li>另外，Java 的可变参数编译后实际会被转换成一个数组，我们看编译后生成的 <code>class</code>文件就可以看出来了。</li></ul><h2 id="Java中的基本数据类型"><a href="#Java中的基本数据类型" class="headerlink" title="Java中的基本数据类型"></a>Java中的基本数据类型</h2><ul><li><p>6 种数字类型：</p><ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li><p>1 种字符类型：<code>char</code></p></li><li><p>1 种布尔型：<code>boolean</code></p></li><li><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230218190858669.png" alt="image-20230218190858669"></p></li><li><p>对于 <code>boolean</code>，官方文档未明确定义，它<strong>依赖于 JVM 厂商的具体实现</strong>。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。</p></li><li><p>另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。<strong>这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一</strong>。</p></li><li><p>注意：</p><ol><li>Java 里使用 <code>long</code> 类型的数据一定要在数值后面加上 <strong>L</strong>，否则将作为整型解析。</li><li>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code></li></ol></li></ul><h2 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h2><ol><li>成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li>包装类型可用于泛型，而基本类型不可以。</li><li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道<strong>几乎所有对象实例都存在于堆中</strong>。</li><li>相比于对象类型， 基本数据类型占用的空间非常小。</li></ol><ul><li>注意 ： <strong>基本数据类型存放在栈中是一个常见的误区！</strong> 基本数据类型的成员变量如果没有被 <code>static</code> 修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中。</li></ul><h2 id="所有的对象实例都存在堆中吗？"><a href="#所有的对象实例都存在堆中吗？" class="headerlink" title="所有的对象实例都存在堆中吗？"></a>所有的对象实例都存在堆中吗？</h2><ul><li>不是，是几乎所有对象实例都存在堆中，<strong>为什么说是几乎所有对象实例呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，<strong>如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存</strong>。</li><li><strong>标量替换</strong>：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是<strong>将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样随着方法调用结束，栈帧也会销毁。有效的减少了堆中创建对象及gc的次数</strong></li></ul><h2 id="包装类型的缓存机制了解么？"><a href="#包装类型的缓存机制了解么？" class="headerlink" title="包装类型的缓存机制了解么？"></a>包装类型的缓存机制了解么？</h2><ul><li><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p></li><li><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p></li><li><p>如果<strong>超出对应范围仍然会去创建新的对象</strong>，缓存的范围区间的大小只是在性能和资源之间的权衡。</p></li><li><p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p></li><li><p>Integer缓存源码（自动装箱用的就是valueOf方法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<span class="comment">//如果范围在缓存中，直接返回缓存的数据</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);<span class="comment">//否则新建对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntegerCache</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230218193854172.png" alt="image-20230218193854172"></p></li></ul><h2 id="自动装箱与拆箱了解吗？原理是什么？"><a href="#自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="自动装箱与拆箱了解吗？原理是什么？"></a>自动装箱与拆箱了解吗？原理是什么？</h2><ul><li>从字节码中，我们发现<strong>装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法</strong>。</li><li>因此：<ul><li><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code></li><li><code>int n = i</code> 等价于 <code>int n = i.intValue()</code>;</li></ul></li><li>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></li></ul><h2 id="为什么浮点数运算的时候会有精度丢失的风险？"><a href="#为什么浮点数运算的时候会有精度丢失的风险？" class="headerlink" title="为什么浮点数运算的时候会有精度丢失的风险？"></a>为什么浮点数运算的时候会有精度丢失的风险？</h2><ul><li><p>这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且<strong>计算机在表示一个数字时，宽度是有限的</strong>，<strong>无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示</strong>。</p></li><li><p>比如十进制的0.2要存放在计算机中，那肯定要转换成2进制来存储，而转成的二进制可能是无限长的，所以必须截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，</span></span><br><span class="line"><span class="comment">// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span> <span class="comment">//第一位二进制小数，取整数部分0，余下的参与下次运算</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> -&gt; <span class="number">0</span> <span class="comment">//第二位二进制小数，取整数部分0，余下的参与下次运算</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> -&gt; <span class="number">1</span> <span class="comment">//第三位二进制小数，取整数部分1，余下的参与下次运算</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> -&gt; <span class="number">1</span> <span class="comment">//第四位二进制小数，取整数部分1，余下的参与下次运算</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> -&gt; <span class="number">0</span>（发生循环）<span class="comment">//第五位二进制小数，取整数部分0，余下的参与下次运算，在这里发生循环，也就意味着0.2转换成的二进制将会是无限循环的，所以必须截断</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何解决浮点数运算的精度丢失问题？"><a href="#如何解决浮点数运算的精度丢失问题？" class="headerlink" title="如何解决浮点数运算的精度丢失问题？"></a>如何解决浮点数运算的精度丢失问题？</h2><ul><li><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</li><li>BigDecimal中提供各种各样的方法来实现BigDecimal对象之间的运算，所以运算的时候要使用其中的方法。</li></ul><h2 id="超过long整型的数据应该如何表示？"><a href="#超过long整型的数据应该如何表示？" class="headerlink" title="超过long整型的数据应该如何表示？"></a>超过long整型的数据应该如何表示？</h2><ul><li>在 Java 中，64 位 long 整型是最大的整数类型。超过了可以用<code>BigInteger</code> ，其内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。和BigDecimal一样，其中提供了各种供对象间进行运算的方法。</li><li>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</li></ul><h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><ul><li>两者的主要区别在于解决问题的方式不同：<ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul></li><li>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</li></ul><h2 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>创建一个对象用什么运算符?对象实体与对象引用有何不同?</h2><ul><li>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（就是指针，指向对象实例的位置）。</li><li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li></ul><h2 id="对象相等和引用相等的区别？"><a href="#对象相等和引用相等的区别？" class="headerlink" title="对象相等和引用相等的区别？"></a>对象相等和引用相等的区别？</h2><ul><li>对象的相等一般比较的是内存中存放的内容是否相等。</li><li>引用相等一般比较的是他们指向的内存地址是否相等。</li></ul><h2 id="类的构造方法的作用是什么"><a href="#类的构造方法的作用是什么" class="headerlink" title="类的构造方法的作用是什么?"></a>类的构造方法的作用是什么?</h2><ul><li>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</li></ul><h2 id="如果一个类没有声明构造方法，该程序能正确执行吗？"><a href="#如果一个类没有声明构造方法，该程序能正确执行吗？" class="headerlink" title="如果一个类没有声明构造方法，该程序能正确执行吗？"></a>如果一个类没有声明构造方法，该程序能正确执行吗？</h2><ul><li>如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑。</li></ul><h2 id="构造方法有哪些特点？是否可被-override"><a href="#构造方法有哪些特点？是否可被-override" class="headerlink" title="构造方法有哪些特点？是否可被 override?"></a>构造方法有哪些特点？是否可被 override?</h2><ul><li>构造方法特点如下：<ol><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ol></li><li>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</li></ul><h2 id="面向对象四大特征"><a href="#面向对象四大特征" class="headerlink" title="面向对象四大特征"></a>面向对象四大特征</h2><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><ul><li>就是指一种思想，我们可以将客观存在的一切事物都抽象成java类，其中属性表示事物的状态信息，方法表示事物可以有的行为。</li></ul><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul><li>封装是指<strong>把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性</strong>。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。就好像如果没有空调遥控器，那么我们就无法操控空凋制冷，空调本身就没有意义了（当然现在还有很多其他方法 ，这里只是为了举例子）。</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。<strong>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率</strong>。</li><li>关于继承如下 3 点请记住：<ol><li>子类拥有父类对象所有的属性和方法（<strong>包括私有属性和私有方法</strong>），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ol></li></ul><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul><li>多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</li><li>多态的特点：<ol><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ol></li></ul><h2 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h2><ul><li>共同点：<ol><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ol></li><li>区别：<ol><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ol></li></ul><h2 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h2><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li><li><strong>引用拷贝</strong>：引用拷贝就是两个不同的引用指向同一个对象。</li></ul><h2 id="Object类的常见方法有哪些？"><a href="#Object类的常见方法有哪些？" class="headerlink" title="Object类的常见方法有哪些？"></a>Object类的常见方法有哪些？</h2><ul><li><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实例被垃圾回收器回收的时候触发的操作，第一次回收触发这个方法，然后会将对象放到一个队列中，此时对象的内存并没有被真正释放；第二次回收的时候会判断队列中的对象是否通过finalize方法重新建立起了引用，如果有，那就不回收了，如果没有，直接回收掉，这次是真回收，会释放内存空间。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="x3D-x3D-和equals-的区别"><a href="#x3D-x3D-和equals-的区别" class="headerlink" title="&#x3D;&#x3D;和equals()的区别"></a>&#x3D;&#x3D;和equals()的区别</h2><ul><li><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：<ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li></ul></li><li>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</li><li><strong><code>equals()</code></strong> <strong>不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等（这个相等的定义是自己定义的）</strong>。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</li><li><code>equals()</code> 方法存在两种使用情况：<ol><li><strong>类没有重写 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ol></li></ul><h2 id="hashCode-有什么用？"><a href="#hashCode-有什么用？" class="headerlink" title="hashCode()有什么用？"></a>hashCode()有什么用？</h2><ul><li><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</li><li><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</li><li>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></li><li>可以<strong>优化对象比较大小时的速度</strong>，通过先比较hashcode，如果hashcode不同，那么这两个对象一定是不同的，如果hashcode相同，再通过equals()方法来进一步比较确定两者是否相同。</li></ul><h2 id="为什么要有-hashCode？"><a href="#为什么要有-hashCode？" class="headerlink" title="为什么要有 hashCode？"></a>为什么要有 hashCode？</h2><ul><li><p>我们以“<code>HashSet</code> 如何检查重复”为例子来说明为什么要有 <code>hashCode</code>？</p></li><li><p>下面这段内容摘自我的 Java 启蒙书《Head First Java》:</p><blockquote><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p></blockquote><p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p></li><li><p><strong>那为什么 JDK 还要同时提供这两个方法呢？</strong>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）！我们在前面也提到了添加元素进<code>HashSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p></li><li><p><strong>那为什么不只提供 <code>hashCode()</code> 方法呢？</strong>这是因为两个对象的<code>hashCode</code> 值相等并不代表两个对象就相等。</p></li><li><p><strong>那为什么两个对象有相同的 <code>hashCode</code> 值，它们也不一定是相等的？</strong>因为 <code>hashCode()</code> 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 <code>hashCode</code> )。</p></li><li><p>总结下来就是 ：</p><ol><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ol></li></ul><h2 id="为什么重写equals-时必须重写hashCode-方法？"><a href="#为什么重写equals-时必须重写hashCode-方法？" class="headerlink" title="为什么重写equals()时必须重写hashCode()方法？"></a>为什么重写equals()时必须重写hashCode()方法？</h2><ul><li>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li><li>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</li><li><strong>思考</strong> ：重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</li><li><strong>总结</strong> ：<ul><li><code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</li><li>两个对象有相同的 <code>hashCode</code> 值，他们也不一定是相等的（哈希碰撞）。</li></ul></li></ul><h2 id="String、StringBuffer、StringBuilder-的区别？"><a href="#String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？"></a>String、StringBuffer、StringBuilder 的区别？</h2><h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h3><ul><li><p><code>String</code> 是不可变的（后面会详细分析原因）。</p></li><li><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">      <span class="type">char</span>[] value;</span><br><span class="line">      <span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">              <span class="keyword">return</span> appendNull();</span><br><span class="line">          <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">          ensureCapacityInternal(count + len);</span><br><span class="line">          str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">          count += len;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">### 线程安全性</span><br><span class="line"></span><br><span class="line">- `String` 中的对象是不可变的，也就可以理解为常量，线程安全。`AbstractStringBuilder` 是 `StringBuilder` 与 `StringBuffer` 的公共父类，定义了一些字符串的基本操作，如 `expandCapacity`、`append`、`insert`、`indexOf` 等公共方法。**`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的**。</span><br><span class="line"></span><br><span class="line">### 性能</span><br><span class="line"></span><br><span class="line">- 每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。**`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用**。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 <span class="number">10</span>%~<span class="number">15</span>% 左右的性能提升，但却要冒多线程不安全的风险。</span><br><span class="line"></span><br><span class="line">### 对于三者使用的总结</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 操作少量的数据: 适用 `String`</span><br><span class="line"><span class="number">2.</span> 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`</span><br><span class="line"><span class="number">3.</span> 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`</span><br><span class="line"></span><br><span class="line">## String为什么是不可变的？</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 保存字符串的字符数组（jdk1<span class="number">.9</span>之后是字节数组）被 `<span class="keyword">final</span>` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。</span><br><span class="line"><span class="number">2.</span> `String` 类被 `<span class="keyword">final</span>` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。</span><br><span class="line"></span><br><span class="line">## String不可变的好处？</span><br><span class="line"></span><br><span class="line">### 便于实现String常量池</span><br><span class="line"></span><br><span class="line">- 在程序编写过程中往往会大量用到String常量，如果每次都为新的String常量申请内存空间的话会对空间造成很大的浪费，所以我们需要字符串常量池来对String常量做一个优化，把之前用过的String保存下来，以后如果再用的话可以直接拿。</span><br><span class="line">- 从上面我们知道了我们需要一个字符串常量池来对使用String做优化，而只有当字符串是不可变的，字符串池才有可能实现。**字符串池的实现可以在运行时节约很多heap空间，因为不同的字符串变量都指向池中的同一个字符串。但如果字符串是可变的，因为这样的话，如果变量改变了它的值，那么其它指向这个值的变量的值也会一起改变**。</span><br><span class="line"></span><br><span class="line">### 可以很方便地作为Map的key</span><br><span class="line"></span><br><span class="line">- 以String作为HashMap的key，String的不可变性保证了其hash值的不可变性，防止出现key值发生变化导致key对象的hash值发生变化，之后再用key的那个对象在map中找对应的value就找不到了（因为hash值变了，找的位置就不对了）。</span><br><span class="line"></span><br><span class="line">### 避免网络安全问题</span><br><span class="line"></span><br><span class="line">- 如果字符串是可变的，那么会引起很严重的安全问题。譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞。</span><br><span class="line"></span><br><span class="line">### 使多线程安全</span><br><span class="line"></span><br><span class="line">- 因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</span><br><span class="line"></span><br><span class="line">### 避免本地安全性问题</span><br><span class="line"></span><br><span class="line">- 类加载器要用到字符串，不可变性提供了安全性，以便正确的类被加载。譬如你想加载java.sql.Connection类，而这个值被改成了myhacked.Connection，那么会对你的数据库造成不可知的破坏。</span><br><span class="line"></span><br><span class="line">### 加快字符串处理速度</span><br><span class="line"></span><br><span class="line">- 因为字符串是不可变的，所以在它创建的时候hashcode就被缓存在对象头中了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</span><br><span class="line"></span><br><span class="line">## Java9为何要将String的底层实现由<span class="type">char</span>[]改成了<span class="type">byte</span>[]？</span><br><span class="line"></span><br><span class="line">- 新版的 String 其实支持两个编码方案： Latin-<span class="number">1</span> 和 UTF-<span class="number">16</span>。JDK 官方就说了绝大部分字符串对象只包含 Latin-<span class="number">1</span> 可表示的字符。如果字符串中包含的汉字没有超过 Latin-<span class="number">1</span> 可表示范围内的字符，那就会使用 Latin-<span class="number">1</span> 作为编码方案。Latin-<span class="number">1</span> 编码方案下，`<span class="type">byte</span>` 占一个字节(<span class="number">8</span> 位)，`<span class="type">char</span>` 占用 <span class="number">2</span> 个字节（<span class="number">16</span>），`<span class="type">byte</span>` 相较 `<span class="type">char</span>` 节省一半的内存空间。</span><br><span class="line">- 如果字符串中包含的汉字超过 Latin-<span class="number">1</span> 可表示范围内的字符，`<span class="type">byte</span>` 和 `<span class="type">char</span>` 所占用的空间是一样的。</span><br><span class="line"></span><br><span class="line">## 字符串拼接用“+”还是StringBuilder？</span><br><span class="line"></span><br><span class="line">- Java 语言本身并不支持运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</span><br><span class="line">- 通过编译后形成的字节码文件的内容可以看出，**字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 **。</span><br><span class="line">- 不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：**编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象**。</span><br><span class="line">- 所以**推荐在循环中拼接字符串时应该事先在循环外面声明好StringBuilder然后在循环中使用StringBuilder的append()方法**。</span><br><span class="line"></span><br><span class="line">## 字符串常量池的作用了解吗？</span><br><span class="line"></span><br><span class="line">- **字符串常量池（jdk1<span class="number">.7</span>之前在方法区的常量池中，jdk1<span class="number">.7</span>的时候字符串常量池被从常量池中单独拎出来放到了堆中；jdk1<span class="number">.8</span>的时候原本在方法区中的每个类特有的静态域也被放到了堆中，具体存放在堆中类在加载阶段生成的class对象的尾部）** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，**主要目的是为了避免字符串的重复创建**。</span><br><span class="line"></span><br><span class="line">## <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);这句话创建了几个字符串对象？</span><br><span class="line"></span><br><span class="line">- 会创建 <span class="number">1</span> 或 <span class="number">2</span> 个字符串对象。</span><br><span class="line">- 如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中（看这说法应该默认是jdk1<span class="number">.7</span>之后的版本）创建 <span class="number">2</span> 个字符串对象“abc”；反之则只会创建<span class="number">1</span>个。</span><br><span class="line"></span><br><span class="line">## intern方法有什么作用？</span><br><span class="line"></span><br><span class="line">- `String.intern()` 是一个 <span class="keyword">native</span>（本地）方法，**其作用是将指定的字符串对象的引用保存在字符串常量池中**，可以简单分为两种情况：</span><br><span class="line">  <span class="number">1.</span> 如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</span><br><span class="line">  <span class="number">2.</span> 如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。</span><br><span class="line"></span><br><span class="line">## String 类型的引用和字面量做“+”运算时发生了什么？</span><br><span class="line"></span><br><span class="line">- 先来看字符串不加 `<span class="keyword">final</span>` 关键字拼接的情况（JDK1<span class="number">.8</span>）：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;</span><br><span class="line">  <span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line">  System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">  System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">  System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure></li><li><p><strong>对于编译期可以确定值的字符串，也就是字面量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串字面量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</strong></p></li><li><p>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。<strong>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中</strong>，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</p></li><li><p>所以，对于 <code>String str3 = &quot;str&quot; + &quot;ing&quot;;</code> 编译器会给你优化成 <code>String str3 = &quot;string&quot;;</code> 。</p></li><li><p>不过要注意，<strong>并不是所有的常量&#x2F;变量都会进行折叠，只有编译器在程序编译期就可以确定值的常量&#x2F;变量才可以</strong>：</p><ul><li>基本数据类型( <code>byte</code>、<code>boolean</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>float</code>、<code>long</code>、<code>double</code>)以及字符串的字面量。</li><li><code>final</code> 修饰的基本数据类型和字符串引用</li><li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li></ul></li><li><p><strong>引用的值在程序编译期是无法确定的（因为值是地址，非final的地址程序不跑起来定不下来），编译器无法对其进行优化（除非引用是final的，final的引用的值在编译期是确定的）。</strong></p></li><li><p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。所以我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p></li><li><p>不过，<strong>字符串引用使用的都是被 <code>final</code> 关键字修饰的字符串引用时，可以让编译器把这个引用当做字面量来做优化处理，因为final引用的值在编译期就会被确定</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"><span class="comment">// 下面两个表达式其实是等价的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 常量池中的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。</p></li><li><p>如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> getStr();</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">// 常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> str1 + str2; <span class="comment">// 在堆上创建的新的对象</span></span><br><span class="line">System.out.println(c == d);<span class="comment">// false</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>总之就是一点，看编译时变量&#x2F;常量的值是否能被确定，如果能，那么编译器就会做常量折叠优化；反之则不做优化</strong>。</p></li></ul><h2 id="Java异常类层次结构图概览"><a href="#Java异常类层次结构图概览" class="headerlink" title="Java异常类层次结构图概览"></a>Java异常类层次结构图概览</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230220221230590.png" alt="image-20230220221230590"></p><h2 id="Exception和Error有什么区别？"><a href="#Exception和Error有什么区别？" class="headerlink" title="Exception和Error有什么区别？"></a>Exception和Error有什么区别？</h2><ul><li>在 Java 中，<strong>所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类</strong>。<code>Throwable</code> 类有两个重要的子类:<ul><li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul></li></ul><h2 id="Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="Checked Exception 和 Unchecked Exception 有什么区别？"></a>Checked Exception 和 Unchecked Exception 有什么区别？</h2><ul><li><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</li><li><strong>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常</strong>。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code>…</li><li><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</li><li><strong><code>RuntimeException</code> 及其子类都统称为非受检查异常</strong>，常见的有（建议记下来，日常开发中会经常用到）：<ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li><li>……</li></ul></li></ul><h2 id="Throwable类常用方法有哪些？"><a href="#Throwable类常用方法有哪些？" class="headerlink" title="Throwable类常用方法有哪些？"></a>Throwable类常用方法有哪些？</h2><ul><li><code>String getMessage()</code>: 返回异常发生时的简要描述</li><li><code>String toString()</code>: 返回异常发生时的详细信息</li><li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li><li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h2 id="try-catch-finally如何使用？"><a href="#try-catch-finally如何使用？" class="headerlink" title="try-catch-finally如何使用？"></a>try-catch-finally如何使用？</h2><ul><li><code>try</code>块 ： 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><code>catch</code>块 ： 用于处理 try 捕获到的异常。</li><li><code>finally</code> 块 ： 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到</li><li><code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li><li><strong>注意：尽量不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</li></ul><h2 id="finally-中的代码一定会执行吗？"><a href="#finally-中的代码一定会执行吗？" class="headerlink" title="finally 中的代码一定会执行吗？"></a>finally 中的代码一定会执行吗？</h2><ul><li><p>不一定的！在某些情况下，finally 中的代码不会被执行。就比如说 <strong>finally 之前虚拟机被终止运行</strong>的话，finally 中的代码就不会被执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Try to do something&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;RuntimeException&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Catch Exception -&gt; &quot;</span> + e.getMessage());</span><br><span class="line">    <span class="comment">// 终止当前正在运行的Java虚拟机</span></span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Finally&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//Try to do something</span></span><br><span class="line"><span class="comment">//Catch Exception -&gt; RuntimeException</span></span><br></pre></td></tr></table></figure></li><li><p>另外，在以下 2 种特殊情况下，<code>finally</code> 块的代码也不会被执行：</p><ol><li><strong>程序所在的线程死亡</strong>。</li><li><strong>关闭 CPU</strong>。</li></ol></li></ul><h2 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h2><ul><li><p><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</p></li><li><p><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</p></li><li><p>《Effective Java》中明确指出：</p><blockquote><p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p></blockquote></li><li><p>Java 中类似于<code>InputStream</code>、<code>OutputStream</code> 、<code>Scanner</code> 、<code>PrintWriter</code>等的资源都需要我们调用<code>close()</code>方法来手动关闭，一般情况下我们都是通过<code>try-catch-finally</code>语句来实现这个需求，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取文本文件的内容</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D://read.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Java 7 之后的 <code>try-with-resources</code> 语句改造上面的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然多个资源需要关闭的时候，使用 <code>try-with-resources</code> 实现起来也非常简单，如果你还是用<code>try-catch-finally</code>可能会带来很多问题。</p></li><li><p>通过使用分号分隔，可以在<code>try-with-resources</code>块中声明多个资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">try</span> (<span class="type">BufferedInputStream</span> <span class="variable">bin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">       <span class="type">BufferedOutputStream</span> <span class="variable">bout</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;out.txt&quot;</span>)))) &#123;</span><br><span class="line">      <span class="type">int</span> b;</span><br><span class="line">      <span class="keyword">while</span> ((b = bin.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">          bout.write(b);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">## 异常使用有哪些需要注意的地方？</span><br><span class="line"></span><br><span class="line">- **不要把异常定义为静态变量**，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 <span class="keyword">new</span> 一个异常对象抛出。</span><br><span class="line">- 抛出的异常信息一定**要有意义**。</span><br><span class="line">- 建议**抛出更加具体的异常**比如字符串转换为数字格式错误的时候应该抛出`NumberFormatException`而不是其父类`IllegalArgumentException`。</span><br><span class="line">- **使用日志打印异常之后就不要再抛出异常了**（两者不要同时存在一段代码逻辑中）。</span><br><span class="line">- ......</span><br><span class="line"></span><br><span class="line">## 什么是泛型？有什么作用？</span><br><span class="line"></span><br><span class="line">- **Java 泛型（Generics）** 是 JDK <span class="number">5</span> 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</span><br><span class="line">- 编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 `ArrayList&lt;Person&gt; persons = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;()` 这行代码就指明了该 `ArrayList` 对象只能传入 `Person` 对象，如果传入其他类型的对象就会报错。</span><br><span class="line">- 并且，原生 `List` 返回类型是 `Object` ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</span><br><span class="line">- 说白了**使用泛型其实就是在编译期编译器帮我们保证泛型中泛型参数的类型正确**，如果不使用泛型，我们需要自己来做这些事情，由于泛型只在编译期体现，在运行时泛型的类型参数会被擦除，泛型参数的类型会转换成上界的类型，所以我感觉泛型也是个语法糖。</span><br><span class="line"></span><br><span class="line">## 泛型的使用方式有哪几种？</span><br><span class="line"></span><br><span class="line">- 泛型一般有三种使用方式:**泛型类**、**泛型接口**、**泛型方法**。</span><br><span class="line"></span><br><span class="line">### 泛型类</span><br><span class="line"></span><br><span class="line">- 代码示例：</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  <span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line">  <span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">private</span> T key;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.key = key;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> key;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如何实例化泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> <span class="title class_">Generic</span>&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><ul><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，不指定具体类型参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现泛型接口，指定具体类型参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GeneratorImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Generator</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">( E[] inputArray )</span>&#123;</span><br><span class="line">      <span class="keyword">for</span> ( E element : inputArray )&#123;</span><br><span class="line">         System.out.printf( <span class="string">&quot;%s &quot;</span>, element );</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray( intArray  );</span><br><span class="line">printArray( stringArray  );</span><br></pre></td></tr></table></figure></li><li><p>注意: <code>public static &lt;E&gt; void printArray( E[] inputArray )</code> 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以<strong>静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code></strong></p></li></ul><h2 id="项目中哪里用到了泛型？"><a href="#项目中哪里用到了泛型？" class="headerlink" title="项目中哪里用到了泛型？"></a>项目中哪里用到了泛型？</h2><ul><li>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</li><li>定义 <code>Excel</code> 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 <code>Excel</code> 导出的数据类型</li><li>构建集合工具类（参考 <code>Collections</code> 中的 <code>sort</code>, <code>binarySearch</code> 方法）。</li><li>……</li></ul><h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><ul><li>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它<strong>赋予了我们在运行时分析类以及执行类中方法的能力</strong>。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</li></ul><h2 id="反射的优缺点"><a href="#反射的优缺点" class="headerlink" title="反射的优缺点?"></a>反射的优缺点?</h2><ul><li>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</li><li>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</li></ul><h2 id="反射的应用场景？"><a href="#反射的应用场景？" class="headerlink" title="反射的应用场景？"></a>反射的应用场景？</h2><ul><li>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring&#x2F;Spring Boot、MyBatis 等等框架中都大量使用了反射机制。</li><li><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></li><li>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。为什么使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？这些都是因为<strong>可以基于反射分析类，然后获取到类&#x2F;属性&#x2F;方法&#x2F;方法的参数上的注解。获取到注解之后，就可以做进一步的处理</strong>，所以说注解其实就是一个标识，通过反射分析注解这个标识来进行相应的处理。</li></ul><h2 id="什么是注解？"><a href="#什么是注解？" class="headerlink" title="什么是注解？"></a>什么是注解？</h2><ul><li><p><code>Annotation</code> （注解） 是 Java5 开始引入的新特性，<strong>可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用</strong>。</p></li><li><p>注解本质是一个继承了<code>Annotation</code> 的特殊接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>JDK提供了很多内置的注解（比如 <code>@Override</code> 、<code>@Deprecated</code>），同时，我们还可以自定义注解。</p></li></ul><h2 id="注解的解析方法有哪几种？"><a href="#注解的解析方法有哪几种？" class="headerlink" title="注解的解析方法有哪几种？"></a>注解的解析方法有哪几种？</h2><ul><li>注解只有被解析之后才会生效，常见的解析方法有两种：<ol><li><strong>编译期直接扫描</strong> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong> ：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。</li></ol></li></ul><h2 id="什么是SPI？"><a href="#什么是SPI？" class="headerlink" title="什么是SPI？"></a>什么是SPI？</h2><ul><li>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：<strong>专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口</strong>。</li><li>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</li><li>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</li></ul><h2 id="SPI和API有什么区别？"><a href="#SPI和API有什么区别？" class="headerlink" title="SPI和API有什么区别？"></a>SPI和API有什么区别？</h2><h2 id="SPI的优缺点？"><a href="#SPI的优缺点？" class="headerlink" title="SPI的优缺点？"></a>SPI的优缺点？</h2><ul><li>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：<ol><li>需要遍历加载所有的实现类，不能做到按需加载，这样效率还是相对较低的。</li><li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li></ol></li></ul><h2 id="什么是序列化？什么是反序列化？"><a href="#什么是序列化？什么是反序列化？" class="headerlink" title="什么是序列化？什么是反序列化？"></a>什么是序列化？什么是反序列化？</h2><h2 id="一次记住运算符优先级"><a href="#一次记住运算符优先级" class="headerlink" title="一次记住运算符优先级"></a>一次记住运算符优先级</h2><ul><li>取值单目计算符——就是说，优先级最高的是和取值相关的运算符，比如“-&gt;”、“.”、“()”、“[]”等；再然后是单目运算符，然后是乘除模加减等计算符。</li><li>左移右移关系比——再然后的就是左移和右移运算符，再然后就是关系运算符(&gt;、&lt;、&lt;&#x3D;等)，再然后就是比较运算符(&#x3D;&#x3D;、!&#x3D;)</li><li>按位与异或与或——然后就是按位与、按位异或、按位或，再然后就是逻辑与和逻辑或</li><li>三目赋值逗号末——再然后就是三目运算符、赋值运算符和逗号运算符</li></ul><h2 id="运算符的结合性"><a href="#运算符的结合性" class="headerlink" title="运算符的结合性"></a>运算符的结合性</h2><ul><li>单目、三目、赋值运算符都是自右向左结合，除此之外都是自左向右结合。</li><li>值得注意的是三目运算符的自右向左结合并不是意味着右边先做操作，而是在两个三目运算符相连且没有括号确定优先级的前提下，右边的三目运算符会被看作一个整体，它不会被优先计算，计算顺序依然以三目运算符的计算顺序为准。即：<code>a?b:c?d:e等价于a?b:(c?d:e)而非(a?b:c)?d:e</code></li><li>只有当两个运算符的优先级相同时才需要利用结合性来确定运算顺序。</li></ul><h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="说一下synchronized锁升级的机制？"><a href="#说一下synchronized锁升级的机制？" class="headerlink" title="说一下synchronized锁升级的机制？"></a>说一下synchronized锁升级的机制？</h2><ul><li>首先在JDK1.6之前，synchronized锁是一个重量级锁，其依赖于操作系统的mutex lock命令，而这个命令呢，是内核态的命令，所以跑在用户态的进程需要将自己切换成内核态之后再去进行系统调用，这样做会有很大的性能损耗，特别是在争抢锁的线程较少的情况下，所以在JDK1.6之后，设计师们引入了偏向锁和轻量级锁来实现synchronized的锁升级机制。</li><li>当只有一个线程来拿锁的时候，synchronized是一个偏向锁的机制，<strong>偏向锁会把提供监视器的对象的对象头中记录下当前线程的id</strong>，当下次这个线程来拿锁的时候，可以直接获取到，这样实际上就是对单线程条件下的优化。</li><li>当之后多个线程来的时候，synchronized会升级成<strong>用CAS+自旋实现的轻量级锁</strong>，所有没有获取到锁的线程会进行自旋尝试获取到锁，这样的操作不会阻塞线程，但是如果线程较多的情况下，线程为了获取到锁进行的自旋次数也会变多，这样的自旋是很耗费cpu的性能的。</li><li>如果自旋次数过多还没能获取到锁，synchronized会升级成重量级锁，<strong>重量级锁就是之前说过的依赖于操作系统的mutex lock命令，在JVM层面上是依赖于monitorenter和monitorexit命令来获取对象的同步监视器monitor</strong>，这俩命令一个指向同步代码段的开头，一个指向结尾，当线程想要获取锁的时候，要先检查monitor的计数器是否是0，如果是0说明可以获取，让计数器++，如果不是0，那么线程阻塞等待。</li></ul><h2 id="为什么ConcurrentHashMap的key和value不能为空？"><a href="#为什么ConcurrentHashMap的key和value不能为空？" class="headerlink" title="为什么ConcurrentHashMap的key和value不能为空？"></a>为什么ConcurrentHashMap的key和value不能为空？</h2><ul><li>这是为了<strong>避免在多线程的情况下产生歧义</strong>，因为在多线程的条件下，如果我们尝试去获取ConcurrentHashMap的key或者value返回了null，那么我们是不能确定到底是key或者value不存在还是本身那个值就是null，如果在单线程下，我们可以通过containsKey这样的方法来求证，但是在多线程下，使用containsKey方法的时候，另外一个线程可以将键值对插入到了那个位置，这就导致containsKey可能返回的值不确定，也就无法求证到底是那两种情况的哪种情况，这样的问题实际上是一个线程同步问题，而ConcurrentHashMap又是线程安全的，所以ConcurrentHashMap不允许出现这样的问题。</li></ul><h2 id="为什么ThreadLocalMap的key是弱引用？"><a href="#为什么ThreadLocalMap的key是弱引用？" class="headerlink" title="为什么ThreadLocalMap的key是弱引用？"></a>为什么ThreadLocalMap的key是弱引用？</h2><ul><li>我们都知道ThreadLocalMap的key是ThreadLocal的弱引用，为什么要这样设计呢？实际上这是<strong>为了防止内存泄漏</strong>而设计的。</li><li>想象一个场景，我们在使用ThreadLocal的时候，我们new了一个ThreadLocal对象，然后用一个强引用指向了它，同时这个ThreadLocal也被Thread中的ThreadLocalMap的key指向了，如果key是强引用，那么当我们不想用这个ThreadLocal从而将我们自己创建的那个强引用改变指向之后，由于还有强引用指向那个ThreadLocal，所以它的空间是永远不会被gc的，在极端情况下就会出现内存泄漏，所以我们将key设置成ThreadLocal的弱引用，这样在ThreadLocal不存在外界的强引用的时候，在下一次gc中会被回收，减少出现内存泄漏问题的概率。</li></ul><h2 id="为什么ThreadLocalMap的value不是弱引用？"><a href="#为什么ThreadLocalMap的value不是弱引用？" class="headerlink" title="为什么ThreadLocalMap的value不是弱引用？"></a>为什么ThreadLocalMap的value不是弱引用？</h2><ul><li>因为<strong>大多数情况下外界不对value有强引用</strong>，我们归根结底还是要通过ThreadLocal这个key从ThreadLocalMap得到value的，这个可以想一下我们平时使用ThreadLocal的场景，我们是通过ThreadLocal这个key来去找value，所以value通常在外界没有强引用，所以如果value是弱引用的话，很容易就被gc掉了，这就导致我们使用ThreadLocal的get方法的时候返回值是null，这显然不是我们期望的结果。</li></ul><h2 id="ThreadLocal在我的项目中的使用"><a href="#ThreadLocal在我的项目中的使用" class="headerlink" title="ThreadLocal在我的项目中的使用"></a>ThreadLocal在我的项目中的使用</h2><ul><li>在使用Feign进行远程调用的时候，http header中的信息会重置，因为Feign本质上是创建了一个新的http报文来进行远程通信，那么如果我们想要Feign在进行远程调用的时候保留http header怎么办？</li><li>Feign提供了拦截器组件，拦截器链会在创建http报文之前执行，所以我们只需要向IOC容器中加入一个继承了Feign提供的拦截器类的类，然后重写拦截器方法，指定Feign创建http报文的header，那么问题又来了，这个header去哪取？</li><li>很明显我们需要从当前线程中获取，所以我们可以在请求打过来的时候使用Spring MVC的拦截器来拦截请求，并使用ThreadLocal来记录这个请求的header，然后再在Feign的拦截器中取出这个header给新的header赋值。</li></ul><h2 id="线程池怎么关闭？"><a href="#线程池怎么关闭？" class="headerlink" title="线程池怎么关闭？"></a>线程池怎么关闭？</h2><ul><li>JDK1.8中，线程池的停止一般使用shutdown()、shutdownNow()方法。</li></ul><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h3><ul><li>有序关闭，已提交的任务继续执行</li><li>不接受新任务</li></ul><h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h3><ul><li>尝试停止所有正在执行的任务</li><li>停止等待执行的任务，并返回等待执行的任务列表</li></ul><h3 id="shutdown-和shutdownNow-的异同"><a href="#shutdown-和shutdownNow-的异同" class="headerlink" title="shutdown()和shutdownNow()的异同"></a>shutdown()和shutdownNow()的异同</h3><ul><li>调用 shutdown() 和 shutdownNow() 方法关闭线程池，线程池都无法接收新的任务。</li><li>shutdown() 方法会继续执行正在执行未完成的任务，shutdownNow() 方法会尝试停止所有正在执行的任务。</li><li>shutdown() 方法没有返回值，shutdownNow() 方法返回等待执行的任务列表。</li><li>awaitTermination(long timeout, TimeUnit unit) 方法可以获取线程池是否已经关闭，需要配合 shutdown() 使用。</li><li>shutdownNow() 不一定能够立马结束线程池，该方法会尝试停止所有正在执行的任务，通过调用 Thread.interrupt() 方法来实现的，如果线程中没有 sleep() 、wait()、Condition、定时锁等应用，interrupt() 方法是无法中断当前的线程的。</li></ul><h2 id="阻塞队列有哪些？"><a href="#阻塞队列有哪些？" class="headerlink" title="阻塞队列有哪些？"></a>阻塞队列有哪些？</h2><ol><li><p><strong>ArrayBlockingQueue ：由数组结构组成的有界阻塞队列</strong>。用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下 不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当 队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入 元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐 量。我们可以使用以下代码创建一个公平的阻塞队列：ArrayBlockingQueue fairQueue &#x3D; new  ArrayBlockingQueue(1000,true);  </p></li><li><p><strong>LinkedBlockingQueue ：由链表结构组成的有界阻塞队列</strong>。基于链表的阻塞队列，同ArrayListBlockingQueue类似，此队列按照先进先出（FIFO）的原则对 元素进行排序。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者 端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费 者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br>LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE）。 </p></li><li><p><strong>PriorityBlockingQueue ：支持优先级排序的无界阻塞队列</strong>。是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现 compareTo()方法来指定元素进行排序规则，或者初始化 PriorityBlockingQueue 时，指定构造 参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。 </p></li><li><p><strong>DelayQueue：使用优先级队列实现的无界阻塞队列</strong>。是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实 现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将DelayQueue运用在以下应用场景： </p><ul><li>缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查询 DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。<br>定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从 DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。</li></ul></li><li><p><strong>SynchronousQueue：不存储元素的阻塞队列</strong>。是一个<strong>不存储元素</strong>的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。 SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给 另外一个线程使用，SynchronousQueue 的吞吐量高于 LinkedBlockingQueue 和 ArrayBlockingQueue</p></li><li><p><strong>LinkedTransferQueue：由链表结构组成的无界阻塞队列</strong>。是一个由链表结构组成的无界阻塞 TransferQueue 队列。相对于其他阻塞队列， LinkedTransferQueue多了 tryTransfer 和transfer方法。</p><ul><li>transfer 方法：如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的 poll()方法时），transfer 方法可以把生产者传入的元素立刻 transfer（传输）给消费者。如 果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素 被消费者消费了才返回。</li><li>tryTransfer 方法：则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费 者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否 接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。 </li><li>对于带有时间限制的tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传 入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时 还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。</li></ul></li><li><p><strong>LinkedBlockingDeque：由链表结构组成的双向阻塞队列</strong>。是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。 双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其 他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast， peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队 列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的后一个元素。另 外插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同 于takeFirst，不知道是不是Jdk的bug，使用时还是用带有First和Last后的方法更清楚。 在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在 “工作窃取”模式中。</p></li></ol><h1 id="JVM-1"><a href="#JVM-1" class="headerlink" title="JVM"></a>JVM</h1><h2 id="java对象在堆中的结构"><a href="#java对象在堆中的结构" class="headerlink" title="java对象在堆中的结构"></a>java对象在堆中的结构</h2><ul><li>主要是分为三部分：<strong>对象头、实例数据、对齐填充</strong></li></ul><h3 id="对象头（header）"><a href="#对象头（header）" class="headerlink" title="对象头（header）"></a>对象头（header）</h3><ul><li>分为两大块，第一块是<strong>占8个字节的markword，其中存放着锁信息、hashcode、GC信息</strong>，第二块是<strong>占4个字节（压缩前是8个字节，默认压缩）的类型指针（class pointer），这个没啥好说的，就是存放的是这个对象的类的元数据（在方法区中）的地址</strong>。</li><li>也就是说一般情况下对象头占12个字节。</li><li>平时所说的拿到了对象的锁，实际上从底层来看就是修改了对象头中的markword中的锁信息</li><li>在调用一次hashcode方法之后，这个对象的hashcode就会被记录到对象头的markword中，下次使用到的时候可以直接拿</li><li>对象头的markword中的GC信息记录的是这个对象的GC分代年龄</li></ul><h3 id="实例数据（instance-data）"><a href="#实例数据（instance-data）" class="headerlink" title="实例数据（instance data）"></a>实例数据（instance data）</h3><ul><li>这一部分<strong>存放着对象的所有实例属性</strong>。</li></ul><h3 id="对齐填充（padding）"><a href="#对齐填充（padding）" class="headerlink" title="对齐填充（padding）"></a>对齐填充（padding）</h3><ul><li>所有对象的大小（以字节为单位）都是8的倍数，这是为了契合64位处理器的位宽，这也是64位处理器能一次处理的数据大小（也就是一个字长的大小），所以对于那些前两个部分加起来不是8的倍数的对象，我们要<strong>补齐最后一段，从而让对象的大小是8的倍数</strong>，这一部分仅作补齐，没有其他含义。</li></ul><h2 id="对象如何定位"><a href="#对象如何定位" class="headerlink" title="对象如何定位"></a>对象如何定位</h2><ul><li>当用一个引用指向一个对象的时候，这个引用是如何找到那个对象的呢？</li></ul><h3 id="通过指针直接定位"><a href="#通过指针直接定位" class="headerlink" title="通过指针直接定位"></a>通过指针直接定位</h3><ul><li>这种方式也是hotspot虚拟机使用的方式，<strong>引用中存放着的是对象的地址</strong>，通过引用可以直接访问到对象。</li><li>好处就是<strong>访问效率高</strong>，坏处就是GC的时候对象会移动，而引用的值也要随之而改变，<strong>GC效率相较间接定位的方式偏低</strong>。</li></ul><h3 id="通过句柄间接定位"><a href="#通过句柄间接定位" class="headerlink" title="通过句柄间接定位"></a>通过句柄间接定位</h3><ul><li>这种方式，<strong>引用中存放的是一个句柄的地址</strong>，而这个<strong>句柄中又有两个直接指针分别指向对象和它的类的元数据</strong>，这种方式相当于通过句柄间接访问对象。</li><li>句柄通常存放在句柄池中，而<strong>句柄池通常是在堆中</strong>。</li><li>这种方式的好处在于，在进行GC的时候，内存中的对象的位置通常会发生改变（），而使用这种间接定位的方式，由于引用指向的是句柄，而句柄的位置不变，所以引用的值不需要改变，由于引用的值控制着很多GC的参数，所以它不变的话<strong>可以提高GC的效率</strong>。坏处就在于需要两次才能定位对象，<strong>定位的效率相较直接定位方式偏低</strong>。</li></ul><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="谈谈你对IO多路复用的理解？"><a href="#谈谈你对IO多路复用的理解？" class="headerlink" title="谈谈你对IO多路复用的理解？"></a>谈谈你对IO多路复用的理解？</h2><ul><li>IO多路复用是一种同步的IO模型，利用IO多路复用模型，我们可以使用一个或多个线程处理多个TCP连接而无需创建和维护过多的线程，IO多路复用有三种实现模型，分别是select模型、poll模型、epoll模型。</li><li></li></ul><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring中Bean的Scope是Singleton的时候Bean是单例模式吗？"><a href="#Spring中Bean的Scope是Singleton的时候Bean是单例模式吗？" class="headerlink" title="Spring中Bean的Scope是Singleton的时候Bean是单例模式吗？"></a>Spring中Bean的Scope是Singleton的时候Bean是单例模式吗？</h2><ul><li>是，但是这里的单例模式的作用范围非常小，只是作用在相同名字的范围，而并非我们通常说的单例模式一样是作用在同一类型上的，也就是说，<strong>平时我们说的单例模式是指一个类的对象只能有一个，而Spring中Bean的Singleton是指相同名字的对象只能有一个</strong>，也就是说如果我们新建一个Bean也是同一个类的对象，但是名字不同，这俩对象是不同的，如果说是我们平时说的那种单例模式的话，这俩对象就应该是相同的。</li></ul><h2 id="Spring中Bean的生命周期？"><a href="#Spring中Bean的生命周期？" class="headerlink" title="Spring中Bean的生命周期？"></a>Spring中Bean的生命周期？</h2><ul><li><strong>推断构造器</strong>：对于Spring来说，想要创建一个Bean的实例，首先就要推断用那个类的哪个构造器，如果其中只有一个构造器，那么Spring就会用唯一的哪个构造器；如果其中有多个构造方法，那么Spring会尝试去找无参构造器，如果找到了就用，如果没找到，Spring就会不知道使用哪个构造器，只能报错。同时我们也<strong>可以在我们想要使用的构造器上加上@Autowired注解来手动指定我们想用的构造器</strong>。</li><li><strong>实例化</strong>：Spring会使用上一步选中的构造器来实例化对应的Bean。</li><li>—————————————————–以上是Bean的实例化，以下是Bean的初始化———————————————————-</li><li><strong>填充属性</strong>：对Bean中使用了依赖注入注解的属性注入依赖。</li><li><strong>处理Aware回调</strong>：如果Bean的类实现了类似于BeanFactoryAware这样的接口，那么Spring会在这一步调用Bean中重写的那些接口中的方法，相当于是Spring把其内部的一些东西暴露给开发者来进行使用。</li><li><strong>初始化前，处理@PostConstruct注解</strong>：如果Bean中有方法上面有@PostConstruct注解，那么Spring会在这一步调用被那个注解修饰的方法。</li><li><strong>初始化，处理InitializingBean接口</strong>：如果Bean的类实现了InitializingBean接口，那么类中就要重写afterPropertiesSet方法，那个方法就是在这一步被Spring调用。当然也可以在xml文件中指定这一步要调用的方法。这一步可以做一些属性校验。</li><li><strong>初始化后，进行AOP</strong>：通过织入切面得到代理对象，此时Bean初始化完成，这个代理对象就是后面我们要使用的Bean。如果没有要织入的切面，那就直接使用Bean对象。</li></ul><h2 id="Spring-AOP是如何实现的？它和AspectJ有什么区别？"><a href="#Spring-AOP是如何实现的？它和AspectJ有什么区别？" class="headerlink" title="Spring AOP是如何实现的？它和AspectJ有什么区别？"></a>Spring AOP是如何实现的？它和AspectJ有什么区别？</h2><ul><li><strong>Spring AOP是使用了动态代理技术</strong>，如果Bean的类没有实现接口，那么使用的是<strong>Cglib动态代理</strong>，它用的是ASM字节码增强技术，这个技术会在解释运行字节码文件的时候动态对字节码进行改变（这也是为什么不使用AOT的原因），不需要被代理的类实现接口，因为其原理是生成一个被代理类的子类作为代理类，所以如果被代理类是final的就不能使用Cglib动态代理了；如果Bean的类实现了接口，那么使用的是<strong>JDK动态代理</strong>来生成被实现接口的代理对象。</li><li><strong>AspectJ是增强的静态代理</strong>，在<strong>对java文件进行编译的时候，会把切面织入到切入点中，也就是说编译形成的字节码文件本身就带着通知的逻辑</strong>，这就是作用在编译期的静态代理，使用AspectJ<strong>需要使用针对AspectJ的特殊编译器来编译文件</strong>。增强体现在相对于普通的静态代理，它不要求被代理类实现接口。</li><li><strong>Spring AOP沿用了AspectJ的部分注解</strong>，比如@Before、@After、@Around等，但是它们的底层原理是截然不同的。</li></ul><h2 id="Spring中的事务是如何实现的？"><a href="#Spring中的事务是如何实现的？" class="headerlink" title="Spring中的事务是如何实现的？"></a>Spring中的事务是如何实现的？</h2><h2 id="Spring事务什么时候失效？"><a href="#Spring事务什么时候失效？" class="headerlink" title="Spring事务什么时候失效？"></a>Spring事务什么时候失效？</h2><ul><li>由于Spring事务是使用Spring AOP实现的，而Spring AOP的原理又是动态代理，如果使用的是Cglib动态代理，那么生成的代理类是被代理类的子类，而对原方法的增强是通过代理类重写被代理类的方法来实现的，这也就意味着<strong>被代理类中的private方法和final方法是无法被代理的</strong>，因为生成的代理类中压根无法重写目标方法来对其进行增强。</li><li>如果<strong>在事务方法中手动调用本类中的其他方法</strong>，事务也会失效，因为这样做相当于通过this来调用本类的方法，而this是当前类的实例而非代理对象，所以调用的方法是没有事务特性的。</li><li>如果<strong>对象未注册到IOC容器中</strong>，事务注解也会失效，因为无法生成代理Bean</li><li><strong>错误的事务传播特性</strong>也会导致事务失效</li><li><strong>内部处理了异常没有往外抛或者手动抛了除指定外的其他异常</strong>，spring的事务也会失效</li></ul><h2 id="Spring是如何解决循环依赖的？"><a href="#Spring是如何解决循环依赖的？" class="headerlink" title="Spring是如何解决循环依赖的？"></a>Spring是如何解决循环依赖的？</h2><ul><li>多个Bean中相互持有对方的引用，就会产生循环依赖问题，循环依赖会导致Bean在依赖注入的时候造成死循环，有三种基本的形态，第一种是两个Bean之间互相依赖，第二种是三个以上的Bean之间互相依赖，第三种是一个Bean自己依赖自己。</li><li>Spring设计了三级缓存去解决循环依赖的问题，<strong>一级缓存存放已经初始化完成的Bean，二级缓存存放刚实例化完成的Bean，三级缓存存放对应Bean的工厂</strong></li><li>当获取一个Bean的时候，Spring会先从一级缓存去找，然后再从二级缓存去找，如果都没有找到，说明当前要获取的这个Bean还没有实例化，于是Spring会先对这个Bean进行实例化操作（注意只是实例化操作，初始化操作没有做，这也就意味着这个Bean中的属性还没有被注入依赖），然后Spring会判断这个Bean是否存在循环依赖问题，如果不存在，那么直接执行下面的内容直到Bean初始化完之后放到一级缓存中，如果存在，那么Spring会先把当前这个刚实例化完的Bean放入到二级缓存中，然后去尝试创建它依赖的那个Bean，那个Bean依赖着之前那个Bean，但是由于之前那个Bean的半成品已经进二级缓存了，所以这个Bean就能顺利走完初始化步骤，然后进入一级缓存，这时又回到了之前那个Bean的初始化步骤，从一级缓存中拿到依赖的那个Bean往下走，初始化完之后也进入一级缓存并从二级缓存中删掉它的引用。</li><li>上面说的情况是两个Bean不存在创建代理对象步骤的时候，如果需要创建代理对象，那么就不能用上面的方法解决循环依赖问题了，因为创建代理对象是在初始化后做的，而它们互相依赖的都是它们的代理对象，前面把实例化后的半成品放到二级缓存中会让后面的Bean引用前面的Bean本身而不是它的代理，这种情况就需要前面的Bean在实例化完之后把自己的一个工厂放到三级缓存中，当后面的Bean想要注入依赖的时候需要从三级缓存中用对应的工厂来得到前面的Bean，这个<strong>工厂实际上会执行AOP步骤中的提前创建代理对象的方法，也就是会提前创建好代理对象，把提前创建好的代理对象放到二级缓存中</strong>，然后后面的Bean就可以使用了。所以这样做就解决了Spring循环依赖的问题。</li></ul><h1 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h1><h2 id="叙述一下Spring-Boot自动装配机制的原理？"><a href="#叙述一下Spring-Boot自动装配机制的原理？" class="headerlink" title="叙述一下Spring Boot自动装配机制的原理？"></a>叙述一下Spring Boot自动装配机制的原理？</h2><ul><li>自动装配简单来说就是<strong>自动去把第三方组件的Bean装载到IOC容器中</strong>，不需要开发人员再去写bean相关配置，要想开启自动装配，我们只需要在启动类上加上@SpringBootApplication注解就可以实现自动装配了，但是这个注解是个复合注解，实际上自动装配是<strong>通过使用@EnableAutoConfiguration注解来进行开启</strong>的。</li><li>自动装配的实现主要依靠三个核心的关键技术：<ol><li>引入Starter启动依赖组件的时候，这个组件中必须包含一个带有**@Configuration注解的配置类<strong>，在这个配置类中我们需要使用</strong>@Bean注解来声明需要装配到IOC容器里面的Bean对象**。</li><li>这个配置类是放在第三方的jar包中的，然后通过Spring Boot中<strong>约定大于配置</strong>的理念，去把这个<strong>配置类的全路径放在classpath:&#x2F;META-INF&#x2F;spring.factories文件中</strong>，这样spring就可以知道这个配置类在第三方jar包中的位置，这个步骤主要是用到了spring中<strong>SpringFactoriesLoader</strong>来完成的。</li><li>Spring Boot在拿到所有第三方jar包里面声明的配置类之后，再通过spring提供的<strong>ImportSelector接口</strong>来实现对这些配置类的<strong>动态加载</strong>从而去完成动态装配的动作。</li></ol></li><li>在我看来，SpringBoot是约定优于配置这一理念下的一个产物，所以在很多地方都能看到这样的思想，它的出现可以<strong>让开发人员更多地聚焦在业务代码的编写上，而不需要去关心和业务无关的配置</strong>。</li><li>@EnableXxxxxx注解的实现实际上也是帮我们去自动完成相关Bean的注入而不需要我们去手动配置需要的Bean。</li></ul><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><ul><li>MyBatis中提供的这两种占位符都是去实现动态SQL的一种方式，通过这两种方式可以把参数传递到SQL语句里面，在执行操作之前，MyBatis会对这两个占位符进行动态的解析，#占位符等同于jdbc里面的一个?占位符，它相当于向PreparedStatement的里面的预处理语句设置参数，而PreparedStatement里面的SQL语句是经过预编译的，在这个SQL语句中使用到了占位符来规定SQL语句的结构，并且<strong>在设置参数的时候如果有特殊字符会自动进行转义，如果参数是表名什么的还会自动加上单引号</strong>，所以#占位符可以防止SQL注入，因为语法的特殊字符给转义了；而使用$号传参相当于直接把参数拼接到了原始SQL里面，MyBatis不会对它进行任何的特殊处理，所以会存在SQL注入的风险。</li><li>所以$和#的区别在于，前者是动态参数，后者是占位符，动态参数无法防止SQL注入的一个问题，所以在实际应用中应该尽可能地去使用#占位符，另外$符号的动态传参可以适合应用在一些动态SQL的场景里面，比如说动态传递表明或者动态设置排序字段等。</li></ul><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="OSI-七层模型是什么？每一层的作用是什么？"><a href="#OSI-七层模型是什么？每一层的作用是什么？" class="headerlink" title="OSI 七层模型是什么？每一层的作用是什么？"></a>OSI 七层模型是什么？每一层的作用是什么？</h2><ul><li>应用层：为计算机用户提供服务</li><li>表示层：数据处理（编解码、加密解密、压缩解压缩）</li><li>会话层：管理（建立、维护、重连）应用程序之间的会话</li><li>传输层：为两台主机进程之间的通信提供的通用的数据传输服务</li><li>网络层：路由和寻址（决定数据在网络上的游走路径）</li><li>数据链路层：对数据进行封装成帧、透明传输、差错校验（CRC循环冗余校验）</li><li>物理层：确定如何表示比特（比如高电平表示1，低电平表示0），确定比特如何传输（通过光缆、同轴电缆等），透明地传输比特流数据</li></ul><h2 id="TCP-x2F-IP-四层模型是什么？每一层的作用是什么？"><a href="#TCP-x2F-IP-四层模型是什么？每一层的作用是什么？" class="headerlink" title="TCP&#x2F;IP 四层模型是什么？每一层的作用是什么？"></a>TCP&#x2F;IP 四层模型是什么？每一层的作用是什么？</h2><h2 id="HTTP和HTTPS的区别？"><a href="#HTTP和HTTPS的区别？" class="headerlink" title="HTTP和HTTPS的区别？"></a>HTTP和HTTPS的区别？</h2><ul><li>HTTP传输的数据是明文，很容易出现安全问题，而HTTPS传输的数据是密文，它结合了<strong>SSL&#x2F;TLS和TCP协议</strong>，对通信数据进行了加密。</li><li>对于SSL&#x2F;TLS协议来说，为了安全起见，应该使用非对称加密机制来保证数据的安全，也就是说发送方使用公钥进行加密，接收方使用私钥进行解密。</li><li>但是由于非对称加密体制需要的计算量较大，所以这样做数据传输效率会比较低，所以<strong>实际上SSL&#x2F;TLS协议是使用对称加密机制来保证数据安全的</strong>，也就是说通信双方都通过同一个公钥进行加密和解密，这样做数据的安全性实际上就是依赖于公钥的保密程度，因为加密和解密算法通常是公开的。</li><li>但是采用这种对称的加密方案的话，公钥的传输又是一个问题，因为接收方如果想要解析数据，就需要发送方发送的公钥，当发送方发送公钥的时候，如果敌手截取了发送方发送的公钥，那么敌手可以伪造一个公钥给接收方发过去，这样接收方之后发送消息都会通过这个伪造的公钥进行加密，这样敌手获取这个数据之后通过自己的私钥进行解密，就能获得明文了，而发送方和接收方对于这个敌手一无所知。</li><li>所以我们引入了<strong>第三方可信的证书颁发机构CA</strong>，如果发送方想要给接收方发送公钥，就要先向CA申请一个证书，CA会把包括要发送的<strong>公钥</strong>在内的数据做成<strong>证书</strong>，然后使用<strong>报文摘要算法</strong>对证书进行计算得到<strong>散列码</strong>，同时CA使用自己的<strong>私钥</strong>对得到的散列码进行<strong>加密</strong>，这样生成的数据就是CA对这个证书的<strong>数字签名</strong>，这个数字签名可以用来判断证书是否有效。</li><li>CA做完上面的操作之后把证书+签名交给发送方，发送方把这些数据发送给接收方，接收方收到之后会使用CA的<strong>公钥</strong>来对数字签名进行<strong>解密</strong>，并对证书数据进行相同的<strong>报文摘要算法</strong>，将计算结果和解密后的数字签名<strong>进行比较</strong>，如果相同，说明证书有效，如果不相同，说明证书无效。</li><li>当引入CA之后，如果敌手截获了CA的证书+签名，那么敌手也没有什么可以做的，敌手如果篡改证书数据而不改签名的话，接收方就会发现证书无效而不予使用，如果敌手想要篡改证书数据又篡改签名的话，由于不知道CA的私钥，所以无法对生成的散列码进行加密，这种情况同样也会被接收端验证出来证书无效。</li><li>总的来说<strong>SSL&#x2F;TLS是通过对称加密数据和通过证书发送公钥的方式来实现数据的安全传输的</strong>。</li></ul><h2 id="HTTP1-0、1-1、2-0、3-0之间的区别？"><a href="#HTTP1-0、1-1、2-0、3-0之间的区别？" class="headerlink" title="HTTP1.0、1.1、2.0、3.0之间的区别？"></a>HTTP1.0、1.1、2.0、3.0之间的区别？</h2><h2 id="TCP网络传输中的粘包问题是什么意思？"><a href="#TCP网络传输中的粘包问题是什么意思？" class="headerlink" title="TCP网络传输中的粘包问题是什么意思？"></a>TCP网络传输中的粘包问题是什么意思？</h2><ul><li>首先明确<strong>TCP协议是流式协议</strong>，这也就意味着使用TCP协议传输数据的话，数据是以字节流来进行传输的，此时<strong>如果我们不用一种机制来确定信息的边界，就会出现粘包问题</strong>，比如A向B发消息，第一个消息转换成字节流是50个字节，第二个消息转换成字节流是100个字节，如果消息的边界无法确认，接收端就可能一次性接收150个字节，这样信息就乱了，两个包像是粘在一起了一样，所以叫粘包。</li><li>所以如果想实现两端的正常通信，只使用TCP协议是不行的，还需要去规定一些额外的东西，应用层用到TCP的协议（比如HTTP、FTP等）都在TCP协议的基础上规定了很多额外的东西，正是因为有这些规定，应用层协议的功能才能得以实现。</li></ul><h2 id="如何解决TCP网络传输中的粘包问题？"><a href="#如何解决TCP网络传输中的粘包问题？" class="headerlink" title="如何解决TCP网络传输中的粘包问题？"></a>如何解决TCP网络传输中的粘包问题？</h2><ul><li>既然粘包问题是由于接收方无法确定信息边界而产生的，所以要解决这个问题可以从这个方面着手：<ol><li>我们可以<strong>约定一个包的大小</strong>，也就是发送方发送和接收方解析都按照这个固定大小来进行解析，这种通信协议的<strong>格式简单但灵活性差</strong>。<strong>如果包内容不足指定的字节数，剩余的空间需要填充特殊的信息</strong>，如 \0（如果不填充特殊内容，如何区分包里面的正常内容与填充信息呢？）；<strong>如果包内容超过指定字节数，又得分包分片</strong>，需要增加额外处理逻辑——在发送端进行分包分片，在接收端重新组装包片。</li><li>我们还可以<strong>指定特定的字符（串）为包的结束标志</strong>，这种协议包比较常见，即字节流中遇到特殊的符号值时就认为到一个包的末尾了。例如，我们熟悉的 FTP协议，发邮件的 SMTP 协议，一个命令或者一段数据后面加上”\r\n”（即所谓的 <strong>CRLF</strong>）表示一个包的结束。对端收到后，每遇到一个”\r\n“就把之前的数据当做一个数据包。这种协议一般用于一些包含各种命令控制的应用中，其<strong>不足之处就是如果协议数据包内容部分需要使用包结束标志字符，就需要对这些字符做转码或者转义操作，以免被接收方错误地当成包结束标志而误解析（数据链路层的透明传输也是这个思路）</strong>。</li><li>我们还可以<strong>使用包头+包体的格式来构建一个包</strong>，这种格式的包一般分为两部分，即包头和包体，包头是固定大小的，且包头中必须含有一个字段来说明接下来的包体有多大。各协议对包头的定义各不相同，而且解包和处理需要进行额外的操作，这也是各协议需要设计的地方。</li></ol></li></ul><h2 id="为什么有HTTP1-1不用，要用RPC协议？"><a href="#为什么有HTTP1-1不用，要用RPC协议？" class="headerlink" title="为什么有HTTP1.1不用，要用RPC协议？"></a>为什么有HTTP1.1不用，要用RPC协议？</h2><ul><li>因为RPC协议的<strong>定制化程度更高</strong>，可以<strong>采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据</strong>，同时也<strong>不需要像 HTTP 那样考虑各种浏览器行为</strong>，比如 302 重定向跳转啥的。</li><li>总而言之就是从微服务的互相调用来看，RPC协议的性能比HTTP1.1要好</li><li>但是在2015年HTTP出了2.0版本，这个版本在HTTP1.1上做了优化，性能较RPC更好，但是由于它出的晚，很多公司内部已经使用RPC好多年了，所以也没必要大费周章地换了。</li></ul><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h2><ol><li>操作系统是管理计算机硬件与软件资源的程序，是计算机的基石。</li><li></li></ol><h2 id="多级反馈队列调度算法了解吗？"><a href="#多级反馈队列调度算法了解吗？" class="headerlink" title="多级反馈队列调度算法了解吗？"></a>多级反馈队列调度算法了解吗？</h2><ul><li>多级反馈队列调度算法实际上是一种<strong>进程调度算法</strong>，它很好地<strong>融合了先来先服务、短作业优先、优先级、时间片轮转这几种进程调度算法的优势</strong>，这种进程调度算法<strong>使得优先级高的进程能快速得到响应的同时又保证了短作业能快速完成</strong>，这也是Unix系统中使用的进程调度算法。</li><li>其工作原理主要就是<strong>划分了多个优先级队列</strong>，每个队列存放不同优先级的进程，然后<strong>每个队列都有属于自己的时间片长度</strong>，<strong>优先级越高的队列时间片的长度越小</strong>（这样其实就是保证了高优先级作业能快速得到响应但是不一定会被处理完，而由于不用等待前面的作业处理完后再处理后面的作业，所以低优先级的短作业会很快被处理完）。</li><li>进行进程调度时会<strong>先从优先级高的队列开始</strong>，用<strong>先来先服务</strong>的方式去<strong>使用队列对应的时间片</strong>来让进程运行，如果在<strong>一个时间片内</strong>运行完毕，那个进程就可以直接退出系统了，如果在一个时间片内没有运行完毕，那么这个进程将会<strong>进入下一个队列的队尾中</strong>，以此类推，直到进程进入最后一个队列的队尾，该算法<strong>对最后一个队列的进程采用的时间片轮转的调度方法</strong>。</li><li>只有在<strong>处理完一个队列之后才会处理下一个队列</strong>，但是如果在处理优先级较低的队列时有优先级较高的进程进入了优先级较高的队列，那么处理机会将当前处理的进程放在当前队列的队尾，然后<strong>立即去处理刚来的较高优先级的进程</strong>。</li></ul><h2 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h2><ul><li>我认为虚拟内存是操作系统<strong>对于物理内存的抽象和封装</strong>，也就是说操作系统通过抽象和封装物理内存来<strong>给进程提供一个逻辑上连续且完整的地址空间</strong>，而这些所谓连续且完整的内存空间<strong>可能在物理层面是离散的</strong>，而且<strong>可能有部分是使用的磁盘上的空间</strong>，这样的做法使得<strong>计算机好像为用户提供了比实际内存大得多的内存空间</strong>，这实际上就是虚拟内存的概念。</li><li>这样做的好处主要有三个：<ol><li>首先就是我们在编写大型应用程序的时候，我们面向的地址空间是操作系统给我们提供的虚拟内存空间，这个空间总是<strong>连续且完整</strong>的，这<strong>给我们进行软件开发带来了极大的便利</strong>。</li><li>其次就是<strong>防止出现地址冲突的问题</strong>，如果操作系统直接将物理地址暴露给进程，那么进程可能会有意或无意地触碰到那些已经在使用地内存空间，这样可能会造成别的进程乃至操作系统的崩溃，但是如果进程面向的是虚拟内存空间就不会出现这种情况，因为虚拟地址会通过操作系统的调控再转换为物理地址，操作系统不会让这种情况发生。</li><li>再者就是使用虚拟内存<strong>消除了计算机同时运行多个程序带来的安全问题</strong>，如果操作系统将物理内存暴露，那么不同的人在编写应用程序的时候可能使用了相同的物理内存，这样不同的程序在同一个计算机上运行的时候就会出现问题，使用虚拟内存就不会出现这样的问题，因为操作系统会动态调控。</li></ol></li><li>基于<strong>局部性原理</strong>，在程序装入时，可以<strong>将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行</strong>。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。<strong>在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序</strong>。另一方面，<strong>操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息</strong>。这样，计算机好像为用户提供了一个比实际内存大得多的存储器——<strong>虚拟内存</strong>。</li><li>我觉得虚拟内存同样是一种<strong>时间换空间</strong>的策略：你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。</li></ul><h2 id="虚拟内存技术的实现？"><a href="#虚拟内存技术的实现？" class="headerlink" title="虚拟内存技术的实现？"></a>虚拟内存技术的实现？</h2><ul><li>虚拟内存技术的实现需要<strong>建立在离散分配的内存管理方式的基础上</strong>，虚拟内存的实现有以下三种方式：<ol><li><strong>请求分页存储管理</strong> ：<strong>建立在分页管理之上</strong>，为了支持虚拟存储器功能而<strong>增加了请求调页功能和页面置换功能</strong>。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，<strong>在作业开始运行之前，仅装入当前要执行的部分段即可运行</strong>。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法<strong>将要用的页面调入到主存</strong>，同时操作系统也可以<strong>将暂时不用的页面置换到外存</strong>中。</li><li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，<strong>增加了请求调段功能、分段置换功能</strong>。请求分段储存管理方式就如同请求分页储存管理方式一样，<strong>在作业开始运行之前，仅装入当前要执行的部分段即可运行</strong>；在执行过程中，可<strong>使用请求调入中断动态装入要访问但又不在内存的程序段</strong>；当内存空间已满，而又需要装入新的段时，<strong>根据置换功能适当调出某个段，以便腾出空间而装入新的段</strong>。</li><li><strong>请求段页式存储管理</strong></li></ol></li><li>这里多说一下，很多人容易搞混请求分页与分页存储管理，两者有何不同呢？<ul><li>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</li><li>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</li></ul></li><li>不管是上面那种实现方式，我们一般都需要：<ol><li><strong>一定容量的内存和外存</strong>：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li><li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li><li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li></ol></li></ul><h2 id="常见的页面置换算法有哪些？"><a href="#常见的页面置换算法有哪些？" class="headerlink" title="常见的页面置换算法有哪些？"></a>常见的页面置换算法有哪些？</h2><ul><li><strong>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断</strong> 。<strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</li><li>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。<strong>用来选择淘汰哪一页的规则叫做页面置换算法</strong>，我们可以把页面置换算法看成是淘汰页面的规则，页面置换算法主要有以下几种：<ol><li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法<strong>所选择的被淘汰页面将是以后永不使用的</strong>，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而<strong>该算法无法实现</strong>。一般作为衡量其他置换算法的方法。</li><li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即<strong>选择在内存中驻留时间最久的页面进行淘汰</strong>。</li><li><strong>LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU 算法赋予每个页面一个访问字段，用来<strong>记录一个页面自上次被访问以来所经历的时间 T</strong>，当须淘汰一个页面时，<strong>选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰</strong>。</li><li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法<strong>选择在之前时期使用最少的页面作为淘汰页</strong>。</li></ol></li></ul><h1 id="数据库理论"><a href="#数据库理论" class="headerlink" title="数据库理论"></a>数据库理论</h1><h2 id="一些数据库术语"><a href="#一些数据库术语" class="headerlink" title="一些数据库术语"></a>一些数据库术语</h2><ul><li><strong>关系</strong>：一个关系对应一张表</li><li><strong>元组</strong>：表中的一行</li><li><strong>属性</strong>：表中的一列</li><li><strong>码</strong>：也称码键，是表中的某个可以唯一标识一个元组的属性</li><li><strong>候选码</strong>：若关系中的一个属性或属性组的值能够唯一地标识一个元组，且他的真子集不能唯一的标识一个元组，则称这个属性或属性组做候选码。</li><li><strong>主码</strong>：从候选码里面任意挑出一个候选码作为主码。</li><li><strong>主属性</strong>：包含在候选码中的属性。</li><li><strong>非主属性</strong>：不包含在候选码中的属性。</li><li>全码：若关系中只有一个候选码,且这个候选码中包含全部属性,则该候选码为全码。</li><li>超码：能表示出所有属性的集合。候选码是最小的超码。</li><li>域：是一组具有相同数据类型的值的集合</li><li>分量：元组中的一个属性</li></ul><h2 id="数据库关系的完整性有哪三种？"><a href="#数据库关系的完整性有哪三种？" class="headerlink" title="数据库关系的完整性有哪三种？"></a>数据库关系的完整性有哪三种？</h2><ol><li>实体完整性：主码唯一且为空。</li><li>参照完整性：外码要么为空，要么对应另一个表的主码。外码指的是别的表的属性，一般用来关联两个表。</li><li>用户定义完整性：用户自己定义的关系要完整，不能有关键属性的遗漏。</li></ol><h2 id="怎么将ER图转换为关系模式？"><a href="#怎么将ER图转换为关系模式？" class="headerlink" title="怎么将ER图转换为关系模式？"></a>怎么将ER图转换为关系模式？</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514141426012.png" alt="image-20220514141426012"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514141438620.png" alt="image-20220514141438620"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20220514141501633.png" alt="就是将关系的属性和两边的主键组合成一个新的关系模式"></p><h2 id="如何对sql进行代数优化？"><a href="#如何对sql进行代数优化？" class="headerlink" title="如何对sql进行代数优化？"></a>如何对sql进行代数优化？</h2><ol><li>选择运算尽量先做</li><li>把投影运算和选择运算同时执行</li><li>把投影同它前后的双目运算符连接起来</li></ol><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="什么是快照读？什么是当前读？"><a href="#什么是快照读？什么是当前读？" class="headerlink" title="什么是快照读？什么是当前读？"></a>什么是快照读？什么是当前读？</h2><ul><li>快照读和当前读是读取数据的不同方式，这两种方式<strong>都能保证一定的事务隔离性</strong>，但是它们的<strong>底层实现不同</strong>。</li><li><strong>当前读</strong>又叫锁定读，顾名思义是用<strong>锁</strong>实现的，读到的是<strong>最新的数据</strong>；<strong>快照读</strong>又叫非锁定读，是使用<strong>MVCC</strong>技术实现的，读到的<strong>不一定是最新的数据</strong>。</li><li>快照读（非锁定读）举例：select * from table</li><li>当前读（锁定读）举例：select * from table <strong>lock in share mode</strong>、select * from table <strong>for update</strong>、insert操作、update操作、delete操作</li></ul><h2 id="介绍一下MVCC？"><a href="#介绍一下MVCC？" class="headerlink" title="介绍一下MVCC？"></a>介绍一下MVCC？</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>MVCC是<strong>多版本并发控制</strong>的意思，InnoDB中使用这个技术和锁技术一起保证事务的隔离性，这个技术主要是能<strong>让事务在不使用锁的前提下保证其隔离性</strong>，由于没有使用到锁，所以<strong>使用MVCC时的并发性能是比较高的</strong>，这也是InnoDB<strong>快照读</strong>的实现原理。</li><li>在<strong>RC</strong>的事务隔离级别下MVCC可以<strong>防止出现脏读</strong>，在<strong>RR</strong>的事务隔离级别下MVCC可以<strong>防止出现脏读、不可重复读和部分幻读</strong>，如果想要解决全部的幻读问题需要搭配<strong>临键锁</strong>来实现。</li></ul><h3 id="技术依赖"><a href="#技术依赖" class="headerlink" title="技术依赖"></a>技术依赖</h3><ul><li><p>InnoDB对MVCC的实现主要依赖于<strong>记录的隐藏字段、Read View和undo log</strong></p></li><li><p>先说一下隐藏字段，起主要作用的主要就是仨：</p><ol><li><strong>DB_TRX_ID</strong>：表示最后一次插入、删除或更新该行的事务 id。</li><li><strong>DB_ROLL_PTR</strong>：指向undo log中的之前这个记录的版本，如果该行无历史版本，则这个字段为空</li><li>DB_ROW_ID：记录的唯一id，如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用该 id 来生成聚簇索引</li></ol></li><li><p>再说一下Read View，生成它的时机在不同的隔离级别中也是不同的，在<strong>RC隔离级别中，在事务中的每个select语句执行之前都会生成一个Read View</strong>；而在<strong>RR隔离级别中，在事务中只有第一个select语句执行之前会生成Read View</strong>，剩下的select语句都使用之前生成的Read View。那么这个Read View中有什么作用呢？我觉得可以把它看成一个<strong>事务状态快照</strong>，在生成它的时候得到当前时刻各事务的状态，然后<strong>根据这些信息和DB_TRX_ID来判断undo log中哪些版本是可见的</strong>。那么Read View中有些什么值呢？起主要作用的有四个字段：</p><ol><li><strong>m_low_limit_id</strong>：<strong>目前出现过的最大的事务 ID+1</strong>，即下一个将被分配的事务 ID。<strong>大于等于这个 ID 的数据版本均不可见</strong></li><li><strong>m_up_limit_id</strong>：<strong>活跃事务列表 m_ids中最小的事务 ID</strong>，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。<strong>小于这个 ID 的数据版本均可见</strong>。</li><li><strong>m_ids</strong>：<strong>Read View创建时其他未提交的活跃事务 ID 列表</strong>。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<strong>m_ids 不包括当前事务自己和已提交的事务（正在内存中）</strong></li><li><strong>m_creator_trx_id</strong>：<strong>创建该 Read View的事务 ID</strong></li></ol><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230306173026267.png" alt="image-20230306173026267"></p></li><li><p>最后说一下undo log，这个日志中<strong>保存着各记录的历史版本</strong>，<strong>各历史版本之间通过记录中的隐藏字段DB_ROLL_PTR来链接</strong>。</p></li></ul><h3 id="如何使用Read-View和DB-TRX-ID字段来判断记录的可见性"><a href="#如何使用Read-View和DB-TRX-ID字段来判断记录的可见性" class="headerlink" title="如何使用Read View和DB_TRX_ID字段来判断记录的可见性"></a>如何使用Read View和DB_TRX_ID字段来判断记录的可见性</h3><ol><li>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的</li><li>如果 DB_TRX_ID &gt;&#x3D; m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5</li><li>m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</li><li>如果 m_up_limit_id &lt;&#x3D; DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的<strong>二分查找</strong>，因为是有序的）<ul><li>如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5</li><li>在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见</li></ul></li><li>在该记录行的 DB_ROLL_PTR 指针所指向的 <code>undo log</code> 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空</li></ol><ul><li>总之就是先判断DB_TRX_ID是否大于最大id，如果是，那就顺着版本链在undo log中找符合条件的历史版本，如果不是，再判断DB_TRX_ID是否小于最小id，如果是，那就直接将该记录加入结果中，如果不是，再去m_ids中找是否有当前DB_TRX_ID的值，如果没有，那就直接将该记录加入到结果中，如果有，就顺着版本链在undo log中找符合条件的历史版本。</li></ul><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li>在事务中进行更新、删除、插入记录的时候，undo log会<strong>把最新的记录状态记录下来</strong>，让隐藏字段DB_TRX_ID字段的值等于操作的事务ID，然后让隐藏字段DB_ROLL_PTR指向之前的那个记录版本。</li><li>在事务中进行快照读的时候，如果是RC隔离级别，那么在读之前会创建一个新的Read View；如果是RR隔离级别，那么在读之前会判断Read View是否已经生成，如果已经生成则使用已有的Read View，如果没有生成就创建一个新的Read View。然后每当读到一条记录的时候，都会<strong>通过DB_TRX_ID和Read View来判断记录的可见性（上面提到了具体步骤）</strong>，如果可见，就加入到结果中，如果不可见，就从undo log中找历史版本加入到结果中，如果没有满足条件的历史版本，那就跳过当前记录。</li></ul><h2 id="为什么InnoDB引擎规定页的默认大小是16kb？"><a href="#为什么InnoDB引擎规定页的默认大小是16kb？" class="headerlink" title="为什么InnoDB引擎规定页的默认大小是16kb？"></a>为什么InnoDB引擎规定页的默认大小是16kb？</h2><ul><li>&#x2F;&#x2F;todo 不知道下面这个说法对不对，我看着还挺合理</li><li>我们都知道页是存储引擎读写的基本单位，但是为什么InnoDB规定页的默认大小是16kb呢？主要是<strong>利用到了局部性原理</strong>，<strong>分页式管理内存的操作系统一般规定页的默认大小是4kb</strong>，而根据空间局部性原理，一个被访问的地址空间周围的地址空间通常也会马上被访问到，所以我们就<strong>将那一页的周围三页一起读取当成存储引擎的一页读到存储引擎的缓冲池中</strong>，这样可以防止频繁IO。</li></ul><h2 id="日常工作中怎么优化SQL？"><a href="#日常工作中怎么优化SQL？" class="headerlink" title="日常工作中怎么优化SQL？"></a>日常工作中怎么优化SQL？</h2><ol><li><strong>对合适的列加索引</strong>：<ul><li>被频繁查询的字段：利用索引的B+树结构加快查询效率</li><li>被作为条件查询的字段：利用索引的B+树结构加快查询效率</li><li>频繁需要排序的字段：可以利用索引的有序性，加快排序的查询时间</li><li>被频繁用于连接的字段：提高多表连接查询的效率</li></ul></li><li><strong>避免索引失效的场景</strong>：<ul><li>使用 <code>SELECT *</code> 进行查询;</li><li>创建了组合索引，但查询条件未遵守最左匹配原则;</li><li>在索引列上进行计算、函数、类型转换等操作;</li><li>以 <code>%</code> 开头的 LIKE 查询比如 <code>like &#39;%abc&#39;</code>;</li><li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li><li>发生隐式转换</li></ul></li><li><strong>避免返回不必要的数据列</strong>，减少返回的数据列可以增加查询的效率</li><li><strong>根据查询分析器适当优化SQL的结构</strong>，比如是否走全表扫描、避免子查询等</li><li><strong>分库分表</strong>：在单表数据量较大或者并发连接数过高的情况下，通过这种方式可以有效提升查询效率</li><li><strong>读写分离</strong>：针对读多写少的场景，这样可以保证写操作的数据库承受更小的压力，也可以缓解独占锁和共享锁的竞争</li></ol><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>—————————————————————————–Redis基础————————————————————————————–</p><h2 id="对于Redis，你的理解是什么？"><a href="#对于Redis，你的理解是什么？" class="headerlink" title="对于Redis，你的理解是什么？"></a>对于Redis，你的理解是什么？</h2><ul><li>Redis是一个<strong>基于内存</strong>实现的<strong>Key-Value数据结构</strong>的<strong>NoSQL数据库</strong>，由于数据是存储在内存之中，所以数据的IO效率是非常高的，当然Redis还提供了一些持久化策略来避免内存数据丢失的问题。NoSQL实际上就是非关系型数据库，这类数据库主要是考虑数据的扩展性、性能和大数据量的存储，弥补了关系型数据库的短板。通常用在分布式系统中做缓存中间件，同时对于企业级应用来说，Redis还提供了主从复制+哨兵+集群的方式来实现高可用，同时通过哈希槽的机制来实现了数据的分片，进一步提升了系统整体的性能和可扩展性。</li></ul><h2 id="什么是Redis？"><a href="#什么是Redis？" class="headerlink" title="什么是Redis？"></a>什么是Redis？</h2><ul><li>Redis是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 <strong>Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据</strong>。</li><li>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap）。并且，Redis 还支持事务 、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</li><li>Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。</li></ul><h2 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h2><ul><li>Redis 内部做了非常多的性能优化，比较重要的主要有下面 3 点：<ol><li>Redis <strong>基于内存</strong>，内存的访问速度是磁盘的上千倍；</li><li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是<strong>单线程事件循环和 IO 多路复用</strong>（Redis 线程模式后面会详细介绍到）；</li><li>Redis <strong>内置了多种优化过后的数据结构实现</strong>，性能非常高。</li></ol></li></ul><h2 id="Redis和Memcached的区别和共同点"><a href="#Redis和Memcached的区别和共同点" class="headerlink" title="Redis和Memcached的区别和共同点"></a>Redis和Memcached的区别和共同点</h2><ul><li>现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据。</li></ul><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k&#x2F;v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k&#x2F;v 数据类型。</li><li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li><li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li><li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li><li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li><li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型（仅IO和执行命令是单线程，其实Redis服务端本身是多线程的）。</strong> （Redis 6.0 引入了多线程 IO ）</li><li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li><li><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li></ol><h2 id="为什么要用Redis-x2F-为什么要用缓存？"><a href="#为什么要用Redis-x2F-为什么要用缓存？" class="headerlink" title="为什么要用Redis&#x2F;为什么要用缓存？"></a>为什么要用Redis&#x2F;为什么要用缓存？</h2><ul><li>主要是从<strong>高性能</strong>和<strong>高并发</strong>两点来分析。</li></ul><h3 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h3><ul><li>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，<strong>如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中</strong>。</li><li>这样有什么好处呢？ 那就是<strong>保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快</strong>。</li></ul><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><ul><li>一般像 MySQL 这类的数据库的 QPS（服务器每秒可以执行的查询次数） 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。</li><li>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑<strong>把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发</strong>。</li></ul><h2 id="Redis除了做缓存之外，还能做什么？"><a href="#Redis除了做缓存之外，还能做什么？" class="headerlink" title="Redis除了做缓存之外，还能做什么？"></a>Redis除了做缓存之外，还能做什么？</h2><ul><li><strong>分布式锁</strong> ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。</li><li><strong>限流</strong> ：一般是通过 Redis + Lua 脚本的方式来实现限流。</li><li><strong>消息队列</strong> ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li><li><strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li><li>……</li></ul><h2 id="Redis可以做消息队列吗？"><a href="#Redis可以做消息队列吗？" class="headerlink" title="Redis可以做消息队列吗？"></a>Redis可以做消息队列吗？</h2><ul><li>Redis 5.0 新增加的一个数据结构 <code>Stream</code> 可以用来做消息队列，<code>Stream</code> 支持：<ol><li>发布 &#x2F; 订阅模式</li><li>按照消费者组进行消费</li><li>消息持久化（ RDB 和 AOF）</li></ol></li><li>不过，和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议是不使用 Redis 来做消息队列的，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</li></ul><h2 id="如何基于Redis实现分布式锁？"><a href="#如何基于Redis实现分布式锁？" class="headerlink" title="如何基于Redis实现分布式锁？"></a>如何基于Redis实现分布式锁？</h2><p>—————————————————————————–Redis数据结构——————————————————————————-</p><h2 id="Redis常用的数据结构有哪些？"><a href="#Redis常用的数据结构有哪些？" class="headerlink" title="Redis常用的数据结构有哪些？"></a>Redis常用的数据结构有哪些？</h2><ul><li><strong>5 种基础数据结构</strong> ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li><li><strong>3 种特殊数据结构</strong> ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li><li>赶不上（GBS）临淄（LZ）黄昏时（HHS）</li></ul><h2 id="String-的应用场景有哪些？"><a href="#String-的应用场景有哪些？" class="headerlink" title="String 的应用场景有哪些？"></a>String 的应用场景有哪些？</h2><ul><li>常规数据（比如 session、token、、序列化后的对象）的缓存；</li><li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li><li>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li><li>……</li></ul><h2 id="存储对象数据使用String还是Hash更好？"><a href="#存储对象数据使用String还是Hash更好？" class="headerlink" title="存储对象数据使用String还是Hash更好？"></a>存储对象数据使用String还是Hash更好？</h2><ul><li><strong>String 存储的是序列化后的对象数据，存放的是整个对象</strong>。<strong>Hash 是对对象的每个字段单独存储</strong>，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。<strong>如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合</strong>。</li><li><strong>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半</strong>。并且，存储具有多层嵌套的对象时也方便很多。<strong>如果系统对性能和资源消耗非常敏感的话，String 就非常适合</strong>。</li><li>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</li></ul><h2 id="String的底层实现是什么？"><a href="#String的底层实现是什么？" class="headerlink" title="String的底层实现是什么？"></a>String的底层实现是什么？</h2><ul><li><p>Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 <code>\0</code> 结尾的字符数组），而是<strong>自己编写了 SDS（Simple Dynamic String，简单动态字符串） 来作为底层实现</strong>。</p></li><li><p>SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。</p></li><li><p>Redis7.0 的 SDS 的部分源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。<strong>Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用</strong>：</p><table><thead><tr><th>类型</th><th>字节</th><th>位</th></tr></thead><tbody><tr><td>sdshdr5</td><td>&lt; 1</td><td>&lt;8</td></tr><tr><td>sdshdr8</td><td>1</td><td>8</td></tr><tr><td>sdshdr16</td><td>2</td><td>16</td></tr><tr><td>sdshdr32</td><td>4</td><td>32</td></tr><tr><td>sdshdr64</td><td>8</td><td>64</td></tr></tbody></table></li><li><p>对于后四种实现都包含了下面这 4 个属性：</p><ol><li><code>len</code> ：字符串的长度也就是已经使用的字节数</li><li><code>alloc</code>：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小</li><li><code>buf[]</code> ：实际存储字符串的数组</li><li><code>flags</code> ：低三位保存类型标志</li></ol></li><li><p>SDS 相比于 C 语言中的字符串有如下提升：</p><ol><li><strong>可以避免缓冲区溢出</strong> ：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li><li><strong>获取字符串长度的复杂度较低</strong> ： C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li><li><strong>减少内存分配次数</strong> ： 为了避免修改（增加&#x2F;减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li><li><strong>二进制安全</strong> ：C 语言中的字符串以空字符 <code>\0</code> 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</li></ol></li><li><p>多提一嘴，很多文章里 SDS 的定义是下面这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，<code>len</code> 和 <code>free</code> 的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。</p></li></ul><h2 id="购物车信息用String还是Hash存储更好呢？"><a href="#购物车信息用String还是Hash存储更好呢？" class="headerlink" title="购物车信息用String还是Hash存储更好呢？"></a>购物车信息用String还是Hash存储更好呢？</h2><ul><li><p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p><ul><li><p>用户 id 为 key</p></li><li><p>商品 id 为 field，商品数量为 value</p></li></ul><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223155104792.png" alt="image-20230223155104792"></p></li><li><p>那用户购物车信息的维护具体应该怎么操作呢？</p><ul><li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li><li>查询购物车信息就是遍历对应的 Hash；</li><li>更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li><li>删除商品就是删除 Hash 中对应的 field；</li><li>清空购物车直接删除对应的 key 即可。</li></ul></li><li><p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。</p></li></ul><h2 id="使用Redis实现一个排行榜怎么做？"><a href="#使用Redis实现一个排行榜怎么做？" class="headerlink" title="使用Redis实现一个排行榜怎么做？"></a>使用Redis实现一个排行榜怎么做？</h2><ul><li>Redis 中有一个叫做 <strong><code>sorted set</code> 的数据结构经常被用在各种排行榜的场景</strong>，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li><li>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li></ul><h2 id="使用Set实现抽奖系统需要用到什么命令？"><a href="#使用Set实现抽奖系统需要用到什么命令？" class="headerlink" title="使用Set实现抽奖系统需要用到什么命令？"></a>使用Set实现抽奖系统需要用到什么命令？</h2><ul><li><code>SPOP key count</code> ： 随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li><li><code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li></ul><h2 id="使用Bitmap统计活跃用户怎么做？"><a href="#使用Bitmap统计活跃用户怎么做？" class="headerlink" title="使用Bitmap统计活跃用户怎么做？"></a>使用Bitmap统计活跃用户怎么做？</h2><ul><li><p>使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</p></li><li><p>初始化数据：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SETBIT 20210308 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">SETBIT 20210308 2 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">SETBIT 20210309 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure></li><li><p>统计 20210308~20210309 总活跃用户数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITOP and desk1 20210308 20210309</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; BITCOUNT desk1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure></li><li><p>统计 20210308~20210309 在线活跃用户数:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; BITOP or desk2 20210308 20210309</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">&gt; BITCOUNT desk2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用HyperLogLog统计页面UV怎么做？"><a href="#使用HyperLogLog统计页面UV怎么做？" class="headerlink" title="使用HyperLogLog统计页面UV怎么做？"></a>使用HyperLogLog统计页面UV怎么做？</h2><ol><li><p>将访问指定页面的每个用户ID添加到HyperLogLog中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFADD PAGE_1:UV USER1 USER2 ...... USERn</span><br></pre></td></tr></table></figure></li><li><p>统计指定页面的UV。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PFCOUNT PAGE_1:UV</span><br></pre></td></tr></table></figure></li></ol><p>—————————————————————————–Redis线程模型——————————————————————————-</p><h2 id="Redis单线程模型了解吗？"><a href="#Redis单线程模型了解吗？" class="headerlink" title="Redis单线程模型了解吗？"></a>Redis单线程模型了解吗？</h2><ul><li><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于<strong>文件事件处理器（file event handler）是单线程方式运行的</strong>，所以我们一般都说 Redis 是单线程模型。</li></ul><blockquote><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。</p><ul><li>文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I&#x2F;O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p></blockquote><ul><li><p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p></li><li><p>这样的好处非常明显： <strong>I&#x2F;O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p></li><li><p>文件事件处理器（file event handler）主要是包含 4 个部分：</p><ol><li>多个 socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ol><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223160742563.png" alt="image-20230223160742563"></p></li></ul><h2 id="Redis6-0之前为什么不使用多线程？"><a href="#Redis6-0之前为什么不使用多线程？" class="headerlink" title="Redis6.0之前为什么不使用多线程？"></a>Redis6.0之前为什么不使用多线程？</h2><ul><li>虽然说 Redis 是单线程模型，但是，实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></li><li>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。</li><li>为此，Redis 4.0 之后新增了<code>UNLINK</code>（可以看作是 <code>DEL</code> 的异步版本）、<code>FLUSHALL ASYNC</code>（清空所有数据库的所有 key，不仅仅是当前 <code>SELECT</code> 的数据库）、<code>FLUSHDB ASYNC</code>（清空当前 <code>SELECT</code> 数据库中的所有 key）等异步命令。大体上来说，Redis 6.0 之前主要还是单线程处理。</li><li><strong>那 Redis6.0 之前为什么不使用多线程？</strong> 我觉得主要原因有 3 点：<ol><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ol></li></ul><h2 id="Redis6-0之后为什么引入了多线程"><a href="#Redis6-0之后为什么引入了多线程" class="headerlink" title="Redis6.0之后为什么引入了多线程"></a>Redis6.0之后为什么引入了多线程</h2><ul><li><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p></li><li><p>虽然，Redis6.0 引入了多线程，但是 <strong>Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行</strong>。因此，你也不需要担心线程安全问题。</p></li><li><p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置IO线程数 &gt; 1，需要修改 redis 配置文件 <code>redis.conf</code> ：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads 4 <span class="comment">#设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span></span><br></pre></td></tr></table></figure></li><li><p>另外：</p><ul><li>io-threads的个数一旦设置，不能通过config动态设置</li><li>当设置ssl后，io-threads将不工作</li></ul></li><li><p>开启多线程后，默认只会使用多线程进行IO写入writes，即发送数据给客户端，如果需要开启多线程IO读取reads，同样需要修改 redis 配置文件 <code>redis.conf</code> :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io-threads-do-reads <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></li><li><p>但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启</p></li></ul><p>—————————————————————————–Redis内存管理——————————————————————————-</p><h2 id="Redis给缓存数据设置过期时间有什么用？"><a href="#Redis给缓存数据设置过期时间有什么用？" class="headerlink" title="Redis给缓存数据设置过期时间有什么用？"></a>Redis给缓存数据设置过期时间有什么用？</h2><ul><li><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p></li><li><p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; expire key 60 <span class="comment"># 数据在 60s 后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; setex key 60 value <span class="comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key <span class="comment"># 查看数据还有多久过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 56</span><br></pre></td></tr></table></figure></li><li><p>注意：<strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p></li><li><p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong>很多时候，我们的<strong>业务场景就是需要某个数据只在某一时间段内存在</strong>，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p></li></ul><h2 id="Redis是如何判断数据是否过期的呢？"><a href="#Redis是如何判断数据是否过期的呢？" class="headerlink" title="Redis是如何判断数据是否过期的呢？"></a>Redis是如何判断数据是否过期的呢？</h2><ul><li><p>Redis 通过一个叫做<strong>过期字典（可以看作是 hash 表）来保存数据过期的时间</strong>。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223164436724.png" alt="image-20230223164436724"></p></li><li><p>过期字典是存储在 redisDb 这个结构里的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    dict *dict;     <span class="comment">//数据库键空间,保存着数据库中所有键值对</span></span><br><span class="line">    dict *expires   <span class="comment">// 过期字典,保存着键的过期时间</span></span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure></li></ul><h2 id="过期的数据的删除策略了解吗？"><a href="#过期的数据的删除策略了解吗？" class="headerlink" title="过期的数据的删除策略了解吗？"></a>过期的数据的删除策略了解吗？</h2><ul><li>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</li><li>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：<ol><li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol></li><li>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 。</li><li>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</li><li>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></li></ul><h2 id="Redis内存淘汰机制了解吗？"><a href="#Redis内存淘汰机制了解吗？" class="headerlink" title="Redis内存淘汰机制了解吗？"></a>Redis内存淘汰机制了解吗？</h2><ul><li>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</li><li>Redis 提供 6 种数据淘汰策略：<ol><li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol></li><li>4.0 版本后增加以下两种：<ol start="7"><li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li><li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ol></li></ul><p>—————————————————————————–Redis持久化机制——————————————————————————-</p><h2 id="怎么保证Redis挂掉之后再重启数据可以进行恢复？"><a href="#怎么保证Redis挂掉之后再重启数据可以进行恢复？" class="headerlink" title="怎么保证Redis挂掉之后再重启数据可以进行恢复？"></a>怎么保证Redis挂掉之后再重启数据可以进行恢复？</h2><ul><li>很多时候我们需要<strong>持久化数据也就是将内存中的数据写入到硬盘里面</strong>，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</li><li>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</li></ul><h2 id="什么是RDB持久化？"><a href="#什么是RDB持久化？" class="headerlink" title="什么是RDB持久化？"></a>什么是RDB持久化？</h2><ul><li><p>Redis 可以<strong>通过创建快照来获得存储在内存里面的数据在某个时间点上的副本</strong>。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p></li><li><p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1           <span class="comment">#在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。</span></span><br><span class="line"></span><br><span class="line">save 300 10          <span class="comment">#在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。</span></span><br><span class="line"></span><br><span class="line">save 60 10000        <span class="comment">#在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="RDB创建快照时会阻塞主线程吗？"><a href="#RDB创建快照时会阻塞主线程吗？" class="headerlink" title="RDB创建快照时会阻塞主线程吗？"></a>RDB创建快照时会阻塞主线程吗？</h2><ul><li><p><strong>默认是子线程执行创建快照的动作，不会阻塞主线程</strong>。</p></li><li><p>Redis 提供了两个命令来生成 RDB 快照文件：</p><ul><li><code>save</code> : 主线程执行，会阻塞主线程；</li><li><code>bgsave</code> : 子线程执行，不会阻塞主线程，默认选项。</li></ul></li></ul><h2 id="什么是AOF持久化？"><a href="#什么是AOF持久化？" class="headerlink" title="什么是AOF持久化？"></a>什么是AOF持久化？</h2><ul><li><p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。<strong>默认情况下 Redis 没有开启 AOF（append only file）方式的持久化</strong>，可以通过 appendonly 参数开启：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly <span class="built_in">yes</span></span><br></pre></td></tr></table></figure></li><li><p><strong>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件</strong>。</p></li><li><p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p></li><li><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    <span class="comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span></span><br><span class="line">appendfsync everysec  <span class="comment">#每秒钟同步一次，显式地将多个写命令同步到硬盘</span></span><br><span class="line">appendfsync no        <span class="comment">#让操作系统决定何时进行同步</span></span><br></pre></td></tr></table></figure></li><li><p><strong>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响</strong>。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p></li></ul><h2 id="AOF日志是如何实现的？"><a href="#AOF日志是如何实现的？" class="headerlink" title="AOF日志是如何实现的？"></a>AOF日志是如何实现的？</h2><ul><li><p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223170909801.png" alt="image-20230223170909801"></p></li><li><p><strong>为什么是在执行完命令之后记录日志呢？</strong></p><ol><li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li><li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li></ol></li><li><p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p><ol><li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li><li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li></ol></li></ul><h2 id="AOF重写了解吗？"><a href="#AOF重写了解吗？" class="headerlink" title="AOF重写了解吗？"></a>AOF重写了解吗？</h2><ul><li>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，<strong>新旧两个文件所保存的数据库状态是相同的，但是新的AOF文件不会包含任何浪费空间的冗余命令，通常体积会较旧AOF文件小很多</strong>。</li><li>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</li><li>在执行 <code>BGREWRITEAOF</code> 命令时，<strong>Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作</strong>。</li><li>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，<strong>重写期间到达的所有写入命令都会写入磁盘两次</strong>。</li></ul><h2 id="如何选择RDB和AOF？"><a href="#如何选择RDB和AOF？" class="headerlink" title="如何选择RDB和AOF？"></a>如何选择RDB和AOF？</h2><ul><li>建议两者都开，不建议只开AOF。如果对数据不敏感可以只开RDB。如果只是做缓存，可以都不开。</li></ul><h3 id="RDB比AOF优秀的地方"><a href="#RDB比AOF优秀的地方" class="headerlink" title="RDB比AOF优秀的地方"></a>RDB比AOF优秀的地方</h3><ol><li><strong>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会必 RDB 文件大很多</strong>。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li><li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，<strong>与 AOF 相比，恢复大数据集的时候，RDB 速度更快</strong>。</li></ol><h3 id="AOF比RDB优秀的地方"><a href="#AOF比RDB优秀的地方" class="headerlink" title="AOF比RDB优秀的地方"></a>AOF比RDB优秀的地方</h3><ol><li><strong>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据</strong>。生成 RDB 文件的过程是比繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li><li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以<strong>存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题</strong>。</li><li><strong>AOF 以一种易于理解和解析的格式包含所有操作的日志，也就是可读性强</strong>。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li></ol><h2 id="Redis-4-0-对于持久化机制做了什么优化？"><a href="#Redis-4-0-对于持久化机制做了什么优化？" class="headerlink" title="Redis 4.0 对于持久化机制做了什么优化？"></a>Redis 4.0 对于持久化机制做了什么优化？</h2><ul><li>由于 RDB 和 AOF 各有优势，于是，<strong>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）</strong>。</li><li><strong>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据</strong>。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，<strong>可读性较差</strong>。</li></ul><p>—————————————————————————–Redis事务———————————————————————————–</p><h2 id="如何使用Redis事务？"><a href="#如何使用Redis事务？" class="headerlink" title="如何使用Redis事务？"></a>如何使用Redis事务？</h2><ul><li><p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET PROJECT</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">&quot;JavaGuide&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>MULTI</code>命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了<code>EXEC</code>命令后，再执行所有的命令</strong>。</p></li><li><p>这个过程是这样的：</p><ol><li>开始事务（<code>MULTI</code>）；</li><li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；</li><li>执行事务(<code>EXEC</code>)。</li></ol></li><li><p>你也可以<strong>通过<code>DISCARD</code>命令取消一个事务，它会清空事务队列中保存的所有命令</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET PROJECT</span><br><span class="line">QUEUED</span><br><span class="line">&gt; DISCARD</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></li><li><p>你可以<strong>通过 <code>WATCH</code> 命令监听指定的 Key，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的 Key 被 其他客户端&#x2F;Session 修改的话，整个事务都不会被执行</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端 1</span></span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;RustGuide&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; WATCH PROJECT</span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端 2</span></span><br><span class="line"><span class="comment"># 在客户端 1 执行 EXEC 命令提交事务之前修改 PROJECT 的值</span></span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;GoGuide&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端 1</span></span><br><span class="line"><span class="comment"># 修改失败，因为 PROJECT 的值被客户端2修改了</span></span><br><span class="line">&gt; EXEC</span><br><span class="line">(nil)</span><br><span class="line">&gt; GET PROJECT</span><br><span class="line"><span class="string">&quot;GoGuide&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>不过，<strong>如果 WATCH与事务在同一个 Session 里，并且被WATCH监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的</strong>。</p></li><li><p>事务内部修改 WATCH 监视的 Key：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; WATCH PROJECT</span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide1&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide2&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide3&quot;</span></span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">127.0.0.1:6379&gt; GET PROJECT</span><br><span class="line"><span class="string">&quot;JavaGuide3&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>事务外部修改 WATCH 监视的Key：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; WATCH PROJECT</span><br><span class="line">OK</span><br><span class="line">&gt; SET PROJECT <span class="string">&quot;JavaGuide2&quot;</span></span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; GET USER</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Redis支持原子性吗？"><a href="#Redis支持原子性吗？" class="headerlink" title="Redis支持原子性吗？"></a>Redis支持原子性吗？</h2><ul><li>Redis 的事务和我们平时理解的关系型数据库的事务不同。</li><li><strong>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行</strong>。并且，<strong>Redis 是不支持回滚（roll back）操作</strong>的。因此，<strong>Redis 事务其实是不满足原子性的（而且不满足持久性）</strong>。</li><li>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得<strong>没必要支持回滚，这样更简单便捷并且性能更好</strong>。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</li><li>你可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></li><li><strong>除了不满足原子性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为（使用lua脚本优化）</strong>。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。因此，<strong>Redis 事务是不建议在日常开发中使用的</strong>。</li></ul><h2 id="如何解决Redis事务的缺陷？"><a href="#如何解决Redis事务的缺陷？" class="headerlink" title="如何解决Redis事务的缺陷？"></a>如何解决Redis事务的缺陷？</h2><ul><li>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们<strong>可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销</strong>。</li><li>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</li><li><strong>如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的</strong>。因此，<strong>严格来说，通过 Lua 脚本来批量执行 Redis 命令也是不满足原子性的</strong>。</li><li>另外，Redis 7.0 新增了Redis functions特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。</li><li>总之<strong>Lua脚本解决的是redis事务中的命令无法送至redis服务端批量执行的问题，并没有完全解决redis事务不具备原子性的特点</strong>。</li></ul><p>—————————————————————————–Redis性能优化———————————————————————————–</p><h2 id="什么是bigkey？"><a href="#什么是bigkey？" class="headerlink" title="什么是bigkey？"></a>什么是bigkey？</h2><ul><li>简单来说，<strong>如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey</strong>。具体多大才算大呢？有一个不是特别精确的参考标准：<strong>string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）</strong>。</li></ul><h2 id="bigkey有什么危害？"><a href="#bigkey有什么危害？" class="headerlink" title="bigkey有什么危害？"></a>bigkey有什么危害？</h2><ul><li>除了会消耗更多的内存空间，bigkey 对性能也会有比较大的影响。</li><li>因此，我们应该尽量避免写入 bigkey！</li></ul><h2 id="如何发现bigkey？"><a href="#如何发现bigkey？" class="headerlink" title="如何发现bigkey？"></a>如何发现bigkey？</h2><ol><li><p><strong>使用 Redis 自带的 <code>--bigkeys</code> 参数来查找</strong>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-cli -p 6379 --bigkeys</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Scanning the entire keyspace to find biggest keys as well as</span></span><br><span class="line"><span class="comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span></span><br><span class="line"><span class="comment"># per 100 SCAN commands (not usually needed).</span></span><br><span class="line"></span><br><span class="line">[00.00%] Biggest string found so far <span class="string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> with 4437 bytes</span><br><span class="line">[00.00%] Biggest list   found so far <span class="string">&#x27;&quot;my-list&quot;&#x27;</span> with 17 items</span><br><span class="line"></span><br><span class="line">-------- summary -------</span><br><span class="line"></span><br><span class="line">Sampled 5 keys <span class="keyword">in</span> the keyspace!</span><br><span class="line">Total key length <span class="keyword">in</span> bytes is 264 (avg len 52.80)</span><br><span class="line"></span><br><span class="line">Biggest   list found <span class="string">&#x27;&quot;my-list&quot;&#x27;</span> has 17 items</span><br><span class="line">Biggest string found <span class="string">&#x27;&quot;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&quot;&#x27;</span> has 4437 bytes</span><br><span class="line"></span><br><span class="line">1 lists with 17 items (20.00% of keys, avg size 17.00)</span><br><span class="line">0 hashs with 0 fields (00.00% of keys, avg size 0.00)</span><br><span class="line">4 strings with 4831 bytes (80.00% of keys, avg size 1207.75)</span><br><span class="line">0 streams with 0 entries (00.00% of keys, avg size 0.00)</span><br><span class="line">0 sets with 0 members (00.00% of keys, avg size 0.00)</span><br><span class="line">0 zsets with 0 members (00.00% of keys, avg size 0.00</span><br></pre></td></tr></table></figure><p>从这个命令的运行结果，我们可以看出：<strong>这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响</strong>。并且，这种方式<strong>只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）</strong>。</p></li><li><p><strong>通过软件分析RDB文件</strong>来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p></li></ol><h2 id="大量key集中过期的问题"><a href="#大量key集中过期的问题" class="headerlink" title="大量key集中过期的问题"></a>大量key集中过期的问题</h2><ul><li>我在上面提到过：对于过期 key，Redis 采用的是 <strong>定期删除+惰性&#x2F;懒汉式删除</strong> 策略。</li><li><strong>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成</strong>，因为这个这个<strong>定期任务线程是在 Redis 主线程中执行的</strong>。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</li><li>如何解决呢？下面是两种常见的方法：<ol><li>给 key <strong>设置随机过期时间</strong>。</li><li>开启 <strong>lazy-free（惰性删除&#x2F;延迟释放） <strong>。lazy-free 特性是 Redis 4.0 开始引入的，指的是</strong>让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程</strong>。</li></ol></li><li>建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</li></ul><p>—————————————————————————–Redis生产问题———————————————————————————–</p><h2 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h2><ul><li><p>缓存穿透说简单点就是<strong>大量请求的 key 是不合理的，根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223190624286.png" alt="image-20230223190624286"></p></li><li><p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p></li></ul><h2 id="如何解决缓存穿透问题？"><a href="#如何解决缓存穿透问题？" class="headerlink" title="如何解决缓存穿透问题？"></a>如何解决缓存穿透问题？</h2><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><h3 id="缓存无效key"><a href="#缓存无效key" class="headerlink" title="缓存无效key"></a>缓存无效key</h3><ul><li><p><strong>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间</strong>，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，<strong>如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key</strong>。很明显，<strong>这种方案并不能从根本上解决此问题</strong>。如果非要用这种方式来解决穿透问题的话，<strong>尽量将无效的 key 的过期时间设置短一点比如 1 分钟</strong>。</p></li><li><p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p></li><li><p>如果用 Java 代码展示的话，差不多是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObjectInclNullById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">cacheValue</span> <span class="operator">=</span> cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">storageValue</span> <span class="operator">=</span> storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用布隆过滤器"><a href="#使用布隆过滤器" class="headerlink" title="使用布隆过滤器"></a>使用布隆过滤器</h3><ul><li><p>布隆过滤器是一个非常神奇的数据结构，通过它我们<strong>可以非常方便地判断一个给定数据是否存在于海量数据中</strong>。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p></li><li><p>具体是这样做的：<strong>把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程</strong>。</p></li><li><p>加入布隆过滤器之后的缓存处理流程图如下：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223191446498.png" alt="image-20230223191446498"></p></li><li><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判（哈希碰撞）。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p></li><li><p>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</p></li><li><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（<strong>一般会有多个哈希函数，有几个哈希函数得到几个哈希值</strong>）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol></li><li><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol></li><li><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p></li></ul><h2 id="什么是缓存击穿？"><a href="#什么是缓存击穿？" class="headerlink" title="什么是缓存击穿？"></a>什么是缓存击穿？</h2><ul><li><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223192036582.png" alt="image-20230223192036582"></p></li><li><p>举个例子 ：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p></li></ul><h2 id="如何解决缓存击穿问题？"><a href="#如何解决缓存击穿问题？" class="headerlink" title="如何解决缓存击穿问题？"></a>如何解决缓存击穿问题？</h2><ol><li><p>设置热点数据<strong>永不过期或者过期时间比较长</strong>。</p></li><li><p>针对热点数据<strong>提前预热</strong>，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</p></li><li><p>请求数据库写数据到缓存之前，先<strong>获取互斥锁</strong>，保证只有一个请求会落到数据库上，减少数据库的压力。</p></li><li><p>实例，用分布式锁和双重检查解决缓存击穿：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable(key = &quot;#id&quot;)</span><span class="comment">//key中追加一个id，防止出现歧义</span></span><br><span class="line"><span class="keyword">public</span> QvsSurvey <span class="title function_">getSurveyInfoById</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="comment">//加分布式锁防止缓存穿透</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">redisLock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;qvs-survey-getSurveyInfoById&quot;</span>);</span><br><span class="line">    redisLock.lock();<span class="comment">//不指定TTL的时候默认30s的TTL，10s之后如果锁还没放开，那么TTL会重新续满，这是看门狗机制</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;qvs-survey::&quot;</span> + id);<span class="comment">//先尝试从redis中获取数据</span></span><br><span class="line">    <span class="keyword">if</span>(!StringUtils.isEmpty(data))&#123;<span class="comment">//如果能获取到数据，说明数据在缓存中已经存在，如果存在直接返回，不存在再查数据库，保证只有一个线程查数据库，这是防止缓存击穿的关键</span></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> om.readValue(data,QvsSurvey.class);<span class="comment">//json反序列化</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;qvs-survey-getSurveyInfoById:&quot;</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">QvsSurvey</span> <span class="variable">qvsSurvey</span> <span class="operator">=</span> <span class="built_in">this</span>.baseMapper.getSurveyInfoById(id);</span><br><span class="line">    redisLock.unlock();<span class="comment">//解锁</span></span><br><span class="line">    <span class="keyword">return</span> qvsSurvey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="缓存穿透和缓存击穿有什么区别？"><a href="#缓存穿透和缓存击穿有什么区别？" class="headerlink" title="缓存穿透和缓存击穿有什么区别？"></a>缓存穿透和缓存击穿有什么区别？</h2><ol><li>缓存穿透中，请求的 key <strong>既不存在于缓存中，也不存在于数据库中</strong>。</li><li>缓存击穿中，请求的 key 对应的是<strong>热点数据</strong> ，该数据<strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</li></ol><h2 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h2><ul><li><p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上:</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223192507611.png" alt="image-20230223192507611"></p></li><li><p>举个例子 ：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p></li></ul><h2 id="如何解决缓存雪崩问题？"><a href="#如何解决缓存雪崩问题？" class="headerlink" title="如何解决缓存雪崩问题？"></a>如何解决缓存雪崩问题？</h2><h3 id="针对Redis服务不可用的情况"><a href="#针对Redis服务不可用的情况" class="headerlink" title="针对Redis服务不可用的情况"></a>针对Redis服务不可用的情况</h3><ol><li>采用 Redis <strong>集群</strong>，避免单机出现问题整个缓存服务都没办法使用。</li><li><strong>限流</strong>，避免同时处理大量的请求。</li></ol><h3 id="针对热点缓存失效的情况"><a href="#针对热点缓存失效的情况" class="headerlink" title="针对热点缓存失效的情况"></a>针对热点缓存失效的情况</h3><ol><li>设置不同的失效时间比如<strong>随机设置缓存的失效时间</strong>。</li><li>缓存永不失效（不太推荐，实用性太差）。</li><li>设置<strong>二级缓存</strong>。</li></ol><h2 id="缓存雪崩和缓存击穿有什么区别？"><a href="#缓存雪崩和缓存击穿有什么区别？" class="headerlink" title="缓存雪崩和缓存击穿有什么区别？"></a>缓存雪崩和缓存击穿有什么区别？</h2><ul><li>缓存雪崩和缓存击穿比较像，但<strong>缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong>。</li></ul><h2 id="如何保证缓存和数据库数据的一致性？"><a href="#如何保证缓存和数据库数据的一致性？" class="headerlink" title="如何保证缓存和数据库数据的一致性？"></a>如何保证缓存和数据库数据的一致性？</h2><ul><li>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</li><li>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache （还有另外一种方案好像是更新db后再更新cache）。</li><li>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：<ol><li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加 cache 更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li></ol></li></ul><p>—————————————————————————Redis集群———————————————————————————–</p><h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>主机数据更新后根据配置和策略， 自动同步到备机的<strong>master&#x2F;slaver机制</strong>，<strong>Master以写为主，Slave以读为主</strong>。</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>读写分离，性能扩展</strong></li><li><strong>容灾快速恢复</strong></li></ul><h3 id="如何配置"><a href="#如何配置" class="headerlink" title="如何配置"></a>如何配置</h3><ul><li>默认所有redis实例都是主机，可以使用<code>slaveof &lt;ip&gt; &lt;port&gt;</code>命令来指定该主机为从机并指定好其归属的主机，从机下面也能配置从机，使用命令设置的话重启后会失效，可以配置在配置文件中永久生效。</li><li>使用<code>slaveof no one</code>将从机变为主机。</li><li>配置好后，主机上可以写数据，从机上只能读数据，如果在从机上写数据会报错。</li><li>主机挂了之后重启即可；从机挂了之后如果没有在配置文件中配置其主从关系，那么就需要重新使用命令来建立从属关系。</li></ul><h3 id="复制延时问题"><a href="#复制延时问题" class="headerlink" title="复制延时问题"></a>复制延时问题</h3><ul><li>由于<strong>所有的写操作都是先在Master上操作，然后同步更新到Slave上</strong>，所以<strong>从Master同步到Slave机器有一定的延迟</strong>，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li><p><strong>Slave启动成功连接到master后会发送一个sync命令</strong>。</p></li><li><p>Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，<strong>master将传送整个数据文件到slave,以完成一次完全同步</strong>。</p></li><li><p><strong>全量复制</strong>：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。</p></li><li><p><strong>增量复制</strong>：Master继续将新的所有收集到的修改命令依次传给slave,完成同步。</p></li><li><p>但是<strong>只要是重新连接master,一次完全同步（全量复制)将被自动执行</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101757180.png" alt="image-20221015101757180"></p></li></ul><h2 id="常用的三种主从结构"><a href="#常用的三种主从结构" class="headerlink" title="常用的三种主从结构"></a>常用的三种主从结构</h2><h3 id="一主二仆"><a href="#一主二仆" class="headerlink" title="一主二仆"></a>一主二仆</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015100717323.png" alt="image-20221015100717323"></p><h3 id="薪火相传"><a href="#薪火相传" class="headerlink" title="薪火相传"></a>薪火相传</h3><ul><li><p>上一个Slave可以是下一个slave的Master，<strong>Slave同样可以接收其他slaves的连接和同步请求</strong>，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。</p></li><li><p>用 slaveof  &lt;ip&gt; &lt;port&gt;进行配置</p><p>中途变更转向:会清除之前的数据，重新建立拷贝最新的</p><p>风险是一旦某个slave宕机，后面的slave都没法备份</p><p>主机挂了，从机还是从机，无法写数据了</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101147373.png" alt="image-20221015101147373"></p></li></ul><h3 id="反客为主"><a href="#反客为主" class="headerlink" title="反客为主"></a>反客为主</h3><ul><li><strong>当一个master宕机后，后面的slave可以立刻升为master</strong>，其后面的slave不用做任何修改。</li><li>用<strong>slaveof no one</strong>将从机变为主机。</li></ul><h2 id="哨兵模式（sentinel）"><a href="#哨兵模式（sentinel）" class="headerlink" title="哨兵模式（sentinel）"></a>哨兵模式（sentinel）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul><li><p>这是<strong>反客为主的自动版</strong>，哨兵能够<strong>后台监控主机是否故障</strong>，如果故障了<strong>根据投票数自动将从库转换为主库</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015101935319.png" alt="image-20221015101935319"></p></li></ul><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><ul><li>这个需要额外配置一个哨兵，先<strong>在配置文件目录下新建sentinel.conf文件</strong>。</li><li>然后在sentinel.conf中填写内容：<strong>sentinel monitor mymaster 127.0.0.1 6379 1</strong>，其中<strong>mymaster为监控对象起的服务器名称</strong>， <strong>1为至少有多少个哨兵同意迁移的数量</strong>。</li><li>最后在redis的安装目录下执行<strong>redis-sentinel  &#x2F;myredis&#x2F;sentinel.conf</strong>来启动哨兵</li></ul><h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><ul><li><p>优先级在redis.conf中默认：slave-priority 100，<strong>值越小优先级越高</strong></p></li><li><p><strong>偏移量是指获得原主机数据最全的</strong></p></li><li><p>每个redis实例启动后都会<strong>随机生成一个40位的runid</strong></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221015103154028.png" alt="image-20221015103154028"></p></li></ul><h2 id="什么是redis集群？"><a href="#什么是redis集群？" class="headerlink" title="什么是redis集群？"></a>什么是redis集群？</h2><ul><li>Redis 集群实现了对Redis的水平扩容，即启动N个redis节点，<strong>将整个数据库分布存储在这N个节点中，每个节点存储总数据的1&#x2F;N</strong>。</li><li>Redis 集群<strong>通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求</strong>。</li><li>上面的主从结构可以是集群的一部分。</li></ul><h2 id="redis集群如何分配节点？"><a href="#redis集群如何分配节点？" class="headerlink" title="redis集群如何分配节点？"></a>redis集群如何分配节点？</h2><ul><li><strong>一个集群至少要有三个主节点</strong>。</li><li>选项 <strong>–cluster-replicas 1 表示我们希望为集群中的每个主节点创建一个从节点</strong>。</li><li>分配原则<strong>尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上</strong>。</li></ul><h2 id="什么是Slots？"><a href="#什么是Slots？" class="headerlink" title="什么是Slots？"></a>什么是Slots？</h2><ul><li><p>就是用来分布式存储数据的结构。</p></li><li><p>一个 Redis 集群包含 16384 个插槽（hash slot）， <strong>数据库中的每个键都属于这 16384 个插槽的其中一个</strong>，<strong>一个插槽中可以有多个键，但一个键只对应一个插槽</strong>。</p></li><li><p><strong>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽</strong>， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p></li><li><p><strong>集群中的每个节点负责处理一部分插槽</strong>。 举个例子， 如果一个集群可以有主节点， 其中：</p><p>节点 A 负责处理 0 号至 5460 号插槽。</p><p>节点 B 负责处理 5461 号至 10922 号插槽。</p><p>节点 C 负责处理 10923 号至 16383 号插槽。</p></li></ul><h2 id="redis集群的故障恢复"><a href="#redis集群的故障恢复" class="headerlink" title="redis集群的故障恢复"></a>redis集群的故障恢复</h2><ul><li><p>如果主节点下线？从节点能否自动升为主节点？答：能，注意：<strong>15秒超时</strong></p></li><li><p>主节点恢复后，主从关系会如何？答：主节点回来会变成从机。</p></li><li><p>如果所有某一段插槽的主从节点都宕掉，redis服务是否还能继续?</p><p><strong>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为yes ，那么 ，整个集群都挂掉。</strong></p><p><strong>如果某一段插槽的主从都挂掉，而cluster-require-full-coverage 为no ，那么，该插槽数据全都不能使用，也无法存储。</strong></p><p>redis.conf中的参数  cluster-require-full-coverage</p></li></ul><h2 id="redis集群的好处？"><a href="#redis集群的好处？" class="headerlink" title="redis集群的好处？"></a>redis集群的好处？</h2><ul><li><strong>实现扩容</strong></li><li><strong>分摊压力</strong></li><li><strong>无中心配置相对简单</strong></li></ul><h2 id="redis集群的不足？"><a href="#redis集群的不足？" class="headerlink" title="redis集群的不足？"></a>redis集群的不足？</h2><ul><li><strong>多键操作是不被支持的</strong>，因为多个键所在的slot可能不同。</li><li><strong>多键的Redis事务是不被支持的，lua脚本不被支持</strong>。</li><li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而<strong>代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大</strong>。</li></ul><p>————————————————————–Redis三种常用的缓存读写策略———————————————————————-</p><h2 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h2><ul><li><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></li><li>Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。</li><li>下面我们来看一下这个策略模式下的缓存读写步骤。</li></ul><h3 id="写"><a href="#写" class="headerlink" title="写"></a>写</h3><ul><li><p>先更新db，然后直接删除cache：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223205824427.png" alt="image-20230223205824427"></p></li></ul><h3 id="读"><a href="#读" class="headerlink" title="读"></a>读</h3><ul><li><p>从 cache 中读取数据，读取到就直接返回；cache 中读取不到的话，就从 db 中读取数据返回。最后再把数据放到 cache 中：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223205919248.png" alt="image-20230223205919248"></p></li></ul><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><p>比如说面试官很可能会追问：“<strong>在写数据的过程中，可以先删除 cache ，后更新 db 么？</strong>”</p><p><strong>答案：</strong> 那肯定是不行的！因为这样可能会造成 <strong>数据库（db）和缓存（Cache）数据不一致</strong>的问题。</p><p>举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。这个过程可以简单描述为：请求 1 先把 cache 中的 A 数据删除 -&gt; 请求 2 从 db 中读取数据-&gt;请求 1 再把 db 中的 A 数据更新</p></li><li><p>当你这样回答上面的问题之后，面试官可能会紧接着就追问：“<strong>在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？</strong>”</p><p><strong>答案：</strong> 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。</p><p>举例：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。这个过程可以简单描述为：请求 1 从 db 读数据 A-&gt; 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） -&gt; 请求 1 将数据 A 写入 cache</p></li></ul><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ol><li><strong>首次请求数据一定不在 cache 的问题</strong>。解决办法：<ul><li>可以将热点数据可以提前放入 cache 中。</li></ul></li><li><strong>写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率。</strong>解决办法：<ul><li>数据库和缓存数据强一致场景 ：更新 db 的时候同样更新 cache，不过我们需要加一个锁&#x2F;分布式锁来保证更新 cache 的时候不存在线程安全问题。</li><li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li></ul></li></ol><h2 id="Read-x2F-Write-Through-Pattern（读写穿透模式）"><a href="#Read-x2F-Write-Through-Pattern（读写穿透模式）" class="headerlink" title="Read&#x2F;Write Through Pattern（读写穿透模式）"></a>Read&#x2F;Write Through Pattern（读写穿透模式）</h2><ul><li>Read&#x2F;Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</li><li>这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入 db 的功能。</li></ul><h3 id="写（Write-Through）"><a href="#写（Write-Through）" class="headerlink" title="写（Write Through）"></a>写（Write Through）</h3><ul><li><p>先查 cache，cache 中不存在，直接更新 db；cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223211749415.png" alt="image-20230223211749415"></p></li></ul><h3 id="读（Read-Through）"><a href="#读（Read-Through）" class="headerlink" title="读（Read Through）"></a>读（Read Through）</h3><ul><li><p>从 cache 中读取数据，读取到就直接返回 ；读取不到的话，先从 db 加载，写入到 cache 后返回响应：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223211840069.png" alt="image-20230223211840069"></p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 <strong>Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache</strong>，而 <strong>Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的</strong>。</li><li>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不在 cache 的问题，对于热点数据可以提前放入缓存中。</li></ul><h2 id="Write-Behind-Pattern（异步缓存写入模式）"><a href="#Write-Behind-Pattern（异步缓存写入模式）" class="headerlink" title="Write Behind Pattern（异步缓存写入模式）"></a>Write Behind Pattern（异步缓存写入模式）</h2><ul><li>Write Behind Pattern 和 Read&#x2F;Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。</li><li>但是，两个又有很大的不同：<strong>Read&#x2F;Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</strong></li><li>很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。</li><li>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。</li><li>Write Behind Pattern 下 db 的写性能非常高，非常<strong>适合一些数据经常变化又对数据一致性要求没那么高的场景</strong>，比如浏览量、点赞量。</li></ul><p>————————————————————————Redis基本数据结构详解—————————————————————————</p><h2 id="Redis基本数据结构的底层数据结构是什么？"><a href="#Redis基本数据结构的底层数据结构是什么？" class="headerlink" title="Redis基本数据结构的底层数据结构是什么？"></a>Redis基本数据结构的底层数据结构是什么？</h2><ul><li><p>Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p></li><li><p>这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、HashTable（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。</p></li><li><p>Redis 基本数据结构的底层数据结构实现如下：</p><table><thead><tr><th>String</th><th>List</th><th>Hash</th><th>Set</th><th>Zset</th></tr></thead><tbody><tr><td>SDS（简单动态字符串）</td><td>LinkedList（双向链表）&#x2F;ZipList（压缩列表）&#x2F;QuickList（快速列表）</td><td>HashTable（哈希表）、ZipList（压缩列表）</td><td>ZipList（压缩列表）、Intset（整数集合）</td><td>ZipList（压缩列表）、SkipList（跳跃表）</td></tr></tbody></table></li><li><p>Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。</p></li></ul><h2 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>String 是 Redis 中最简单同时也是最常用的一个数据结构。</p></li><li><p>String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220142410.png" alt="image-20230223220142410"></p></li><li><p>虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（Simple Dynamic String，<strong>SDS</strong>）。相比于 C 的原生字符串，<strong>Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出</strong>。</p></li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220438634.png" alt="image-20230223220438634"></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>需要<strong>存储常规数据</strong>的场景：<ul><li>举例 ：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。</li><li>相关命令 ： <code>SET</code>、<code>GET</code>。</li></ul></li><li>需要<strong>计数</strong>的场景：<ul><li>举例 ：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li><li>相关命令 ：<code>SET</code>、<code>GET</code>、 <code>INCR</code>、<code>DECR</code> 。</li></ul></li><li><strong>分布式锁</strong>：<ul><li>利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁（存在一些缺陷，<strong>通常不建议这样实现分布式锁</strong>）。</li></ul></li></ul><h2 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>Redis 中的 List 其实就是链表数据结构的实现。</p></li><li><p>许多高级编程语言都内置了链表的实现比如 Java 中的 <code>LinkedList</code>，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 List 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220254844.png" alt="image-20230223220254844"></p></li></ul><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220502834.png" alt="image-20230223220502834"></p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>信息流展示</strong>：<ul><li>举例 ：最新文章、最新动态。</li><li>相关命令 ： <code>LPUSH</code>、<code>LRANGE</code>。</li></ul></li><li><strong>消息队列</strong>：<ul><li>Redis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。</li><li>相对来说，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</li></ul></li></ul><h2 id="Hash（哈希表）"><a href="#Hash（哈希表）" class="headerlink" title="Hash（哈希表）"></a>Hash（哈希表）</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</p></li><li><p>Hash 类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220743151.png" alt="image-20230223220743151"></p></li></ul><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223220809369.png" alt="image-20230223220809369"></p><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>对象数据存储场景</strong>：<ul><li>举例 ：用户信息、商品信息、文章信息、购物车信息。</li><li>相关命令 ：<code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）。</li></ul></li></ul><h2 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>Redis 中的 Set 类型是一种<strong>无序集合，集合中的元素没有先后顺序但都唯一</strong>，有点类似于 Java 中的 <code>HashSet</code> 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p></li><li><p>你可以基于 Set 轻易实现交集、并集、差集的操作，比如你<strong>可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223222643653.png" alt="image-20230223222643653"></p></li></ul><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223222716378.png" alt="image-20230223222716378"></p><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>需要存放的数据不能重复的场景</strong>：<ul><li>举例：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</li><li>相关命令：<code>SCARD</code>（获取集合数量） 。</li></ul></li><li><strong>需要获取多个数据源交集、并集和差集的场景</strong>：<ul><li>举例 ：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集） 、订阅号推荐（差集+交集） 等场景。</li><li>相关命令：<code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）。</li></ul></li><li><strong>需要随机获取数据源中的元素的场景</strong>：<ul><li>举例 ：抽奖系统、随机。</li><li>相关命令：<code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）。</li></ul></li><li><strong>可以用于解决接口幂等性的问题</strong>：<ul><li>给调用接口要执行的操作一个uuid存到redis的set中，然后如果这次没有调用完又来了一次调用，那么这次调用的时候就能通过set中的uuid来判断是否是同一个请求，如果是，就拒绝这次请求，这样就实现了接口的幂等性。</li></ul></li></ul><h2 id="Sorted-Set（有序集合）"><a href="#Sorted-Set（有序集合）" class="headerlink" title="Sorted Set（有序集合）"></a>Sorted Set（有序集合）</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>Sorted Set 类似于 Set，但和 Set 相比，<strong>Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表</strong>。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223223030914.png" alt="image-20230223223030914"></p></li></ul><h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223223054604.png" alt="image-20230223223054604"></p><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong>：<ul><li>举例 ：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li><li>相关命令 ：<code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li></ul></li><li><strong>需要存储的数据有优先级或者重要程度的场景</strong>：<ul><li>举例 ：优先级任务队列。</li><li>相关命令 ：<code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li></ul></li></ul><p>————————————————————————Redis特殊数据结构详解—————————————————————————</p><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, <strong>只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身</strong> 。我们知道 8 个 bit 可以组成一个 byte，所以 <strong>Bitmap 本身会极大的节省储存空间</strong>。</p></li><li><p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223223400243.png" alt="image-20230223223400243"></p></li></ul><h3 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223223428295.png" alt="image-20230223223428295"></p><h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>需要保存状态信息（0&#x2F;1 即可表示）的场景</strong>：<ul><li>举例 ：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li><li>相关命令 ：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>。</li></ul></li><li><strong>实现布隆过滤器</strong>：<ul><li>&#x2F;&#x2F;todo</li></ul></li></ul><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><ul><li>HyperLogLog 是一种有名的<strong>基数计数概率算法</strong> ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。</li><li>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素。这是真的厉害，这就是数学的魅力么！并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：<ul><li><strong>稀疏矩阵</strong> ：计数较少的时候，占用空间很小。</li><li><strong>稠密矩阵</strong> ：计数达到某个阈值的时候，占用 12k 的空间。</li></ul></li><li>基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code>0.81%</code> 。）。</li></ul><h3 id="常用命令-6"><a href="#常用命令-6" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223224557133.png" alt="image-20230223224557133"></p><h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>数量量巨大（百万、千万级别以上）的计数场景</strong>：<ul><li>举例 ：热门网站每日&#x2F;每周&#x2F;每月访问 ip 数统计、热门帖子 uv 统计、</li><li>相关命令 ：<code>PFADD</code>、<code>PFCOUNT</code> 。</li></ul></li></ul><h2 id="Geospatial-index"><a href="#Geospatial-index" class="headerlink" title="Geospatial index"></a>Geospatial index</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><ul><li><p>Geospatial index（地理空间索引，简称 GEO） 主要<strong>用于存储地理位置信息</strong>，<strong>基于 Sorted Set 实现</strong>，GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。通过 GEO 我们可以轻松<strong>实现两个位置距离的计算、获取指定位置附近的元素</strong>等功能。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223224817449.png" alt="image-20230223224817449"></p></li></ul><h3 id="常用命令-7"><a href="#常用命令-7" class="headerlink" title="常用命令"></a>常用命令</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230223224838093.png" alt="image-20230223224838093"></p><h3 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><strong>需要管理使用地理空间数据的场景</strong>：<ul><li>举例：附近的人。</li><li>相关命令: <code>GEOADD</code>、<code>GEORADIUS</code>、<code>GEORADIUSBYMEMBER</code> 。</li></ul></li></ul><p>————————————————————————Redis内存碎片详解—————————————————————————</p><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h2><ul><li>我们可以把消息队列看作是<strong>一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可</strong>。由于队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。</li><li>参与消息传递的双方称为生产者和消费者，<strong>生产者负责发送消息，消费者负责处理消息</strong>。</li><li>我们知道操作系统中的进程通信的一种很重要的方式就是消息队列。我们这里提到的消息队列稍微有点区别，更多指的是各个服务以及系统内部各个组件&#x2F;模块之前的通信，属于一种中间件。</li><li>随着分布式和微服务系统的发展，消息队列在系统设计中有了更大的发挥空间，<strong>使用消息队列可以降低系统耦合性、实现任务异步、有效地进行流量削峰</strong>，是分布式和微服务系统中重要的组件之一。</li></ul><h2 id="消息队列有什么用？"><a href="#消息队列有什么用？" class="headerlink" title="消息队列有什么用？"></a>消息队列有什么用？</h2><ul><li>通常来说，使用消息队列能为我们的系统带来下面三点好处：<ol><li><strong>通过异步处理提高系统性能（减少响应所需时间）。</strong></li><li><strong>削峰&#x2F;限流</strong></li><li><strong>降低系统耦合性。</strong></li></ol></li><li>如果在面试的时候你被面试官问到这个问题的话，一般情况是你在你的简历上涉及到消息队列这方面的内容，这个时候推荐你结合你自己的项目来回答。</li></ul><h3 id="通过异步处理提高系统性能（减少响应所需时间）"><a href="#通过异步处理提高系统性能（减少响应所需时间）" class="headerlink" title="通过异步处理提高系统性能（减少响应所需时间）"></a>通过异步处理提高系统性能（减少响应所需时间）</h3><ul><li><strong>将用户的请求数据存储到消息队列之后就立即返回结果。随后，系统再对消息进行消费</strong>。</li><li>因为用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败。因此，<strong>使用消息队列进行异步处理之后，需要适当修改业务流程进行配合</strong>，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</li></ul><h3 id="削峰-x2F-限流"><a href="#削峰-x2F-限流" class="headerlink" title="削峰&#x2F;限流"></a>削峰&#x2F;限流</h3><ul><li><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。</strong></li></ul><h3 id="降低系统耦合度"><a href="#降低系统耦合度" class="headerlink" title="降低系统耦合度"></a>降低系统耦合度</h3><ul><li>使用消息队列还可以<strong>降低系统耦合度</strong>。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。</li><li>生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。</li><li><strong>消息队列使用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</li><li>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</li><li>另外，为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</li><li><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了 5 种消息模型。</li></ul><h2 id="使用消息队列产生的问题？"><a href="#使用消息队列产生的问题？" class="headerlink" title="使用消息队列产生的问题？"></a>使用消息队列产生的问题？</h2><ul><li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li><li><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li></ul><h2 id="AMQP是什么？"><a href="#AMQP是什么？" class="headerlink" title="AMQP是什么？"></a>AMQP是什么？</h2><ul><li>AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制。</li><li><strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></li></ul><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="相关名词介绍"><a href="#相关名词介绍" class="headerlink" title="相关名词介绍"></a>相关名词介绍</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029093829448.png" alt="image-20221029093829448"></p><ul><li><strong>Broker（代理）</strong>：<strong>接收和分发消息的应用</strong>，RabbitMQ Server 就是 Message Broker。</li><li><strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP（协议）的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。<strong>当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</strong>。</li><li><strong>Connection</strong>：<strong>publisher／consumer 和 broker 之间的 TCP 连接</strong>。</li><li><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。<strong>Channel 是在 connection 内部建立的逻辑连接</strong>，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的Connection极大减少了操作系统建立TCP connection的开销</strong>。</li><li><strong>Exchange</strong>：message 到达 broker 的第一站，<strong>根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去</strong>。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</li><li><strong>Queue</strong>：<strong>消息最终被送到这里等待 consumer 取走</strong>。</li><li><strong>Binding</strong>：<strong>exchange 和 queue 之间的虚拟连接</strong>，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</li></ul><h2 id="RabbitMQ是什么？"><a href="#RabbitMQ是什么？" class="headerlink" title="RabbitMQ是什么？"></a>RabbitMQ是什么？</h2><ul><li>RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持多种客户端如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</li><li>RabbitMQ是使用Erlang编写的一个开源的消息队列，本身支持很多的协议：AMQP，XMPP, SMTP, STOMP，也正是如此，使的它变的非常重量级，更适合于企业级的开发。它同时实现了一个Broker构架，这意味着消息在发送给客户端时先在中心队列排队，对路由(Routing)、负载均衡(Load balance)或者数据持久化都有很好的支持。</li><li>PS:也可能直接问什么是消息队列？<strong>消息队列就是一个使用队列来通信的组件</strong>。</li></ul><h2 id="RabbitMQ的特点？"><a href="#RabbitMQ的特点？" class="headerlink" title="RabbitMQ的特点？"></a>RabbitMQ的特点？</h2><ul><li><strong>可靠性</strong>: RabbitMQ 使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。</li><li><strong>灵活的路由</strong> : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个 交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。</li><li><strong>扩展性</strong>: 多个 RabbitMQ 节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。</li><li><strong>高可用性</strong> : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。</li><li><strong>多种协议</strong>: RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP， MQTT 等多种消息 中间件协议。</li><li><strong>多语言客户端</strong> :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。</li><li><strong>管理界面</strong> : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。</li><li><strong>插件机制</strong> : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。</li></ul><h2 id="AMQP是什么？-1"><a href="#AMQP是什么？-1" class="headerlink" title="AMQP是什么？"></a>AMQP是什么？</h2><ul><li>AMQP的全称为：Advanced Message Queuing Protocol（高级消息队列协议）</li><li>RabbitMQ 就是 AMQP 协议的 <code>Erlang</code> 的实现(当然 RabbitMQ 还支持 <code>STOMP2</code>、 <code>MQTT3</code> 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定 。</li><li>RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相应的概念。目前 RabbitMQ 最新版本默认支持的是 AMQP 0-9-1。</li></ul><h3 id="AMQP协议的三层结构"><a href="#AMQP协议的三层结构" class="headerlink" title="AMQP协议的三层结构"></a>AMQP协议的三层结构</h3><ol><li><strong>Module Layer</strong>:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。</li><li><strong>Session Layer</strong>:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。</li><li><strong>TransportLayer</strong>:最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。</li></ol><h3 id="AMQP模型的三大组件"><a href="#AMQP模型的三大组件" class="headerlink" title="AMQP模型的三大组件"></a>AMQP模型的三大组件</h3><ol><li><strong>交换器 (Exchange)</strong> ：消息代理服务器中用于把消息路由到队列的组件。</li><li><strong>队列 (Queue)</strong> ：用来存储消息的数据结构，位于硬盘或内存中。</li><li><strong>绑定 (Binding)</strong> ：一套规则，告知交换器消息应该将消息投递给哪个队列。</li></ol><h2 id="说说生产者Producer和消费者Consumer？"><a href="#说说生产者Producer和消费者Consumer？" class="headerlink" title="说说生产者Producer和消费者Consumer？"></a>说说生产者Producer和消费者Consumer？</h2><ul><li><strong>生产者</strong> :<ul><li>消息生产者，就是投递消息的一方。</li><li>消息一般包含两个部分：消息体（<code>payload</code>)和标签(<code>Label</code>)。</li></ul></li><li><strong>消费者</strong> ：<ul><li>消费消息，也就是接收消息的一方。</li><li>消费者连接到 RabbitMQ 服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。</li></ul></li></ul><h2 id="说说-Broker-服务节点、Queue-队列、Exchange-交换器？"><a href="#说说-Broker-服务节点、Queue-队列、Exchange-交换器？" class="headerlink" title="说说 Broker 服务节点、Queue 队列、Exchange 交换器？"></a>说说 Broker 服务节点、Queue 队列、Exchange 交换器？</h2><ul><li><strong>Broker</strong> ：可以看做 RabbitMQ 的服务节点。一般请下一个 Broker 可以看做一个 RabbitMQ 服务器。</li><li><strong>Queue</strong> : RabbitMQ 的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时<strong>队列中的消息会被平摊（轮询）给多个消费者进行处理</strong>。</li><li><strong>Exchange</strong> : 生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。</li></ul><h2 id="什么是死信队列？"><a href="#什么是死信队列？" class="headerlink" title="什么是死信队列？"></a>什么是死信队列？</h2><ul><li><strong>DLX，全称为 <code>Dead-Letter-Exchange</code>，死信交换器</strong>，死信邮箱。当消息在一个队列中变成死信 (<code>dead message</code>) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，<strong>绑定 DLX 的队列就称之为死信队列</strong>。</li></ul><h2 id="死信是如何导致的？"><a href="#死信是如何导致的？" class="headerlink" title="死信是如何导致的？"></a>死信是如何导致的？</h2><ol><li>消息被拒（<code>Basic.Reject /Basic.Nack</code>) 且 <code>requeue = false</code>。</li><li>消息 TTL 过期。</li><li>队列满了，无法再添加。</li></ol><h2 id="什么是延迟队列？"><a href="#什么是延迟队列？" class="headerlink" title="什么是延迟队列？"></a>什么是延迟队列？</h2><ul><li>延迟队列指的是存储对应的延迟消息，消息被发送以后，并不想让消费者立刻拿到消息，而是<strong>等待特定时间后，消费者才能拿到这个消息进行消费</strong>。</li></ul><h2 id="RabbitMQ怎么实现延迟队列？"><a href="#RabbitMQ怎么实现延迟队列？" class="headerlink" title="RabbitMQ怎么实现延迟队列？"></a>RabbitMQ怎么实现延迟队列？</h2><ul><li>RabbitMQ本身是没有延迟队列的，要实现延迟消息，一般有两种方式：<ol><li>通过RabbitMQ本身队列的特性来实现，需要使用RabbitMQ的死信交换机（Exchange）和消息的存活时间TTL（Time To Live）。</li><li>在RabbitMQ 3.5.7及以上的版本提供了一个插件（rabbitmq-delayed-message-exchange）来实现延迟队列功能。同时，插件依赖Erlang&#x2F;OPT 18.0及以上。</li></ol></li><li>也就是说，AMQP 协议以及RabbitMQ本身没有直接支持延迟队列的功能，但是可以通过TTL和DLX模拟出延迟队列的功能。</li></ul><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ul><li><p>先来个架构图，需要<strong>手动给队列配置它的死信队列</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117110145349.png" alt="image-20221117110145349"></p></li><li><p>具体是怎么实现呢？首先我们可以<strong>给队列或者发的消息设置TTL，阻塞掉那个队列的所有消费者，这样消息就能在队列中自然过期，然后被送到死信交换机中，然后被路由到死信队列中，真正的消费者是消费死信队列中的消息，这样就达到了延时队列的效果</strong>。</p></li><li><p>关于消息和队列TTL的几个问题：首先就是如果一个消息设置了TTL，它所去的队列也设置了TTL，那么<strong>较小的那个值会被使用</strong>。然后就是如果<strong>设置了队列的TTL，那么一旦消息过期，消息会立刻被丢弃</strong>；如果<strong>只是设置了消息的TTL，那么即使消息过期也不一定会被马上丢弃，因为消息会等它被消费到的时候判断是否过期</strong>，过期就丢弃，不过期就消费。</p></li></ul><h2 id="什么是优先级队列？"><a href="#什么是优先级队列？" class="headerlink" title="什么是优先级队列？"></a>什么是优先级队列？</h2><ul><li>RabbitMQ 自 V3.5.0 有优先级队列实现，优先级高的队列会先被消费。</li><li>可以通过<code>x-max-priority</code>参数来实现优先级队列。不过，当消费速度大于生产速度且 Broker 没有堆积的情况下，优先级显得没有意义。</li></ul><h2 id="RabbitMQ有哪些工作模式？"><a href="#RabbitMQ有哪些工作模式？" class="headerlink" title="RabbitMQ有哪些工作模式？"></a>RabbitMQ有哪些工作模式？</h2><ul><li><p><strong>简单模式</strong>：一个生产者，一个消费者，中间通过一个队列直接连接。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230224114922728.png" alt="image-20230224114922728"></p></li><li><p><strong>work 工作模式</strong>：就是<strong>有多个消费者消费队列里的消息，队列里的消息只能被一个消费者消费，这样多部署几个消费者，就可以缓解压力</strong>，比如过年的时候抢票，抢票成功后会给你发短信，这个时候就可以把发短信的任务放入队列里，然后有多个发短信的服务来处理队列里的任务。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230224114937419.png" alt="image-20230224114937419"></p></li><li><p><strong>pub&#x2F;sub 发布订阅模式</strong>：用到一个Exchange交换机角色来帮助我们把消息发给所有订阅我们的消费者。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230224115119733.png" alt="image-20230224115119733"></p></li><li><p><strong>Routing 路由模式</strong>：路由模式就是交换机并不是给所有订阅他的队列发送消息了，而是<strong>根据路由键来确定应该给哪个队列发送消息，队列和交换机绑定的时候需要通过路由键，而生产者发送消息的时候也需要指定路由键</strong>，这样就可以确定给哪个队列发送消息了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230224115144791.png" alt="image-20230224115144791"></p></li><li><p><strong>Topic 主题模式</strong>：主题模式就相当于模糊匹配，假如我想给姓张的发送消息，那么我就可以通过主题模式给所有姓张的发送消息。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230224115222685.png" alt="image-20230224115222685"></p></li></ul><h2 id="RabbitMQ消息怎么传输？"><a href="#RabbitMQ消息怎么传输？" class="headerlink" title="RabbitMQ消息怎么传输？"></a>RabbitMQ消息怎么传输？</h2><ul><li>由于 TCP 链接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈，所以 <strong>RabbitMQ 使用信道的方式来传输数据</strong>。信道（Channel）是生产者、消费者与 RabbitMQ 通信的渠道，<strong>信道是建立在 TCP 链接上的虚拟链接，且每条 TCP 链接上的信道数量没有限制</strong>。就是说 RabbitMQ 在一条 TCP 链接上建立成百上千个信道来达到多个线程处理，<strong>这个 TCP 被多个线程共享，每个信道在 RabbitMQ 都有唯一的 ID，保证了信道私有性，每个信道对应一个线程使用</strong>。</li></ul><h2 id="如何保证消息的可靠性？"><a href="#如何保证消息的可靠性？" class="headerlink" title="如何保证消息的可靠性？"></a>如何保证消息的可靠性？</h2><ul><li>可能出现这几种问题：消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。</li><li>生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：<strong>事务机制和 Confirm 机制是互斥的，两者不能共存</strong>，会导致 RabbitMQ 报错。</li><li>RabbitMQ 自身：持久化、集群、普通模式、镜像模式。</li><li>RabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制。</li></ul><h2 id="如何保证RabbitMQ消息的顺序性？"><a href="#如何保证RabbitMQ消息的顺序性？" class="headerlink" title="如何保证RabbitMQ消息的顺序性？"></a>如何保证RabbitMQ消息的顺序性？</h2><ul><li>拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是**多一些 queue (消息队列)**而已，确实是麻烦点；</li><li>或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 <strong>consumer(消费者)内部用内存队列做排队</strong>，然后分发给底层不同的 worker 来处理。</li></ul><h2 id="如何保证RabbitMQ的高可用？"><a href="#如何保证RabbitMQ的高可用？" class="headerlink" title="如何保证RabbitMQ的高可用？"></a>如何保证RabbitMQ的高可用？</h2><ul><li>RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。RabbitMQ 有三种模式：<strong>单机模式、普通集群模式、镜像集群模式</strong>。</li></ul><h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><ul><li>Demo 级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式。</li></ul><h3 id="普通集群模式"><a href="#普通集群模式" class="headerlink" title="普通集群模式"></a>普通集群模式</h3><ul><li>意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你<strong>创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据</strong>（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。</li><li>你消费的时候，实际上<strong>如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来</strong>。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。</li></ul><h3 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h3><ul><li>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，<strong>在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思</strong>。然后每次你写消息到 queue 的时候，都会<strong>自动把消息同步到多个实例的 queue 上</strong>。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。</li><li>这样的<strong>好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据</strong>。<strong>坏处在于，性能开销太大，消息需要同步到所有机器上，导致网络带宽压力和消耗很重</strong>！镜像集群下，每个节点都存放着所有 queue 的完整数据。</li></ul><h2 id="如何解决消息挤压问题？"><a href="#如何解决消息挤压问题？" class="headerlink" title="如何解决消息挤压问题？"></a>如何解决消息挤压问题？</h2><ul><li><strong>临时紧急扩容</strong>。先修复 consumer 的问题，确保其恢复消费速度，然后将现有 cnosumer 都停掉。新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</li></ul><h2 id="如何解决消息队列的延时以及过期失效问题？"><a href="#如何解决消息队列的延时以及过期失效问题？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？"></a>如何解决消息队列的延时以及过期失效问题？</h2><ul><li>RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是<strong>批量重导</strong>，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，<strong>将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来</strong>。也只能是这样了。假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;Java基础&quot;&gt;&lt;a href=&quot;#Java基础&quot; class=&quot;headerlink&quot; title=&quot;Java基础&quot;&gt;&lt;/a&gt;Java基础&lt;/h1&gt;&lt;h2 id=&quot;Ja</summary>
      
    
    
    
    
    <category term="综合知识" scheme="https://konjacor.github.io/tags/%E7%BB%BC%E5%90%88%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>贾岛项目开发日志</title>
    <link href="https://konjacor.github.io/2022/12/22/%E8%B4%BE%E5%B2%9B%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"/>
    <id>https://konjacor.github.io/2022/12/22/%E8%B4%BE%E5%B2%9B%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</id>
    <published>2022-12-22T14:24:37.000Z</published>
    <updated>2024-01-10T02:25:08.332Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>本项目基于尚硅谷的谷粒商城项目，主要是做的时候我想根据自己所学的东西对谷粒商城进行一定程度的改造，有点属于自己的特色，做这个项目的过程也是我巩固之前所学知识的一个机会，所以趁这个机会，把开发日志写一下，积累一下实战经验。</li></ul><h1 id="2022-x2F-12-x2F-23"><a href="#2022-x2F-12-x2F-23" class="headerlink" title="2022&#x2F;12&#x2F;23"></a>2022&#x2F;12&#x2F;23</h1><h2 id="为什么使用微服务的架构风格"><a href="#为什么使用微服务的架构风格" class="headerlink" title="为什么使用微服务的架构风格"></a>为什么使用微服务的架构风格</h2><ul><li>微服务的架构风格，实际上就是将一个单独的应用程序拆分成了多个小服务，每个小服务运行在自己的的进程中，并且它们之间使用轻量级的通信机制，通常是HTTP API，这些服务是围绕着应用的业务能力来构建的，并且可以独立部署，这些服务可以使用不同的编程语言编写、可以使用不同的数据存储技术，并且所有服务之间保持着最低限度的集中式管理。简而言之：<strong>微服务架构拒绝大型单体应用，基于业务边界进行服务微化拆分，各个服务独立部署运行</strong>。</li><li>使用微服务的架构风格使得项目获得了很好的可扩展性，再需要添加新功能的时候只需要把精力集中在开发新服务上即可，不用把精力花费在之前的代码上，这就是使用微服务解耦带来的好处之一，除此之外使用微服务的架构风格遇到错误和故障可以将其隔离以防止这些错误蔓延到别的服务模块，微服务带来的好处还有很多，但是同时它也给运维人员、开发人员等提出了新的挑战，比如：我该如何做到高可用呢？我该如何在分布式的事务中保证数据的一致性？服务被调用的时候中间的某个服务出现了错误，我该怎么办？我该怎么才能找到错误的服务？对于这些服务我该使用什么样的部署方案？我该如何对流量进行监控和限制？等等诸如此类的问题。</li></ul><h2 id="集群、分布式和节点"><a href="#集群、分布式和节点" class="headerlink" title="集群、分布式和节点"></a>集群、分布式和节点</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223142832425.png" alt="image-20221223142832425"></p><h2 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223143038851.png" alt="image-20221223143038851"></p><ul><li>使用HTTP+JSON的方式来进行远程调用的好处在于他们提供的天然的跨平台性，JSON可以在任何平台上被编码或是解码，而对于大多数编程语言来说，他们都有对应的发送HTTP请求的方法。</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223143343097.png" alt="image-20221223143343097"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223143418977.png" alt="image-20221223143418977"></p><ul><li>不要让某台机器太忙或者太闲</li></ul><h2 id="服务注册-x2F-发现中心"><a href="#服务注册-x2F-发现中心" class="headerlink" title="服务注册&#x2F;发现中心"></a>服务注册&#x2F;发现中心</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223143510152.png" alt="image-20221223143510152"></p><ul><li>将服务的消费者和服务的生产者解耦，引入中间件进行服务的管理。</li></ul><h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223143814126.png" alt="image-20221223143814126"></p><ul><li>将配置和服务解耦，引入中间件集中管理微服务的配置信息。</li></ul><h2 id="服务熔断和服务降级"><a href="#服务熔断和服务降级" class="headerlink" title="服务熔断和服务降级"></a>服务熔断和服务降级</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223144306392.png" alt="image-20221223144306392"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223144331911.png" alt="image-20221223144331911"></p><ul><li>熔断器有半开机制，在熔断器打开后的一个时间窗口后，熔断器开始变成半开状态，尝试将流量放行，如果要是放行的流量返回了正常的结果，那么熔断器就会尝试关闭。</li><li>服务降级可以看作是服务熔断后的一种处理方式。</li></ul><h2 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223144626739.png" alt="image-20221223144626739"></p><ul><li>拦截所有打过来的请求，先做断言，断言成功之后，做过滤，最后再进行路由。</li></ul><h2 id="完整服务架构图"><a href="#完整服务架构图" class="headerlink" title="完整服务架构图"></a>完整服务架构图</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223145200445.png" alt="image-20221223145200445"></p><h2 id="微服务划分图"><a href="#微服务划分图" class="headerlink" title="微服务划分图"></a>微服务划分图</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223145837732.png" alt="image-20221223145837732"></p><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223153607206.png" alt="image-20221223153607206"></p><ul><li>虚拟化的容器，里面通过镜像装好了各种软件，镜像可以从Docker的hub上获取，软件可以在Docker中运行，因为软件的运行时环境都被打包到镜像中了，通过镜像安装后，软件就具备了在docker中运行的能力，各软件的运行环境相互隔离，一个出问题不会影响另外一个。</li><li>用这个技术安装软件非常方便，省去了在linux上安装软件的一系列繁琐的步骤。</li></ul><h2 id="租了个腾讯云服务器"><a href="#租了个腾讯云服务器" class="headerlink" title="租了个腾讯云服务器"></a>租了个腾讯云服务器</h2><ul><li>用来做后面的部署工作啥的，centos7.6系统，自带了个docker，4核8g，100gSSD。</li></ul><h2 id="使用docker安装mysql-5-7"><a href="#使用docker安装mysql-5-7" class="headerlink" title="使用docker安装mysql 5.7"></a>使用docker安装mysql 5.7</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><ul><li><p>有了云服务器和docker之后，安装这些软件就变得非常容易了，只需要在云服务器上运行**<code>sudo docker pull mysql:5.7</code><strong>就能下载了，下载别的软件的时候这个命令的格式基本不变，不过要注意的是，</strong>如果要指定下载软件镜像的版本，应该在镜像名称的后面加个冒号然后指定版本，如果不加冒号则默认下载最新版**：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223163407228.png" alt="image-20221223163407228"></p></li></ul><h3 id="查看已经下载的镜像"><a href="#查看已经下载的镜像" class="headerlink" title="查看已经下载的镜像"></a>查看已经下载的镜像</h3><ul><li><p>然后可以通过**<code>sudo docker images</code><strong>命令来</strong>查看已经下载的所有镜像**：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223163502237.png" alt="image-20221223163502237"></p></li></ul><h3 id="创建实例并启动"><a href="#创建实例并启动" class="headerlink" title="创建实例并启动"></a>创建实例并启动</h3><ul><li><p>使用如下的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223173136099.png" alt="image-20221223173136099"></p><p><strong>最后产生的是该实例的id</strong>。</p></li><li><p>参数说明：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223164759780.png" alt="image-20221223164759780"></p></li><li><p>从这里也能看出来<strong>docker中的部分冒号一般充当映射的作用，冒号前面的是运行docker的宿主机的内容，冒号后面的是docker这个虚拟容器中的内容</strong>，明白了这个看很多docker命令就了然许多了。</p></li><li><p>所谓<strong>目录挂载-v</strong>就是<strong>将一个目录挂载到另一个目录下，这样在访问被挂载到的目录的时候就相当于访问到了挂载目录，实际上是用软连接（快捷方式）实现的</strong>，这样就省得每次想要修改实例内部的文件的时候都要进实例中修改了,<strong>在挂载目录之前为了防止出现权限不够的问题，最好是先用命令<code>sudo chmod -R 777 目录路径</code>来提升相关目录的权限</strong>。</p></li><li><p>关于<strong>端口映射-p</strong>，由于<strong>mysql是跑在docker里面的3306端口上的</strong>，从外面无法访问，所以我们<strong>需要将docker里的3306端口和其宿主机的3306端口进行一个映射，这样外面在访问宿主机的3306端口的时候就能访问到docker的3306端口了</strong>。</p></li><li><p>至于<strong>设置实例名称–name</strong>，实例名称之后可以当作实例的唯一标识，那一串实例id也可以当作实例的唯一标识，但是用实例名称作为标识方便多了不是吗？</p></li><li><p><strong>-d就是从后台启动</strong>，后面要写<strong>镜像名:版本号</strong></p></li></ul><h3 id="查看某个实例的日志"><a href="#查看某个实例的日志" class="headerlink" title="查看某个实例的日志"></a>查看某个实例的日志</h3><ul><li><p>使用命令**<code>docker logs 实例名或实例id</code>**来查看某个实例的日志：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223205722266.png" alt="image-20221223205722266"></p></li></ul><h3 id="查看docker中正在运行的软件"><a href="#查看docker中正在运行的软件" class="headerlink" title="查看docker中正在运行的软件"></a>查看docker中正在运行的软件</h3><ul><li><p>使用**<code>docker ps -a</code><strong>命令来</strong>查看当前docker中所有状态的软件，包括正在运行的和已经终止的<strong>；使用</strong><code>docker ps</code><strong>命令来</strong>查看当前docker中正在运行的软件**：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223173216375.png" alt="image-20221223173216375"></p></li></ul><h3 id="停止docker实例"><a href="#停止docker实例" class="headerlink" title="停止docker实例"></a>停止docker实例</h3><ul><li><p>使用**<code>docker stop 实例名或实例id</code><strong>来</strong>将一个实例从正在运行状态变成已经终止的状态<strong>，注意</strong>停止docker实例的运行并不代表着删除docker实例**，停止docker实例运行后还可以通过启动docker实例来让其恢复运行，而删除docker实例后就这个实例就永远不能启动了，要想跑实例就必须再创建一个实例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223191435300.png" alt="image-20221223191435300"></p></li></ul><h3 id="启动docker实例"><a href="#启动docker实例" class="headerlink" title="启动docker实例"></a>启动docker实例</h3><ul><li><p>使用**<code>docker start 实例名或实例id</code>**来将一个状态是终止状态的实例启动：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223191618624.png" alt="image-20221223191618624"></p></li></ul><h3 id="重启docker实例"><a href="#重启docker实例" class="headerlink" title="重启docker实例"></a>重启docker实例</h3><ul><li>使用**<code>docker restart 实例名或实例id</code>**来将一个状态是运行状态的实例重新启动。</li></ul><h3 id="删除docker容器"><a href="#删除docker容器" class="headerlink" title="删除docker容器"></a>删除docker容器</h3><ul><li>有的实例已经没有在运行了，但是其容器还存在绑定着一些资源，我们想将其移除，可以使用**<code>docker rm 实例ID或实例名</code>**来将其删除。</li></ul><h3 id="删除docker本地镜像"><a href="#删除docker本地镜像" class="headerlink" title="删除docker本地镜像"></a>删除docker本地镜像</h3><ul><li>首先可以通过**<code>docker images</code><strong>来查看本地镜像名称及id，然后可以通过</strong><code>docker rmi 镜像名或镜像id</code>**来删除本地镜像。</li></ul><h3 id="进入docker正在运行的实例内部"><a href="#进入docker正在运行的实例内部" class="headerlink" title="进入docker正在运行的实例内部"></a>进入docker正在运行的实例内部</h3><ul><li>由于<strong>docker实例有一个软件完整的运行环境，所以它本质上拥有一个完整的linux目录结构（以linux系统下的docker来说</strong>），我们可以通过**<code>docker exec -it 实例名或实例id /bin/bash</code>**进入到这个实例的内部的操作台，然后就可以对实例的内部进行操作了，操作就和linux一样，毕竟是个linux环境。</li><li>也可以修改最后一部分以运行实例内部中的其他东西。</li><li>通过**<code>exit</code>**命令从实例内部的操作台中退出到外面。</li></ul><h3 id="让对应的容器开机自启动实例"><a href="#让对应的容器开机自启动实例" class="headerlink" title="让对应的容器开机自启动实例"></a>让对应的容器开机自启动实例</h3><ul><li>使用命令**<code>sudo docker update 容器id或容器名 --restart=always</code>**来配置开机自启动。</li></ul><h3 id="创建mysql的配置文件"><a href="#创建mysql的配置文件" class="headerlink" title="创建mysql的配置文件"></a>创建mysql的配置文件</h3><ul><li><p>在刚才挂载的宿主机上的目录下新建配置文件my.cnf(用**<code>touch 文件名</code><strong>或者</strong><code>vim/vi 文件名</code>**都行)填入以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">init_connect=&#x27;SET collation_connection = utf8_unicode_ci&#x27;</span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure></li><li><p> <!--开启springboot和配置相关的代码提示--><dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-configuration-processor</artifactId>    <optional>true</optional></dependency>xml</p></li></ul><h3 id="查看各实例占用资源的情况"><a href="#查看各实例占用资源的情况" class="headerlink" title="查看各实例占用资源的情况"></a>查看各实例占用资源的情况</h3><ul><li>可以使用<code>docker stats</code>命令来进行查看。</li></ul><h3 id="将docker容器中的内容复制到指定位置"><a href="#将docker容器中的内容复制到指定位置" class="headerlink" title="将docker容器中的内容复制到指定位置"></a>将docker容器中的内容复制到指定位置</h3><ul><li>使用命令**<code>docker container cp 容器名:容器内部目录 目标目录</code>**来实现。</li></ul><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><ul><li>SSH（Secure Shell） 是较可靠，<strong>专为远程登录会话和其他网络服务提供安全性的协议</strong>，利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题，这是因为SSH相较于其他的传输协议来说对数据进行了加密处理。</li><li>我们<strong>通常使用实现SSH协议的软件来实现远程数据传输、远程连接等操作</strong>，这个连接操作<strong>可以使用基于密钥的安全验证</strong>的，<strong>也可以使用基于口令的安全验证</strong>。</li></ul><h2 id="在本地使用Navicat通过SSH协议连接到服务器上的mysql数据库"><a href="#在本地使用Navicat通过SSH协议连接到服务器上的mysql数据库" class="headerlink" title="在本地使用Navicat通过SSH协议连接到服务器上的mysql数据库"></a>在本地使用Navicat通过SSH协议连接到服务器上的mysql数据库</h2><ul><li>出于安全考虑，我们不使用基于口令的安全验证方式，实际上腾讯云服务器上ssh协议的配置文件中也是默认将这种方式关闭的，我们使用基于密钥的安全验证。</li></ul><h3 id="创建密钥"><a href="#创建密钥" class="headerlink" title="创建密钥"></a>创建密钥</h3><ul><li>SSH协议通常使用基于密钥的安全验证方式，所以我们要先在腾讯云控制台上新建一个密钥，公钥会显示在控制台，而密钥会下载到本地。</li></ul><h3 id="将密钥绑定到服务器实例上"><a href="#将密钥绑定到服务器实例上" class="headerlink" title="将密钥绑定到服务器实例上"></a>将密钥绑定到服务器实例上</h3><ul><li>就是把刚才创建的SSH公钥绑定到服务器上，这样别的主机就可以使用那个SSH公钥对应的私钥来向服务器发起SSH连接。</li></ul><h3 id="新建连接"><a href="#新建连接" class="headerlink" title="新建连接"></a>新建连接</h3><ul><li>在navicat上新建一个连接，名字随便取，然后数据库的密码填服务器上数据库的密码。</li><li>然后配置SSH，勾选使用SSH通道，填写服务器ip，填写用户名，验证方法选公钥，然后私钥选择刚才下载下来的那个文件，通行短语就是每次连接的时候需要输入的口令，自己随便设置一个就行，建议勾选保存通行短语，这样就不用每次连接都输入通行短语了，测试连接，发现可以连通，点击确认即可。</li></ul><h2 id="使用docker安装redis"><a href="#使用docker安装redis" class="headerlink" title="使用docker安装redis"></a>使用docker安装redis</h2><ul><li><p>前面基本和mysql的安装类似，pull的是最新版的</p></li><li><p>在外面预先创建好redis的配置文件，因为实例中redis一开始可能没有redis.conf，进行挂载目录的时候宿主机的redis.conf可能会被错误的识别为一个目录，所以要在指定位置先创建好redis.conf防止发生歧义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/redis/conf</span><br><span class="line">touch /mydata/redis/conf/redis.conf</span><br></pre></td></tr></table></figure></li><li><p>创建实例并启动的命令，最后一句是表示让redis-server按照对应路径下的配置文件进行启动，要预先在外面对应位置创建好redis.conf文件，注意这个redis.conf文件存在的目录在不同版本的redis中有区别，具体按安装的redis版本为准：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis \</span><br><span class="line">-v /mydata/redis/data:/data \</span><br><span class="line">-v /mydata/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf \</span><br><span class="line">-d redis /usr/local/bin/redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure></li><li><p>使用**<code>docker exec -it redis redis-cli</code>**可以打开redis实例中的redis-cli</p></li><li><p>在redis的配置文件中添加<strong>appendonly yes</strong>，配置让redis使用aof的方式持久化数据</p></li><li><p>可以在本地<strong>使用Redis Desktop Manager来远程访问redis</strong>，也是用SSH连接，和前面的Navicat类似，这里就不赘述了，但是注意这个软件用到了服务器上的6379端口，所以要先把6379端口开放之后才能连接上。</p></li></ul><h2 id="在IDEA中搭建各种模块"><a href="#在IDEA中搭建各种模块" class="headerlink" title="在IDEA中搭建各种模块"></a>在IDEA中搭建各种模块</h2><ul><li><p>先clone下来刚建好的仓库，再创建各个模块</p></li><li><p>每个模块使用springboot的初始化工具进行初始化，每个一开始都配上web和openfeign的环境</p></li></ul><h1 id="2022-x2F-12-x2F-24"><a href="#2022-x2F-12-x2F-24" class="headerlink" title="2022&#x2F;12&#x2F;24"></a>2022&#x2F;12&#x2F;24</h1><h2 id="设置项目的-gitignore文件"><a href="#设置项目的-gitignore文件" class="headerlink" title="设置项目的.gitignore文件"></a>设置项目的.gitignore文件</h2><ul><li><p>两个星号**指所有子目录及其递归结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">target/</span><br><span class="line">pom.xml.tag</span><br><span class="line">pom.xml.releaseBackup</span><br><span class="line">pom.xml.versionsBackup</span><br><span class="line">pom.xml.next</span><br><span class="line">release.properties</span><br><span class="line">dependency-reduced-pom.xml</span><br><span class="line">buildNumber.properties</span><br><span class="line">.mvn/timing.properties</span><br><span class="line"># https://github.com/takari/maven-wrapper#usage-without-binary-jar</span><br><span class="line">.mvn/wrapper/maven-wrapper.jar</span><br><span class="line"></span><br><span class="line">**/mvnw</span><br><span class="line">**/mvnw.cmd</span><br><span class="line">**/.mvn</span><br><span class="line">**/target/</span><br><span class="line">.idea</span><br><span class="line">**/.gitignore</span><br></pre></td></tr></table></figure></li></ul><h2 id="IDEA中Project-Structure中的Facets配置"><a href="#IDEA中Project-Structure中的Facets配置" class="headerlink" title="IDEA中Project Structure中的Facets配置"></a>IDEA中Project Structure中的Facets配置</h2><ul><li><p>这个配置实际上就是在告诉IDEA怎么去处理你的对应模块，比如说我给一个模块设置了一个spring的Facets，那么IDEA就知道使用对待spring模块的方式来对待我的这个模块，每个模块可以配置多个Facets，并且每个Facets可以进行相应的配置从而来让IDEA帮我们配置关于这个模块的一些东西：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221224154946122.png" alt="image-20221224154946122"></p></li></ul><h2 id="PowerDesigner"><a href="#PowerDesigner" class="headerlink" title="PowerDesigner"></a>PowerDesigner</h2><ul><li>这个软件是用来设计数据库的</li><li>所有表无论关系多么复杂都不应该建立外键，外键关联非常消耗数据库的性能</li><li>可以用这个软件针对设计出来的数据库导出sql文件（Database-generate database选项）</li></ul><h2 id="启动报错：java-程序包org-aspectj-lang不存在"><a href="#启动报错：java-程序包org-aspectj-lang不存在" class="headerlink" title="启动报错：java: 程序包org.aspectj.lang不存在"></a>启动报错：java: 程序包org.aspectj.lang不存在</h2><ul><li>可能是springboot版本的问题，改个版本试下</li></ul><h2 id="前端项目下载依赖"><a href="#前端项目下载依赖" class="headerlink" title="前端项目下载依赖"></a>前端项目下载依赖</h2><ul><li>可以通过**<code>npm install</code>**命令来下载一个前端项目所需要的依赖文件。</li></ul><h2 id="前端项目运行"><a href="#前端项目运行" class="headerlink" title="前端项目运行"></a>前端项目运行</h2><ul><li>使用**<code>npm run dev</code>**来运行前端项目</li></ul><h2 id="查看windows系统的端口占用"><a href="#查看windows系统的端口占用" class="headerlink" title="查看windows系统的端口占用"></a>查看windows系统的端口占用</h2><ul><li>使用**<code>netstat -ano</code>**命令查看所有端口的占用情况，再根据详细信息中的PID从任务管理器中找到对应的应用。</li></ul><h2 id="关于子模块的依赖问题"><a href="#关于子模块的依赖问题" class="headerlink" title="关于子模块的依赖问题"></a>关于子模块的依赖问题</h2><ul><li>一般来说子模块用到的依赖应该在父模块声明方便管理，然后子模块再声明一次。</li><li>其实也可以将子模块都用得到的依赖放到common模块中，然后子模块引入common模块，省的在子模块中再声明一次了就。</li></ul><h2 id="关于maven的版本问题"><a href="#关于maven的版本问题" class="headerlink" title="关于maven的版本问题"></a>关于maven的版本问题</h2><ul><li>用IDEA的话maven尽量用3.6.3的版本吧，这个版本的maven对各个版本的IDEA都挺兼容的，我感觉我从远程下载不下来jar包是因为我maven版本太高了的原因，我现在是3.8.6，我去试试低版本。</li><li>好像也不太行，总之还是尽量用第二梯队的吧，啥东西也是别无脑上最新版。</li></ul><h1 id="2022-x2F-12-x2F-27"><a href="#2022-x2F-12-x2F-27" class="headerlink" title="2022&#x2F;12&#x2F;27"></a>2022&#x2F;12&#x2F;27</h1><h2 id="关于有些jar包无法从远程仓库下载"><a href="#关于有些jar包无法从远程仓库下载" class="headerlink" title="关于有些jar包无法从远程仓库下载"></a>关于有些jar包无法从远程仓库下载</h2><ul><li><p>首先排除一下网络问题</p></li><li><p>然后可能是你这个jar包在你配置的那个仓库中没有，你需要重新配置一个有那个jar包的仓库的镜像，至于怎么知道这个jar包在哪个仓库中有，可以从中央仓库中搜索，然后点下面这几个标签之一就能查看标签对应的仓库地址了：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221227202945652.png" alt="image-20221227202945652"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221227203005023.png" alt="image-20221227203005023"></p></li><li><p>如果还是不能解决的话，也可以手动下载然后根据gav地址配置到本地的maven仓库中。</p></li><li><p>最后就是记得使用解决方案之后clean一下maven，不然可能还是爆红。</p></li></ul><h1 id="2022-x2F-12-x2F-28"><a href="#2022-x2F-12-x2F-28" class="headerlink" title="2022&#x2F;12&#x2F;28"></a>2022&#x2F;12&#x2F;28</h1><h2 id="关于mybatis-plus的代码生成器的依赖"><a href="#关于mybatis-plus的代码生成器的依赖" class="headerlink" title="关于mybatis-plus的代码生成器的依赖"></a>关于mybatis-plus的代码生成器的依赖</h2><ul><li><p>搞了半天终于搞定了mybatis-plus代码生成器的依赖，依赖列表如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mybatis-plus.version</span>&gt;</span>3.1.2<span class="tag">&lt;/<span class="name">mybatis-plus.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mybatis-plus-generator.version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">mybatis-plus-generator.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mysql-connector-java.version</span>&gt;</span>8.0.17<span class="tag">&lt;/<span class="name">mysql-connector-java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.1.13<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">velocity-engine-core.version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">velocity-engine-core.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--mybatis-plus 持久层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis-plus代码生成器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus-generator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 代码生成器依赖的某个工具类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-lang3.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql数据库驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql-connector-java.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--阿里druid连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.velocity/velocity-engine-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;velocity-engine-core.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="关于数据库表的一些设计规范"><a href="#关于数据库表的一些设计规范" class="headerlink" title="关于数据库表的一些设计规范"></a>关于数据库表的一些设计规范</h2><ul><li>根据《阿里巴巴开发手册》中提到的，<strong>每张表应该都有id、gmt_create（记录创建时间）、gmt_modified（记录修改时间）字段</strong>，说明：其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1（或者用varchar 19存，每次使用雪花算法自动生成19位uuid）。gmt_create、gmt_modified 的类型均为 date_time 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</li><li>还可以<strong>创建is_deleted字段来标识当前记录是否被逻辑删除</strong>，开发的时候可以配置逻辑删除插件来对这个字段实现自动化操作，并且<strong>应该让被逻辑删除的记录无法被查到</strong>。</li></ul><h2 id="关于spring-boot-maven-plugin"><a href="#关于spring-boot-maven-plugin" class="headerlink" title="关于spring-boot-maven-plugin"></a>关于spring-boot-maven-plugin</h2><ul><li>这个插件如果要是配置到pom文件中，那么在maven进行构建的时候就会去找这个pom文件管辖范围下的程序入口main，所以如果父工程没有程序入口main，就不要引入这个插件，不然在执行maven的生命周期时会报错。</li></ul><h2 id="maven执行install的时候报单元测试错误"><a href="#maven执行install的时候报单元测试错误" class="headerlink" title="maven执行install的时候报单元测试错误"></a>maven执行install的时候报单元测试错误</h2><ul><li><p>可以在下面这个地方设置成跳过单元测试的模式，设置完成后再执行就好了：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221228183630929.png" alt="image-20221228183630929"></p></li></ul><h2 id="IDEA有时包明明存在但是运行程序时总是报找不到某个包"><a href="#IDEA有时包明明存在但是运行程序时总是报找不到某个包" class="headerlink" title="IDEA有时包明明存在但是运行程序时总是报找不到某个包"></a>IDEA有时包明明存在但是运行程序时总是报找不到某个包</h2><ul><li><p>首先尝试刷新Maven，有的时候IDE会抽风导致很多包明明存在但却没有被加载。</p></li><li><p>再者有可能是IDEA的bug，可以在下面这个地方将IDE的构建&#x2F;运行操作委托给maven，不过设置了这个之后不保证以后不会出什么问题，所以解决问题之后能改回来就尽量改回来吧：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221228184212604.png" alt="image-20221228184212604"></p></li></ul><h1 id="2022-x2F-12-x2F-29"><a href="#2022-x2F-12-x2F-29" class="headerlink" title="2022&#x2F;12&#x2F;29"></a>2022&#x2F;12&#x2F;29</h1><h2 id="记录一种奇怪的依赖引入方式"><a href="#记录一种奇怪的依赖引入方式" class="headerlink" title="记录一种奇怪的依赖引入方式"></a>记录一种奇怪的依赖引入方式</h2><ul><li><p>在处理依赖的时候发现了一种比较奇怪的依赖引入方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个结构的依赖我翻了翻之前的博客，没发现有相关的解释，值为pom的type标签和值为import的scope标签也从来没见过，上网搜了搜，基本可以将这个东西理解成一个比较方便引入的整体，需要引入的时候直接往pom里一粘，具体的解释目前还不得而知。（如果原pom本来就有dependencyManagement标签怎么办？如果要是父pom中引入了这种格式的依赖，那子pom应该以怎样的格式引入这样的依赖？type标签和scope标签的值到底是什么含义？）</p></li></ul><h2 id="关于nacos-2-x版本无法访问的问题"><a href="#关于nacos-2-x版本无法访问的问题" class="headerlink" title="关于nacos 2.x版本无法访问的问题"></a>关于nacos 2.x版本无法访问的问题</h2><ul><li><p>在服务器的docker上安装了nacos-server的2.0.2版本，但是在本地启动springboot的服务却报错无法连接到nacos-server，但是在本地的浏览器上访问服务器的8848端口下的nacos目录是可以访问的，就奇了怪了，后来搜索了一下才知道，原来<strong>2.x版本的nacos-server还用到了9848（8848+1000）和9849（8848+1001）两个端口，这两个端口号不是固定的是通过主服务端口加上一个固定的偏移量得来的</strong>，所以在docker启动镜像的时候要用多个-p命令同时指定三个端口的映射：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221229172729337.png" alt="image-20221229172729337"></p></li></ul><h2 id="关于在nacos配置中心上做配置"><a href="#关于在nacos配置中心上做配置" class="headerlink" title="关于在nacos配置中心上做配置"></a>关于在nacos配置中心上做配置</h2><ul><li><p>配置中心的命名空间可以用来隔离不同的服务，也可以用来隔离不同的开发环境，也可以自定义隔离规则，在命名空间下还有组可以进行环境隔离，要想指定特定的命名空间和组，需要在bootstrap配置文件中进行相关配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置命名空间,填的是命名空间的id</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.namespace</span>=<span class="string">coupon</span></span><br><span class="line"><span class="comment">#配置组，填的是组名</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.group</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure></li><li><p>如果一个配置文件中的内容过多的话，可以将一个配置文件拆成多个配置文件，每一个配置文件各司其职，不过这样的方式需要最后在本地的bootstrap配置文件中进行配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置配置中心上自定义名称的配置文件，可以把很长的配置文件拆分开放到配置中心上，然后在这里配置读取</span></span><br><span class="line"><span class="comment">#中心上的配置文件名称</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[0].data-id</span>=<span class="string">datasource.yaml</span></span><br><span class="line"><span class="comment">#设置组</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[0].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="comment">#开启刷新以保证服务可以事实获取到最新的改动</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[0].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[1].data-id</span>=<span class="string">mybatis.yaml</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[1].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[1].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[2].data-id</span>=<span class="string">other.yaml</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[2].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[2].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="2022-x2F-12-x2F-30"><a href="#2022-x2F-12-x2F-30" class="headerlink" title="2022&#x2F;12&#x2F;30"></a>2022&#x2F;12&#x2F;30</h1><h2 id="如何排除不想加载的包"><a href="#如何排除不想加载的包" class="headerlink" title="如何排除不想加载的包"></a>如何排除不想加载的包</h2><ol><li><p>可以在pom文件中使用exclusions-exclusion标签来对指定jar包进行排除</p></li><li><p>也可以在@SpringBootApplication注解中设置exclude参数，实参应该是某个AutoConfiguration的class对象，比如想要排除数据源相关的包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="2023-x2F-1-x2F-1"><a href="#2023-x2F-1-x2F-1" class="headerlink" title="2023&#x2F;1&#x2F;1"></a>2023&#x2F;1&#x2F;1</h1><h2 id="关于使用mybatis-plus查不出数据的问题"><a href="#关于使用mybatis-plus查不出数据的问题" class="headerlink" title="关于使用mybatis-plus查不出数据的问题"></a>关于使用mybatis-plus查不出数据的问题</h2><ul><li>首先检查@TableId注解，看看数据库的id和实体类的id是否一致</li><li>也有可能是@TableLogic注解导致的，因为注解上@TableLogic注解后默认这个字段不能为空，此时要是数据库中的数据这个字段为空，那就查不出来。</li><li>总而言之大部分是实体类和数据库表的字段参数不一致造成的。</li></ul><h2 id="在实体类中添加数据库表中不存在的字段"><a href="#在实体类中添加数据库表中不存在的字段" class="headerlink" title="在实体类中添加数据库表中不存在的字段"></a>在实体类中添加数据库表中不存在的字段</h2><ul><li>需要加上**<code>@TableField(exist = false)</code>**注解。</li><li>不过更规范的做法应该是再写一个VO类，然后使用bean拷贝。</li></ul><h2 id="在VScode中添加vue代码模板"><a href="#在VScode中添加vue代码模板" class="headerlink" title="在VScode中添加vue代码模板"></a>在VScode中添加vue代码模板</h2><ul><li><p>首先点击<strong>文件-首选项-配置用户代码片段</strong>，然后点击<strong>新建全局代码片段文件</strong>，然后<strong>将模板复制进去或者自己写一个模板</strong>，其中<strong>prefix属性就是你输入prefix属性对应的值会提示产生这个代码片段</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Print to console&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;&lt;!-- $1 --&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;template&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;div class=&#x27;$2&#x27;&gt;$5&lt;/div&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;/template&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;script&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//这里可以导入其他文件（比如：组件，工具js，第三方插件js，json文件，图片文件等等）&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//例如：import 《组件名称》 from &#x27;《组件路径》&#x27;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;export default &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//import引入的组件需要注入到对象中才能使用&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;components: &#123;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;data() &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//这里存放数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;return &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//监听属性 类似于data概念&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;computed: &#123;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//监控data中的数据变化&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;watch: &#123;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//方法集合&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;methods: &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//生命周期 - 创建完成（可以访问当前this实例）&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;created() &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//生命周期 - 挂载完成（可以访问DOM元素）&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;mounted() &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;beforeCreate() &#123;&#125;, //生命周期 - 创建之前&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;beforeMount() &#123;&#125;, //生命周期 - 挂载之前&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;beforeUpdate() &#123;&#125;, //生命周期 - 更新之前&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;updated() &#123;&#125;, //生命周期 - 更新之后&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;beforeDestroy() &#123;&#125;, //生命周期 - 销毁之前&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;destroyed() &#123;&#125;, //生命周期 - 销毁完成&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;activated() &#123;&#125;, //如果页面有keep-alive缓存功能，这个函数会触发&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;/script&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;style scoped&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;/style&gt;&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;生成vue模板&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http-get请求&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;httpget&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;this.\\$http(&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;url: this.\\$http.adornUrl(&#x27;&#x27;),&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;method: &#x27;get&#x27;,&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;params: this.\\$http.adornParams(&#123;&#125;)&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;&#125;).then((&#123; data &#125;) =&gt; &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;&#125;)&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;httpGET请求&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http-post请求&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;httppost&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;this.\\$http(&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;url: this.\\$http.adornUrl(&#x27;&#x27;),&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;method: &#x27;post&#x27;,&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;data: this.\\$http.adornData(data, false)&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;&#125;).then((&#123; data &#125;) =&gt; &#123; &#125;);&quot;</span> </span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;httpPOST请求&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="2023-x2F-1-x2F-2"><a href="#2023-x2F-1-x2F-2" class="headerlink" title="2023&#x2F;1&#x2F;2"></a>2023&#x2F;1&#x2F;2</h1><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><ul><li><p>由于某些软件的CORS（Cross-Origin Resource Sharing 跨域资源共享）policy的设置，使得我们在跨域访问资源的时候会出现禁止跨域访问资源的问题，<strong>协议、域名、端口其中有一个不同都会产生跨域</strong>，详细解释：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS%E3%80%82">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS。</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230102142732589.png" alt="image-20230102142732589"></p></li><li><p>对于这样的跨域问题我们可以从两个方向着手解决：</p><ol><li><p>其一是使用nginx将项目部署为同一域</p></li><li><p>其二是在跨域访问的响应资源的http报文header中写明当次请求允许跨域，可以在网关中配置跨域过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CorsWebFilter <span class="title function_">corsWebFilter</span><span class="params">()</span>&#123;<span class="comment">//配置跨域过滤器，让资源允许被跨域访问</span></span><br><span class="line">    <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">    <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line"></span><br><span class="line">    corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);<span class="comment">//允许所有带有头部的资源被跨域访问</span></span><br><span class="line">    corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);<span class="comment">//允许资源被所有访问方式跨域访问</span></span><br><span class="line">    corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);<span class="comment">//允许资源被所有域名跨域访问</span></span><br><span class="line">    corsConfiguration.setAllowCredentials(<span class="literal">true</span>);<span class="comment">//允许cookie资源跨域访问</span></span><br><span class="line"></span><br><span class="line">    source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,corsConfiguration);<span class="comment">//对于任意资源路径进行跨域配置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完上面这些之后，资源在返回的时候就会经过过滤器，在资源的响应header上加上我们配置的字段，浏览器看到之后自然就会将该资源放行。</p></li></ol></li></ul><h2 id="如何初始化并启动一个前端项目"><a href="#如何初始化并启动一个前端项目" class="headerlink" title="如何初始化并启动一个前端项目"></a>如何初始化并启动一个前端项目</h2><ol><li>使用<strong>npm init</strong>命令初始化项目目录</li><li>使用<strong>npm install</strong>命令安装package.json文件中写的依赖</li><li>使用<strong>npm run dev</strong>命令启动项目</li></ol><h1 id="2023-x2F-1-x2F-3"><a href="#2023-x2F-1-x2F-3" class="headerlink" title="2023&#x2F;1&#x2F;3"></a>2023&#x2F;1&#x2F;3</h1><h2 id="项目中如何进行文件存储"><a href="#项目中如何进行文件存储" class="headerlink" title="项目中如何进行文件存储"></a>项目中如何进行文件存储</h2><ul><li><p>如果项目需要我们进行文件存储，我们应该怎么办？</p></li><li><p>首先我们能想到的是在后端创建一个目录，专门用来存放前端传过来的文件，但是这样有个问题，就是后端在部署为集群的时候，前端对于后端的访问肯定是负载均衡的，所以前端不一定将文件存放到哪个集群节点中，访问的时候也不一定访问哪个集群节点，并不能保证文件一定会被读取到。</p></li><li><p>再者我们可以创建一个专门的文件服务器来对文件进行存储，直接将文件传给文件服务器，这样可以保证存储的文件可以被读取到，但是我们自己搭建的文件服务器难免会出现一些问题，而且我们还要拿出专门的时间去对其进行维护。所以我们可以使用云存储功能，去购买别人公司的云存储功能，我们只需要将我们的程序和公司的接口对接就能实现云存储的功能了，而且公司里有专业的运维人员来维护，我们只要掏钱就行了。</p></li><li><p>那么我们应该采取什么样的策略来实现文件存储呢？是前端将文件传给后端，然后后端再交给云服务器吗？这样可以实现，但是这样做后端的压力过大，仅仅是处理文件上传请求就已经占用了后端太多的资源，所以我们<strong>可以利用用户端的资源来上传文件，后端要做的只是返回一个签名，前端带着这个签名申请将文件上传到云服务器，如果签名被云服务器承认，那么文件就可以从前端直接上传到云服务器上，很明显这样做大大减少了后端的压力</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230103165550800.png" alt="image-20230103165550800"></p></li><li><p>springcloud alibaba整合了阿里的OSS服务的SDK并对其进行了封装，我们如果想要使用它的功能，只需要<strong>导入springcloud alibaba的依赖、oss的starter依赖，然后在配置文件中进行身份验证的配置和endpoint的配置，然后在controller中注入OSSClient对象，使用OSSClient对象就可以实现各种操作了</strong>。整合的时候oss的starter依赖尽量和springcloud alibaba的依赖版本相同，不然可能会出现依赖冲突，出现依赖冲突后需要手动exclusion一些包。</p></li><li><p>前端收到签名后，按照阿里云的文档构造请求体，然后直接给bucket对应的url发post请求即可，文档：<a href="https://help.aliyun.com/document_detail/31926.html">https://help.aliyun.com/document_detail/31926.html</a></p></li><li><p>上传文件的时候可以使用UUID+原始文件名组成上传文件名来防止出现命名冲突。</p></li><li><p>dir目录可以设置成格式化的年月日，这样每天上传的文件都会放到一个对应当天日期的目录中方便管理。</p></li><li><p>记得在阿里云oss控制台那边配置CORS policy，不然会有跨域问题。</p></li></ul><h1 id="2023-x2F-1-x2F-4"><a href="#2023-x2F-1-x2F-4" class="headerlink" title="2023&#x2F;1&#x2F;4"></a>2023&#x2F;1&#x2F;4</h1><h2 id="后端数据校验"><a href="#后端数据校验" class="headerlink" title="后端数据校验"></a>后端数据校验</h2><h3 id="为什么后端要进行数据校验"><a href="#为什么后端要进行数据校验" class="headerlink" title="为什么后端要进行数据校验"></a>为什么后端要进行数据校验</h3><ul><li>虽然前端有进行数据校验，但是如果一些不法分子不通过前端向后端发送数据，比如使用postman等工具，也就绕过了前端的数据校验，所以后端必须再进行一次数据校验以保证系统的安全。</li></ul><h3 id="关于JSR"><a href="#关于JSR" class="headerlink" title="关于JSR"></a>关于JSR</h3><ul><li>JSR是Java Specification Requests的缩写，意思是<strong>Java 规范提案</strong>。是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。</li></ul><h3 id="关于JSR-303"><a href="#关于JSR-303" class="headerlink" title="关于JSR-303"></a>关于JSR-303</h3><p>JSR-303 是JAVA EE 6 中的一项子规范，叫做<strong>Bean Validation</strong>，是用来校验数据的规范，Hibernate Validator 是 Bean Validation 的参考实现 . Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。</p><h3 id="基本数据校验"><a href="#基本数据校验" class="headerlink" title="基本数据校验"></a>基本数据校验</h3><ul><li><p>主要是使用JSR-303标准，这套标准规定了java中对各种数据进行校验的标准，各公司对于这套标准的实现提供了多种多样的注解，通过<strong>给实体类属性上面添加对应的校验注解、自定义message提示消息</strong>并且<strong>给想要校验的参数注解上@Valid</strong>来实现对实参数据的校验，实参校验不通过会响应包含自定义message提示消息在内的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(value = &quot;品牌名&quot;)</span></span><br><span class="line"><span class="meta">@NotBlank(message = &quot;品牌名不能为空&quot;)</span><span class="comment">//数据校验，该字段不能为空，并且至少有一个非空字符</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> PmsBrand entity)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pmsBrandService.save(entity)?Result.ok():Result.error();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果<strong>想要获取校验的结果，可以在被@Valid注解修饰的参数后面紧跟着写一个BindingResult类型的参数，这个参数封装了它前面参数的校验结果</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> PmsBrand entity, BindingResult bindingResult)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取所有元素校验的错误结果</span></span><br><span class="line">        bindingResult.getFieldErrors().forEach(item-&gt;&#123;</span><br><span class="line">            <span class="comment">//获取到错误信息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> item.getDefaultMessage();</span><br><span class="line">            <span class="comment">//获取错误的属性的名字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> item.getField();</span><br><span class="line">            map.put(field,message);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> Result.error().code(<span class="number">400</span>).message(<span class="string">&quot;提交的数据不合法&quot;</span>).data(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pmsBrandService.save(entity)?Result.ok():Result.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果想要<strong>自定义数据校验的规则，可以使用@Pattern注解，其中的regexp属性支持正则表达式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(value = &quot;检索首字母&quot;)</span></span><br><span class="line"><span class="meta">@NotEmpty</span></span><br><span class="line"><span class="meta">@Pattern(regexp = &quot;/^[a-zA-Z]$/&quot;,message = &quot;检索首字母必须是一个字母&quot;)</span><span class="comment">//自定义的数据校验，可以写正则表达式</span></span><br><span class="line"><span class="keyword">private</span> String firstLetter;</span><br></pre></td></tr></table></figure></li><li><p>依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-validator.version</span>&gt;</span>6.0.16.Final<span class="tag">&lt;/<span class="name">hibernate-validator.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--JSR303规范的数据校验实现--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate-validator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="分组数据校验"><a href="#分组数据校验" class="headerlink" title="分组数据校验"></a>分组数据校验</h3><ul><li><p>适用于多场景下的复杂校验</p></li><li><p>上面的校验方式有点问题，那就是<strong>如果我们想要在不同的业务场景下用不同的校验规则，那怎么办呢？</strong>就比如说在我save数据的时候我想要上面那套校验规则，但是现在我想设置一套update数据的校验规则，那该怎么办呢？基于这种情况，我们可以使用分组的数据校验。</p></li><li><p>首先我们<strong>创建一些空接口来标识不同的场景，也就是表示不同的分组</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.valid;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 19:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AddGroup</span> &#123;<span class="comment">//校验数据时的对应增加数据的情况的分组，只是一个标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.valid;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 19:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UpdateGroup</span> &#123;<span class="comment">//校验数据时的对应更新数据的情况的分组，只是一个标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后我们<strong>根据需要给实体类属性上的数据校验注解的groups属性赋值，表示这个数据校验注解在什么分组下生效</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(value = &quot;品牌id&quot;)</span></span><br><span class="line"><span class="meta">@TableId(value = &quot;brand_id&quot;, type = IdType.ASSIGN_ID)</span></span><br><span class="line"><span class="meta">@NotNull(message = &quot;修改必须指定品牌id&quot;,groups = UpdateGroup.class)</span></span><br><span class="line"><span class="meta">@Null(message = &quot;新增不能指定品牌id&quot;,groups = AddGroup.class)</span></span><br><span class="line"><span class="keyword">private</span> String brandId;</span><br></pre></td></tr></table></figure></li><li><p>最后我们<strong>在controller的参数中使用<code>@Validated(&#123;分组接口1.class,...&#125;)</code>注解来表示对被修饰的数据是以什么分组来进行校验，只有对应分组的数据校验注解会在这次数据校验中生效</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@Validated(&#123;AddGroup.class&#125;)</span> <span class="meta">@RequestBody</span> PmsBrand entity)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pmsBrandService.save(entity)?Result.ok():Result.error();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果属性上的<strong>数据校验注解没有指定groups，那么在参数中指定以某个分组进行数据校验的时候，没有指定groups的数据校验注解就无效</strong>。</p></li></ul><h3 id="自定义数据校验"><a href="#自定义数据校验" class="headerlink" title="自定义数据校验"></a>自定义数据校验</h3><ul><li><p>有时提供的数据校验注解无法很好的完成任务，这个时候我们就需要自定义数据校验逻辑来满足我们的需求。</p></li><li><p>首先我们需要<strong>编写一个自定义的校验注解，包括自定义的错误信息配置文件</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.valid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.TYPE_USE;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 20:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span><span class="comment">//与生成java文档相关，被这个元注解修饰的注解可以被很好地显示在文档中</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123; &#125;)</span><span class="comment">//该校验注解使用哪些校验器进行校验，可以绑定多个校验器以适配不同的场景</span></span><br><span class="line"><span class="meta">@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span><span class="comment">//该注解可以标识在哪些位置</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span><span class="comment">//让该注解在运行时能被获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListValue &#123;<span class="comment">//用来校验数据是否是指定的数据集中的数据</span></span><br><span class="line">    <span class="comment">//注解的属性就是在写注解的时候可以在小括号中指定的那些属性</span></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;com.konjacer.mallisland.common.valid.ListValue.message&#125;&quot;</span>;<span class="comment">//错误信息去哪取，默认是从classpath下的ValidationMessages.properties配置文件中取，我们可以自己写一个这样的配置文件放在classpath下，让它从我们自己的配置文件中取对应的值</span></span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//分组数据校验功能，若指定了分组，则该注解只对指定分组的数据校验生效</span></span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//和负载相关</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] vals() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//指定校验数据可以是哪些数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ValidationMessages.properties</span></span><br><span class="line"><span class="attr">com.konjacer.mallisland.common.valid.ListValue.message</span>=<span class="string">必须提交指定的值</span></span><br></pre></td></tr></table></figure></li><li><p>然后我们需要<strong>编写一个自定义的校验器</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.valid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 20:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListValueConstraintValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;ListValue,Integer&gt; &#123;<span class="comment">//实现接口的第一个类型参数是用在哪个注解上，第二个是处理什么类型的数据</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//用来判断数据在不在给定的数据中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ListValue constraintAnnotation)</span> &#123;<span class="comment">//初始化方法</span></span><br><span class="line">        <span class="comment">//ConstraintValidator.super.initialize(constraintAnnotation);</span></span><br><span class="line">        <span class="type">int</span>[] vals = constraintAnnotation.vals();<span class="comment">//获取在使用注解时传入的数据，是从ListValue注解中拿到的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> val : vals)&#123;</span><br><span class="line">            set.add(val);<span class="comment">//把给定的数据给set</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 需要校验的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context context in which the constraint is evaluated</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否校验成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(Integer value, ConstraintValidatorContext context)</span> &#123;<span class="comment">//判断是否校验成功</span></span><br><span class="line">        <span class="keyword">return</span> set.contains(value);<span class="comment">//判断被修饰的属性的值在不在给定的数据中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后我们应该<strong>关联自定义的校验器和自定义的校验注解</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.valid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.TYPE_USE;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 20:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span><span class="comment">//与生成java文档相关，被这个元注解修饰的注解可以被很好地显示在文档中</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123;ListValueConstraintValidator.class&#125;)</span><span class="comment">//该校验注解使用哪些校验器进行校验，可以绑定多个校验器以适配不同的场景</span></span><br><span class="line"><span class="meta">@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span><span class="comment">//该注解可以标识在哪些位置</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span><span class="comment">//让该注解在运行时能被获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListValue &#123;<span class="comment">//用来校验数据是否是指定的数据集中的数据</span></span><br><span class="line">    <span class="comment">//注解的属性就是在写注解的时候可以在小括号中指定的那些属性</span></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;com.konjacer.mallisland.common.valid.ListValue.message&#125;&quot;</span>;<span class="comment">//错误信息去哪取，默认是从classpath下的ValidationMessages.properties配置文件中取，我们可以自己写一个这样的配置文件放在classpath下，让它从我们自己的配置文件中取对应的值</span></span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//分组数据校验功能，若指定了分组，则该注解只对指定分组的数据校验生效</span></span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//和负载相关</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] vals() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//指定校验数据可以是哪些数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="NotBlank、-NotNull、-NotEmpty、-NonNull四者之间的区别"><a href="#NotBlank、-NotNull、-NotEmpty、-NonNull四者之间的区别" class="headerlink" title="@NotBlank、@NotNull、@NotEmpty、@NonNull四者之间的区别"></a>@NotBlank、@NotNull、@NotEmpty、@NonNull四者之间的区别</h3><p>1.@NotNull：<strong>一般用在基本类型上</strong>，不能为null，但可以为空字符串</p><p>2.@NotEmpty：<strong>一般用在集合类上</strong>，不能为null，并且长度必须大于0</p><p>3.@NotBlank：<strong>只能作用在String上</strong>，不能为null，而且调用trim()后（去掉头尾空格），长度必须大于0</p><p>4.@NonNull：<strong>在方法或构造函数的参数上使用，</strong>生成一个空值检查语句</p><h3 id="Validated注解和-Valid注解的区别"><a href="#Validated注解和-Valid注解的区别" class="headerlink" title="@Validated注解和@Valid注解的区别"></a>@Validated注解和@Valid注解的区别</h3><h2 id="项目中的系统状态码使用规范"><a href="#项目中的系统状态码使用规范" class="headerlink" title="项目中的系统状态码使用规范"></a>项目中的系统状态码使用规范</h2><ul><li>状态码应该是一个<strong>5位的数字</strong></li><li>状态码的<strong>前两位表示业务场景或者对应的模块，最后三位表示状态类型</strong>，比如：01200可以定义为向01场景的请求成功。</li><li>应该<strong>将状态码定义为枚举类型</strong>，<strong>在封装统一返回类型的对象时，不要使用数字、字符串等的字面量，应该使用状态码枚举类中定义过的对象</strong>。</li></ul><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><ul><li><p>让各个方法来处理异常未免有点太过于繁琐，所以可以设置一个异常处理中心，<strong>所有的异常均由这个异常处理中心进行处理</strong>，实际上也是一个解耦的思想，将异常处理和具体业务方法解耦，在这个异常处理中心中可以<strong>写方法和具体的异常进行绑定，这样每当对应的异常被抛出，异常中心对应的方法就会将对应的异常处理掉</strong>。</p></li><li><p>除了设置相对精确的异常和方法的映射外，<strong>对于没有方法与之对应的异常，我们应该写一个方法对他们进行兜底处理</strong>，如果没有匹配到任何一个异常处理方法，那就使用兜底的方法。</p></li><li><p>结合上面写的数据校验的处理，我们认为<strong>将数据校验的处理放到controller中是非常繁琐的，所以我们可以考虑将其迁移到异常处理中心中做统一的处理</strong>，<strong>由于数据校验失败的时候会抛异常，所以我们只要针对对应的异常绑定对应的处理方法就行了</strong>，这样我们在controller中就可以只关注于处理业务请求，而无需分心在处理数据校验失败的情况了。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.mallisland.commonutils.Result;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.mallisland.commonutils.ResultCode;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindingResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ValidationException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 17:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &quot;com.konjacer.mallisland.product.controller&quot;)</span><span class="comment">//注册为异常处理中心并且返回的数据转换为json，参数配置的是异常处理中心生效范围</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallislandExceptionHandler</span> &#123;<span class="comment">//统一处理所有的异常</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span><span class="comment">//指定处理什么异常</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">VaildExceptionHandler</span><span class="params">(MethodArgumentNotValidException exception)</span>&#123;<span class="comment">//指定的异常被抛出时这个方法就会处理它</span></span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> exception.getBindingResult();<span class="comment">//获取参数校验结果</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取所有元素校验的错误结果</span></span><br><span class="line">        bindingResult.getFieldErrors().forEach(item-&gt;&#123;</span><br><span class="line">            <span class="comment">//获取到错误信息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> item.getDefaultMessage();</span><br><span class="line">            <span class="comment">//获取错误的属性的名字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> item.getField();</span><br><span class="line">            map.put(field,message);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> Result.error()</span><br><span class="line">                .code(ResultCode.VALID_ERROR.getCode())</span><br><span class="line">                .message(ResultCode.VALID_ERROR.getMessage())</span><br><span class="line">                .data(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Throwable.class)</span><span class="comment">//如过没有找到对应的异常处理方法就兜底处理</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">ExceptionHandler</span><span class="params">(Throwable throwable)</span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;错误：&quot;</span>,throwable);<span class="comment">//日志输出具体的异常信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.error()</span><br><span class="line">                .code(ResultCode.UNKNOW_ERROR.getCode())</span><br><span class="line">                .message(ResultCode.UNKNOW_ERROR.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置实体类字段自动填充后没有效果"><a href="#配置实体类字段自动填充后没有效果" class="headerlink" title="配置实体类字段自动填充后没有效果"></a>配置实体类字段自动填充后没有效果</h2><ul><li><p>自动填充的相关注解有：**<code>@TableField(fill = FieldFill.INSERT)</code>、<code>@TableField(fill = FieldFill.UPDATE)</code>、<code>@TableField(fill = FieldFill.INSERT_UPDATE)</code>、<code>@TableField(fill = FieldFill.DEFAULT)</code><strong>，他们分别代表：</strong>插入时填充、更新时填充、插入和更新时填充、默认不填充**。</p></li><li><p>除了写注解之外，还需要进行配置，<strong>需要新建一个实现MetaObjectHandler接口的类，然后在其中配置自动填充的规则，并将该类注册到IOC容器中</strong>，然后自动填充的注解才能生效。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-03 15:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;<span class="comment">//配置被插入时自动填充的注解修饰的属性自动填充的值</span></span><br><span class="line">        <span class="comment">//用属性名称而不是字段名称</span></span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;gmtCreate&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;gmtModified&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;isDeleted&quot;</span>,<span class="number">0</span>,metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;<span class="comment">//配置被更新时自动填充的注解修饰的属性自动填充的值</span></span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;gmtModified&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2023-x2F-1-x2F-5"><a href="#2023-x2F-1-x2F-5" class="headerlink" title="2023&#x2F;1&#x2F;5"></a>2023&#x2F;1&#x2F;5</h1><h2 id="SPU和SKU"><a href="#SPU和SKU" class="headerlink" title="SPU和SKU"></a>SPU和SKU</h2><h3 id="SPU（Standard-Product-Unit-标准化产品单元）"><a href="#SPU（Standard-Product-Unit-标准化产品单元）" class="headerlink" title="SPU（Standard Product Unit 标准化产品单元）"></a>SPU（Standard Product Unit 标准化产品单元）</h3><ul><li>是商品信息聚合的最小单位，是一组可复用、易于检索的标准化信息的集合，该集合描述了一个产品的特性。</li><li>比如红米Note9 pro 1亿像素摄像头 钛合金外壳 产自于中国…这些信息就是SPU，是一个产品的<strong>基本属性（规格参数）</strong>，因为任何一个红米Note9 pro手机都拥有以上特性，我们用这些信息聚合成了一个产品。</li><li>可以通过SPU的属性值来对具体产品进行搜索。</li></ul><h3 id="SKU（Stock-Keeping-Unit-最小库存单元）"><a href="#SKU（Stock-Keeping-Unit-最小库存单元）" class="headerlink" title="SKU（Stock Keeping Unit 最小库存单元）"></a>SKU（Stock Keeping Unit 最小库存单元）</h3><ul><li>上面SPU还有一些没有提到的特性，比如手机的颜色、内存等，这些属性都不是产品固定的，而是可以选择的，也叫<strong>销售属性</strong>，比如我可以选择内存是8g，颜色是蓝色，这些属性一旦被具体确定下来，那么这个具体的产品就是一个SKU，可以直接通过这些属性的值定位到库存中的具体存货。</li></ul><h2 id="JsonInclude注解"><a href="#JsonInclude注解" class="headerlink" title="@JsonInclude注解"></a>@JsonInclude注解</h2><ul><li>可以用在实体类的属性上，来标识这个实体类属性在什么条件下才可以被转换为json数据，比如**<code>@JsonInclude(JsonInclude.Include.NON_EMPTY)</code><strong>就标识</strong>当被其修饰的属性不为空的时候，那个属性才会被转换成json数据的一部分，如果为空，那么最后返回的json数据中就不包含这个字段**。</li><li>还有其他参数，可以看源码。</li></ul><h1 id="2023-x2F-1-x2F-6"><a href="#2023-x2F-1-x2F-6" class="headerlink" title="2023&#x2F;1&#x2F;6"></a>2023&#x2F;1&#x2F;6</h1><h2 id="EnableTransactionManagement"><a href="#EnableTransactionManagement" class="headerlink" title="@EnableTransactionManagement"></a>@EnableTransactionManagement</h2><ul><li>可以在配置类中写上这个注解，表示<strong>开启事务功能</strong>，<strong>之后可以通过在访问数据库的方法上添加<code>@Transactional</code>注解来标识该方法是事务方法，可以对里面操作数据库的部分新建一个事务来进行处理</strong>。</li><li>如果只添加@Transactional注解无法生效，需要用@EnableTransactionManagement注解开启事务功能才能生效。</li><li>大部分功能都是需要先用注解开启，然后使用相应注解才生效的。</li></ul><h2 id="数据库表的冗余存储"><a href="#数据库表的冗余存储" class="headerlink" title="数据库表的冗余存储"></a>数据库表的冗余存储</h2><ul><li>在进行数据存储的时候，<strong>为了避免多次单表查询带来的性能问题，我们可以将一些常用字段冗余存储到某一张表中，但是这样做必须保证增删改的时候，要保证数据的一致性</strong>，不能表里的数据都删了，冗余字段还有那个被删的数据，这样是不对的，所以对关联表进行增删改的时候要注意将数据同步到别的表的冗余字段中。</li></ul><h2 id="不要使用多表联查"><a href="#不要使用多表联查" class="headerlink" title="不要使用多表联查"></a>不要使用多表联查</h2><ul><li>使用笛卡尔积的多表联查对于效率来说是毁灭性打击。</li></ul><h2 id="target目录下没有mapper的xml文件"><a href="#target目录下没有mapper的xml文件" class="headerlink" title="target目录下没有mapper的xml文件"></a>target目录下没有mapper的xml文件</h2><ul><li><p>这个问题我找了好几个小时才解决，解决的过程中我对服务的运行又有了新的认识。</p></li><li><p>问题出现在我在启动服务之后测试自己写的sql语句，在调用mapper的时候它报错，大意就是没有找到和mapper绑定的xml文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.ibatis.binding.BindingException: Invalid bound statement (not found) ......</span><br></pre></td></tr></table></figure></li><li><p>然后因为项目运行的时候，环境实际上是和开发环境的目录不一样嘛，<strong>服务运行的时候是用的target输出目录下的目录结构</strong>，然后我就去target下找，找到mapper目录后一看，xml文件一个都没导入进来，那运行的时候找不到xml文件也就不难理解了。</p></li><li><p>我这开发时目录结构好像和主流的方案不太一样，我这个mapper的xml文件没有放到resources目录下，我这用代码生成器生成的，xml文件全在mapper目录下放着，如果要是xml文件在resouces目录下，根据maven的默认build策略，这些xml文件应该会被build在运行时环境的classes目录下（我也不确定，之后验证一下回来改）。但是我这xml文件在java路径下放着，<strong>根据maven的默认build策略，maven只会把java路径下的所有java文件给build，别的文件不会被build，所以xml文件全没被build</strong>。</p></li><li><p>那么怎么样才能让xml文件被build呢？主要是<strong>需要在服务对应的pom文件中的build标签中写明在build的时候需要额外添加一些什么文件，maven在build项目的时候默认只会把java目录下的java文件给build，所以我们应该显式告诉它java目录下的xml文件也需要被build</strong>，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果不配置resource，mapper.xml文件不会被加载到target，就会报找不到的错误。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置打包规则，告诉maven在java目录下还要额外build什么文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果有了上面的配置，原本默认的将resource中的文件打包操作就会被覆盖掉，所以需要手动指定--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--打包规则，打包时将resource文件夹下的配置文件排除，注意只有打包的时候使用，平时要注释掉--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- &lt;excludes&gt;--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--      &lt;exclude&gt;**/*.properties&lt;/exclude&gt;--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--      &lt;exclude&gt;**/*.yml&lt;/exclude&gt;--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--      &lt;exclude&gt;**/*.yaml&lt;/exclude&gt;--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- &lt;/excludes&gt;--&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>这样xml文件就被build到classes文件中了，位置和开发时的位置相同，但是，重新启动服务之后，测试接口，发现还是有问题，还是报同样的错误，所以我推断<strong>可能是mybatis-plus找xml文件位置的默认配置的问题，mp默认配置找xml文件的目录是<code>classpath*:/mapper/**/*.xml</code>，这意味着它会找所有包的classes目录下的mapper目录下的所有子目录下的xml文件，但是我这些xml文件不在这个路径下，所以应该将其改成<code>classpath:/**/mapper/**/*.xml</code>，因为mapper目录不直接在classes根目录下，所以classes目录和mapper目录之间应该用<code>**</code>来表示</strong>，改完之后就能正常运行了：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置mybatis-plus的mapper的xml文件的位置，默认是classpath*:/mapper/**/*.xml，classpath后面的*代表除了自己的classpath，引入的jar包的classpath也会被检索</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/**/mapper/**/*.xml</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="java-Object的划分"><a href="#java-Object的划分" class="headerlink" title="java Object的划分"></a>java Object的划分</h2><h3 id="PO（persistent-object）持久对象"><a href="#PO（persistent-object）持久对象" class="headerlink" title="PO（persistent object）持久对象"></a>PO（persistent object）持久对象</h3><ul><li>PO就是<strong>对应数据库中某个表中的一条记录，多个记录可以用PO的集合</strong>，PO中应该不包含任何对数据库的操作。</li></ul><h3 id="DO（Domain-Object）领域对象"><a href="#DO（Domain-Object）领域对象" class="headerlink" title="DO（Domain Object）领域对象"></a>DO（Domain Object）领域对象</h3><ul><li>就是<strong>从现实世界中抽象出来的有形或者无形的业务实体</strong>。</li></ul><h3 id="TO（Transfer-Object）数据传输对象"><a href="#TO（Transfer-Object）数据传输对象" class="headerlink" title="TO（Transfer Object）数据传输对象"></a>TO（Transfer Object）数据传输对象</h3><ul><li><strong>不同的应用程序之间传输的对象</strong></li></ul><h3 id="DTO（Data-Transfer-Object）数据传输对象"><a href="#DTO（Data-Transfer-Object）数据传输对象" class="headerlink" title="DTO（Data Transfer Object）数据传输对象"></a>DTO（Data Transfer Object）数据传输对象</h3><ul><li>这个概念来源于J2EE的设计模式，原来的目的是为了EJB 的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，<strong>泛指用于展示层与服务层之间的数据传输的对象</strong>。</li></ul><h3 id="VO（Value-Object-x2F-View-Object）值对象-x2F-视图对象"><a href="#VO（Value-Object-x2F-View-Object）值对象-x2F-视图对象" class="headerlink" title="VO（Value  Object&#x2F;View Object）值对象&#x2F;视图对象"></a>VO（Value  Object&#x2F;View Object）值对象&#x2F;视图对象</h3><ul><li>通常用于业务层之间的数据传递，和 PO一样也是仅仅包含数据而已。但应是<strong>抽象出的业务对象，可以和表对应，也可以不</strong>，这根据业务的需要。用new关键字创建，由GC回收的。</li><li>或者叫View Object视图对象，vo的结构由具体的业务视图决定。</li><li>接收页面传递来的数据，封装成对象；将业务处理完成的对象，封装成页面要用的数据，都是VO。</li></ul><h3 id="BO（business-object）业务对象"><a href="#BO（business-object）业务对象" class="headerlink" title="BO（business object）业务对象"></a>BO（business object）业务对象</h3><ul><li>从业务模型的角度看，见 UML元件领域模型中的领域对象。封装业务逻辑的java对象，通过调用DAO方法，结合PO,VO进行业务操作。business object:业务对象，主要作用是<strong>把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象</strong>。比如一个简历，有教育经历、工作经历、社会关系等等。我们可以把教育经历对应一个 PO，工作经历对应一个PO，社会关系对应一个 PO。建立一个对应简历的 BO对象处理简历，每个BO包含这些PO。这样处理业务逻辑时，我们就可以针对BO去处理。</li></ul><h3 id="POJO（plain-ordinary-java-object）简单无规则java对象"><a href="#POJO（plain-ordinary-java-object）简单无规则java对象" class="headerlink" title="POJO（plain ordinary java object）简单无规则java对象"></a>POJO（plain ordinary java object）简单无规则java对象</h3><ul><li>传统意义的 java对象。就是说在一些Object&#x2F;Relation Mapping工具中，能够做到维护数据库表记录的 PO完全是一个符合Java Bean规范的纯 Java对象，没有增加别的属性和方法。我的理解就是最基本的 java Bean ，只有属性字段及setter和 getter方法。</li><li>POJO是 DO&#x2F;DTO&#x2F;BO&#x2F;VO 的统称。</li></ul><h3 id="DAO（data-access-object）数据访问对象"><a href="#DAO（data-access-object）数据访问对象" class="headerlink" title="DAO（data access object）数据访问对象"></a>DAO（data access object）数据访问对象</h3><ul><li>是一个 sun 的一个标准 J2EE设计模式，这个模式中有个接口就是DAO，它负责持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和PO 结合使用，DAO中包含了各种数据库的操作方法。通过它的方法，结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO，提供数据库的CRUD 操作。</li></ul><h2 id="复制VO的数据到Entity"><a href="#复制VO的数据到Entity" class="headerlink" title="复制VO的数据到Entity"></a>复制VO的数据到Entity</h2><ul><li>可以<strong>使用spring包中的BeanUtils工具类的copyProperties方法，可以将VO中的元素赋值给Entity，不过要注意，只有具有相同名称的属性才会被赋值，名字不相同或者不存在的属性都不会被赋值</strong>。</li></ul><h1 id="2023-x2F-1-x2F-7"><a href="#2023-x2F-1-x2F-7" class="headerlink" title="2023&#x2F;1&#x2F;7"></a>2023&#x2F;1&#x2F;7</h1><h2 id="使用符合场景的wrapper"><a href="#使用符合场景的wrapper" class="headerlink" title="使用符合场景的wrapper"></a>使用符合场景的wrapper</h2><ul><li>查询的时候用QueryWrapper，更新的时候用UpdateWrapper。</li></ul><h2 id="使用-RequestParam接收query参数"><a href="#使用-RequestParam接收query参数" class="headerlink" title="使用@RequestParam接收query参数"></a>使用@RequestParam接收query参数</h2><ul><li><p>可以指定或不指定value参数来接收单个对应的query参数，如果指定value，则将和value名称相同的query参数的值赋值给注解修饰的属性，如果不指定value，则将和被修饰的变量名称相同的query参数的值赋值给被修饰的属性。也可以指定require的值，如果为true说明这个属性不能接收不到参数，如果为false，说明这个属性允许接收不到参数，默认为true：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestParam(value = &quot;page&quot;,required = false)</span> Long current</span><br></pre></td></tr></table></figure></li><li><p>也可以直接修饰一个Map&lt;String,String&gt;类型的属性params，query参数会全部放到那里面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestParam</span> Map&lt;String,String&gt; params</span><br></pre></td></tr></table></figure></li></ul><h2 id="Mapper中的selectCount方法"><a href="#Mapper中的selectCount方法" class="headerlink" title="Mapper中的selectCount方法"></a>Mapper中的selectCount方法</h2><ul><li>根据wrapper中的条件，统计符合条件的记录数量。</li></ul><h2 id="批量删除的动态sql"><a href="#批量删除的动态sql" class="headerlink" title="批量删除的动态sql"></a>批量删除的动态sql</h2><ul><li><p>可以用动态sql，遍历所有想要删除的数据的条件拼接在where后面，找到所有符合条件的数据一起删除：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;deleteBatchRelation&quot;</span>&gt;</span></span><br><span class="line">    UPDATE `pms_attr_attrgroup_relation` SET is_deleted=1 WHERE</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;entities&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">separator</span>=<span class="string">&quot; OR &quot;</span>&gt;</span></span><br><span class="line">        (attr_id=#&#123;item.attrId&#125; AND attr_group_id=#&#123;item.attrGroupId&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="每一层结构做了什么事"><a href="#每一层结构做了什么事" class="headerlink" title="每一层结构做了什么事"></a>每一层结构做了什么事</h2><ul><li>Controller用来处理请求，接收和校验数据</li><li>Service接收Controller传来的数据，进行业务逻辑的处理</li><li>Controller接收Service处理完的数据，封装与页面进行交互的VO</li></ul><h1 id="2023-x2F-1-x2F-8"><a href="#2023-x2F-1-x2F-8" class="headerlink" title="2023&#x2F;1&#x2F;8"></a>2023&#x2F;1&#x2F;8</h1><h2 id="基于OpenFeign的远程调用"><a href="#基于OpenFeign的远程调用" class="headerlink" title="基于OpenFeign的远程调用"></a>基于OpenFeign的远程调用</h2><ul><li><p>首先要使用Feign的远程调用功能要先<strong>在配置类中使用注解<code>@EnableFeignClients</code>开启这个功能，并指定远程调用接口的所在包目录，这一个注解的本质实际上是把指定位置的所有被@FeignClient注解修饰的bean注册到ioc容器中</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.konjacer.mallisland.product.feign&quot;)</span></span><br></pre></td></tr></table></figure></li><li><p>然后<strong>在对应的目录下创建接口，用对应的注解<code>@FeignClient</code>修饰这个接口，注解中的参数是被远程调用的服务在服务注册中心的服务名</strong>，这个远程调用可以过网关也可以不过网关，注意修改下面的uri就行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;mallisland-coupon&quot;)</span><span class="comment">//这是个声明式远程调用客户端，里面的方法远程调用了别的模块的方法，注解里面要指明想要调用的服务在服务注册中心里的名称</span></span><br></pre></td></tr></table></figure></li><li><p>然后<strong>在新建的接口中写远程调用的方法，用注解告知方法远程调用的路径，方法签名尽量和要调用的方法的签名相同</strong>，不过理论上<strong>在参数上用了<code>@RequestBody</code>注解的话，TO就会被转为json放到请求体中然后发送给远程服务，别的注解的效果类推</strong>，所以如果能保证接收方能接收发送方的json数据，那就没啥问题，不过方法签名还是尽量相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/coupon/sms-coupon/memberGetCoupons&quot;)</span><span class="comment">//地址要写全，就是通过这个地址来进行远程调用</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">memberGetCoupons</span><span class="params">(<span class="meta">@RequestBody</span> SpuBoundTo spuBoundTo)</span>;</span><br></pre></td></tr></table></figure></li><li><p>然后就可以<strong>在想用的地方注入对应的远程调用接口，然后通过注入的bean调用相应的方法来实现远程调用，不过一定要保证被调用的方法在服务注册中心中能找到</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">CouponFeignService couponFeignService;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SpuBoundTo</span> <span class="variable">spuBoundTo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpuBoundTo</span>();</span><br><span class="line">    couponFeignService.memberGetCoupons(spuBoundTo);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="在IDEA中同时启动多个服务"><a href="#在IDEA中同时启动多个服务" class="headerlink" title="在IDEA中同时启动多个服务"></a>在IDEA中同时启动多个服务</h2><ul><li><p>首先点击Edit Configurations：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230108173107813.png" alt="image-20230108173107813"></p></li><li><p>然后新建一个Compound：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230108173201032.png" alt="image-20230108173201032"></p></li><li><p>在新建的Compound中添加想要一起启动的服务，并且可以对他们的启动做自定义的配置：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230108173439649.png" alt="image-20230108173439649"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230108173502497.png" alt="image-20230108173502497"></p></li><li><p>之后启动对应的Compound就能同时启动多个服务了：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230108173552108.png" alt="image-20230108173552108"></p></li></ul><h2 id="配置json数据中日期数据的格式"><a href="#配置json数据中日期数据的格式" class="headerlink" title="配置json数据中日期数据的格式"></a>配置json数据中日期数据的格式</h2><ul><li><p>可以在springboot的配置文件中做以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#配置json数据中日期数据的格式</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="配置日志等级"><a href="#配置日志等级" class="headerlink" title="配置日志等级"></a>配置日志等级</h2><ul><li><p>可以在springboot的配置文件中做以下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#设置指定包下的日志级别</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    com.konjacer: info</span><br></pre></td></tr></table></figure></li></ul><h1 id="2023-x2F-1-x2F-10"><a href="#2023-x2F-1-x2F-10" class="headerlink" title="2023&#x2F;1&#x2F;10"></a>2023&#x2F;1&#x2F;10</h1><h2 id="linux中在命令上下载网络内容"><a href="#linux中在命令上下载网络内容" class="headerlink" title="linux中在命令上下载网络内容"></a>linux中在命令上下载网络内容</h2><ul><li>可以使用wget工具来进行下载，但是在使用wget之前需要使用**<code>sudo yum install wget</code>**安装wget</li><li>安装完之后通过**<code>wget &lt;url&gt;</code>**命令来从指定的url中下载文件</li></ul><h2 id="linux修改目录的权限"><a href="#linux修改目录的权限" class="headerlink" title="linux修改目录的权限"></a>linux修改目录的权限</h2><ul><li>可以使用**<code>sudo chmod -R 777 目录路径</code><strong>来将一个目录以及其中的所有子目录的文件改成最高权限777，</strong>-R是recursion递归的意思**，意思就是会递归地设置权限。</li></ul><h2 id="linux解压文件"><a href="#linux解压文件" class="headerlink" title="linux解压文件"></a>linux解压文件</h2><ul><li>可以使用unzip工具，没有可以用yum命令**<code>sudo yum install unzip</code>**下载一个。</li><li>通过**<code>unzip -d 目标目录 文件名</code>**命令来将指定文件解压到指定目录下。</li></ul><h1 id="2023-x2F-1-x2F-11"><a href="#2023-x2F-1-x2F-11" class="headerlink" title="2023&#x2F;1&#x2F;11"></a>2023&#x2F;1&#x2F;11</h1><h2 id="为什么有些包导入后里面的某些包和预期的不太一样"><a href="#为什么有些包导入后里面的某些包和预期的不太一样" class="headerlink" title="为什么有些包导入后里面的某些包和预期的不太一样"></a>为什么有些包导入后里面的某些包和预期的不太一样</h2><ul><li><p>可能是springboot项目的pom文件中对这些包有版本管理，导致这个版本传递到了后来的那些包中，要想修改，只需要<strong>先找到springboot的pom文件</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230111164504024.png" alt="image-20230111164504024"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230111164523772.png" alt="image-20230111164523772"></p></li><li><p>在springboot的pom文件中找到对应的那个包后<strong>将那个包的版本控制变量在当前项目的pom文件中进行重写即可</strong>。</p></li></ul><h2 id="ES中的nested类型"><a href="#ES中的nested类型" class="headerlink" title="ES中的nested类型"></a>ES中的nested类型</h2><ul><li>官方释义：这个nested类型是object一种数据类型，<strong>允许对象数组以相互独立的方式进行索引</strong></li><li>在设置一个索引（index）的映射（mapping）的时候，如果不将type设置成nested，那么这个属性在存放有结构的数据比如某种对象的时候，es在底层就会对这个对象进行扁平化处理，对象中相同的属性值会被一同放入到一个数组中进行维护，而查的时候也是基于那个维护的数组，这样做会产生很多问题。</li><li>所以为了防止有结构的属性被扁平化处理，在做映射的时候应该把存放非基本数据类型的数据的属性的type设置成nested。</li><li>在查询nested类型的数据的时候也不能和普通数据一样查询，要显示声明我要查的是nested类型的数据，详见官方文档。</li></ul><h2 id="ES的倒排索引"><a href="#ES的倒排索引" class="headerlink" title="ES的倒排索引"></a>ES的倒排索引</h2><ul><li>就是对一堆文本进行分词处理（把文本划分成词），然后记录每个分词在哪个文本中出现过，这样找的时候就能利用关键词来找到关键词出现过的文本了。（&#x2F;&#x2F;todo 至于分词怎么存。。。字典树？我暂时不清楚，之后清楚了再来改）</li></ul><h2 id="ES存储数据的结构"><a href="#ES存储数据的结构" class="headerlink" title="ES存储数据的结构"></a>ES存储数据的结构</h2><ul><li>最大的一层叫index也就是索引，再小一层叫type也就是类型（已经弃用，最好不要再用），再小一层叫doc也就是文档，每个文档就相当于mysql中的一个数据库中的一个表的一个记录，文档中还有各种各样的属性。</li></ul><h2 id="ES设置-x2F-修改索引的映射"><a href="#ES设置-x2F-修改索引的映射" class="headerlink" title="ES设置&#x2F;修改索引的映射"></a>ES设置&#x2F;修改索引的映射</h2><p>- </p><ul><li>索引的映射理论上来讲设置了之后是不能变的，所以如果想要修改索引的映射，方法就是重新创建一个索引，然后在新索引中设置想要的映射，然后做数据迁移，把之前索引的数据迁移到新索引中。</li></ul><h2 id="ES查询数据"><a href="#ES查询数据" class="headerlink" title="ES查询数据"></a>ES查询数据</h2><ul><li>通过DSL（结构化查询）语句来进行查询，es帮我们把功能都暴露成rest风格的接口了，所以如果我们想要查询ES中的数据，那么我们只需要写一个json格式的DSL来表明我们的需求，然后给ES服务发送相应的请求，那么ES就会回复给我们想要的数据。</li><li>具体DSL语句的写法可以参照官方文档。</li><li>一个复杂的DSL中可能同时存在：模糊匹配、过滤、排序、分页、高亮显示、聚合分析等要求，所以在学习的时候可以对准这几个部分来进行学习。</li></ul><h2 id="ES聚合分析"><a href="#ES聚合分析" class="headerlink" title="ES聚合分析"></a>ES聚合分析</h2><ul><li>对于聚合分析，实际上就是根据聚合条件来将查询到的数据进行逻辑分组，因为是逻辑分组，所以不同聚合之间肯定是可以有重复数据，聚合之中可以有子聚合，子聚合用的数据是父聚合的结果，要类比的话，就像mysql中的group by。</li></ul><h1 id="2023-x2F-1-x2F-12"><a href="#2023-x2F-1-x2F-12" class="headerlink" title="2023&#x2F;1&#x2F;12"></a>2023&#x2F;1&#x2F;12</h1><h2 id="统一返回类使用泛型处理的好处"><a href="#统一返回类使用泛型处理的好处" class="headerlink" title="统一返回类使用泛型处理的好处"></a>统一返回类使用泛型处理的好处</h2><ul><li>首先就是<strong>有更好的可读性</strong>，可以使开发人员一眼就能看出这个统一返回类中存放的是什么类型的数据。</li><li>再者就是<strong>方便数据的提取</strong>，如果要是统一返回类作为远程调用接口的返回值，那么我们拿到远程调用的结果后想要从统一返回类中将数据提取出来，如果不用泛型，那么为了提取其中的数据我们会进行一系列的显式类型转换操作，还有可能去判断类型的正确性，使用了泛型之后，这种的问题将不复存在，因为编译器自动帮你把这些活儿干了，如果我们将错误的数据放进去，编译都过不了，api的客户端拿到数据之后开箱即用，无需更多操作，提升了开发效率。</li></ul><h2 id="lambda表达式和stream流式编程中使用的外部变量必须为final"><a href="#lambda表达式和stream流式编程中使用的外部变量必须为final" class="headerlink" title="lambda表达式和stream流式编程中使用的外部变量必须为final"></a>lambda表达式和stream流式编程中使用的外部变量必须为final</h2><ul><li>经常会出现类似这样的错误：<code>Variable used in lambda expression should be final or effectively final</code>，这主要是因为在lambda表达式或者stream流式编程中使用了外部非final的变量，为什么会有这种规定呢？</li><li>这个具体原因我也不太清楚，不过大体上好像是为了保护数据的一致性而规定的。</li><li>所以以后在lambda表达式和stream流式编程中使用非final的外部变量的时候，要先在外面声明一个final的副本，然后在lambda表达式或stream流式编程中使用那个副本就可以了。</li></ul><h1 id="2023-x2F-1-x2F-13"><a href="#2023-x2F-1-x2F-13" class="headerlink" title="2023&#x2F;1&#x2F;13"></a>2023&#x2F;1&#x2F;13</h1><h2 id="SpringBoot整合ElasticSearch"><a href="#SpringBoot整合ElasticSearch" class="headerlink" title="SpringBoot整合ElasticSearch"></a>SpringBoot整合ElasticSearch</h2><ul><li><p>首先要引入依赖，依赖版本要和es的版本一致，如果出现写的版本一致，但是实际上引入的es版本不一致的情况，可以参照2023&#x2F;1&#x2F;11的”为什么有些包导入后里面的某些包和预期的不太一样“来在本地pom重写springboot的pom的properties中的对应包的version属性来解决：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">elasticsearch-rest-high-level-client.version</span>&gt;</span>7.4.2<span class="tag">&lt;/<span class="name">elasticsearch-rest-high-level-client.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--操作elasticsearch的java client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;elasticsearch-rest-high-level-client.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后在配置类中进行相关的配置，主要是<strong>构造Bean交给Spring和构造一个通用的设置项</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallislandElasticSearchConfig</span> &#123;<span class="comment">//elasticsearch的配置类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestOptions COMMON_OPTIONS;<span class="comment">//elasticsearch通用的设置项</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        RequestOptions.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> RequestOptions.DEFAULT.toBuilder();<span class="comment">//使用默认规则</span></span><br><span class="line"><span class="comment">//        builder.addHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + TOKEN);</span></span><br><span class="line"><span class="comment">//        builder.setHttpAsyncResponseConsumerFactory(</span></span><br><span class="line"><span class="comment">//                new HttpAsyncResponseConsumerFactory</span></span><br><span class="line"><span class="comment">//                        .HeapBufferedResponseConsumerFactory(30 * 1024 * 1024 * 1024));</span></span><br><span class="line">        COMMON_OPTIONS = builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">esRestClient</span><span class="params">()</span>&#123;<span class="comment">//创建Bean交给Spring</span></span><br><span class="line">        <span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;101.42.35.83&quot;</span>,<span class="number">9200</span>,<span class="string">&quot;http&quot;</span>)<span class="comment">//es的地址</span></span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后注入Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;<span class="comment">//用来操作es</span></span><br></pre></td></tr></table></figure></li><li><p>以一个批量保存为例，展示基本用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">productStatusUp</span><span class="params">(List&lt;SkuEsModel&gt; skuEsModels)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//给es中建立索引product,建立好映射关系</span></span><br><span class="line">    <span class="comment">//给es中保存这些数据</span></span><br><span class="line">    <span class="type">BulkRequest</span> <span class="variable">bulkRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">    skuEsModels.forEach(model-&gt;&#123;</span><br><span class="line">        <span class="comment">//构造保存请求并加入bulk请求中</span></span><br><span class="line">        <span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(EsConstant.IndexName.PRODUCT.getName());</span><br><span class="line">        indexRequest.id(model.getSkuId());<span class="comment">//设置id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> JSON.toJSONString(model);<span class="comment">//实体转json</span></span><br><span class="line">        indexRequest.source(source, XContentType.JSON);<span class="comment">//设置内容为json数据，记得设置内容类型（第二个参数）</span></span><br><span class="line">        bulkRequest.add(indexRequest);<span class="comment">//加入bulk批量操作中</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">BulkResponse</span> <span class="variable">bulkResponse</span> <span class="operator">=</span> restHighLevelClient.bulk(bulkRequest, MallislandElasticSearchConfig.COMMON_OPTIONS);<span class="comment">//bulk方法批量操作，记得第二个参数写配置在配置类中的通用设置</span></span><br><span class="line">    <span class="comment">//如果批量操作错误则处理错误</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> bulkResponse.hasFailures();<span class="comment">//是否有错误</span></span><br><span class="line">    List&lt;String&gt; collect = Arrays.stream(bulkResponse.getItems()).map(item-&gt; item.getId()).collect(Collectors.toList());</span><br><span class="line">    log.error(<span class="string">&quot;商品上架错误，上架错误的商品编号分别为：&#123;&#125;&quot;</span>,collect);</span><br><span class="line">    <span class="keyword">return</span> !b;<span class="comment">//取反返回更符合正常逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Feign的调用流程"><a href="#Feign的调用流程" class="headerlink" title="Feign的调用流程"></a>Feign的调用流程</h2><ol><li><p>构造请求数据，将对象转为json数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RequestTemplate</span> <span class="variable">template</span> <span class="operator">=</span> buildTemplateFromArgs.create(argv);</span><br></pre></td></tr></table></figure></li><li><p>发送请求进行执行，执行成功后会解码响应数据:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executeAndDecode(template);</span><br></pre></td></tr></table></figure></li><li><p>执行请求会有重试机制，在执行之前会new一个重试器，通过重试器的重试策略来决定是否重试，伪代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">   executeAndDecode(tempLate);</span><br><span class="line">       &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">               retryer.continueOrPropagate(e);</span><br><span class="line">           &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">               <span class="keyword">throw</span> ex;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">## 一个没有进行前后端分离的架构</span><br><span class="line"></span><br><span class="line">- 静态资源扔到nginx中，然后视图用模板引擎（模板引擎，这里特指用于Web开发的模板引擎，是**为了使用户界面与业务数据/内容分离而产生的**，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的文档。模板引擎的**基本机理就是替换/转换，将指定的标签转换为需要的业务数据，将指定的伪语句按照某种流程来变换输出**。）写好，**所有的静态资源去nginx中取**：</span><br><span class="line"></span><br><span class="line">  ![image-<span class="number">20230113193900265</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230113193900265.png)</span></span><br><span class="line"></span><br><span class="line">## 引入Thymeleaf模板引擎</span><br><span class="line"></span><br><span class="line">- 首先要引入依赖，版本最好和boot的版本一致：</span><br><span class="line"></span><br><span class="line">  ```xml</span><br><span class="line">  &lt;spring-boot-starter-thymeleaf.version&gt;<span class="number">2.3</span><span class="number">.4</span>.RELEASE&lt;/spring-boot-starter-thymeleaf.version&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!--thymeleaf模板引擎--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring-boot-starter-thymeleaf.version&#125;&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>在配置文件中关闭thymeleaf的缓存以在开发阶段保证其可见性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="comment">#关闭thymeleaf的缓存以在开发期间看到实时效果</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></li><li><p>SpringMVC的自动配置类WebMvcAutoConfiguration中默认约定静态资源都放在classpath的static&#x2F;public&#x2F;resources&#x2F;templates下，可以直接被访问到。</p></li><li><p>thymeleaf默认约定当controller方法返回string的时候，视图解析器会进行拼串处理，会定位资源到prefix+返回值+suffix，默认的prefix是“classpath:&#x2F;templates&#x2F;”，默认的suffix是“.html”，页面资源默认从templates中取。</p></li><li><p>为了保证项目结构的清晰，我们也约定，页面文件都放在templates下，然后页面用到的静态资源放到static下。</p></li><li><p>springboot约定，在访问项目的时候，如果有，会默认先找index.html页面来进行显示。</p></li><li><p>在开发时如果想要不重启服务器而实时更新页面，可以引入dev-tools使用热部署功能，修改完thymeleaf的页面后直接ctrl+shift+f9重新编译页面即可，如果是其他比如对配置的修改，还是手动重启下吧！不过开发后端的时候不建议开dev-tools，因为频繁的自动重启会使得开发效率低下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="2023-x2F-1-x2F-14"><a href="#2023-x2F-1-x2F-14" class="headerlink" title="2023&#x2F;1&#x2F;14"></a>2023&#x2F;1&#x2F;14</h1><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><ul><li><p><strong>正向代理服务器帮客户端去访问客户端想要访问的服务器，在收到结果之后再返回给客户端，也就是说正向代理服务器是在偏客户端这一边的</strong>。比如我想访问谷歌，但是我没办法直接访问到谷歌，所以我可以租一个正向代理服务器，每次我访问谷歌，我都会给那个正向代理服务器发送请求让那个正向代理服务器帮我去访问谷歌：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230114191838794.png" alt="image-20230114191838794"></p></li><li><p><strong>反向代理帮服务器接收客户端的请求，再把请求转发给对应的服务器，也就是反向代理服务器是在偏服务器这一边的</strong>。比如我要访问一个域名，这个域名可能是服务端的反向代理服务器的地址，是个公网ip，这样我就先访问到了服务端的反向代理服务器，然后反向代理服务器再帮我把我的请求转发给我真正想要访问的内网服务器，主打一个<strong>屏蔽内网服务器的信息和负载均衡地访问</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230114192302868.png" alt="image-20230114192302868"></p></li></ul><h2 id="nginx配置文件结构"><a href="#nginx配置文件结构" class="headerlink" title="nginx配置文件结构"></a>nginx配置文件结构</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230114200634788.png" alt="image-20230114200634788"></p><ul><li><p>查看nginx.conf文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到里面是没有server块的，这是因为其中使用到了include语句，server块在被include的文件中。</p></li><li><p>找到conf.d&#x2F;default.conf，也可以写别的扩展名为conf的文件，从上面的include语句中也能看出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  /var/log/nginx/log/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    proxy_pass   http://127.0.0.1;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    root           html;</span><br><span class="line">    #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    #    fastcgi_index  index.php;</span><br><span class="line">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">    #    include        fastcgi_params;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line">    # concurs with nginx&#x27;s one</span><br><span class="line">    #</span><br><span class="line">    #location ~ /\.ht &#123;</span><br><span class="line">    #    deny  all;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>server块中的server_name参数是干什么用的？每当我们从浏览器输入ip或者域名访问一个服务器的时候，http的请求报文中会携带一个host字段，这个字段就是记录着我们输入的ip或域名，而server_name会对请求报文中的host字段进行匹配，如果匹配成功，则会执行我们在下面指定的操作。</p></li></ul><h2 id="如何解决nginx转发的时候会丢掉原本请求报文的一些字段"><a href="#如何解决nginx转发的时候会丢掉原本请求报文的一些字段" class="headerlink" title="如何解决nginx转发的时候会丢掉原本请求报文的一些字段"></a>如何解决nginx转发的时候会丢掉原本请求报文的一些字段</h2><ul><li>nginx在对请求进行转发的时候会丢掉很多原本请求报文中存在的一些字段，比如host字段等，为了在nginx转发后获取这些字段，我们需要对nginx进行配置，可以在server块中的location块中使用<code>proxy_pass url</code>来设置满足条件的请求转发到哪里，通常配合和server同级的upstream块使用；使用<code>proxy_set_header Host $host;</code>来给转发的请求加头的Host字段，$host是取出当前请求的host字段的值。</li></ul><h2 id="使用nginx搭建域名访问环境"><a href="#使用nginx搭建域名访问环境" class="headerlink" title="使用nginx搭建域名访问环境"></a>使用nginx搭建域名访问环境</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230114205112366.png" alt="image-20230114205112366"></p><h2 id="通过JMeter压力测试来尝试对项目进行优化"><a href="#通过JMeter压力测试来尝试对项目进行优化" class="headerlink" title="通过JMeter压力测试来尝试对项目进行优化"></a>通过JMeter压力测试来尝试对项目进行优化</h2><ul><li><p>JMeter去apache官网下一个就行，选择编辑-添加-线程（用户）-线程组来添加一组测试，配置线程属性后，右键那个新建的测试可以选择添加一些取样器和监听器，运行就点上面那个运行按钮，清除记录就点那些带扫帚的按钮：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115154428987.png" alt="image-20230115154428987"></p></li><li><p>对页面压测的时候可以勾选下图中的那个选项，来把加载静态资源的时间也统计在里面：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115170421371.png" alt="image-20230115170421371"></p></li><li><p>影响项目性能的考虑点包括：数据库、应用程序、中间件、网络和操作系统等方面</p></li><li><p>在进行优化前应该先考虑自己的应用属于CPU密集型（大量计算）还是IO密集型（大量IO），我记得线程池线程数量的设置也受这两种类型的影响，<strong>CPU密集型的线程数应该设置为N（核心线程数）+1，IO密集型的线程数应该设置为2N（核心线程数）</strong>：</p><blockquote><p><strong>如果我们设置的线程池数量太小的话，如果同一时间有大量任务&#x2F;请求需要处理，可能会导致大量的请求&#x2F;任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务&#x2F;请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</strong></p><p><strong>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</strong></p><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I&#x2F;O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p><p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p><hr><p>著作权归所有 原文链接：<a href="https://javaguide.cn/java/concurrent/java-thread-pool-summary.html">https://javaguide.cn/java/concurrent/java-thread-pool-summary.html</a></p></blockquote></li><li><p>对于CPU密集型应用的优化，我们可以尝试优化代码的逻辑和算法；对于IO密集型应用的优化，我们可以尝试优化代码逻辑，比如优化掉循环多次IO的代码。对于这两种应用有一种通用的优化方式，就是加强对应的硬件，CPU密集型就加强CPU、多CPU并发处理等，IO密集型就加强硬盘、内存，添加缓存等。</p></li><li><p>尝试让项目少进行Full GC（这里指old GC也就是只对老年代GC，有的时候Full GC还代指所有代的GC，这个就具体情况具体分析了），因为Full GC速度很慢</p></li></ul><h1 id="2023-x2F-1-x2F-15"><a href="#2023-x2F-1-x2F-15" class="headerlink" title="2023&#x2F;1&#x2F;15"></a>2023&#x2F;1&#x2F;15</h1><h2 id="在IDEA中给某个服务配置jvm参数"><a href="#在IDEA中给某个服务配置jvm参数" class="headerlink" title="在IDEA中给某个服务配置jvm参数"></a>在IDEA中给某个服务配置jvm参数</h2><ul><li><p>点击Edit Configurations：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115150549616.png" alt="image-20230115150549616"></p></li><li><p>在里面选择自己想要配置jvm参数的服务，在对应位置写上自己想要配置的参数即可：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115150702257.png" alt="image-20230115150702257"></p></li><li><p>配置堆的最大最小值时，分配的大小要接着命令的后面写，不要有空格，不要有冒号或等号，就是紧接着写，所以为啥要这样写呢，是有什么原因还是规定？</p></li></ul><h2 id="通过监视java进程以分析其各种指标从而做出优化"><a href="#通过监视java进程以分析其各种指标从而做出优化" class="headerlink" title="通过监视java进程以分析其各种指标从而做出优化"></a>通过监视java进程以分析其各种指标从而做出优化</h2><ul><li><p>可以使用jdk自带的工具<strong>jconsole和jvisualvm</strong>，推荐使用后者，后者是前者的加强版。</p></li><li><p>在配置了环境变量的情况下，在控制台直接输入jvisualvm来启动这个工具：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115153518894.png" alt="image-20230115153518894"></p></li><li><p>监视线程的部分如下图所示：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115153907989.png" alt="image-20230115153907989"></p><p>其中左下角的图例分别是：</p><p>运行：正在运行的线程</p><p>休眠：执行了sleep()方法的线程</p><p>等待：执行了wait()方法的线程，说明该线程正在等待其他线程的结果</p><p>驻留：线程池中空闲的线程</p><p>监视：被阻塞的线程，说明该线程正在等待别的线程释放锁以获得共享资源</p></li><li><p>如果还想让jvisualvm监视别的东西，比如gc，我们可以给jvisualvm安装插件，点击工具-插件，但是我们点击检查更新的时候可能会报无法连接的错误：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115154833965.png" alt="image-20230115154833965"></p><p>怎么解决呢？</p><p>首先我们去jvisualvm的插件官网：<a href="https://visualvm.github.io/pluginscenters.html%EF%BC%9A">https://visualvm.github.io/pluginscenters.html：</a></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115155229067.png" alt="image-20230115155229067"></p><p>查看我们装的jdk版本：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115155258812.png" alt="image-20230115155258812"></p><p>然后找到和我们的jdk版本匹配的url点进去，复制最上面的那个url：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115155428020.png" alt="image-20230115155428020"></p><p>然后回到jvisualvm的插件那里，点击设置-编辑，换上我们刚才复制的url后点确定：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115155540658.png" alt="image-20230115155540658"></p><p>然后就可以正常使用了。</p><p>选择自己想要安装的插件就可以了，这里主要是安装一下visual gc插件以监视gc的整个过程：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115155716557.png" alt="image-20230115155716557"></p><p>安装完后重启就能看到新的选项了：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115161309220.png" alt="image-20230115161309220"></p></li><li><p>从上图中也可以看到老年代Full GC（这里指old GC也就是只对老年代GC，有的时候Full GC还代指所有代的GC，这个就具体情况具体分析了）了3次花费的时间比新生代Eden区Minor GC了14次花费的时间还要长不少，这也印证了之前说的，老年代的GC效率很低，尽量少让老年代GC。</p></li></ul><h2 id="JVM分析与调优"><a href="#JVM分析与调优" class="headerlink" title="JVM分析与调优"></a>JVM分析与调优</h2><ul><li><p>在分析阶段，我们可以通过JMeter来对服务的各个环节来进行压测，最好是分成单独的压测和组合的压测，这样得到的结果可以汇总成一个表格，通过表格来判断我们应该从哪里着手进行优化：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115195332580.png" alt="image-20230115195332580"></p></li><li><p>中间件越多，性能损失越大，大多都损失在网络交互了，如果想要优化，可以先从中间件入手，优化中间件，提高中间件的吞吐量，再者可以从网络传输的部分入手，可以采用更好的网线、采用更高效的网络传输协议等</p></li><li><p>业务的优化可以考虑以下几个方面：DB（数据库）优化、静态资源访问优化、模板渲染速度优化（前后不分离的话）、业务逻辑优化（比如在循环中查表的问题）</p></li><li><p>对于数据库的优化，无非就是优化数据库查表的效率，<strong>数据量大的时候</strong>，对主键进行查询的时候效率比较高，那是因为主键有索引，对别的没有索引的字段进行查询的话，数据库会进行全表查询，在数据量比较大的时候这种查询的效率非常低，所以为了优化数据库的查询效率，我们可以<strong>考虑给查询得多的字段加上索引来加速查询</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115171845911.png" alt="image-20230115171845911"></p></li><li><p>有的时候通过jvisualvm可以看出来，整个服务的性能瓶颈出现在老年代的频繁GC，所以针对这个问题我们可以修改jvm的启动设置，手动给jvm设置内存：</p><ul><li>-Xmx用来设置堆的最大占用内存，例：<code>-Xmx100m</code></li><li>-Xms用来设置堆的最小占用内存，例：<code>-Xms100m</code></li><li>-Xmn用来设置堆中新生代的占用内存，JVM官方推荐新生代占整个堆的3&#x2F;8，其中Eden:S0:S1 &#x3D; 8:1:1，例：<code>-Xmn30m</code></li><li>未完待续……</li></ul></li></ul><h2 id="Nginx动静分离"><a href="#Nginx动静分离" class="headerlink" title="Nginx动静分离"></a>Nginx动静分离</h2><ul><li><p>为了对访问静态数据这一步进行优化，我们可以选择将静态资源全部放到nginx中，这样每当我们需要静态资源的时候，找nginx要就可以了，而不用发请求向后端要了，相当于把从nginx到后端的这段链路优化掉了，服务能腾出不少线程来专注为动态请求服务，能提升不少吞吐量：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115181112309.png" alt="image-20230115181112309"></p></li><li><p>所以以后可以将项目用到的所有静态资源全部放到nginx中，对静态资源的访问请求都应该由nginx直接返回。</p></li><li><p>首先把static下的文件全部放到服务器的nginx挂载的外部文件夹html中，这个文件夹是被nginx的保存静态资源的目录挂载的。</p></li><li><p>然后修改index.html中的访问静态资源的路径，都要在原路径前面加上一个&#x2F;static&#x2F;，这个&#x2F;static&#x2F;是准备在nginx中进行配置的，如果要是访问路径以&#x2F;static&#x2F;开头，那么nginx就要把请求转到指定的地方，所以这个&#x2F;static&#x2F;也可以自定义。</p></li><li><p>然后修改nginx的配置文件，主要就是加一个location做静态资源请求的转发映射：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以/static/开头的请求全部转到root下</span></span><br><span class="line">location /static/ &#123;</span><br><span class="line">    root   /usr/share/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>之后给ngxin发以&#x2F;static&#x2F;开头的静态资源请求，都会被nginx转发到nginx的静态资源目录中查找并返回对应的资源。</p></li></ul><h2 id="缓存的使用"><a href="#缓存的使用" class="headerlink" title="缓存的使用"></a>缓存的使用</h2><ul><li><p>当我们将大部分优化手段都做了一遍之后，如果还想提高系统的吞吐量，那么我们可以引入缓存，减少查数据库的次数。</p></li><li><p>哪些数据适合放入缓存？</p><ol><li><strong>即时性、数据一致性要求不高</strong>的</li><li><strong>访问量大且更新频率不高</strong>的数据（读多，写少）</li></ol></li><li><p>读缓存使用流程：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115224124283.png" alt="image-20230115224124283"></p></li><li><p>至于缓存的实现，可以是多种多样的，比如最简单的就是本地缓存，写个map装东西，在访问数据库之前先看看想要的数据在map中有没有，如果有就直接取，如果没有就查数据库，但是这样做会有很多问题，首先就是如果服务部署成一个集群，那么多个本地缓存的数据一致性难以保证，并且我们自己写的缓存很难有生产级别的缓存淘汰机制等，并且本地缓存和代码耦合度太高，后续难以维护，可读性也乏善可陈。</p></li><li><p>我们想要的缓存实现，应该是<strong>解耦的，稳定的，并且能在集群部署的情况下保证缓存之间的数据的一致性，并且应该有优秀的缓存淘汰算法可供我们进行选择</strong>。</p></li><li><p>综上所述，我们需要的应该是一个缓存中间件，所有服务更新缓存都是更新在中间件中，并且中间件还支持集群部署，这样就解决了缓存之间数据一致性的问题，中间件本身还是解耦的，并且还有多样的数据淘汰策略可供我们选择，缓存中间件有很多，redis挺好用，那就用redis。</p></li></ul><h1 id="2023-x2F-1-x2F-16"><a href="#2023-x2F-1-x2F-16" class="headerlink" title="2023&#x2F;1&#x2F;16"></a>2023&#x2F;1&#x2F;16</h1><h2 id="关于父项目管理子项目依赖的版本的问题"><a href="#关于父项目管理子项目依赖的版本的问题" class="headerlink" title="关于父项目管理子项目依赖的版本的问题"></a>关于父项目管理子项目依赖的版本的问题</h2><ul><li>如果父项目的dependency不写version，那么子项目是获取不到父项目的依赖版本的，即使是父项目的dependency的version能从它的父项目中得到，今天踩坑了&#x3D; &#x3D;。</li></ul><h2 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h2><ul><li><p>首先就是引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring-boot-starter-data-redis.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring-boot-starter-data-redis.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后就是在配置文件中进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment">#配置redis的主机地址和端口</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">111.111</span><span class="number">.111</span><span class="number">.111</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure></li><li><p>然后我们看看redis的AutoConfiguration类：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116151143755.png" alt="image-20230116151143755"></p><p>里面有两个注入到spring IOC容器中的bean，前者是和对象操作相关的，后者是和字符串操作相关的，我们<strong>使用缓存存放的数据一般都是json格式的数据</strong>，所以用后面的bean多一些。</p></li><li><p>使用StringRedisTemplate来操作redis，总的来说就是先获取对redis的某个数据结构的操作对象，然后再用那个获得的操作对象来执行一系列对于指定数据结构的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedis</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//获得对value的操作对象</span></span><br><span class="line">ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line"><span class="comment">//执行保存操作</span></span><br><span class="line">ops.set(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world_&quot;</span>+ UUID.randomUUID().toString());</span><br><span class="line"><span class="comment">//执行查询操作</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> ops.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;保存的key为hello的value是：&quot;</span>+hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以使用RedisDesktopManager软件来可视化地查看远端服务器上redis中存放的数据：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116154522095.png" alt="image-20230116154522095"></p></li><li><p>为了防止有人偷偷连上我们的redis做一些乱七八糟的操作，我们可以在redis的client中使用<code>config set requirepass 密码</code>设置密码，登录client的时候要使用<code>AUTH 密码</code>来进行登录，记得改一下RedisDesktopManager的客户端连接的设置，把那密码给写上，不然连不上；然后还要在项目的配置文件中设置一下spring.redis.password属性的值以让我们的项目也能成功连接上redis。</p></li><li><p>之后对于想要从数据库中查找符合存放在redis中要求的数据之前，要先检查一下缓存中有没有，如果有直接拿，如果没有再查数据库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTree</span><span class="params">()</span>&#123;<span class="comment">//给listWithTree方法加入缓存后的逻辑</span></span><br><span class="line">    <span class="comment">//给缓存中存放的是对象转成的json数据，拿出的也是json数据需要转成对象，有天然的跨平台性，这是序列化与反序列化的一种实现</span></span><br><span class="line">    <span class="comment">//尝试从redis中取想要的数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">catelogData</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;catelogData&quot;</span>);<span class="comment">//字面量按说应该抽成常量，这里只是为了方便</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(catelogData))&#123;<span class="comment">//如果redis中没有我们想要的数据，那么我们才从数据库中查,并将查到的结果加入缓存中</span></span><br><span class="line">        List&lt;PmsCategory&gt; result = listWithTreeFromDb();<span class="comment">//从数据库中查</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">store</span> <span class="operator">=</span> JSON.toJSONString(result);<span class="comment">//将结果转成json数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;catelogData&quot;</span>,store);<span class="comment">//将json数据存入redis</span></span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//返回从数据库中查到的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果redis中有我们想要的数据，那么我们可以反序列化之后直接使用</span></span><br><span class="line">    <span class="comment">//Json反序列化操作，注意第二个参数作为类型令牌的使用</span></span><br><span class="line">    List&lt;PmsCategory&gt; result = JSON.parseObject(catelogData,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;PmsCategory&gt;&gt;()&#123;&#125;);</span><br><span class="line">    log.info(<span class="string">&quot;是从redis中取的结果~&quot;</span>);</span><br><span class="line">    <span class="comment">//返回反序列化后的结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeFromDb</span><span class="params">()</span> &#123;<span class="comment">//原listWithTree方法</span></span><br><span class="line">    <span class="comment">//查出所有分类</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * baseMapper就相当于这个service对应的mapper，</span></span><br><span class="line"><span class="comment">     * 因为看上面继承了ServiceImpl，</span></span><br><span class="line"><span class="comment">     * 其中这个service对应的mapper被当作泛型的类型参数传进去了，</span></span><br><span class="line"><span class="comment">     * 而里面有个泛型参数类型的变量就是baseMapper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;PmsCategory&gt; data = baseMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//todo 组装成树形结构</span></span><br><span class="line">    <span class="comment">//找到所有的一级分类</span></span><br><span class="line">    List&lt;PmsCategory&gt; level1Menu = data.stream()</span><br><span class="line">            .filter(pmsCategory -&gt; pmsCategory.getParentCid().equals(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">            .map(menu -&gt; &#123;</span><br><span class="line">                menu.setChildren(getChildren(data,menu));</span><br><span class="line">                <span class="keyword">return</span> menu;</span><br><span class="line">            &#125;)</span><br><span class="line">            .sorted(Comparator.comparingInt(PmsCategory::getSort))<span class="comment">//Comparator封装了比较两个int变量的Comparator，直接传个方法引用告知其如何从元素中取得int变量即可</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> level1Menu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在对使用了缓存的方法进行压测的时候可能会出现的堆外内存溢出的问题：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116164117198.png" alt="image-20230116164117198"></p></li></ul><h2 id="高并发环境下缓存失效的问题"><a href="#高并发环境下缓存失效的问题" class="headerlink" title="高并发环境下缓存失效的问题"></a>高并发环境下缓存失效的问题</h2><h3 id="缓存穿透（大流量查一个不存在的数据）"><a href="#缓存穿透（大流量查一个不存在的数据）" class="headerlink" title="缓存穿透（大流量查一个不存在的数据）"></a>缓存穿透（大流量查一个不存在的数据）</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116165314128.png" alt="image-20230116165314128"></p><ul><li>就是查询一个不存在的数据，导致每次查询都要查数据库，缓存形同虚设，数据库的查询压力会增大，直至崩溃。所以针对数据库中不存在的结果，我们可以在查了数据库之后，<strong>把这个不存在的结果当作空值存在redis中并设置一定的过期时间</strong>，这样短时间内针对这个不存在的结果的查询，就会走缓存，数据库就不会有那么大的压力了。</li></ul><h3 id="缓存雪崩（流量高峰时缓存中的数据短时间内同时过期）"><a href="#缓存雪崩（流量高峰时缓存中的数据短时间内同时过期）" class="headerlink" title="缓存雪崩（流量高峰时缓存中的数据短时间内同时过期）"></a>缓存雪崩（流量高峰时缓存中的数据短时间内同时过期）</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116165905379.png" alt="image-20230116165905379"></p><h3 id="缓存击穿（热点数据在流量高峰期失效）"><a href="#缓存击穿（热点数据在流量高峰期失效）" class="headerlink" title="缓存击穿（热点数据在流量高峰期失效）"></a>缓存击穿（热点数据在流量高峰期失效）</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116170154726.png" alt="image-20230116170154726"></p><h2 id="分布式的情况下如何加锁"><a href="#分布式的情况下如何加锁" class="headerlink" title="分布式的情况下如何加锁"></a>分布式的情况下如何加锁</h2><ul><li><p>如果要是使用本地锁，使用this作为锁，那么作为单机应用来说是完全没有问题的，因为spring中的bean是单例的，可以保证每次的这个this是同一个对象。</p></li><li><p>但是如果要是分布式的情况下，不同的节点有不同的spring IOC容器，这样使用本地锁this无法将所有节点全部锁住，所以我们为了应对这个问题，可以使用分布式锁，不过这玩意儿性能比较低，其实仔细一想，如果分布式的情况下使用本地锁，无非也就是多放了几个请求进去嘛，无可厚非，所以这个分布式锁的使用情况就具体情况具体分析了，适用于那种大型分布式系统，那种集群节点很多的那种，如果能带来更高的性能就用，可以压测试试。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116171855477.png" alt="image-20230116171855477"></p></li><li><p>分布式锁基本原理，无非也就是把获取锁的这部分抽出来，怎么实现无所谓，关键是要和服务解耦：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116181622257.png" alt="image-20230116181622257"></p></li><li><p>我们可以使用redis的天然特性来去实现这个加锁操作，最简单的说就是每个线程到了redis，先set一个值，如果这个值没有设置，那么他设置了，他就可以进行下面的操作，如果要是值已经设置了，说明有线程已经到过了，那当前的线程就没有抢到锁，可以使用redis的命令setnx也就是指定的key没有值的情况下才进行set，不然就不进行set，这就是分布式锁的基本原理，类似于乐观锁：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116185358324.png" alt="image-20230116185358324"></p></li><li><p>上一个阶段中存在一个问题，如果出现问题导致redis锁没有释放，那么redis锁就一直不能被获取，就死锁了，也就是<strong>无法保证业务的原子性</strong>，针对这样的问题，我们可以给redis锁设置一个自动过期时间，一段时间过后，就算没有用程序将redis锁释放，过期时间到了锁就会被自动释放：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116190133025.png" alt="image-20230116190133025"></p></li><li><p>上个阶段中也有问题，万一在设置过期时间之前，突然断电了，那么过期时间没能设置，又死锁了，针对这种情况，我们可以把设置过期时间和获取锁的操作一起进行，让他们变成一个原子操作，这样就能解决这个问题：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116190717037.png" alt="image-20230116190717037"></p></li><li><p>上面这个阶段又有问题，问题出现在删除锁的情况下，万一一个持有锁的服务超时了，锁被自动释放掉了，然后别的线程拿到了锁，但是最后那个超时的服务又要执行删除锁的操作，这样就导致别人的锁被他删掉了，为了解决这个问题，我们给redis锁的值设置为uuid，这样每个人最后删除的时候总是尝试删除自己的锁：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116193241172.png" alt="image-20230116193241172"></p></li><li><p>上面这个阶段还是有问题，问题就在于我们无法保证最后获取锁的值并检查和释放锁这两个操作的原子性，这会导致什么后果呢，如果一个线程去redis查了自己的锁，在数据返回的时候，锁过期了，别的又加了锁，再之后这个数据到达本地，判断也通过了，就会执行释放锁的操作，又释放成别人的锁了。根据redis官方的说法，解决这个问题需要使用lua脚本以保证这些操作的一致性：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116193559497.png" alt="image-20230116193559497"></p></li><li><p>总结一下就是，使用redis做分布式锁，需要注意保证设置过期时间并加锁和检查是否是自己的锁并解锁的操作的原子性，还需要保证加锁的值是各线程特有的，前者是使用redis的语法保证原子性，后者是通过使用lua脚本保证原子性，以下是对之前代码的分布式锁实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTree</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listWithTreeByRedisLock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeByRedisLock</span><span class="params">()</span>&#123;<span class="comment">//用redis实现分布式锁，不过查出来的内容没放缓存呢还</span></span><br><span class="line">    <span class="comment">//分布式锁，去redis中set相同key的值，谁set成功了谁就拿到锁了，可以执行后面的内容，没拿到锁的进行睡眠并自旋，直到拿到锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();<span class="comment">//这是为了防止误删别人的锁，所以每个人设置锁的值都应该是唯一的，最后删除锁之前也要检查是不是自己的再删</span></span><br><span class="line">    <span class="comment">//尝试获取redis锁，使用的那个方法可以保证设置过期时间和设置值的操作是原子的，具体执行的语句应该是setnx Key Value EX 300 NX</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>,uuid,<span class="number">300</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;<span class="comment">//如果拿到了锁，就执行下面的操作</span></span><br><span class="line">        log.info(<span class="string">&quot;获取分布式锁成功&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> listWithTreeFromDb();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;<span class="comment">//在finally中解锁，保证锁会被解掉</span></span><br><span class="line">            <span class="comment">//保证了检查锁和解锁两个操作原子性的lua脚本</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">            <span class="comment">//删除锁,第一个参数是封装的脚本，泛型是返回值类型，redis删除成功返回1，删除不成功返回0，所以是个long，第二个参数是顺序的所有脚本中用到的key，第三个参数是顺序的所有脚本中用到的value</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">ifDeleted</span> <span class="operator">=</span> stringRedisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;Long&gt;(script,Long.class),Arrays.asList(<span class="string">&quot;lock&quot;</span>),uuid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果没有拿到锁，就睡眠并自旋</span></span><br><span class="line">        log.info(<span class="string">&quot;获取分布式锁失败，将在一定时间后重试&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;出现异常：&#123;&#125;&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listWithTreeByRedisLock();<span class="comment">//递归自旋，感觉不如提到前面做循环自旋，这个太占栈空间了。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeByLocalLock</span><span class="params">()</span>&#123;<span class="comment">//给listWithTree方法加入缓存后的逻辑,用的是本地锁</span></span><br><span class="line">    <span class="comment">//给缓存中存放的是对象转成的json数据，拿出的也是json数据需要转成对象，有天然的跨平台性，这是序列化与反序列化的一种实现</span></span><br><span class="line">    <span class="comment">//todo 空结果缓存：解决缓存穿透 随机过期时间：解决缓存雪崩 加锁：解决缓存击穿</span></span><br><span class="line">    <span class="comment">//尝试从redis中取想要的数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">catelogData</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;catelogData&quot;</span>);<span class="comment">//字面量按说应该抽成常量，这里只是为了方便</span></span><br><span class="line">    List&lt;PmsCategory&gt; result = <span class="literal">null</span>;<span class="comment">//最后要返回的结果</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(catelogData))&#123;<span class="comment">//如果redis中没有我们想要的数据，那么我们才从数据库中查,并将查到的结果加入缓存中</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;<span class="comment">//加本地锁以防止缓存穿透，把存入缓存的代码也放进来，防止缓存还没更新的时候下一个请求到了然后做出错误的判断</span></span><br><span class="line">            catelogData = stringRedisTemplate.opsForValue().get(<span class="string">&quot;catelogData&quot;</span>);<span class="comment">//再查一遍缓存用于双重校验</span></span><br><span class="line">            <span class="keyword">if</span>(!StringUtils.isEmpty(catelogData))&#123;<span class="comment">//双重校验，如果缓存中有数据了，就不用从数据库中查了</span></span><br><span class="line">                <span class="comment">//Json反序列化操作，注意第二个参数作为类型令牌的使用</span></span><br><span class="line">                result = JSON.parseObject(catelogData,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;PmsCategory&gt;&gt;()&#123;&#125;);</span><br><span class="line">                log.info(<span class="string">&quot;查redis~&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;查数据库~&quot;</span>);</span><br><span class="line">            result = listWithTreeFromDb();<span class="comment">//从数据库中查</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">store</span> <span class="operator">=</span> JSON.toJSONString(result);<span class="comment">//将结果转成json数据</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;catelogData&quot;</span>,store);<span class="comment">//将json数据存入redis</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//返回从数据库中查到的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果redis中有我们想要的数据，那么我们可以反序列化之后直接使用</span></span><br><span class="line">    <span class="comment">//Json反序列化操作，注意第二个参数作为类型令牌的使用</span></span><br><span class="line">    result = JSON.parseObject(catelogData,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;PmsCategory&gt;&gt;()&#123;&#125;);</span><br><span class="line">    log.info(<span class="string">&quot;查redis~&quot;</span>);</span><br><span class="line">    <span class="comment">//返回反序列化后的结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeFromDb</span><span class="params">()</span> &#123;<span class="comment">//原listWithTree方法</span></span><br><span class="line">    <span class="comment">//查出所有分类</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * baseMapper就相当于这个service对应的mapper，</span></span><br><span class="line"><span class="comment">     * 因为看上面继承了ServiceImpl，</span></span><br><span class="line"><span class="comment">     * 其中这个service对应的mapper被当作泛型的类型参数传进去了，</span></span><br><span class="line"><span class="comment">     * 而里面有个泛型参数类型的变量就是baseMapper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;PmsCategory&gt; data = baseMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//todo 组装成树形结构</span></span><br><span class="line">    <span class="comment">//找到所有的一级分类</span></span><br><span class="line">    List&lt;PmsCategory&gt; level1Menu = data.stream()</span><br><span class="line">            .filter(pmsCategory -&gt; pmsCategory.getParentCid().equals(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">            .map(menu -&gt; &#123;</span><br><span class="line">                menu.setChildren(getChildren(data,menu));</span><br><span class="line">                <span class="keyword">return</span> menu;</span><br><span class="line">            &#125;)</span><br><span class="line">            .sorted(Comparator.comparingInt(PmsCategory::getSort))<span class="comment">//Comparator封装了比较两个int变量的Comparator，直接传个方法引用告知其如何从元素中取得int变量即可</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> level1Menu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对于原子加锁和解锁我们可以抽取成工具类，但是分布式锁有更专业的工具，下面会介绍到。</p></li></ul><h2 id="本地锁的时序问题"><a href="#本地锁的时序问题" class="headerlink" title="本地锁的时序问题"></a>本地锁的时序问题</h2><ul><li><p>本地锁的范围一定要考虑清楚，就拿上面写的那个查数据库的逻辑来说，如果要是将结果放入缓存的操作在锁外面，那么在一个线程释放锁之后，另一个线程进入代码块并判断缓存中有没有数据，由于数据还没来得及放入缓存，所以这个地方自然是返回false，那这个线程就又查了一遍数据库，所以锁的范围一定要考虑清楚，应该把放缓存的代码放到加锁的代码块中。</p></li><li><p>而且如果要是放入缓存的操作只是发一个网络请求就向下执行的话，我们还应该考虑网络延迟等因素的影响，所以最保险的做法我感觉是在最后用while循环判断缓存是否已经更新，如果更新了再释放锁。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116173314106.png" alt="image-20230116173314106"></p></li></ul><h2 id="对上面的代码进行加本地锁以防止缓存击穿"><a href="#对上面的代码进行加本地锁以防止缓存击穿" class="headerlink" title="对上面的代码进行加本地锁以防止缓存击穿"></a>对上面的代码进行加本地锁以防止缓存击穿</h2><ul><li><p>一定考虑清楚锁的范围，还有别忘了双重校验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTree</span><span class="params">()</span>&#123;<span class="comment">//给listWithTree方法加入缓存后的逻辑</span></span><br><span class="line">    <span class="comment">//给缓存中存放的是对象转成的json数据，拿出的也是json数据需要转成对象，有天然的跨平台性，这是序列化与反序列化的一种实现</span></span><br><span class="line">    <span class="comment">//todo 空结果缓存：解决缓存穿透 随机过期时间：解决缓存雪崩 加锁：解决缓存击穿</span></span><br><span class="line">    <span class="comment">//尝试从redis中取想要的数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">catelogData</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;catelogData&quot;</span>);<span class="comment">//字面量按说应该抽成常量，这里只是为了方便</span></span><br><span class="line">    List&lt;PmsCategory&gt; result = <span class="literal">null</span>;<span class="comment">//最后要返回的结果</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(catelogData))&#123;<span class="comment">//如果redis中没有我们想要的数据，那么我们才从数据库中查,并将查到的结果加入缓存中</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;<span class="comment">//加本地锁以防止缓存穿透，把存入缓存的代码也放进来，防止缓存还没更新的时候下一个请求到了然后做出错误的判断</span></span><br><span class="line">            catelogData = stringRedisTemplate.opsForValue().get(<span class="string">&quot;catelogData&quot;</span>);<span class="comment">//再查一遍缓存用于双重校验</span></span><br><span class="line">            <span class="keyword">if</span>(!StringUtils.isEmpty(catelogData))&#123;<span class="comment">//双重校验，如果缓存中有数据了，就不用从数据库中查了</span></span><br><span class="line">                <span class="comment">//Json反序列化操作，注意第二个参数作为类型令牌的使用</span></span><br><span class="line">                result = JSON.parseObject(catelogData,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;PmsCategory&gt;&gt;()&#123;&#125;);</span><br><span class="line">                log.info(<span class="string">&quot;查redis~&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;查数据库~&quot;</span>);</span><br><span class="line">            result = listWithTreeFromDb();<span class="comment">//从数据库中查</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">store</span> <span class="operator">=</span> JSON.toJSONString(result);<span class="comment">//将结果转成json数据</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;catelogData&quot;</span>,store);<span class="comment">//将json数据存入redis</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//返回从数据库中查到的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果redis中有我们想要的数据，那么我们可以反序列化之后直接使用</span></span><br><span class="line">    <span class="comment">//Json反序列化操作，注意第二个参数作为类型令牌的使用</span></span><br><span class="line">    result = JSON.parseObject(catelogData,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;PmsCategory&gt;&gt;()&#123;&#125;);</span><br><span class="line">    log.info(<span class="string">&quot;查redis~&quot;</span>);</span><br><span class="line">    <span class="comment">//返回反序列化后的结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeFromDb</span><span class="params">()</span> &#123;<span class="comment">//原listWithTree方法</span></span><br><span class="line">    <span class="comment">//查出所有分类</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * baseMapper就相当于这个service对应的mapper，</span></span><br><span class="line"><span class="comment">     * 因为看上面继承了ServiceImpl，</span></span><br><span class="line"><span class="comment">     * 其中这个service对应的mapper被当作泛型的类型参数传进去了，</span></span><br><span class="line"><span class="comment">     * 而里面有个泛型参数类型的变量就是baseMapper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;PmsCategory&gt; data = baseMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//todo 组装成树形结构</span></span><br><span class="line">    <span class="comment">//找到所有的一级分类</span></span><br><span class="line">    List&lt;PmsCategory&gt; level1Menu = data.stream()</span><br><span class="line">            .filter(pmsCategory -&gt; pmsCategory.getParentCid().equals(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">            .map(menu -&gt; &#123;</span><br><span class="line">                menu.setChildren(getChildren(data,menu));</span><br><span class="line">                <span class="keyword">return</span> menu;</span><br><span class="line">            &#125;)</span><br><span class="line">            .sorted(Comparator.comparingInt(PmsCategory::getSort))<span class="comment">//Comparator封装了比较两个int变量的Comparator，直接传个方法引用告知其如何从元素中取得int变量即可</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> level1Menu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>压力测试：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116175914279.png" alt="image-20230116175914279"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116175847264.png" alt="image-20230116175847264"></p><p>可以看到只查了一次数据库，所以这个锁在单机情况下是有作用的。</p></li></ul><h2 id="用IDEA模拟集群"><a href="#用IDEA模拟集群" class="headerlink" title="用IDEA模拟集群"></a>用IDEA模拟集群</h2><ul><li><p>可以在想要模拟集群的服务上右键，选择copy configuration，然后换个端口号，改改配置，多搞几个一起启动就行了：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116180519759.png" alt="image-20230116180519759"></p></li></ul><h1 id="2023-x2F-1-x2F-17"><a href="#2023-x2F-1-x2F-17" class="headerlink" title="2023&#x2F;1&#x2F;17"></a>2023&#x2F;1&#x2F;17</h1><h2 id="自旋锁（Spin-Lock）"><a href="#自旋锁（Spin-Lock）" class="headerlink" title="自旋锁（Spin Lock）"></a>自旋锁（Spin Lock）</h2><ul><li>就是没拿到锁的时候自己在那转，直到拿到锁，可以用循环或者递归实现。</li></ul><h2 id="可重入锁（Reentrant-Lock）"><a href="#可重入锁（Reentrant-Lock）" class="headerlink" title="可重入锁（Reentrant Lock）"></a>可重入锁（Reentrant Lock）</h2><ul><li><del>假设有两个方法分别是方法a和方法b，方法b在方法a中，他们都想加同一把锁，如果要是不可重入锁，那么在a拿到锁之后，b就会无限等待，就死锁了；如果是可重入锁，那么当a拿到锁后，它里面的方法b在某种情况下也可以拿到a锁，避免了死锁问题，所以为了避免死锁问题，我们的锁应该都尽量设计成可重入锁</del>。</li><li>可重入锁是指可以被已经获取该锁的线程重新获取，可以防止递归的时候出现死锁的情况。</li></ul><h2 id="公平锁（Fair-Lock）"><a href="#公平锁（Fair-Lock）" class="headerlink" title="公平锁（Fair Lock）"></a>公平锁（Fair Lock）</h2><ul><li>就是一个线程拿到锁之后，又有很多线程想要拿锁，在之前拿到锁的线程释放锁之后，那些后来的线程会按照一定的顺序来拿锁而非抢占，这就是公平锁。释放锁后进行抢占的那是非公平锁。</li></ul><h2 id="读写锁（ReadWrite-Lock）"><a href="#读写锁（ReadWrite-Lock）" class="headerlink" title="读写锁（ReadWrite Lock）"></a>读写锁（ReadWrite Lock）</h2><ul><li><p>如果一个线程拿着写锁在修改数据，而另一个线程想要拿读锁读取数据，那么它是拿不到的，只有当写锁被释放之后，它才能拿到读锁，这样就保证了读线程读到的都是最新的数据。</p></li><li><p>同样，如果一个线程拿着读锁在读取数据，而另一个线程想要拿写锁修改数据，那么它是拿不到的，只有当读锁被释放之后，它才能拿到写锁。</p></li><li><p>如果要是很多线程并发读取数据（写锁在释放状态），那么他们拿的是共享读锁，可以一起读，类似于无锁的状态。</p></li><li><p>如果要是很多线程并发修改数据（读锁在释放状态），那么他们要拿排他&#x2F;互斥写锁，不能一起写。</p></li><li><p>也就是<strong>共享读，排他&#x2F;独享&#x2F;互斥写</strong>，<strong>读写不兼容，读读兼容，写写不兼容</strong>。</p></li><li><p>读写锁总是成对出现，写锁控制着读锁，只要写锁没释放，读锁就要等待；读锁没释放，写锁也要等待。</p></li><li><p>这其实设计操作系统中读者和写者的问题，可以再去翻翻书。</p></li><li><p><strong>对于频繁读，偶尔写的业务场景，加读写锁对性能影响不大</strong>。</p></li><li><p>代码示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117154614171.png" alt="image-20230117154614171"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117154650048.png" alt="image-20230117154650048"></p></li></ul><h2 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h2><ul><li><p>信号量的值是个数字，每当一个线程拿到这个锁，信号量就减1，只要信号量不为0，来的线程就能拿到锁，当信号量减为0时，再想获得这个锁就要等待或者不拿锁了直接走掉。</p></li><li><p>可以用作分布式限流等操作中。</p></li><li><p>代码示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117154926261.png" alt="image-20230117154926261"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117154943639.png" alt="image-20230117154943639"></p></li></ul><h2 id="闭锁（CountDownLatch）"><a href="#闭锁（CountDownLatch）" class="headerlink" title="闭锁（CountDownLatch）"></a>闭锁（CountDownLatch）</h2><ul><li><p>有多个线程可以同时拿着闭锁，但是只有当所有的线程都释放闭锁之后，闭锁才会被释放。</p></li><li><p>应用场景：加载多个配置，需要加载完所有的配置才能走下一步。</p></li><li><p>代码示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117155137552.png" alt="image-20230117155137552"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117155150238.png" alt="image-20230117155150238"></p></li></ul><h2 id="最好把注入的对象名写成把他注册到spring-IOC容器中的那个方法的名字"><a href="#最好把注入的对象名写成把他注册到spring-IOC容器中的那个方法的名字" class="headerlink" title="最好把注入的对象名写成把他注册到spring IOC容器中的那个方法的名字"></a>最好把注入的对象名写成把他注册到spring IOC容器中的那个方法的名字</h2><ul><li>相当于那个组件的id，增强可读性</li></ul><h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><ul><li><p>这是一个封装了很多分布式操作的包，用它我们可以很轻松的实现分布式锁（包括上面写的那些锁，方法名字和上面写的那些锁的名字差不多）、分布式对象等高级操作。</p></li><li><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">redisson.version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">redisson.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--redisson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;redisson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>虽然它有starter，可以进行自动配置，但是我们还是手动配置一下以获取更深的理解，给它新建一个配置类进行配置，最后返回的是一个RedissonClient实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRedissonConfig</span> &#123;<span class="comment">//redisson的配置类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;shutdown&quot;)</span></span><br><span class="line">    RedissonClient <span class="title function_">redisson</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">//创建配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://101.42.35.83:6379&quot;</span>);</span><br><span class="line">        <span class="comment">//根据config创建RedissonClient实例</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>它的所有操作都是通过RedissonClient的实例来做的，所以以后用的时候，注入RedissonClient，然后用就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RedissonClient redisson;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/testRedisson&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">testRedisson</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">myLock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;myLock&quot;</span>);<span class="comment">//获取一把锁，参数是锁的名字，通过名字区分不同的锁，名字相同的就是同一把锁</span></span><br><span class="line">    myLock.lock();<span class="comment">//加锁,获取不到锁的线程会被阻塞</span></span><br><span class="line">    <span class="keyword">try</span>&#123;<span class="comment">//锁的ttl会利用看门狗自动续期，不用担心业务时间长锁会过期，默认ttl为30s，也不用担心程序挂掉之后不会解锁</span></span><br><span class="line">        System.out.println(<span class="string">&quot;加锁成功，执行业务...&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">//如果业务结束，那么看门狗不会再给锁的ttl续期</span></span><br><span class="line">        System.out.println(<span class="string">&quot;解锁...&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">        myLock.unlock();<span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(redisson);</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果是正常的，没有获得锁的线程会阻塞，之前的线程放开锁后马上开始竞争锁：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116232306338.png" alt="image-20230116232306338"></p><p>在redis中能看到锁：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116232334579.png" alt="image-20230116232334579"></p></li><li><p>可以发现加锁后，一个任务运行的时候出现错误没能解锁之后，另外一个任务仍然能拿到锁，这是因为<strong>redisson在redis中加锁的时候设置了过期时间TTL，默认是30s，也就是一个看门狗时间</strong>，而这个TTL也没那么简单，TTL会被监视，<strong>如果业务还在运行中，那么这个TTL会在1&#x2F;3个看门狗时间也就是10s后自动续期到一个看门狗时间也就是30s，一直重复直到业务完成或宕掉；如果业务没有在运行了，TTL就不会做自动续期，最后TTL减到0锁被淘汰</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117143059296.png" alt="image-20230117143059296"></p></li><li><p>但是<strong>如果在使用锁的时候显式地指定了过期时间，那么看门狗机制会失效</strong>，虽然我也不知道它为啥这样设计…</p></li><li><p>不过<strong>自动续期TTL会造成性能的损失</strong>，所以之后在用的时候最好还是显式指定超时时间。</p></li><li><p>redisson中有上面写的那些锁的实现，名字和那些锁的名字差不多，<strong>带try的方法是尝试获取锁的时候不阻塞，不带try的方法是尝试获取锁的时候阻塞</strong>。</p></li><li><p>用redisson再改造一下昨天写的代码，看着简洁多了，不过<strong>在给锁命名的时候要注意锁的粒度问题</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeByRedissonLock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//新建分布式锁</span></span><br><span class="line">    <span class="comment">//起名的时候涉及锁的粒度越细，速度越快，粒度越大，速度越慢</span></span><br><span class="line">    <span class="comment">//可以按照具体的服务名以及缓存内容等给锁起名，保证锁的粒度合理</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">myLock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;product-listWithTree-lock&quot;</span>);</span><br><span class="line">    myLock.lock(<span class="number">30</span>,TimeUnit.SECONDS);<span class="comment">//上锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listWithTreeFromDb();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        myLock.unlock();<span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="缓存数据一致性问题"><a href="#缓存数据一致性问题" class="headerlink" title="缓存数据一致性问题"></a>缓存数据一致性问题</h2><ul><li>缓存里面的数据如何和数据库中的数据保持一致？</li></ul><h3 id="双写模式"><a href="#双写模式" class="headerlink" title="双写模式"></a>双写模式</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117161428127.png" alt="image-20230117161428127"></p><ul><li>就是写完数据库之后再改缓存，但是这样比较麻烦，而且在高并发的情况下缓存中可能出现脏数据，可以通过加锁解决；或者系统允许有一定的脏数据存在，因为脏数据一段时间过后会被淘汰，再查数据库更新的缓存就是最新的了。</li><li>但是这种方案是虽然读最新数据可能有延迟，但是整体是满足最终一致性的。</li></ul><h3 id="失效模式"><a href="#失效模式" class="headerlink" title="失效模式"></a>失效模式</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117162628865.png" alt="image-20230117162628865"></p><ul><li>就是写完数据库，把对应的缓存删掉，直到下一次有请求主动查数据库来更新缓存。</li><li>还是会有读脏数据的情况出现，具体情况就是左边那个图，可以通过加锁来解决。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>解决方案无非就是给<strong>缓存数据加上过期时间，保证并发读写的时候加读写锁</strong>，不过这样数据在缓存中更新会产生一定程度的延迟，所以说那些需要频繁写，并且对实时性要求很高的数据，就不要放缓存了，直接查数据库就行了。</p></li><li><p>永远记住，<strong>缓存只用来保证最终一致性</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117162901916.png" alt="image-20230117162901916"></p></li><li><p>不过完全解决缓存数据的一致性也可以使用阿里的Canal中间件，Canal会伪装成mysql的一个从服务器，可以通过订阅来监听mysql的变化，一旦mysql发生变化，Canal马上就会去更新缓存，这样我们就把更新缓存的操作和业务代码解耦了；同时Canal也可以做大数据分析，它可以同时订阅多个数据库中的表，每当订阅的表发生改变，Canal就动态分析计算出一个新的表，之后我们可以操作这个新的表来实现一些功能，比如用户智能推荐功能：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117163401840.png" alt="image-20230117163401840"></p></li><li><p>该项目最终决定采用<strong>失效模式+读写锁</strong>来保证缓存和数据库的数据一致性：</p><ul><li>缓存的所有数据都有过期时间，数据过期后下一次查询触发主动更新</li><li>读写数据的时候，加上分布式的读写锁，对于频繁读，偶尔写的场景，加读写锁对系统的性能影响不大。</li></ul></li></ul><h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><ul><li><p>为了简化我们使用缓存的操作，spring专门抽取了一个包来<strong>统一不同的缓存技术以供我们进行使用</strong>，这就是Spring Cache。</p></li><li><p>Spring Cache中主要定义了两个接口，<strong>Cache和CacheManager</strong>，<strong>CacheMannager根据使用的缓存实现不同有很多种实现，其中管理着相同缓存实现下各种各样的根据我们逻辑划分的缓存组件，不过它只是相当于用来定义缓存规则的，其中存放的缓存组件才是真正帮我们crud数据的</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117171457073.png" alt="image-20230117171457073"></p></li></ul><h3 id="整合Spring-Cache"><a href="#整合Spring-Cache" class="headerlink" title="整合Spring Cache"></a>整合Spring Cache</h3><ul><li><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring-boot-starter-cache.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring-boot-starter-cache.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--spring cache--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-starter-cache.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>查看其自动配置类CacheAutoConfiguration，发现它会导入RedisCacheConfiguration等配置类，并且自动配置好了redis的缓存管理器RedisCacheManager：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(CacheProperties.class)</span><span class="comment">//这里面配置的都是在配置文件中可以进行配置的东西</span></span><br><span class="line"><span class="comment">//----------------------------------------</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CacheConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">CacheType[] types = CacheType.values();</span><br><span class="line">String[] imports = <span class="keyword">new</span> <span class="title class_">String</span>[types.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">imports[i] = CacheConfigurations.getConfigurationClass(types[i]);<span class="comment">//在这里通过所有缓存的配置类得到了所有类型的缓存</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> imports;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">getConfigurationClass</span><span class="params">(CacheType cacheType)</span> &#123;</span><br><span class="line">Class&lt;?&gt; configurationClass = MAPPINGS.get(cacheType);<span class="comment">//根据缓存类型做映射</span></span><br><span class="line">Assert.state(configurationClass != <span class="literal">null</span>, () -&gt; <span class="string">&quot;Unknown cache type &quot;</span> + cacheType);</span><br><span class="line"><span class="keyword">return</span> configurationClass.getName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;CacheType, Class&lt;?&gt;&gt; MAPPINGS;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">Map&lt;CacheType, Class&lt;?&gt;&gt; mappings = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(CacheType.class);</span><br><span class="line">mappings.put(CacheType.GENERIC, GenericCacheConfiguration.class);</span><br><span class="line">mappings.put(CacheType.EHCACHE, EhCacheCacheConfiguration.class);</span><br><span class="line">mappings.put(CacheType.HAZELCAST, HazelcastCacheConfiguration.class);</span><br><span class="line">mappings.put(CacheType.INFINISPAN, InfinispanCacheConfiguration.class);</span><br><span class="line">mappings.put(CacheType.JCACHE, JCacheCacheConfiguration.class);</span><br><span class="line">mappings.put(CacheType.COUCHBASE, CouchbaseCacheConfiguration.class);</span><br><span class="line">mappings.put(CacheType.REDIS, RedisCacheConfiguration.class);<span class="comment">//在这儿</span></span><br><span class="line">mappings.put(CacheType.CAFFEINE, CaffeineCacheConfiguration.class);</span><br><span class="line">mappings.put(CacheType.SIMPLE, SimpleCacheConfiguration.class);</span><br><span class="line">mappings.put(CacheType.NONE, NoOpCacheConfiguration.class);</span><br><span class="line">MAPPINGS = Collections.unmodifiableMap(mappings);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="meta">@Bean</span><span class="comment">//向容器中注册了RedisCacheManager</span></span><br><span class="line">RedisCacheManager <span class="title function_">cacheManager</span><span class="params">(CacheProperties cacheProperties, CacheManagerCustomizers cacheManagerCustomizers,</span></span><br><span class="line"><span class="params">ObjectProvider&lt;org.springframework.data.redis.cache.RedisCacheConfiguration&gt; redisCacheConfiguration,</span></span><br><span class="line"><span class="params">ObjectProvider&lt;RedisCacheManagerBuilderCustomizer&gt; redisCacheManagerBuilderCustomizers,</span></span><br><span class="line"><span class="params">RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line"><span class="type">RedisCacheManagerBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(</span><br><span class="line">determineConfiguration(cacheProperties, redisCacheConfiguration, resourceLoader.getClassLoader()));</span><br><span class="line">List&lt;String&gt; cacheNames = cacheProperties.getCacheNames();</span><br><span class="line"><span class="keyword">if</span> (!cacheNames.isEmpty()) &#123;</span><br><span class="line">builder.initialCacheNames(<span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(cacheNames));</span><br><span class="line">&#125;</span><br><span class="line">redisCacheManagerBuilderCustomizers.orderedStream().forEach((customizer) -&gt; customizer.customize(builder));</span><br><span class="line"><span class="keyword">return</span> cacheManagerCustomizers.customize(builder.build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中配置使用redis作为缓存：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure></li><li><p>在配置类上开启缓存功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span><span class="comment">//开启缓存功能</span></span><br></pre></td></tr></table></figure></li><li><p>然后就可以使用注解来实现功能了：</p><ol><li>@Cacheable：用在方法上，触发将方法返回的数据保存到缓存的操作</li><li>@CacheEvict：用在方法上，触发将方法返回的数据从缓存中删除的操作，可以用作失效模式</li><li>@CachePut：用在方法上，在不影响方法执行的情况下更新缓存为方法的返回值，可以用作双写模式</li><li>@Caching：用在方法上，组合以上多个操作</li><li>@CacheConfig：用在类上，在类的级别共享缓存的相同配置</li></ol></li><li><p>对昨天写的代码用这种方式加缓存，比之前的代码简洁了不是一点半点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般每一个需要缓存的数据我们都来指定要放到哪个名字的逻辑分区中，推荐按照业务类型分区</span></span><br><span class="line"><span class="meta">@Cacheable(&#123;&quot;product-category&quot;&#125;)</span><span class="comment">//代表当前方法的结果需要缓存，如果缓存中有，那么方法可以直接不用调用，然后去缓存中取数据；如果缓存中没有，会调用方法，最后把方法的结果放入缓存中。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTree</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listWithTreeFromDb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117183129988.png" alt="image-20230117183129988"></p></li></ul><h3 id="Cacheable注解"><a href="#Cacheable注解" class="headerlink" title="@Cacheable注解"></a>@Cacheable注解</h3><ul><li><p>@Cacheable的默认行为：</p><ol><li>如果缓存中存在数据，那么方法直接不执行，直接用缓存中的数据</li><li>缓存的key默认自动生成，缓存默认的名字是分区名::SimpleKey []</li><li>缓存的value，默认使用jdk的序列化机制，将序列化后的数据存到redis中</li><li>默认TTL为-1</li></ol></li><li><p>可以用注解中的key属性来指定生成的缓存的key，不过这个属性接收的是一个spEL表达式，这个表达式的语法可以去官方找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key属性的参数是一个spEL表达式，下面这个表达式的意思是取方法的名字作为参数</span></span><br><span class="line"><span class="meta">@Cacheable(value = &#123;&quot;product-category&quot;&#125;,key = &quot;#root.method.name&quot;)</span><span class="comment">//value参数指定的是分组，key参数指定的是向redis中存放的key的名字</span></span><br></pre></td></tr></table></figure></li><li><p>指定缓存数据的TTL，可以在配置文件中统一修改，但是这样做可能会引起缓存雪崩，怎样把定义缓存TTL的粒度降下去呢?</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="comment">#设置缓存类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="comment">#设置ttl为300000毫秒</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="number">300000</span></span><br></pre></td></tr></table></figure></li><li><p>将数据保存为json格式怎么搞，要实现这个比较麻烦，通过追踪源码可以得知，spring cache会加载默认的RedisCacheConfiguration，所以我们只需要重新写一个RedisCacheConfiguration加入到Spring IOC容器中覆盖掉之前的那个即可，不过我们自定义后，就不走自动配置那条路了，所以要把自动配置的内容再写一份到我们自定义的那个配置类中以让配置文件中的配置生效，为了方便拿到配置文件中的数据，我们还应该把相应的属性类和当前的配置类进行绑定，这是springboot的内容，我有点不太熟练：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span><span class="comment">//开启缓存功能</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(CacheProperties.class)</span><span class="comment">//为了用CacheProperties，这是springboot的内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCacheConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//参数会自动从容器中找</span></span><br><span class="line">    RedisCacheConfiguration <span class="title function_">redisCacheConfiguration</span><span class="params">(CacheProperties cacheProperties)</span>&#123;<span class="comment">//其实容器中有这个，但是我们这样做相当于把之前那个存在的重写了，看源码可以得知，由于走这儿了就不走自动配置了，所以在配置文件中的配置也要写到这里来</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig();<span class="comment">//新建一个RedisCacheConfiguration</span></span><br><span class="line">        config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>()));<span class="comment">//指定key的序列化方式为string</span></span><br><span class="line">        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">GenericFastJsonRedisSerializer</span>()));<span class="comment">//指定value的序列化方式为json</span></span><br><span class="line">        CacheProperties.<span class="type">Redis</span> <span class="variable">redisProperties</span> <span class="operator">=</span> cacheProperties.getRedis();<span class="comment">//得到redis的配置</span></span><br><span class="line">        <span class="comment">//将配置文件中的所有内容生效，以下大部分内容来自源码</span></span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getTimeToLive() != <span class="literal">null</span>) &#123;</span><br><span class="line">            config = config.entryTtl(redisProperties.getTimeToLive());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getKeyPrefix() != <span class="literal">null</span>) &#123;</span><br><span class="line">            config = config.prefixCacheNameWith(redisProperties.getKeyPrefix());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isCacheNullValues()) &#123;</span><br><span class="line">            config = config.disableCachingNullValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isUseKeyPrefix()) &#123;</span><br><span class="line">            config = config.disableKeyPrefix();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还有几个常用配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="comment">#设置缓存类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="comment">#设置ttl为300000毫秒</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="number">300000</span></span><br><span class="line">      <span class="comment">#设置缓存key的前缀，如果不设置则默认使用缓存组件的名字，可以设置开启或不开启</span></span><br><span class="line">  <span class="attr">key-prefix:</span> <span class="string">CACHE_</span></span><br><span class="line">  <span class="attr">use-key-prefix:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">#是否缓存空值，开启可以避免缓存穿透</span></span><br><span class="line">  <span class="attr">cache-null-values:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="CacheEvict注解"><a href="#CacheEvict注解" class="headerlink" title="@CacheEvict注解"></a>@CacheEvict注解</h3><ul><li><p>可以<strong>用在更新&#x2F;删除数据的方法上，每次数据更新都会删掉它的缓存，直到下一次查库主动更新缓存，这样其实就是失效模式的实现</strong>。</p></li><li><p>删除单个key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(value = &quot;category&quot;,key = &quot;listWithTree&quot;)</span><span class="comment">//value指定分区，key指定要删除的key的名字</span></span><br></pre></td></tr></table></figure></li><li><p>如果有一些场景需要删除多个key（比如级联删除）怎么办？有两个方法：</p><ol><li><p>首先可以用之间介绍到的@Caching方法组合多个@CacheEvict注解来实现删除多个key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching(evict = &#123;</span></span><br><span class="line"><span class="meta">    @CacheEvict(value = &quot;category&quot;,key = &quot;listWithTree&quot;),</span></span><br><span class="line"><span class="meta">    @CacheEvict(value = &quot;category&quot;,key = &quot;listWithTree2&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p>然后就是可以在@CacheEvict注解中给allEntries属性设置为true，这样它就会把那个分区中的所有缓存都删掉，这个分区只是在spring中标识，其中存着那个key属于哪个分区，实际上redis中不存在什么分区什么的，所以才叫它逻辑分区嘛，所以以后我们尽量把数据分好区，这样删的时候也好删：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(value = &quot;category&quot;,allEntries = true)</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>推荐开启key的前缀，这样存的key在RedisDesktopManager中会以树形呈现，每一段之间用冒号隔开，比较方便查看。</p></li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul><li><strong>在类层面上使用@CacheConfig注解来指定cacheNames</strong>，这样在类中的和缓存相关的注解的cacheNames就都是它指定的了，因此，我们只需要<strong>在方法层面上的注解指定key</strong>就可以了，key可以使用SpEL表达式，比如：”#user.id”就是读取方法参数中名为user的参数中的id变量。<strong>在redis中缓存的key的结构是：”cacheNames::key”</strong></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>解决<strong>缓存穿透</strong>问题：在配置文件中配置允许缓存空数据：<code>spring.cache.redis.cache-null-values=true</code></li><li>解决<strong>缓存击穿</strong>问题：<ol><li>自己写本地锁或者是用redisson的分布式锁</li><li>将@Cacheable注解的sync属性设置为true，不过其中给的实现是本地锁：<code>@Cacheable(value = &#123;&quot;product-category&quot;&#125;,key = &quot;#root.method.name&quot;,sync = true)</code></li></ol></li><li>解决<strong>缓存雪崩</strong>问题：给数据加上随机的过期时间，给数据加过期时间可以在配置文件中进行配置，时间的单位是毫秒：<code>spring.cache.redis.time-to-live=30000</code></li><li>解决<strong>缓存和数据库的一致性</strong>问题：<ol><li>读写加锁</li><li>引入Canal中间件，感知到MySQL的更新后去更新缓存</li><li>对于读少写多的数据，直接去数据库查就行了</li></ol></li><li>对于<strong>常规数据</strong>（读多写少，及时性、一致性要求不高的数据），可以使用Spring Cache，使用的时候对于写模式往往是只要有过期时间就足够了。</li><li>对于<strong>特殊数据</strong>，只能具体问题具体分析了，需要特殊的设计，可以结合前面的Redisson分布式锁以及JUC本地锁来实现。</li></ul><h1 id="2023-x2F-1-x2F-18"><a href="#2023-x2F-1-x2F-18" class="headerlink" title="2023&#x2F;1&#x2F;18"></a>2023&#x2F;1&#x2F;18</h1><h2 id="看到句名言"><a href="#看到句名言" class="headerlink" title="看到句名言"></a>看到句名言</h2><ul><li>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</li></ul><h1 id="2023-x2F-1-x2F-19"><a href="#2023-x2F-1-x2F-19" class="headerlink" title="2023&#x2F;1&#x2F;19"></a>2023&#x2F;1&#x2F;19</h1><h2 id="尝试提前给前端向后端传的数据约定好解析方式"><a href="#尝试提前给前端向后端传的数据约定好解析方式" class="headerlink" title="尝试提前给前端向后端传的数据约定好解析方式"></a>尝试提前给前端向后端传的数据约定好解析方式</h2><ul><li>有一些表示我们可以做一下提前的约定，然后后端按照约定去解析条件，比如我想要从前端用一个变量传递一个数字区间到后端，那么我们可以约定这个变量是string的，然后这个string中有两个数字，数字之间用一个下划线分开，那两个数字就是左右边界，那么后端就根据这个约定来解析这个条件后再去做一些操作。</li><li>总而言之就是，对于那些前端不好表达的条件，我们可以提前做个约定，约定一下这样的数据前端怎样表示，后端怎样解析，之后我们就可以按照这样的约定去实现对应的功能了。</li></ul><h2 id="如何完成一个ES的查询"><a href="#如何完成一个ES的查询" class="headerlink" title="如何完成一个ES的查询"></a>如何完成一个ES的查询</h2><ul><li>首先根据需求设计出<strong>DSL语句</strong>、<strong>设计VO类封装查询条件</strong></li><li>然后在java的service层方法中<strong>使用es提供的api（主要是一些builder）根据DSL语句和传过来的VO查询条件实例结合约定来构建查询</strong></li><li>最后就是<strong>执行，然后解析返回的结果</strong>，可以<strong>把解析的结果封装成一个返回结果的实体类</strong>，用于视图数据</li></ul><h2 id="尝试在VO中使用静态内部类"><a href="#尝试在VO中使用静态内部类" class="headerlink" title="尝试在VO中使用静态内部类"></a>尝试在VO中使用静态内部类</h2><ul><li>如果有些类型从逻辑上是属于这个vo，那么我们可以在这个vo中写静态内部类来表示这些类型，从逻辑上看比较合理，维护起来也方便。</li></ul><h1 id="2023-x2F-1-x2F-20"><a href="#2023-x2F-1-x2F-20" class="headerlink" title="2023&#x2F;1&#x2F;20"></a>2023&#x2F;1&#x2F;20</h1><h2 id="初始化线程的四种方式"><a href="#初始化线程的四种方式" class="headerlink" title="初始化线程的四种方式"></a>初始化线程的四种方式</h2><ol><li><p>继承Thread，重写run方法，然后new实例调用start方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread01</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;这里是main方法线程~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Thread01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用继承Thread类的方式来初始化线程~&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程启动,线程id为：&quot;</span>+<span class="built_in">this</span>.getId());</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;这里是&quot;</span>+<span class="built_in">this</span>.getId()+<span class="string">&quot;号线程~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Runnable接口，重写run方法，然后把它的实例当作参数传入Thread实例的构造器中，最后用Thread实例调用start方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable01</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;这里是main方法线程~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Runnable01</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用实现Runnable接口的方式来初始化线程~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Callable接口+FutureTask（可以拿到返回结果，可以处理异常）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable01</span>());<span class="comment">//也可以接收Runnable的实现类</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程返回结果是：&quot;</span>+futureTask.get());<span class="comment">//这个是等待线程执行完毕之后获取结果,当前线程会阻塞在这里</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;这里是main方法线程~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Callable01</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;<span class="comment">//Callable接口的泛型是线程返回值类型</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用实现Runnable接口的方式来初始化线程~&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程启动,线程id为：&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程池，每个系统中只有少数线程池，<strong>项目业务中所有的多线程异步任务都应该交给线程池执行</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;()</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        pool.execute(<span class="keyword">new</span> <span class="title class_">Runnable01</span>());</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;这里是main方法线程~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>第1、2种方式不能得到返回值，第3、4种方式可以得到返回值。</li><li>第1、2、3种方式都不能控制资源，第4种方式可以控制资源，性能稳定。</li><li>总之，以后业务中所有异步任务都用第4种方式处理，也就是使用线程池。</li></ul><h2 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h2><ul><li><strong>降低资源的消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>：因为线程池中的线程数没有超过线程池的最大线程数时，有的线程处于等待分配任务的状态，当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h2 id="线程池（ThreadPoolExecutor）详解"><a href="#线程池（ThreadPoolExecutor）详解" class="headerlink" title="线程池（ThreadPoolExecutor）详解"></a>线程池（ThreadPoolExecutor）详解</h2><ul><li>jdk给我们提供了比较简单的创建线程池的方法，那就是使用Executors类中的方法来创建一些预配置好的线程池，但是阿里巴巴开发手册中不推荐这样的创建方式，主要原因是里面的大部分方法创建的线程池都有OOM的风险，而且几乎不能让程序员能够更深入地理解线程池的各种参数。所以<strong>阿里巴巴开发手册中推荐使用原生创建线程池的方式ThreadPoolExecutor，所有的参数都由自己来进行设置，降低OOM的概率，并且还能加深对于线程池参数的理解</strong>，所以下面的内容都是在详解ThreadPoolExecutor。</li><li>值得注意的是，线程池的存在会阻塞住使用线程池的那个线程，所以程序会一直等待任务直至线程池销毁程序才会结束。</li></ul><h3 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h3><ol><li><strong>int corePoolSize</strong>：核心线程数，这些线程按需创建，也就是<strong>懒加载</strong>，一开始没有核心线程创建，直到有任务过来，核心线程被创建，但是任务结束后，核心线程即使空闲也不会销毁（除非设置了核心线程的存活时间），而是重新等待异步任务的到来。当线程池中new的线程数达到核心线程数之后，再有任务过来，任务就会被装到等待队列中，等待核心线程空闲，一旦核心线程有空闲，那么等待队列就会pop出一个任务使用空闲的核心线程来执行。</li><li><strong>int maximumPoolSize</strong>：最大线程数，在核心线程都忙碌且任务队列也满着的情况下，如果有任务再来，那么任务队列会pop一个任务，创建一个新的线程去执行它，并把刚来的任务放到任务队列中，刚才新创建的线程不属于核心线程，因为在创建它的时候核心线程已经满了，它也并非是永久存在的，因为第三个参数就是设置了核心线程外空闲线程的存活时间，一旦过了存活时间，这些多出来的<strong>空闲</strong>线程就会被自动销毁以达到控制资源的目的。<strong>最大线程数包括核心线程数</strong>，也就是说还能额外创建的线程数等于最大线程数-核心线程数</li><li><strong>long keepAliveTime</strong>：非核心<strong>空闲</strong>线程的存活时间，一旦非核心线程<strong>空闲的时间</strong>达到我们设置的值，那么那个非核心空闲线程就会被摧毁，这样可以达到控制资源的目的。换句话说，这是多余的空闲线程在终止前等待新任务的最长时间。</li><li><strong>TimeUnit unit</strong>：时间单位，就是上一个参数的时间单位（秒、毫秒、分啥的），这个没啥好说的</li><li><strong>BlockingQueue&lt;Runnable&gt; workQueue</strong>：阻塞队列，这个就是用来指定当核心线程数满且都在忙碌的情况下新来的任务应该装到的任务队列，一旦有线程空闲，那么队列中就会pop出一个任务来使用空闲线程执行。<strong>一定要指定队列大小</strong>，一些阻塞队列的默认容量是int的最大值，在任务数量很多的情况下可能会出现OOM。</li><li><strong>ThreadFactory threadFactory</strong>：线程的创建工厂，用于线程池创建新线程的时候，有默认实现（不填该参数或者用Executors.defaultThreadFactory()获得），如果想要自定义可以自己写一个。</li><li><strong>RejectedExecutionHandler handler</strong>：拒绝策略，就是指定当线程池和任务队列都满了的情况下，再来任务应该如何处理，有默认实现，默认是使用丢弃策略（不填该参数或者用new ThreadPoolExecutor.AbortPolicy()获得），就是线程池和任务队列都满了的情况下会直接丢弃后来的任务。还有直接调用任务的run方法（这样就是同步而非异步调用了，使用的线程是跑线程池的那个线程）的策略等。</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120164900396.png" alt="image-20230120164900396"></p><h2 id="CompletableFuture异步编排"><a href="#CompletableFuture异步编排" class="headerlink" title="CompletableFuture异步编排"></a>CompletableFuture异步编排</h2><ul><li>在我们执行异步任务的时候，可能出现一种情况，就是多个异步任务之间有一定的执行顺序，比如有两个异步任务A、B，异步任务B的执行依赖于异步任务A的返回值，那么这两个异步任务的执行就会有个先后顺序，我们需要对这些异步任务进行编排以让他们按照我们想要的顺序进行执行，那么我们怎么才能实现这种操作呢？可以使用CompletableFuture来做异步编排，这是JDK1.8之后新增的内容。</li><li>Future&lt;T&gt;接口：定义异步操作的结果，可以<strong>获取异步结果</strong>。</li><li>CompletableFuture就像js中的Promise一样，本质上都是封装了一个有逻辑的异步任务，然后通过链式编程有条不紊地编排任务并执行。</li><li>这个类中基本所有的api的返回值类型都是CompletableFuture，这就为我们<strong>链式编排异步任务</strong>提供了方便，<strong>其中的异步方法产生的效果都是针对这一整个异步任务链来说的</strong>，比如后面的allOf方法，并不是说所有异步任务都执行完后再执行当前线程，而是所有的异步任务都执行完后再执行返回的CompletableFuture之后的链上的操作，本质上它还是异步的，和当前线程没有关系。</li></ul><h3 id="创建异步对象"><a href="#创建异步对象" class="headerlink" title="创建异步对象"></a>创建异步对象</h3><ul><li><p>CompletableFuture提供了四个静态方法来创建一个异步操作：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120175236094.png" alt="image-20230120175236094"></p></li><li><p>可以从上面看到，<strong>runAsync方法是没有返回结果的，supplyAsync方法是有返回结果的</strong>。</p></li><li><p>传入的异步操作<strong>会用默认的线程池执行，但是也可以传入自定义的线程池，让异步任务用自定义的线程池执行</strong>。</p></li><li><p><strong>Runnable和Supplier都是函数式接口</strong>，所以这些方法都<strong>可以使用lambda表达式来作为参数</strong>。</p></li><li><p>runAsync方法使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程~&quot;</span>);</span><br><span class="line">        &#125;,pool);</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>supplyAsync方法使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面那些方法最后都会返回一个Completable类型的结果，我们可以使用这个返回值的方法来做异步编排，就类似于js中的Future中的then方法、error方法啥的</p></li></ul><h3 id="计算完成时的回调方法"><a href="#计算完成时的回调方法" class="headerlink" title="计算完成时的回调方法"></a>计算完成时的回调方法</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120185615279.png" alt="image-20230120185615279"></p><ul><li><p><strong>whenComplete</strong>可以处理正常和异常的<strong>计算结果</strong>，<strong>exceptionally</strong>处理<strong>异常情况</strong>，带async后缀的是指这个方法仍是交给线程池来异步执行，不带async后缀的就是使用当前线程同步执行。</p></li><li><p>非常非常非常像js的异步编程，whenComplete就类似js中Promise的then方法，exceptionally就类似js中Promise的error方法。</p></li><li><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">0</span>;</span><br><span class="line">        &#125;, pool).whenComplete((res,exception)-&gt;&#123;<span class="comment">//可以获取返回值和异常，但是无法修改返回数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;异步任务成功完成,结果是：&quot;</span>+res+<span class="string">&quot;异常是：&quot;</span>+exception);</span><br><span class="line">        &#125;).exceptionally(exception-&gt;<span class="number">10</span>);<span class="comment">//感知异常，可以修改返回数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="handle方法"><a href="#handle方法" class="headerlink" title="handle方法"></a>handle方法</h3><ul><li><p>可对结果做最后的处理，可以处理异常，可以改变返回值等，聚合了之前whenComplete和exceptionally方法的功能。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120190826146.png" alt="image-20230120190826146"></p></li><li><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">2</span>;</span><br><span class="line">        &#125;, pool).handle((res,err)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (res!=<span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程串行化方法"><a href="#线程串行化方法" class="headerlink" title="线程串行化方法"></a>线程串行化方法</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120192513872.png" alt="image-20230120192513872">、</p><ul><li><p>这些方法实际上就可以解决我们之前提出的那个问题，就是如何保证A、B两个异步方法的执行顺序。</p></li><li><p><strong>thenApply方法</strong>：当一个线程依赖另一个线程的返回结果时，获取上一个任务返回的结果，进行相应操作后，返回当前任务的返回值。带async的是异步执行。</p></li><li><p><strong>thenAccept方法</strong>：接收上一个任务的返回结果，并消费这个结果进行相应的操作，当前任务无返回结果。带async的是异步执行。</p></li><li><p><strong>thenRun方法</strong>：无法接收上一个任务的返回结果，上一个任务执行完成后，执行当前任务，当前任务无返回值。带async的是异步执行。</p></li><li><p>以上方法都在上一个任务执行结束后执行。</p></li><li><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程~&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;第一个方法执行~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">0</span>;</span><br><span class="line">        &#125;, pool).thenApply(res-&gt;&#123;<span class="comment">//拿到上一个任务的返回值，做操作，然后再返回，好像Stream的转换流...</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第二个方法执行~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        &#125;).exceptionally(err-&gt;<span class="string">&quot;10&quot;</span>);<span class="comment">//中间任何一个任务出现问题都会直接跳到这里来</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>之前的whenComplete和exceptionally方法都是针对整个异步方法链的，方法链中任何一个地方出现异常都会直接跳到最后的exceptionally方法。</p></li></ul><h3 id="两任务组合-都完成后执行第三个任务"><a href="#两任务组合-都完成后执行第三个任务" class="headerlink" title="两任务组合-都完成后执行第三个任务"></a>两任务组合-都完成后执行第三个任务</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120195142611.png" alt="image-20230120195142611"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120195207076.png" alt="image-20230120195207076"></p><ul><li><p><strong>thenCombine方法</strong>：组合两个异步任务，获取两个异步任务的返回结果，处理第三个任务，并返回第三个任务的返回结果。带async的是异步执行第三个任务。</p></li><li><p><strong>thenAcceptBoth方法</strong>：组合两个异步任务，获取两个异步任务的返回结果，处理第三个任务，第三个任务没有返回值。带async的是异步执行第三个任务。</p></li><li><p><strong>runAfterBoth方法</strong>：组合两个异步任务，不获取两个异步任务的返回结果，处理第三个任务，第三个任务没有返回值。带async的是异步执行第三个任务。</p></li><li><p><strong>任务三是在以上方法的参数中定义的</strong>。</p></li><li><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程1~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">2</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程2~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">5</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future03 = future01.thenCombineAsync(future02,(e1,e2)-&gt;e1+e2,pool).exceptionally(err-&gt;<span class="number">10</span>);<span class="comment">//任务1、2都结束后任务3才开始,这个方法任务3可以拿到任务1、2的返回值，并且任务3也能有返回值</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future03.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="两任务组合-一个任务完成后执行第三个任务"><a href="#两任务组合-一个任务完成后执行第三个任务" class="headerlink" title="两任务组合-一个任务完成后执行第三个任务"></a>两任务组合-一个任务完成后执行第三个任务</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120214254090.png" alt="image-20230120214254090"></p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120214317865.png" alt="image-20230120214317865"></p><ul><li><p><strong>applyToEither方法</strong>：两个任务中有一个任务完成后，获取它的返回值，处理第三个任务，并有新的返回值。带async的是异步执行第三个任务。</p></li><li><p><strong>acceptEither方法</strong>：两个任务中有一个任务完成后，获取它的返回值，处理第三个任务，没有新的返回值。带async的是异步执行第三个任务。</p></li><li><p><strong>runAfterEither方法</strong>：两个任务中有一个任务完成后，不获取它的返回值，处理第三个任务，没有新的返回值。带async的是异步执行第三个任务。</p></li><li><p><strong>任务一、二的返回值类型要相同</strong>，不然任务三都不知道怎么接收上一个任务的参数了。</p></li><li><p><strong>任务三是在以上方法的参数中定义的</strong>。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//睡上一觉模拟第一个任务执行较慢，看看任务3能否在任务2结束后顺利执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程1~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">2</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程2~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">5</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future03 = future01.applyToEitherAsync(future02,e-&gt;e,pool).exceptionally(err-&gt;<span class="number">10</span>);<span class="comment">//任务1、2的其中一个任务结束后任务3就会开始,这个方法任务3可以拿到先结束的那个任务的返回值，并且任务3也能有返回值</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future03.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="多任务组合"><a href="#多任务组合" class="headerlink" title="多任务组合"></a>多任务组合</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120220345334.png" alt="image-20230120220345334"></p><ul><li><p><strong>allOf方法</strong>：等待所有任务都完成后，再执行返回的CompletableFuture后面的操作，不能获取任务的返回值。</p></li><li><p><strong>anyOf方法</strong>：只要有一个任务完成，就执行返回的CompletableFuture后面的操作，可以获取第一个完成的任务的返回值。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//睡上一觉模拟第一个任务执行较慢，看看任务3能否在任务2结束后顺利执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程1~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">2</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程2~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">5</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future03 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程3~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Void&gt; future04 = CompletableFuture.allOf(future01, future02, future03);<span class="comment">//必须所有任务都执行完，才可以执行future04后面的操作</span></span><br><span class="line">        future04.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//睡上一觉模拟第一个任务执行较慢，看看任务3能否在任务2结束后顺利执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程1~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">2</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程2~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">5</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future03 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程3~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Object&gt; future04 = CompletableFuture.anyOf(future01, future02, future03);<span class="comment">//只要有一个任务执行完，那么就可以执行future04后面的操作了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最先执行完的那个任务的返回值是：&quot;</span>+future04.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用异步编排来获取一个网页的资源"><a href="#使用异步编排来获取一个网页的资源" class="headerlink" title="使用异步编排来获取一个网页的资源"></a>使用异步编排来获取一个网页的资源</h2><ul><li>如果获取网页资源的操作都是同步的，那么加载一个页面需要的时间是很长的，所以我们可以使用异步的方法来加载网页资源，这样网页资源加载完成的时间就只取决于所有异步操作中最慢的那个了，但是由于加载资源的异步操作可能有顺序上的要求，所以我们要对这些异步请求资源的方法来进行异步编排来保证最终结果的正确性。</li></ul><h1 id="2023-x2F-1-x2F-23"><a href="#2023-x2F-1-x2F-23" class="headerlink" title="2023&#x2F;1&#x2F;23"></a>2023&#x2F;1&#x2F;23</h1><h2 id="快速定位网页元素在代码中的位置"><a href="#快速定位网页元素在代码中的位置" class="headerlink" title="快速定位网页元素在代码中的位置"></a>快速定位网页元素在代码中的位置</h2><ul><li>页面跑起来之后打开浏览器的开发者工具（摁f12），然后点最左上角的按钮（审查元素），然后点击想要定位的元素，就能跳转到指定元素在代码中对应的位置了。</li></ul><h2 id="ToString注解"><a href="#ToString注解" class="headerlink" title="@ToString注解"></a>@ToString注解</h2><ul><li>是lombok中的一个注解，将该注解写在类上，可以自动生成该类的toString方法。</li></ul><h2 id="如何在MyBatis的xml文件中引用一个内部类"><a href="#如何在MyBatis的xml文件中引用一个内部类" class="headerlink" title="如何在MyBatis的xml文件中引用一个内部类"></a>如何在MyBatis的xml文件中引用一个内部类</h2><ul><li><p>MyBatis的xml文件的标签中的很多属性都要求给一个完全类路径的参数，别的类没啥问题，但是<strong>如果要是使用到内部类，那么在传参的时候最后一个分隔符不能用“.”，而应该用“$”</strong>，要不然就会报无法解析那个内部类的错误。</p></li><li><p>代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;SpuItemAttrGroupVo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.konjacer.mallisland.product.entity.vo.SkuItemVo$SpuItemAttrGroupVo&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="对于有嵌套属性的返回值使用MyBatis的自定义结果集封装"><a href="#对于有嵌套属性的返回值使用MyBatis的自定义结果集封装" class="headerlink" title="对于有嵌套属性的返回值使用MyBatis的自定义结果集封装"></a>对于有嵌套属性的返回值使用MyBatis的自定义结果集封装</h2><ul><li><p>对于写在xml文件中的sql语句的<strong>有嵌套属性的返回值</strong>，我们应该创建一个resultMap并在crud标签的<strong>resultMap属性</strong>指定成我们自定义的resultMap，这样做可以使得查出来的数据能够准确地映射到我们指定的位置，其中的嵌套属性中的数据我们需要手动和查出来的数据作映射，这样查出来的数据就可以映射到嵌套属性中了。如果不使用自定义的resultMap，那么mybatis不知道怎么把查出来的结果和返回值中的嵌套属性做映射，返回的结果就会出错。</p></li><li><p>代码示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--返回值中有嵌套属性的，要声明自定义的结果集来作为最后的返回值，不然mybatis不知道怎么把数据映射到嵌套属性中。注意内部类完全路径的写法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;SpuItemAttrGroupVo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.konjacer.mallisland.product.entity.vo.SkuItemVo$SpuItemAttrGroupVo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;groupName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;attr_group_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置其中的集合属性的映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;attrs&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.konjacer.mallisland.product.entity.vo.SkuItemVo$SpuBaseAttrVo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;attr_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;attrName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;attr_value&quot;</span> <span class="attr">property</span>=<span class="string">&quot;attrValue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--resultType声明的是返回的集合类型里面元素的类型--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--此处的联表查询只是为了熟悉操作，真正开发时尽量不要使用联表查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAttrGroupWithAttrsBySpuId&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">&quot;SpuItemAttrGroupVo&quot;</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">        pav.`spu_id`,ag.`attr_group_name`,ag.`attr_group_id`,</span><br><span class="line">        aar.`attr_id`,attr.`attr_id`,pav.`attr_value`</span><br><span class="line">    FROM `pms_attr_group` ag</span><br><span class="line">        LEFT JOIN `pms_attr_attrgroup_relation` aar ON aar.`attr_group_id` = ag.`attr_group_id`</span><br><span class="line">        LEFT JOIN `pms_attr` attr ON attr.`attr_id` = aar.`attr_id`</span><br><span class="line">        LEFT JOIN `pms_product_attr_value` pav ON pav.`attr_id` = attr.`attr_id`</span><br><span class="line">    WHERE ag.catelog_id = #&#123;catalogId&#125; AND pav.`spu_id` = #&#123;spuId&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="将对应的配置和实体类进行绑定"><a href="#将对应的配置和实体类进行绑定" class="headerlink" title="将对应的配置和实体类进行绑定"></a>将对应的配置和实体类进行绑定</h2><ul><li><p>先导入一个包以开启和配置相关的代码提示，不导入这个包也不影响后续的操作：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启springboot和配置相关的代码提示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>需要用到注解**<code>@ConfigurationProperties</code><strong>，该注解可以把配置文件中指定前缀的配置和被其修饰的类绑定，类中的</strong>非静态属性<strong>可以通过</strong>前缀和属性名**在配置文件中进行配置。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mallisland.thread&quot;)</span><span class="comment">//指定要绑定的前缀</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//注册到IOC容器中方便后续使用</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfigProperties</span> &#123;<span class="comment">//配置实体类</span></span><br><span class="line">    <span class="keyword">private</span> Integer coreSize;</span><br><span class="line">    <span class="keyword">private</span> Integer maxSize;</span><br><span class="line">    <span class="keyword">private</span> Integer keepAliveTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置线程池的相关属性，用的是自定义的配置实体类，使用前缀+属性名来对实体类中的属性进行配置</span></span><br><span class="line"><span class="attr">mallisland:</span></span><br><span class="line">  <span class="attr">thread:</span></span><br><span class="line">    <span class="attr">core-size:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">max-size:</span> <span class="number">200</span></span><br><span class="line">    <span class="attr">keep-alive-time:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></li><li><p>要想使用自定义的配置实体类，可以使用相应注解将其加入到ioc容器中。还有一点就是，<strong>被@Bean修饰的方法的参数可以自动注入，不需要任何额外的注解</strong>，使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">threadPool</span><span class="params">(ThreadPoolConfigProperties pool)</span>&#123;<span class="comment">//参数自动注入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            pool.getCoreSize(),</span><br><span class="line">            pool.getMaxSize(),</span><br><span class="line">            pool.getKeepAliveTime(),</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100000</span>),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">            );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>除了将自定义的配置实体类加入到ioc容器中外，还可以通过给<strong>配置类</strong>加上**<code>@EnableConfigurationProperties</code>**注解来开启对应的配置实体类，将指定的类注入到ioc容器中，使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ThreadPoolConfigProperties.class)</span><span class="comment">//开启使用指定的配置实体类，将指定的类注册进ioc容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">threadPool</span><span class="params">(ThreadPoolConfigProperties pool)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                pool.getCoreSize(),</span><br><span class="line">                pool.getMaxSize(),</span><br><span class="line">                pool.getKeepAliveTime(),</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100000</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="给模块添加一个线程池"><a href="#给模块添加一个线程池" class="headerlink" title="给模块添加一个线程池"></a>给模块添加一个线程池</h2><ul><li>可以<strong>在配置类中new一个线程池通过@Bean注解注册到ioc容器中</strong></li><li>然后线程池的参数应该是可在配置文件中配置的，所以我们要<strong>写一个配置实体类来表示我们允许配置的属性</strong></li><li>然后<strong>将配置实体类和对应前缀的配置绑定</strong>，这样以后我们就能通过在配置文件中配置的方式来改变配置实体类中的属性值了</li><li>然后我们<strong>将配置实体类注册到ioc容器中</strong>，之后就可以在创建线程池的方法中使用配置实体类的属性值作为线程池的参数了。</li></ul><h2 id="对业务逻辑进行异步编排优化示例"><a href="#对业务逻辑进行异步编排优化示例" class="headerlink" title="对业务逻辑进行异步编排优化示例"></a>对业务逻辑进行异步编排优化示例</h2><ul><li><p>其中第2、3、4个任务只依赖于第1个任务的返回值，第5个任务不依赖任何返回值，除了第1个任务外都没有返回值，所以先异步执行任务1、5（无先后顺序），然后得到1的返回值后再异步执行任务2、3、4（无先后顺序），最后通过<strong>使用allOf方法和get方法阻塞直到所有任务完成（真正起到阻塞当前线程的是get方法，allof方法只是阻塞了异步任务链）</strong>然后返回结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SkuItemVo <span class="title function_">item</span><span class="params">(String skuId)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">SkuItemVo</span> <span class="variable">skuItemVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkuItemVo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sku基本信息获取,查pms_sku_info</span></span><br><span class="line">    CompletableFuture&lt;PmsSkuInfo&gt; infoFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="type">PmsSkuInfo</span> <span class="variable">info</span> <span class="operator">=</span> getById(skuId);</span><br><span class="line">        skuItemVo.setInfo(info);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取spu的销售属性组合，依赖于第一个任务的返回值</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; saleAttrFuture = infoFuture.thenAcceptAsync((res) -&gt; &#123;</span><br><span class="line">        List&lt;SkuItemVo.SkuItemSaleAttrVo&gt; saleAttrVos = pmsSkuSaleAttrValueService.getSaleAttrsBySpuId(res.getSpuId());</span><br><span class="line">        skuItemVo.setSaleAttr(saleAttrVos);</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取spu的介绍,查pms_spu_info_desc，依赖于第一个任务的返回值</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; descFuture = infoFuture.thenAcceptAsync((res) -&gt; &#123;</span><br><span class="line">        <span class="type">PmsSpuInfoDesc</span> <span class="variable">spuInfoDescEntity</span> <span class="operator">=</span> pmsSpuInfoDescService.getById(res.getSpuId());</span><br><span class="line">        skuItemVo.setDesp(spuInfoDescEntity);</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取spu的规格参数信息，依赖于第一个任务的返回值</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; baseAttrFuture = infoFuture.thenAcceptAsync((res) -&gt; &#123;</span><br><span class="line">        List&lt;SkuItemVo.SpuItemAttrGroupVo&gt; attrGroupVos = pmsAttrGroupService.getAttrGroupWithAttrsBySpuId(res.getSpuId(), res.getCatalogId());</span><br><span class="line">        skuItemVo.setGroupAttrs(attrGroupVos);</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取sku的图片信息，查pms_sku_images</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; imageFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        List&lt;PmsSkuImages&gt; images = pmsSkuImagesService.getImagesBySkuId(skuId);</span><br><span class="line">        skuItemVo.setImages(images);</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞等待直到所有任务都完成，后面的get方法是必须的，不然没有阻塞当前线程的效果，会还没等任务都完成就返回了，因为这里的allOf方法是针对异步任务链来说的，本质上allOf还是异步任务</span></span><br><span class="line">    CompletableFuture</span><br><span class="line">            .allOf(infoFuture,saleAttrFuture,descFuture,baseAttrFuture,imageFuture)</span><br><span class="line">            .get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> skuItemVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2023-x2F-1-x2F-24"><a href="#2023-x2F-1-x2F-24" class="headerlink" title="2023&#x2F;1&#x2F;24"></a>2023&#x2F;1&#x2F;24</h1><h2 id="注册组件的时候一定使用准确的注解"><a href="#注册组件的时候一定使用准确的注解" class="headerlink" title="注册组件的时候一定使用准确的注解"></a>注册组件的时候一定使用准确的注解</h2><ul><li>就是某一层的组件往ioc容器里注册的时候就应该使用对应层的注册组件的注解，比如Controller层用@Controller注解，Service层用@Service注解，dao层用@Repository，普通的组件用@Component。</li><li>之前一直以为这四个注解完全相同，现在才直到<strong>这些组件或多或少都会有一点自己特化的功能（比如被@Controller 注解的bean会被spring-mvc框架所使用；被@Repository 注解的bean会被作为持久层操作（数据库）的bean来使用），有的时候用错可能会出问题，所以一定要保证使用的注解是对应层的注解</strong>。</li></ul><h2 id="使用SpringMVC的内容配置视图映射"><a href="#使用SpringMVC的内容配置视图映射" class="headerlink" title="使用SpringMVC的内容配置视图映射"></a>使用SpringMVC的内容配置视图映射</h2><ul><li><p>省的写页面跳转的Controller了，代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallislandWebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;<span class="comment">//配置视图映射</span></span><br><span class="line">        registry.addViewController(<span class="string">&quot;/login.html&quot;</span>).setViewName(<span class="string">&quot;login&quot;</span>);<span class="comment">//设置视图名称会结合themeleaf中的前后缀形成完整的跳转路径</span></span><br><span class="line">        registry.addViewController(<span class="string">&quot;/reg.html&quot;</span>).setViewName(<span class="string">&quot;reg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>值得注意的是这种映射方式只有get方式才能访问到，因为要进行转发，而转发的对象要求使用get方式进行访问。</p></li></ul><h2 id="整合阿里云短信服务（SMS）"><a href="#整合阿里云短信服务（SMS）" class="headerlink" title="整合阿里云短信服务（SMS）"></a>整合阿里云短信服务（SMS）</h2><ul><li><p>其实就是跟着官网的api文档来，然后一步步修修改改，核心代码抽一抽，解解耦，做做组件，映射一下组件的非静态属性到配置文件，指不定哪天官网又改了调用api的方式了，所以下面的内容仅供参考。</p></li><li><p>先<strong>在第三方服务的模块中整合阿里云短信服务并暴露接口</strong></p></li><li><p>首先根据官网的提示，先引入SMS服务用到的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--阿里云短信服务的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dysmsapi20170525<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后把官网给的示例代码改改做成一个ioc组件，把一些可配置的内容抽出去变成非静态属性，并将它们和配置文件中指定的前缀绑定，这样我们就可以在配置文件中配置这些内容了。<strong>本质上这个服务还是向阿里云的指定域名发送请求</strong>，请求参数可以自定义以实现不同的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.cloud.alicloud&quot;)</span><span class="comment">//和配置文件指定前缀的配置进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下五个变量做成可配置的，从配置文件中读取值赋值给属性是基于属性的set方法的，所以类上要加@Data注解</span></span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> <span class="string">&quot;dysmsapi.aliyuncs.com&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">templateCode</span> <span class="operator">=</span> <span class="string">&quot;SMS_154950909&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">signName</span> <span class="operator">=</span> <span class="string">&quot;阿里云短信测试&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用AK&amp;SK初始化账号Client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> com.aliyun.dysmsapi20170525.Client <span class="title function_">createClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        com.aliyun.teaopenapi.models.<span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.teaopenapi.models.Config()</span><br><span class="line">                <span class="comment">// 必填，您的 AccessKey ID</span></span><br><span class="line">                .setAccessKeyId(accessKey)</span><br><span class="line">                <span class="comment">// 必填，您的 AccessKey Secret</span></span><br><span class="line">                .setAccessKeySecret(secretKey);</span><br><span class="line">        <span class="comment">// 访问的域名</span></span><br><span class="line">        config.endpoint = endpoint;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.dysmsapi20170525.Client(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSmsCode</span><span class="params">(String phoneNum,String code)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//System.out.println(accessKey+&quot; &quot;+secretKey);</span></span><br><span class="line">        <span class="comment">// 工程代码泄露可能会导致AccessKey泄露，并威胁账号下所有资源的安全性。以下代码示例仅供参考，建议使用更安全的 STS 方式，更多鉴权访问方式请参见：https://help.aliyun.com/document_detail/378657.html</span></span><br><span class="line">        com.aliyun.dysmsapi20170525.<span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> createClient();</span><br><span class="line">        com.aliyun.dysmsapi20170525.models.<span class="type">SendSmsRequest</span> <span class="variable">sendSmsRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.dysmsapi20170525.models.SendSmsRequest();</span><br><span class="line">        <span class="comment">//设置请求参数</span></span><br><span class="line">        sendSmsRequest</span><br><span class="line">                .setPhoneNumbers(phoneNum)<span class="comment">//电话号码</span></span><br><span class="line">                .setSignName(signName)<span class="comment">//短信签名名称</span></span><br><span class="line">                .setTemplateCode(templateCode)<span class="comment">//短信模板Code</span></span><br><span class="line">                .setTemplateParam(<span class="string">&quot;&#123;\&quot;code\&quot;:\&quot;&quot;</span>+code+<span class="string">&quot;\&quot;&#125;&quot;</span>);<span class="comment">//短信模板变量对应的实际值</span></span><br><span class="line">        com.aliyun.teautil.models.<span class="type">RuntimeOptions</span> <span class="variable">runtime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.teautil.models.RuntimeOptions();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 复制代码运行请自行打印 API 的返回值</span></span><br><span class="line">            <span class="type">SendSmsResponse</span> <span class="variable">sendSmsResponse</span> <span class="operator">=</span> client.sendSmsWithOptions(sendSmsRequest, runtime);</span><br><span class="line">            System.out.println(sendSmsResponse.getStatusCode()+<span class="string">&quot; &quot;</span>+sendSmsResponse.getBody().getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TeaException error) &#123;</span><br><span class="line">            <span class="comment">// 如有需要，请打印 error</span></span><br><span class="line">            System.out.println(error);</span><br><span class="line">            com.aliyun.teautil.Common.assertAsString(error.message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception _error) &#123;</span><br><span class="line">            <span class="type">TeaException</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeaException</span>(_error.getMessage(), _error);</span><br><span class="line">            <span class="comment">// 如有需要，请打印 error</span></span><br><span class="line">            System.out.println(error);</span><br><span class="line">            com.aliyun.teautil.Common.assertAsString(error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面这个Component还能做优化，上面这样的写法虽然它整体是单例的，但是<strong>每次调用其中的方法时都会重新创建一个相同的client对象，这样就造成了性能的浪费，所以可以把重复创建的那个对象放到配置类中当成Bean注册给IOC容器，这样就能保证调用方法时不会重新创建对象（利用了Bean默认作用域是单例模式生成的性质）</strong>。</p></li><li><p>然后就是<strong>在第三方服务模块向外提供服务接口</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sms&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgController</span> &#123;<span class="comment">//阿里云短信服务的Controller</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SmsComponent smsComponent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供给别的服务进行调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phone 电话号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code 想发的验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/sendCode&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone,<span class="meta">@RequestParam(&quot;code&quot;)</span> String code)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//System.out.println(phone);</span></span><br><span class="line">        smsComponent.sendSmsCode(phone,code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后就是<strong>在认证中心使用服务接口向外提供短信发送的接口</strong>，要考虑的问题很多，比如说验证码要再次检查怎么办？验证码有效时间10分钟怎么搞？验证码60s内不能重复发送怎么搞？接口防刷怎么搞？可以通过引入redis解决部分问题，第一个问题可以解决，把验证码存到redis中，验证的时候直接拿就行；第二个问题也好解决，就是给放入缓存的数据加上ttl，到期就被淘汰，验证码也就失效了；第三个问题可以在存放验证码的时候，后缀带上个系统时间，然后每次发验证码的时候都检查当前时间是不是在缓存的时间的60s开外，如果不在，直接返回失败信息；最后一个问题之后再解决把：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ThirdFeignService thirdFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sms/sendCode&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone)</span>&#123;</span><br><span class="line">        <span class="comment">//todo 接口防刷</span></span><br><span class="line">        <span class="comment">//防止同一个手机号在60s内再发送验证码，我们可以给验证码带上系统时间的后缀，再想发的时候检查缓存中验证码的时间是否在60s之前。进来先检查这个</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisCode</span> <span class="operator">=</span> redisTemplate.opsForValue().get(AuthServerConstant.SmsConstant.SMS_CODE_CACHE_PREFIX.getValue()+phone);</span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(redisCode)) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">timeBefore</span> <span class="operator">=</span> Long.parseLong(redisCode.split(<span class="string">&quot;_&quot;</span>)[<span class="number">1</span>]);<span class="comment">//获取缓存中记录的上次添加验证码到缓存的时间</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() - timeBefore &lt; <span class="number">60000</span>) &#123;<span class="comment">//如果这次请求在上次请求的60s内，直接失败</span></span><br><span class="line">                <span class="keyword">return</span> Result</span><br><span class="line">                        .error()</span><br><span class="line">                        .code(ResultCode.SMS_CODE_EXCEPTION.getCode())</span><br><span class="line">                        .message(ResultCode.SMS_CODE_EXCEPTION.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取随机四位数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> String.valueOf((<span class="type">int</span>)(Math.random()*<span class="number">9000</span>+<span class="number">1000</span>));</span><br><span class="line">        <span class="comment">//为了验证码的再次校验，验证码暂时存到redis中,key是服务前缀+手机号防止撞key，value是验证码，要带上ttl，一般验证码不是都是几分钟就过期嘛</span></span><br><span class="line">        <span class="comment">//给验证码带上系统时间后缀，方便下次请求时检验请求是否是在60s之内发送的</span></span><br><span class="line">        redisTemplate.opsForValue().set(AuthServerConstant.SmsConstant.SMS_CODE_CACHE_PREFIX.getValue()+phone,code+<span class="string">&quot;_&quot;</span>+System.currentTimeMillis(),<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//远程调用发送验证码的方法</span></span><br><span class="line">        thirdFeignService.sendCode(phone,code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="给缓存到redis中的数据的key增加前缀"><a href="#给缓存到redis中的数据的key增加前缀" class="headerlink" title="给缓存到redis中的数据的key增加前缀"></a>给缓存到redis中的数据的key增加前缀</h2><ul><li>这个可以<strong>避免key的冲突</strong>，比如说我想缓存一个手机号的key，但是很多个服务都想要缓存这个key，那么我们在缓存的时候就产生了key的冲突，所以解决方法就是，每个服务有自己的缓存前缀（可以写成常量），无论是向redis中写还是查，都带着这个前缀来标识自己是哪个服务缓存的数据，这样在缓存或者查询的时候就不会产生key冲突了。</li></ul><h1 id="2023-x2F-1-x2F-25"><a href="#2023-x2F-1-x2F-25" class="headerlink" title="2023&#x2F;1&#x2F;25"></a>2023&#x2F;1&#x2F;25</h1><h2 id="MD5盐值加密"><a href="#MD5盐值加密" class="headerlink" title="MD5盐值加密"></a>MD5盐值加密</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><ul><li>即Message Digest Algorithm 5，是一种信息摘要算法</li><li><strong>压缩性</strong>：任意长度的数据，算出的MD5值的长度可以固定</li><li><strong>容易计算</strong>：从原数据计算出MD5值很容易</li><li><strong>抗修改性</strong>：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大的区别</li><li><strong>强抗碰撞性</strong>：想找到两个不同的数据使它们具有相同的MD5值，是非常困难的</li><li><strong>不可逆性</strong>：无法通过MD5值推算出原数据，网上那些所谓的MD5解析，是利用MD5值的抗修改性，从彩虹表（一个用于加密散列函数 逆运算的预先计算好的表 ）中查已经计算出的MD5的值对应的明文，遇到彩虹表中没有的MD5值，它就无法解析了。</li></ul><h3 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a>加盐</h3><ul><li>直接向数据库中存放MD5值就很安全吗？比裸奔是安全不少，但是还不够，因为<strong>黑客有可能拿着数据库中的MD5值去彩虹表中查，万一有些人设置的密码强度不够，那么很容易密码就会被破解出来</strong>。</li><li>所以不能单纯使用计算出的MD5值，我们可以<strong>通过生成随机数与明文数据进行组合后再计算MD5值（也就是给数据加盐），将最后计算出的结果作为存放在数据库中的数据</strong>。</li><li>而对于加的盐值，我们也得找地方存，<strong>可以存在数据库中，但是这样的话，黑客破解数据库后很容易就能取得盐值</strong>。也可以存到最后生成的MD5值中，spring家的<strong>BCryptPasswordEncoder</strong>类中的encode方法是<strong>将盐值存放到了最后生成的密文中</strong>，也就是说，通过特定的操作，可以从最后的密文中分离出盐值，这样做安全性就很高了，因为<strong>黑客并不知道怎么分离盐值，就算黑客得到了盐值，由于盐值是随机的，黑客无法利用已有的彩虹表，必须从头开始构建一个彩虹表来进行暴力破解，大大加大了黑客的破解成本</strong>。</li><li>在<strong>进行数据校验的时候我们需要组合盐值和用户输入数据之后再去计算MD5值进行校验</strong>。</li></ul><h2 id="用户注册后端实现"><a href="#用户注册后端实现" class="headerlink" title="用户注册后端实现"></a>用户注册后端实现</h2><ul><li><p>先在认证中心过了验证码的验证，然后远程调用会员模块的接口来将用户的数据存到数据库中。</p></li><li><p>细节还挺多的，首先就是<strong>后端校验数据，收集校验错误信息</strong>；然后就是<strong>从redis中拿验证码来和用户传过来的做对比校验，涉及验证码过期和验证码不匹配的情况，验证通过后要删除缓存（令牌机制）</strong>；然后就是<strong>远程调用用户模块来进行注册，可能成功也可能失败</strong>，用户注册的时候密码不能使用明文存储，使用spring家提供的<strong>BCryptPasswordEncoder</strong>类来做<strong>MD5盐值加密</strong>。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/regist&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">regist</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserRegistVo vo, BindingResult bindingResult)</span>&#123;</span><br><span class="line">    <span class="comment">//todo 重定向携带数据，利用session原理。将数据放到session中。只要跳到下一个页面取出这个数据后，session里面的数据就会删掉</span></span><br><span class="line">    <span class="comment">//todo 分布式下的session问题</span></span><br><span class="line">    <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">        <span class="comment">//收集所有错误信息，构造成一个map</span></span><br><span class="line">        Map&lt;String,String&gt; errors = bindingResult.getFieldErrors()</span><br><span class="line">                .stream()</span><br><span class="line">                .collect(Collectors.toMap(FieldError::getField,FieldError::getDefaultMessage));</span><br><span class="line">        <span class="keyword">return</span> Result.error().data(<span class="string">&quot;errors&quot;</span>,errors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> vo.getCode();</span><br><span class="line">    <span class="type">String</span> <span class="variable">redisResult</span> <span class="operator">=</span> redisTemplate.opsForValue().get(AuthServerConstant.SmsConstant.SMS_CODE_CACHE_PREFIX.getValue()+vo.getPhone());</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(redisResult))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error().message(<span class="string">&quot;验证码已过期&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!code.equals(redisResult.split(<span class="string">&quot;_&quot;</span>)[<span class="number">0</span>]))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error().message(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//验证码校验成功后删除验证码,令牌机制，只用一次</span></span><br><span class="line">    redisTemplate.delete(AuthServerConstant.SmsConstant.SMS_CODE_CACHE_PREFIX.getValue()+vo.getPhone());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用远程服务进行注册,可能成功也可能失败</span></span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> memberFeignService.regist(vo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>会员模块中保存用户数据的Service层方法，<strong>主要关注MD5盐值加密和自定义异常抛出</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UmsMemberLevelMapper umsMemberLevelMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">regist</span><span class="params">(MemberRegistVo vo)</span> <span class="keyword">throws</span> PhoneExistException,UsernameExistException&#123;</span><br><span class="line">    <span class="type">UmsMember</span> <span class="variable">member</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UmsMember</span>();</span><br><span class="line">    <span class="comment">//设置默认等级</span></span><br><span class="line">    <span class="comment">//UmsMemberLevel level = umsMemberLevelMapper.getDefaultLevel();</span></span><br><span class="line">    <span class="comment">//member.setLevelId(level.getId());</span></span><br><span class="line">    <span class="comment">//设置传过来的那些数据</span></span><br><span class="line">    <span class="comment">//检查用户名和手机号是否唯一</span></span><br><span class="line">    <span class="keyword">if</span>(checkPhoneUnique(vo.getPhone()))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PhoneExistException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(checkUsernameUnique(vo.getUsername()))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameExistException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    member.setUsername(vo.getUsername());</span><br><span class="line">    member.setMobile(vo.getPhone());</span><br><span class="line">    <span class="comment">//密码要进行加密存储,MD5加盐加密,spring家这个加盐算法就是能从最后的结果中解析出盐值来，但是怎么解析不知道，安全性就在这里体现</span></span><br><span class="line">    <span class="type">BCryptPasswordEncoder</span> <span class="variable">passwordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> passwordEncoder.encode(vo.getPassword());</span><br><span class="line">    member.setPassword(encode);</span><br><span class="line">    <span class="comment">//设置其他的默认信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> save(member);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPhoneUnique</span><span class="params">(String phone)</span>&#123;<span class="comment">//返回手机号是否存在，true就是已经存在，false就是不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.baseMapper.selectCount(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;UmsMember&gt;().eq(<span class="string">&quot;mobile&quot;</span>,phone))&gt;<span class="number">0</span>;<span class="comment">//查满足条件的记录的数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkUsernameUnique</span><span class="params">(String username)</span>&#123;<span class="comment">//返回用户名是否存在，true就是已经存在，false就是不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.baseMapper.selectCount(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;UmsMember&gt;().eq(<span class="string">&quot;username&quot;</span>,username))&gt;<span class="number">0</span>;<span class="comment">//查满足条件的记录的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>会员模块中保存用户数据的Controller层方法，<strong>主要关注针对不同异常使用相应的错误码返回</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/regist&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">regist</span><span class="params">(<span class="meta">@RequestBody</span> MemberRegistVo vo)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> umsMemberService.regist(vo)?Result.ok():Result.error();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (PhoneExistException e)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">return</span> Result</span><br><span class="line">                .error()</span><br><span class="line">                .code(ResultCode.PHONE_EXIST_EXCEPTION.getCode())</span><br><span class="line">                .message(ResultCode.PHONE_EXIST_EXCEPTION.getMessage());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (UsernameExistException e)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">return</span> Result</span><br><span class="line">                .error()</span><br><span class="line">                .code(ResultCode.USERNAME_EXIST_EXCEPTION.getCode())</span><br><span class="line">                .message(ResultCode.USERNAME_EXIST_EXCEPTION.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="通过使用自定义异常-Service层-和自定义错误码-Controller层-来处理程序出现的问题"><a href="#通过使用自定义异常-Service层-和自定义错误码-Controller层-来处理程序出现的问题" class="headerlink" title="通过使用自定义异常(Service层)和自定义错误码(Controller层)来处理程序出现的问题"></a>通过使用自定义异常(Service层)和自定义错误码(Controller层)来处理程序出现的问题</h2><ul><li><p>如果一个<strong>Service层的方法会发生很多问题，那么首先应该把这些问题对应的自定义异常抛出去，抛给Controller层</strong>；然后<strong>Controller针对不同的异常类型给统一返回对象设置对应异常类型的错误码</strong>。</p></li><li><p>这样做是因为<strong>Controller层是后端数据离开该模块的最后一层，应该使用统一返回对象来进行返回，从而可以让别的模块或者前端来解析使用，在这一层抛异常不合适</strong>。而<strong>Service层的数据是返回给Controller层的，它抛的异常Controller层也能接收到，所以可以向外抛异常</strong>。</p></li><li><p>这个用法在上一组业务代码中有体现。</p></li><li><p>自定义异常示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230125195746070.png" alt="image-20230125195746070"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFailedException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginFailedException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;用户账号或密码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="配置文件不起作用"><a href="#配置文件不起作用" class="headerlink" title="配置文件不起作用"></a>配置文件不起作用</h2><ul><li>可能是配置文件没有被build，检查配置文件是否被build进了classes目录，如果没有，应该在pom文件中显式声明将其加入要build的文件中。</li></ul><h2 id="开启mybatis-plus的日志打印"><a href="#开启mybatis-plus的日志打印" class="headerlink" title="开启mybatis-plus的日志打印"></a>开启mybatis-plus的日志打印</h2><ul><li><p>在配置文件中进行配置，打印的内容可以看到具体执行的sql语句：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置mybatis-plus的mapper位置，默认是classpath*:/mapper/**/*.xml，classpath后面的*代表除了自己的classpath，引入的jar包的classpath也会被检索</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/**/mapper/**/*.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#开启打印mybatis运行日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="用户登录后端实现"><a href="#用户登录后端实现" class="headerlink" title="用户登录后端实现"></a>用户登录后端实现</h2><ul><li><p>这个比较简单了就，主要就是注意使用<strong>BCryptPasswordEncoder</strong>类的match方法来验证密码，然后注意Service层和Controller层的<strong>抛接发问题处理模型（Service层抛异常，Controller层接异常，Controller层发错误码出去）</strong>。</p></li><li><p>先走认证中心，然后认证中心远程调用用户模块的登录方法。</p></li><li><p>认证中心的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> UserLoginVo vo)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> memberFeignService.login(vo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用户模块的Controller层方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> MemberLoginVo vo)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">UmsMember</span> <span class="variable">member</span> <span class="operator">=</span> umsMemberService.login(vo);</span><br><span class="line">        <span class="keyword">return</span> Result.ok().data(<span class="string">&quot;data&quot;</span>,member);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(LoginFailedException e)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">return</span> Result</span><br><span class="line">                .error()</span><br><span class="line">                .code(ResultCode.LOGIN_FAILED_EXCEPTION.getCode())</span><br><span class="line">                .message(ResultCode.LOGIN_FAILED_EXCEPTION.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用户模块的Service层方法（忘给数据的isDeleted属性加上自动填充注解导致好长时间都没有查出数据蚌）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UmsMember <span class="title function_">login</span><span class="params">(MemberLoginVo vo)</span> <span class="keyword">throws</span> LoginFailedException&#123;</span><br><span class="line">    <span class="comment">//System.out.println(vo.getLoginacct()+&quot; &quot;+vo.getPassword());</span></span><br><span class="line">    <span class="comment">//用户用username和phone登录都行</span></span><br><span class="line">    QueryWrapper&lt;UmsMember&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.eq(<span class="string">&quot;username&quot;</span>,vo.getLoginacct()).or().eq(<span class="string">&quot;mobile&quot;</span>,vo.getLoginacct());</span><br><span class="line">    <span class="comment">//System.out.println(wrapper.getSqlComment());</span></span><br><span class="line">    <span class="type">UmsMember</span> <span class="variable">member</span> <span class="operator">=</span> <span class="built_in">this</span>.baseMapper.selectOne(wrapper);</span><br><span class="line">    <span class="comment">//System.out.println(member);</span></span><br><span class="line">    <span class="comment">//用户不存在的情况处理一下</span></span><br><span class="line">    <span class="keyword">if</span>(member==<span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LoginFailedException</span>();</span><br><span class="line">    <span class="comment">//匹配密码，不匹配直接抛异常</span></span><br><span class="line">    <span class="type">BCryptPasswordEncoder</span> <span class="variable">passwordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    <span class="keyword">if</span>(!passwordEncoder.matches(vo.getPassword(),member.getPassword()))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LoginFailedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> member;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="社交登录"><a href="#社交登录" class="headerlink" title="社交登录"></a>社交登录</h2><ul><li>可以在登录界面提供第三方的登录，这样可以避免用户进行繁琐的注册流程，而且这些第三方平台使用的人一般也挺多，相当于变相利用第三方平台的大流量。</li><li>通过社交登录，就相当于我们利用用户在第三方平台上的一些信息，给这个用户自动注册了一个账号，注册的这个账号的一些信息是我们通过社交登录拿到的第三方平台上的这个用户的信息。</li></ul><h2 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h2><ul><li><p>OAuth（开放授权）：是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或者分享他们数据的所有内容。</p></li><li><p>OAuth2.0：与用户相关的OpenAPI（例如获取用户信息，动态同步，照片，日志，分享等），为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式地向用户征求授权。</p></li><li><p>官方版流程：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230125231614349.png" alt="image-20230125231614349"></p></li><li><p>比较准确的流程应该是：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230125231716917.png" alt="image-20230125231716917"></p><p>用户在输入完自己的第三方平台的登录信息之后，请求会发给第三方服务的服务器进行认证，认证通过之后会给用户想要登录的网站发送一个code，网站拿到这个code之后可以使用它向第三方服务器申请一个access_token，code一般只能用一次，网站拿到这个access_token之后，就可以拿着这个access_token去找qq存放用户开放信息的服务器请求用户开放数据来做相应的操作了，access_token一般可以使用多次，但有过期时间。</p></li></ul><h1 id="2023-x2F-1-x2F-26"><a href="#2023-x2F-1-x2F-26" class="headerlink" title="2023&#x2F;1&#x2F;26"></a>2023&#x2F;1&#x2F;26</h1><h2 id="使用第三方登录"><a href="#使用第三方登录" class="headerlink" title="使用第三方登录"></a>使用第三方登录</h2><ul><li>各第三方平台一般都会有他们对应的开放平台，其中提供很多开放的功能、api啥的 ，那想要用哪家的第三方登录功能就要去对应的开放平台去申请使用，申请完成之后，跟着开放平台上的文档一步步走就行了。</li></ul><h2 id="比较方便的封装了发送http请求的包"><a href="#比较方便的封装了发送http请求的包" class="headerlink" title="比较方便的封装了发送http请求的包"></a>比较方便的封装了发送http请求的包</h2><ul><li>可以用apache的HTTPUtils或者用restTemplate</li></ul><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><ul><li><p>时序图(Sequence Diagram)，又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。</p></li><li><p>也就是说可以用时序图来表示多个对象之间的交互关系</p></li><li><p>纵轴代表时间，横轴代表各种对象&#x2F;角色，对象下面的虚线是该对象的生命线，该对象的活动可以在生命线上用一个小矩形体现，这种小矩形叫控制焦点，对象之间发送同步消息用一条实线和实心箭头表示，发送异步消息用一条实线和一个大于号表示，返回消息用一条虚线和小于号表示，自关联的消息就是用箭头指向自己。</p></li><li><p>第三方登录的时序图示例：</p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126163007555.png" alt="image-20230126163007555"  /><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126162933956.png" alt="image-20230126162933956"></p></li><li><p>另一个时序图示例：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126151828420.png" alt="image-20230126151828420"></p></li></ul><h2 id="Session原理"><a href="#Session原理" class="headerlink" title="Session原理"></a>Session原理</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126164612737.png" alt="image-20230126164612737"></p><ul><li>由于<strong>http协议是无状态的，所以为了记录用户的状态使用户不必要每次都进行登录等重复操作，我们需要用到session技术</strong>，下面以登录场景举例，后台在处理用户的登录请求时，会<strong>将用户的状态存放在一个session中（可以想象session为一个map），所有session由一个sessionManager统一管理，之后服务器会命令浏览器保存一下这个用户的sessionId，浏览器就会保存，实际上这就是cookie，之后浏览器访问服务器都会带上它存储的cookie，cookie中有这个用户的sessionId等信息，服务器拿到之后就从sessionManager中找到对应的session，获取用户的状态从而将会话恢复到之前的状态</strong>。</li><li>就像是去银行卡办理业务一样，浏览器是客户，服务器是银行，客户进入银行存钱（session），银行发给客户一个银行卡（cookie）作为用户的凭证，这样每次用户来存钱银行都能正确处理。</li></ul><h2 id="Session共享问题"><a href="#Session共享问题" class="headerlink" title="Session共享问题"></a>Session共享问题</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126165443562.png" alt="image-20230126165443562"></p><ul><li>单机服务使用session没啥大问题，但是如果这个服务是个分布式的服务，问题就会出现，<strong>由于session是存放在受理用户对应操作的那个服务器上的，别的服务器没有用户的那个session，那么用户在使用别的服务器的服务的时候，那些服务器无法拿到用户的session</strong>。</li><li>比如用户在认证中心完成了登录，然后转到了主业务的服务器使用相应的服务，那么主业务的服务器是没有用户的session的，也就无法恢复用户的状态。再者如果用户都是使用的同一个服务，但是这个服务是集群部署，用户的请求经过负载均衡打在了同一服务的不同主机上，也没法保证提供服务的主机中有用户的session。这两个情景下的问题都是分布式下的session共享问题。</li></ul><h3 id="解决方案-session复制"><a href="#解决方案-session复制" class="headerlink" title="解决方案-session复制"></a>解决方案-session复制</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126170507748.png" alt="image-20230126170507748"></p><ul><li>这个优缺点都很明显，优点就是tomcat原生支持，配置起来简单；缺点就是session同步需要占用网络带宽、集群中节点数量太多的话单个节点会占用太多的空间来存储所有节点的session。</li><li>所以一般不用这种方法。</li></ul><h3 id="解决方案-客户端存储"><a href="#解决方案-客户端存储" class="headerlink" title="解决方案-客户端存储"></a>解决方案-客户端存储</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230127144611512.png" alt="image-20230127144611512"></p><ul><li>这种方法就是把session信息全都存到客户端的cookie中，不可能会用这种方法，安全性太低，而且cookie有长度限制，信息一多了就放不下了。</li></ul><h3 id="解决方案-hash一致性"><a href="#解决方案-hash一致性" class="headerlink" title="解决方案-hash一致性"></a>解决方案-hash一致性</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230127145021102.png" alt="image-20230127145021102"></p><ul><li>就是用户首次访问负载均衡服务器的时候，给用户的ip做一个hash，得到用户ip的hash值，然后再根据负载均衡给他分配服务器，以后只要还是这个ip过来访问，那么我们就给他转到和之前相同的服务器。</li><li>缺点就是服务器断电、服务器增减、用户ip改变等情况session会失效，不过这都是小概率事件。</li></ul><h3 id="解决方案-统一存储"><a href="#解决方案-统一存储" class="headerlink" title="解决方案-统一存储"></a>解决方案-统一存储</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230127145706059.png" alt="image-20230127145706059"></p><ul><li>来点儿名言：计算机中的问题没有什么是加一个中间层无法解决的。所以加一层装所有的session即可。不过就是增加了一次网络调用，读取速度比直接从内存中读取慢很多。</li></ul><h3 id="解决方案-子域session共享"><a href="#解决方案-子域session共享" class="headerlink" title="解决方案-子域session共享"></a>解决方案-子域session共享</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230127150420849.png" alt="image-20230127150420849"></p><ul><li>上面那个解决方案还有一些问题，就是当服务让浏览器存cookie的时候，默认的域名往往是子域名，这就导致浏览器只有访问对应的子域名的时候会带上cookie。</li><li>所以在上一个方案的基础上，我们应该在让浏览器存cookie的时候，手动声明域名为父域名以扩大cookie的作用域。</li></ul><h1 id="2023-x2F-1-x2F-27"><a href="#2023-x2F-1-x2F-27" class="headerlink" title="2023&#x2F;1&#x2F;27"></a>2023&#x2F;1&#x2F;27</h1><h2 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h2><ul><li>spring家给的session解决方案，不过现在前后端分离的项目好像不怎么用这种技术了，等我先研究研究现在的主流解决方案之后再回来搞这一块儿。&#x2F;&#x2F;todo</li><li>只要http协议还是无状态的协议，session技术就不会被淘汰。</li></ul><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><ul><li><p>Json Web Token（JWT）是为了网络应用环境间传递声明而执行的一种基于JSON的开发标准（RFC 7519），该token被设计为紧凑且安全的，特别适用于分布式站点的单点登陆（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p></li><li><p>总之，<strong>这个技术相当于把之前存在服务端的用户状态session转移到了用户端上</strong>，也就是说使用jwt生成的json对象中有用户的状态，我们把这个json对象叫做token，token存在客户端中，客户端想要从服务端申请数据的时候，就带上这个token，这样服务端就能从这个token中拆解出信息，从而对这个用户进行认证。这样<strong>服务端就不用保存任何session了，不用去考虑怎样解决分布式下的session共享问题了，将用户状态和服务端解耦，很明显对服务端的可扩展性是有提升的</strong>。</p></li><li><p>JWT的认证流程图：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230216230348282.png" alt="image-20230216230348282"></p></li></ul><h3 id="session和jwt的区别"><a href="#session和jwt的区别" class="headerlink" title="session和jwt的区别"></a>session和jwt的区别</h3><ol><li>session 存储在服务端占用服务器资源，而 JWT 存储在客户端</li><li>session 存储在 Cookie 中，存在伪造跨站请求伪造攻击的风险</li><li>session 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用</li><li>存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性</li></ol><h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><ul><li>就是如果要是一个公司下面有很多个项目，那么我们期望实现一处登录，处处登录，比如一个公司有个商城项目，还有个在线视频网站项目，那么我们期望用户注册的时候，只需要注册这个公司的账号，然后就能登录这个公司旗下的所有项目，并且在其中一个项目登录了账号之后，再访问另外一个项目就不用重复登录了，这样的功能就是单点登录功能-一次登录可以访问多个应用。</li><li>这个要练习起来比较吃环境，不大好办，之后再搞吧。&#x2F;&#x2F;todo</li></ul><h1 id="2023-x2F-1-x2F-28"><a href="#2023-x2F-1-x2F-28" class="headerlink" title="2023&#x2F;1&#x2F;28"></a>2023&#x2F;1&#x2F;28</h1><h2 id="使用alt-insert来在IDEA中快速创建预制代码块"><a href="#使用alt-insert来在IDEA中快速创建预制代码块" class="headerlink" title="使用alt+insert来在IDEA中快速创建预制代码块"></a>使用alt+insert来在IDEA中快速创建预制代码块</h2><ul><li>这个快捷键还挺好用的，可以快速创建构造器、重写方法、实现方法等。</li></ul><h2 id="使用拦截器来判断用户的状态"><a href="#使用拦截器来判断用户的状态" class="headerlink" title="使用拦截器来判断用户的状态"></a>使用拦截器来判断用户的状态</h2><ul><li><p><strong>拦截器是spring mvc中的内容，它可以在Controller层的方法调用之前、调用之后、页面渲染之后执行相应的操作</strong>，所以如果我们想每次执行业务方法之前判断用户的状态，可以自定义一个拦截器。</p></li><li><p>拦截器可以单独放在一个包中，自定义的拦截器要实现spring提供的<strong>HandlerInterceptor</strong>接口，然后根据需求重写接口中的不同方法，返回true是放行请求，返回false是拦截请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;<span class="comment">//返回true是放行请求，返回false是拦截请求</span></span><br><span class="line">        <span class="keyword">return</span> HandlerInterceptor.<span class="built_in">super</span>.preHandle(request, response, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果想要让拦截器工作，还需要让他注册到ioc容器中让其生效并设置其可以拦截的请求，对于mvc相关的配置，我们可以新建一个实现了<strong>WebMvcConfigurer</strong>接口的配置类，然后在配置类中通过重写相应的方法来进行相关的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartWebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//将自定义的拦截器使用注册器注册到容器中并让其生效，指定其可以拦截的请求为所有请求</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">CartInterceptor</span>())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用ThreadLocal在同一个线程共享数据"><a href="#使用ThreadLocal在同一个线程共享数据" class="headerlink" title="使用ThreadLocal在同一个线程共享数据"></a>使用ThreadLocal在同一个线程共享数据</h2><ul><li><p>当有请求到达tomcat的时候，tomcat就会用一个线程来处理这个请求，从拦截器到controller到service到dao最后再返回来，这一串都在同一个线程，这样我们就可以使用JDK的ThreadLocal来在这一个线程中共享数据。</p></li><li><p>比如在拦截器中取得了一些数据，把这些数据做到ThreadLocal对象后，在进行后面的操作的时候就可以很容易地取出这些数据了。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230128182826838.png" alt="image-20230128182826838"></p></li><li><p>使用ThreadLocal可以新建一个它的泛型，对外开放，再调用其set方法来维护一个对象，一个ThreadLocal只能维护一个对象，用的时候使用get方法取出ThreadLocal维护的对象。</p></li><li><p>使用ThreadLocal的好处就是可以实现线程隔离，<strong>每个线程都有一个属于自己的ThreadLocalMap&lt;ThreadLocal&lt;T&gt;,Object&gt;<strong>，这个类是ThreadLocal的内部类，</strong>ThreadLocalMap维护着当前线程的所有ThreadLocal对象对应的对象</strong>，这样<strong>每次使用ThreadLocal的get方法取出对象的时候，实际上是从本线程的ThreadLocalMap中取那个ThreadLocal对应的那个对象，这样就实现了线程之间的隔离</strong>，同理，<strong>使用ThreadLocal的set方法的时候也是在本线程的ThreadLocalMap中set进ThreadLocal和那个对象组成的键值对</strong>。</p></li><li><p>ThreadLocal的set方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//得到当前线程的对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//得到线程对象的ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);<span class="comment">//向当前线程的ThreadLocalMap中存放当前ThreadLocal对应的对象</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ThreadLocal的get方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//得到当前线程的对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//得到线程对象的ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);<span class="comment">//从当前线程的ThreadLocalMap中获得当前ThreadLocal对应的对象</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Docker安装RabbitMQ"><a href="#Docker安装RabbitMQ" class="headerlink" title="Docker安装RabbitMQ"></a>Docker安装RabbitMQ</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230128192259784.png" alt="image-20230128192259784"></p><ul><li>从15672端口进rabbitmq的可视化管理界面，用户名和密码默认都是guest</li><li>客户端使用高级消息队列协议（AMQP）来和rabbitmq进行交互的端口是5672端口</li><li>rabbitmq支持导出和导入配置文件，这让配置的迁移变得简单</li></ul><h1 id="2023-x2F-1-x2F-30"><a href="#2023-x2F-1-x2F-30" class="headerlink" title="2023&#x2F;1&#x2F;30"></a>2023&#x2F;1&#x2F;30</h1><h2 id="RabbitMQ的工作原理"><a href="#RabbitMQ的工作原理" class="headerlink" title="RabbitMQ的工作原理"></a>RabbitMQ的工作原理</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029093829448.png" alt="image-20221029093829448"></p><ul><li><strong>Broker（代理）</strong>：<strong>接收和分发消息的应用</strong>，RabbitMQ Server 就是 Message Broker。</li><li><strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP（协议）的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。<strong>当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</strong>。</li><li><strong>Connection</strong>：<strong>publisher／consumer 和 broker 之间的 TCP 连接</strong>。</li><li><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。<strong>Channel 是在 connection 内部建立的逻辑连接</strong>，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的Connection极大减少了操作系统建立TCP connection的开销</strong>。</li><li><strong>Exchange</strong>：message 到达 broker 的第一站，<strong>根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去</strong>。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</li><li><strong>Queue</strong>：<strong>消息最终被送到这里等待 consumer 取走</strong>。</li><li><strong>Binding</strong>：<strong>exchange 和 queue 之间的虚拟连接</strong>，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</li></ul><h2 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><ul><li><p>首先引入高级消息队列的场景启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring-boot-starter-amqp.version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">spring-boot-starter-amqp.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--高级消息队列的场景启动器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-starter-amqp.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引入场景启动器后RabbitAutoConfiguration就会自动生效，它会<strong>向容器中自动注册RabbitTemplate、AmqpAdmin、CachingConnectionFactory、RabbitMessagingTemplate对象</strong>，并且<strong>所有属性都可以通过前缀为“spring.rabbitmq”的配置项来在配置文件中进行配置</strong>。</p></li></ul><h3 id="进行配置"><a href="#进行配置" class="headerlink" title="进行配置"></a>进行配置</h3><ul><li><p>在配置文件中进行配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定rabbitmq的主机地址和连接端口</span></span><br><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">konjacer.com</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="comment">#配置virtual-host，这个和namespace的概念差不多，是用来做不同用户之间的隔离的</span></span><br><span class="line"><span class="attr">spring.rabbitmq.virtual-host</span>=<span class="string">/</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="开启注解"><a href="#开启注解" class="headerlink" title="开启注解"></a>开启注解</h3><ul><li>使用**@EnableRabbit**来启动高级消息队列的功能</li></ul><h3 id="增删组件"><a href="#增删组件" class="headerlink" title="增删组件"></a>增删组件</h3><ul><li><p>对于<strong>RabbitMQ中的交换机、队列、Binding等组件的增删操作可以使用之前向容器中注册的AmqpAdmin对象来做</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">AmqpAdmin amqpAdmin;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAmqpAdmin</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//创建Exchange交换机</span></span><br><span class="line"><span class="type">DirectExchange</span> <span class="variable">directExchange</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;test-exchange&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">amqpAdmin.declareExchange(directExchange);</span><br><span class="line"><span class="comment">//创建Queue队列,exclusive如果是true那么只有一个连接可以连接到这个队列</span></span><br><span class="line"><span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;test-queue&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">amqpAdmin.declareQueue(queue);</span><br><span class="line"><span class="comment">//创建Binding绑定关系来绑定交换机和队列,将指定的交换机和目的地（可以是交换机也可以是队列,在第二个参数中声明）进行绑定，使用routingKey作为指定的路由键</span></span><br><span class="line"><span class="type">Binding</span> <span class="variable">binding</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Binding</span>(<span class="string">&quot;test-queue&quot;</span>, Binding.DestinationType.QUEUE,<span class="string">&quot;test-exchange&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">amqpAdmin.declareBinding(binding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><ul><li><p>如果想要<strong>进行收发消息的相关操作，我们可以使用之前注册到容器中的RabbitTemplate对象</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRabbitTemplate</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//发送消息,会使用到序列化机制将对象写出去,默认使用java的序列化机制,所以如果发送的消息是个对象，那么对象对应的类必须实现序列化接口Serializable</span></span><br><span class="line"><span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">rabbitTemplate.convertAndSend(<span class="string">&quot;test-exchange&quot;</span>,<span class="string">&quot;test&quot;</span>,msg);</span><br><span class="line"><span class="comment">//更改默认的序列化机制需要在ioc容器中添加另外一个消息转换器以覆盖默认的消息转换器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果想要更改默认的写出对象的序列化机制，可以<strong>在配置类中向ioc容器中添加一个新的json消息转换器以覆盖默认的转换器，这样以后就是将对象转换成json数据写出了</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;<span class="comment">//将json的消息转换器放到ioc容器中，这样以后在发送对象消息的时候，对象会被序列化成json数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><ul><li><p>主要是通过两个注解来实现消息的接收，首先就是**@RabbitListener<strong>注解，这个注解可以修饰方法和类，其中queue属性可以声明要监听的队列名称，如果要是修饰方法，那么被监听的队列中来了新消息后被修饰的方法会接收到新的消息；如果要是这个注解修饰类，那么被监听的队列中来了新消息之后，类中被</strong>@RabbitHandler**注解修饰的方法会根据消息类型和自己的形参类型来接收消息（如果类型相同就接收）。</p></li><li><p>一般都是用**@RabbitListener<strong>注解修饰类，然后用</strong>@RabbitHandler<strong>注解修饰类中的方法，这样可以</strong>细化接收消息方法的粒度，每个方法只接收符合自己实参类型的消息<strong>，注意</strong>方法中可以选择三个接收参数**：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;test-queue&quot;&#125;)</span><span class="comment">//声明要监听的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OmsOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OmsOrderMapper, OmsOrder&gt; <span class="keyword">implements</span> <span class="title class_">OmsOrderService</span> &#123;</span><br><span class="line">    <span class="comment">//一个队列可以很多消费者来同时监听，只要消费者收到消息，队列就会删除消息，所以一个消息只会被一个消费者接收到，默认是轮询接收策略</span></span><br><span class="line">    <span class="comment">//只有当一个消息完全处理完（即方法运行结束），才可以接收下一个消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span><span class="comment">//声明该方法为消息处理方法，如果有消息到达类上注解中声明的要监听的队列，那么被@RabbitHandler注解修饰的方法会根据消息对象的类型和形参类型来选择接收（两者类型相同就接收）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">            Message msg,</span></span><br><span class="line"><span class="params">            OmsOrderService omsOrderService,</span></span><br><span class="line"><span class="params">            Channel channel</span></span><br><span class="line"><span class="params">    )</span>&#123;<span class="comment">//可选三个参数接收：原生消息类型Message封装了消息（消息头+消息体），除了消息本身还有很多其他信息，第二个参数写消息中的对象的类可以直接接收到消息对象，第三个参数可以获取到客户端和mq之间连接中的进行消息交互的channel</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span>+msg+<span class="string">&quot; &quot;</span>+<span class="string">&quot;接收到的消息内容对象：&quot;</span>+omsOrderService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一个队列可以很多消费者来同时监听，只要消费者收到消息，队列就会删除消息，所以<strong>一个消息只会被一个消费者接收到</strong>，默认是轮询接收策略。</p></li><li><p><strong>只有当一个消息完全处理完（即方法运行结束），对应的方法才可以接收下一个消息</strong>。</p></li></ul><h2 id="RabbitMQ消息确认机制-可靠抵达"><a href="#RabbitMQ消息确认机制-可靠抵达" class="headerlink" title="RabbitMQ消息确认机制-可靠抵达"></a>RabbitMQ消息确认机制-可靠抵达</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230130173903685.png" alt="image-20230130173903685"></p><ul><li>为了保证消息的可靠抵达，我们可以在channel中使用事务机制，所有步骤都成功了之后整体才会成功，但是这样做性能下降很严重。我们还可以使用消息确认机制来实现消息的可靠抵达，这种方案性能损耗较小。</li></ul><h3 id="开启ConfirmCallback回调"><a href="#开启ConfirmCallback回调" class="headerlink" title="开启ConfirmCallback回调"></a>开启ConfirmCallback回调</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230130174647641.png" alt="image-20230130174647641"></p><ul><li><p>是<strong>生产者的消息成功到达Broker的回调方法</strong>，要想开启这个方法，可以<strong>在配置文件中进行相应的配置</strong>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启从生产者到Broker的消息成功到达回调，开启后消息成功从生产者到Broker后RabbitTemplate会调用对应的回调方法ConfirmCallback，所以如果我们想要定制这个回调方法，需要改一下RabbitTemplate中的参数然后再把它扔回ioc容器</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure></li><li><p>然后<strong>在配置文件中定制一下rabbitTemplate，给里面塞一个自定义的ConfirmCallback方法</strong>，这样之后消息从生产者到Broker之后，rabbitTemplate就会调用我们自定义的ConfirmCallback回调方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;<span class="comment">//将json的消息转换器放到ioc容器中，这样以后在发送对象消息的时候，对象会被序列化成json数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制rabbitTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span><span class="comment">//在MyRabbitConfig对象的构造器执行完之后再执行这个方法，为的是让RabbitTemplate先装载完毕？2023-03-11：这个是在选择构造器，实例化，依赖注入，处理相关aware类的重写方法之后执行，所以在执行的时候，rabbitTemplate已经被注入了，可以直接使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRabbitTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自定义消息从生产者到Broker的成功回调</span></span><br><span class="line"><span class="comment">         * 只要消息从生产者到Broker，ack就等于true</span></span><br><span class="line"><span class="comment">         * correlationData：当前消息的唯一关联数据（这个是消息的唯一id），发送的时候最好带上这个参数（要能唯一标识一个消息，可以是uuid），这样方便后面识别消息，也方便存数据库</span></span><br><span class="line"><span class="comment">         * ack：消息是否成功收到</span></span><br><span class="line"><span class="comment">         * cause：失败的原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(((correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;correlationData:&quot;</span>+correlationData+<span class="string">&quot;ack:&quot;</span>+ack+<span class="string">&quot;cause:&quot;</span>+cause);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="开启ReturnCallback回调"><a href="#开启ReturnCallback回调" class="headerlink" title="开启ReturnCallback回调"></a>开启ReturnCallback回调</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230130210051832.png" alt="image-20230130210051832"></p><ul><li><p>是<strong>消息未能从交换机传到队列中的回调方法</strong>，要想启用这个方法，可以在配置文件中进行设置，下面<strong>还设置开启了一个消息到达队列的回调方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#开启消息未能从交换机传到队列的回调方法</span><br><span class="line">spring.rabbitmq.publisher-returns=<span class="literal">true</span></span><br><span class="line">#只要抵达队列，优先以异步的方式回调ReturnConfirm方法</span><br><span class="line">spring.rabbitmq.template.mandatory=<span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>然后就是在RabbitTemplate中自定义上面开启的两个回调方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;<span class="comment">//将json的消息转换器放到ioc容器中，这样以后在发送对象消息的时候，对象会被序列化成json数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制rabbitTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span><span class="comment">//在MyRabbitConfig对象的构造器执行完之后再执行这个方法，为的是让RabbitTemplate先装载完毕？</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRabbitTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自定义消息从生产者到Broker的成功回调</span></span><br><span class="line"><span class="comment">         * 只要消息从生产者到Broker，ack就等于true</span></span><br><span class="line"><span class="comment">         * correlationData：当前消息的唯一关联数据（这个是消息的唯一id），发送的时候最好带上这个参数（要能唯一标识一个消息，可以是uuid），这样方便后面识别消息，也方便存数据库</span></span><br><span class="line"><span class="comment">         * ack：消息是否成功收到</span></span><br><span class="line"><span class="comment">         * cause：失败的原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(((correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;correlationData:&quot;</span>+correlationData+<span class="string">&quot;ack:&quot;</span>+ack+<span class="string">&quot;cause:&quot;</span>+cause);</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自定义消息未抵达队列的回调</span></span><br><span class="line"><span class="comment">         * message：投递失败的消息的详细信息</span></span><br><span class="line"><span class="comment">         * replyCode：回复的状态码</span></span><br><span class="line"><span class="comment">         * replyText：回复的文本内容</span></span><br><span class="line"><span class="comment">         * exchange：当时这个消息是从哪个交换机发出去的</span></span><br><span class="line"><span class="comment">         * routingKey：当时这个消息用的哪个路由键</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;失败的消息：&quot;</span>+message);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="开启ack消息确认机制"><a href="#开启ack消息确认机制" class="headerlink" title="开启ack消息确认机制"></a>开启ack消息确认机制</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230131161537978.png" alt="image-20230131161537978"></p><ul><li><p>是<strong>消息从队列到消费者的回调，有ack和nack&#x2F;reject三种回调，ack是逻辑上消息处理成功，nack&#x2F;reject是逻辑上消息处理失败</strong>，消费者客户端在不同的时间执行这两个回调时”处理成功&#x2F;失败“有不同的意义，需要具体情况具体分析，<strong>默认是自动确认的，只要消息被消费者接收到，那么即使消息没有被处理完（也就是接收消息的方法没有运行完）消费者客户端也会自动确认ack，服务端收到确认ack后就会移除对应的消息</strong>。</p></li><li><p>上面说的<strong>这种只要接收到消息就自动确认的机制是有很大问题的，会造成消息的丢失</strong>，比如消费者收到了很多消息，对于这些消息消费者都回复了ack，服务端收到ack后就把队列中的消息删除了，但是消费者在处理完一部分消息后宕机了，那么那些没有处理完的消息就丢失了，队列里也没了，因为服务端收到ack后就把对应的消息删掉了。</p></li><li><p>所以要解决上面说的那种问题，我们<strong>可以采用手动确认，也就是处理消息的方法结束之后，我们再手动向服务端发送ack</strong>，这样就能保证服务端接收到ack并删除对应消息的时候，消息已经再消费者客户端处理完毕了，<strong>解决了上面那种情况下消息丢失的问题</strong>。<strong>在手动确认模式下，只要我们没有调用ack，那么服务端中对应的消息就一直是unchecked状态，即使消费者宕机消息也不会丢失，而是会变成ready状态，当下一次有新的消费者连接到这个队列的时候，消息就会被重新发给消费者</strong>。要想采用手动确认，首先要在配置文件中进行相关的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#手动ack消息</span><br><span class="line">spring.rabbitmq.listener.simple.acknowledge-mode=manual</span><br></pre></td></tr></table></figure></li><li><p>然后就是在处理消息的方法中手动调用channel的一些有ack&#x2F;nack&#x2F;reject功能的方法来告知服务端消息的处理情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------ack消息处理完毕------------------------------------</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;test-queue&quot;&#125;)</span><span class="comment">//声明要监听的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OmsOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OmsOrderMapper, OmsOrder&gt; <span class="keyword">implements</span> <span class="title class_">OmsOrderService</span> &#123;</span><br><span class="line">    <span class="comment">//一个队列可以很多消费者来同时监听，只要消费者收到消息，队列就会删除消息，所以一个消息只会被一个消费者接收到，默认是轮询接收策略</span></span><br><span class="line">    <span class="comment">//只有当一个消息完全处理完（即方法运行结束），才可以接收下一个消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span><span class="comment">//声明该方法为消息处理方法，如果有消息到达类上注解中声明的要监听的队列，那么被@RabbitHandler注解修饰的方法会根据消息对象的类型和形参类型来选择接收（两者类型相同就接收）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">            Message msg,</span></span><br><span class="line"><span class="params">            OmsOrderService omsOrderService,</span></span><br><span class="line"><span class="params">            Channel channel</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> IOException &#123;<span class="comment">//可选三个参数接收：原生消息类型Message封装了消息（消息头+消息体），除了消息本身还有很多其他信息，第二个参数写消息中的对象的类可以直接接收到消息对象，第三个参数可以获取到客户端和mq之间连接中的进行消息交互的channel</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span>+msg+<span class="string">&quot; &quot;</span>+<span class="string">&quot;接收到的消息内容对象：&quot;</span>+omsOrderService);</span><br><span class="line">        <span class="comment">//手动确认ack表示消息已经处理完毕，服务端可以把对应的消息删掉了</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> msg.getMessageProperties().getDeliveryTag();<span class="comment">//获取消息在队列中的编号，用于ack</span></span><br><span class="line">        channel.basicAck(deliveryTag,<span class="literal">false</span>);<span class="comment">//第一个参数是消息在队列中的编号，用于服务端找到对应的消息，第二个参数为是否批量删除，false表示这个ack只ack对应的那一条消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------nack/reject拒收消息------------------------------------</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;test-queue&quot;&#125;)</span><span class="comment">//声明要监听的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OmsOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OmsOrderMapper, OmsOrder&gt; <span class="keyword">implements</span> <span class="title class_">OmsOrderService</span> &#123;</span><br><span class="line">    <span class="comment">//一个队列可以很多消费者来同时监听，只要消费者收到消息，队列就会删除消息，所以一个消息只会被一个消费者接收到，默认是轮询接收策略</span></span><br><span class="line">    <span class="comment">//只有当一个消息完全处理完（即方法运行结束），才可以接收下一个消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span><span class="comment">//声明该方法为消息处理方法，如果有消息到达类上注解中声明的要监听的队列，那么被@RabbitHandler注解修饰的方法会根据消息对象的类型和形参类型来选择接收（两者类型相同就接收）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">            Message msg,</span></span><br><span class="line"><span class="params">            OmsOrderService omsOrderService,</span></span><br><span class="line"><span class="params">            Channel channel</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> IOException &#123;<span class="comment">//可选三个参数接收：原生消息类型Message封装了消息（消息头+消息体），除了消息本身还有很多其他信息，第二个参数写消息中的对象的类可以直接接收到消息对象，第三个参数可以获取到客户端和mq之间连接中的进行消息交互的channel</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span>+msg+<span class="string">&quot; &quot;</span>+<span class="string">&quot;接收到的消息内容对象：&quot;</span>+omsOrderService);</span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> msg.getMessageProperties().getDeliveryTag();<span class="comment">//获取消息在队列中的编号，用于ack</span></span><br><span class="line">        <span class="comment">//手动调用nack/reject表示拒收消息,第一个参数是消息在队列中的编号，第二个参数为是否批量拒绝，第三个参数为是否将拒收的消息重新入队，如果是false，则直接删除掉对应的消息</span></span><br><span class="line">        channel.basicNack(deliveryTag,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2023-x2F-1-x2F-31"><a href="#2023-x2F-1-x2F-31" class="headerlink" title="2023&#x2F;1&#x2F;31"></a>2023&#x2F;1&#x2F;31</h1><h2 id="RabbitMQ延时队列实现定时任务"><a href="#RabbitMQ延时队列实现定时任务" class="headerlink" title="RabbitMQ延时队列实现定时任务"></a>RabbitMQ延时队列实现定时任务</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230131170636690.png" alt="image-20230131170636690"></p><p>- </p><h2 id="Feign远程调用丢失请求头的问题"><a href="#Feign远程调用丢失请求头的问题" class="headerlink" title="Feign远程调用丢失请求头的问题"></a>Feign远程调用丢失请求头的问题</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230131191229994.png" alt="image-20230131191229994"></p><ul><li><p>简而言之就是<strong>Feign在进行远程调用的时候会创建一个新的request，这个request中啥也没有，然后再根据远程调用方法的参数向request的请求体等地方塞数据</strong>，但是由于远程调用方法传的只是数据，所以Feign新建的request只能得到数据，无法得到别的东西，自然就无法得到服务收到的请求的请求头等信息。</p></li><li><p>所以我们应该在feign新建request完成之前，给request设置好它的请求头。通过feign运行过程的源码可以得知，在feign新建request完成之前会执行多个拦截器，所以我们可以<strong>编写一个feign中用到的拦截器，在拦截器中手动给feign构造的requestTemplate中加入当前收到的请求的请求头</strong>。那么如何给拦截器共享请求头呢？由于拦截器和收到请求的服务是在同一个线程中，所以当然<strong>可以使用ThreadLocal进行数据共享</strong>；<strong>也可以使用spring给我们封装的当前线程的请求数据，使用RequestContextHolder.getRequestAttributes()来获取</strong>，RequestContextHolder中维护了很多当前线程请求的上下文数据，这个底层就是用ThreadLocal实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallislandFeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;requestInterceptor&quot;)</span><span class="comment">//设置这个bean的标识符</span></span><br><span class="line">    <span class="keyword">public</span> RequestInterceptor <span class="title function_">requestInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> template -&gt; &#123;</span><br><span class="line">            <span class="comment">//通过RequestContextHolder拿到当前线程收到的请求</span></span><br><span class="line">            <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">            <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();<span class="comment">//获取请求</span></span><br><span class="line">            <span class="comment">//获得当前线程收到请求的cookie</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">cookie</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Cookie&quot;</span>);</span><br><span class="line">            <span class="comment">//把当前线程收到请求的cookie放到feign构造的requestTemplate中</span></span><br><span class="line">            template.header(<span class="string">&quot;Cookie&quot;</span>,cookie);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>所以解决后整个流程应该是这样的：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230131195252805.png" alt="image-20230131195252805"></p></li></ul><h2 id="异步情况下Feign丢失上下文的问题"><a href="#异步情况下Feign丢失上下文的问题" class="headerlink" title="异步情况下Feign丢失上下文的问题"></a>异步情况下Feign丢失上下文的问题</h2><ul><li><p>在上面加上拦截器的情况下，对Feign的远程调用方法进行异步调用的时候，Feign构造的request又出现了没有header的情况，这是什么问题呢？这是<strong>因为异步任务换了线程了，异步任务所在的线程无法获取到别的线程的ThreadLocal中的数据</strong>：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230131202603266.png" alt="image-20230131202603266"></p></li><li><p>解决方法很简单，<strong>只需要在CompletableFuture的方法参数中写的异步任务流程的lambda中手动添加上主线程的数据即可</strong>，可以在主线程使用RequestContextHolder的getRequestAttributes方法拿到数据，然后再在异步任务流程的lambda中使用使用RequestContextHolder的setRequestAttributes方法设置数据，RequestContextHolder底层是基于ThreadLocal实现的，所以不同线程有不同的RequestContextHolder。</p></li></ul><h1 id="2023-x2F-2-x2F-2"><a href="#2023-x2F-2-x2F-2" class="headerlink" title="2023&#x2F;2&#x2F;2"></a>2023&#x2F;2&#x2F;2</h1><h2 id="对数据库非主属性的唯一性约束"><a href="#对数据库非主属性的唯一性约束" class="headerlink" title="对数据库非主属性的唯一性约束"></a>对数据库非主属性的唯一性约束</h2><ul><li>可以给那个属性添加唯一索引，这样可以保证那个属性值的唯一性，但是唯一索引的效率可能偏低？</li></ul><h2 id="接口的幂等性"><a href="#接口的幂等性" class="headerlink" title="接口的幂等性"></a>接口的幂等性</h2><h3 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h3><ul><li>接口幂等性就是<strong>用户对于同一操作发起的一次请求或者多次请求的结果是一致的</strong>，不会因为多次点击而产生了副作用。</li></ul><h3 id="哪些情况下需要保证接口的幂等性"><a href="#哪些情况下需要保证接口的幂等性" class="headerlink" title="哪些情况下需要保证接口的幂等性"></a>哪些情况下需要保证接口的幂等性</h3><ol><li>用户多次点击同一个按钮（也就是用户多次调用同一个接口）</li><li>用户回退页面后再次进行提交</li><li>微服务之间进行互相调用，由于网络问题导致请求失败，feign触发重试机制</li><li>其他业务情况</li></ol><h3 id="什么情况下不需要保证接口的幂等性"><a href="#什么情况下不需要保证接口的幂等性" class="headerlink" title="什么情况下不需要保证接口的幂等性"></a>什么情况下不需要保证接口的幂等性</h3><ul><li>以SQL为例，有些操作是天然幂等的，比如crud一些固定的值、带主键的insert。</li><li>而有些SQL却不是幂等的，比如update一个值让其+1，或者是insert一个不带主键的元素（可以重复被insert）。</li></ul><h2 id="接口幂等性的解决方案"><a href="#接口幂等性的解决方案" class="headerlink" title="接口幂等性的解决方案"></a>接口幂等性的解决方案</h2><h3 id="token令牌机制"><a href="#token令牌机制" class="headerlink" title="token令牌机制"></a>token令牌机制</h3><ul><li>服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，<strong>服务器会把token保存在redis中</strong>。</li><li>然后调用业务接口请求的时候，把token携带到后端，<strong>token一般放在请求头部</strong>。</li><li>服务器判断token是否在redis中存在，如果存在表示这是第一次请求，删除token，继续执行业务。</li><li>如果判断token不存在redis中，就表示当前的操作是重复操作，直接返回重复标记给客户端，这样就保证了业务代码不被重复执行。</li></ul><h4 id="危险性"><a href="#危险性" class="headerlink" title="危险性"></a>危险性</h4><ol><li><p>先删除token还是后删除token？</p><ul><li>先删除可能导致第一次请求过来删除token后，业务没能处理完成，进行重试的时候，带的是之前的token，但是之前的token已经被删掉了，所以业务就无法被处理完成了。</li><li>后删除可能导致在处理的过程中，服务闪断，出现超时，token没能被删除，别人继续重试的时候，由于token还存在，所以服务又会被处理一次。</li><li>所以<strong>在使用token的时候，最好是设计成先删除token，如果业务调用失败，就重新获取新的token再次请求</strong>。</li></ul></li><li><p>token的获取、比较和删除操作的整体必须是原子性的</p><ul><li><p>这个问题比较好理解，如果这三个操作的整体不是原子性的，那么在高并发的情况下可能会产生业务的重复处理（一个时间段可能同时有很多线程拿到了那个token并进行比较）。</p></li><li><p>可以使用lua脚本完成这个操作：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[<span class="number">1</span>])==ARGV[<span class="number">1</span>] <span class="keyword">then</span> <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>]) <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="各种锁机制"><a href="#各种锁机制" class="headerlink" title="各种锁机制"></a>各种锁机制</h3><h4 id="数据库悲观锁"><a href="#数据库悲观锁" class="headerlink" title="数据库悲观锁"></a>数据库悲观锁</h4><ul><li>例：select * from xxxx where id &#x3D; 1 for update;</li><li>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，需要根据实际情况选用。另外要注意的是，id 字段一定是主键或者唯一索引，不然可能造成锁表的结果，处理起来会非常麻烦。</li></ul><h4 id="数据库乐观锁"><a href="#数据库乐观锁" class="headerlink" title="数据库乐观锁"></a>数据库乐观锁</h4><ul><li>这种方法适合用在更新的场景中，例：update t_goods set count &#x3D; count -1 , version &#x3D; version + 1 where good_id&#x3D;2 and version &#x3D; 1</li><li>根据 version 版本，也就是在操作库存前先获取当前商品的 version 版本号，然后操作的时候带上此 version 号。我们梳理下，我们第一次操作库存时，得到 version 为1，调用库存服务version 变成了 2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传入的 version 还是 1，再执行上面的 sql 语句时，就不会执行；因为version 已经变为 2 了，where 条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。乐观锁主要使用于处理读多写少的问题。</li></ul><h4 id="业务层分布式锁"><a href="#业务层分布式锁" class="headerlink" title="业务层分布式锁"></a>业务层分布式锁</h4><ul><li>如果多个机器可能在同一时间同时处理相同的数据，比如多台机器定时任务都拿到了相同数据处理，我们就可以加分布式锁，锁定此数据，处理完成后释放锁。获取到锁的必须先判断这个数据是否被处理过。</li></ul><h3 id="各种唯一约束"><a href="#各种唯一约束" class="headerlink" title="各种唯一约束"></a>各种唯一约束</h3><h4 id="数据库唯一约束"><a href="#数据库唯一约束" class="headerlink" title="数据库唯一约束"></a>数据库唯一约束</h4><ul><li>插入数据，应该按照唯一索引进行插入，比如订单号，相同的订单就不可能有两条记录插入。我们在数据库层面防止重复。</li><li>这个机制是利用了数据库的主键唯一约束的特性，解决了在 insert 场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。</li><li>如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。</li></ul><h4 id="用redis的set数据结构防重"><a href="#用redis的set数据结构防重" class="headerlink" title="用redis的set数据结构防重"></a>用redis的set数据结构防重</h4><ul><li>很多数据需要处理，只能被处理一次，比如我们可以计算数据的 MD5 将其放入redis 的set，每次处理数据，先看这个 MD5 是否已经存在，存在就不处理</li></ul><h3 id="防重表"><a href="#防重表" class="headerlink" title="防重表"></a>防重表</h3><ul><li>使用订单号 orderNo 做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。</li><li>之前的redis的set防重也是这个道理。</li></ul><h3 id="全局请求唯一id"><a href="#全局请求唯一id" class="headerlink" title="全局请求唯一id"></a>全局请求唯一id</h3><ul><li>调用接口时，生成一个唯一 id，redis 将数据保存到集合中（去重），存在即处理过。可以使用 nginx 设置每一个请求的唯一 id：<code>proxy_set_header X-Request-Id $request_id;</code></li></ul><h2 id="使用token令牌机制解决接口幂等性"><a href="#使用token令牌机制解决接口幂等性" class="headerlink" title="使用token令牌机制解决接口幂等性"></a>使用token令牌机制解决接口幂等性</h2><ul><li>在给需要用到幂等性接口的前端返回数据的时候生成一个token，给前端发一份，给redis中存一份。举例来说，给redis中存的时候，key可以用固定前缀+用户id，这样能保证一个用户在同一时间内只能完成一个订单。</li><li>在进行token验证的时候要注意两点，第一是<strong>要验证完token后要先删掉token再处理业务，这是为了防止业务重复处理</strong>；第二是<strong>要保证获取、比较、删除token这三步整体的原子性，这是为了防止在高并发的情况下导致的业务重复处理</strong>，保证三步完整性的lua脚本：**<code>if redis.call(&#39;get&#39;,KEYS[1])==ARGV[1] then return redis.call(&#39;del&#39;,KEYS[1]) else return 0 end</code>**，使用StringRedisTemplate中的execute方法来执行lua脚本，返回0说明token校验失败，返回1说明token校验成功。</li></ul><h2 id="Transactional本地事务"><a href="#Transactional本地事务" class="headerlink" title="@Transactional本地事务"></a>@Transactional本地事务</h2><ul><li><p>这个注解用于方法上，表明该方法对数据库的操作是一个事务，如果要是<strong>被这个注解修饰的方法中抛了异常，那么这个方法之前对数据库做的操作都会回滚（默认是对抛出的RuntimeException作出相应）</strong>。</p></li><li><p>可以<strong>通过这个注解的rollbackFor属性指定方法抛出哪些异常时数据库会回滚</strong>。</p></li><li><p><strong>本地事务只能控制当前服务对数据库操作的回滚，无法控制业务处理链上其他服务对数据库操作的回滚</strong>。</p></li><li><p>可以<strong>使用isolation属性来调整事务的隔离级别，MySQL的事务隔离级别默认是REPEATABLE-READ（可重复读）</strong>。</p></li><li><p>可以<strong>使用propagation属性来调整事务的传播行为，MySQL的事务传播行为默认是REQUIRED</strong>。</p></li><li><p>可以<strong>使用timeout属性来设置事务的超时时间，也就是这个事务如果要是在规定的时间内没有处理完的话，就会回滚数据库操作</strong>。</p></li><li><p>spring家的事务注解是通过生成代理对象来实现功能的，所以同一个对象内事务方法互调时，被调用的事务方法的注解是默认失效的，因为这样做相当于绕过了代理对象。所以在同一个对象内进行事务方法互调的时候，应该使用代理对象来进行事务方法的调用：</p><ol><li><p>首先引入aop的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring-boot-starter-aop.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring-boot-starter-aop.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--aop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-starter-aop.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后<strong>在配置类上用注解开启AspectJ动态代理的功能并对外暴露代理对象</strong>：**<code>@EnableAspectJAutoProxy</code>**，这样以后创建动态代理都是通过AspectJ来进行创建（即使没有实现接口，也能创建，这是它最大的特点），如果不加这个注解，那么动态代理会通过JDK来进行创建。</p></li><li><p>然后就是在同一个对象内事务方法互调的时候，调用事务方法的时候使用当前类的代理对象来进行调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是在OrderServiceImpl类的一个事务方法内部</span></span><br><span class="line"><span class="type">OrderServiceImpl</span> <span class="variable">orderService</span> <span class="operator">=</span> (OrderService)AopContext.currentProxy();<span class="comment">//获取当前类的代理对象</span></span><br><span class="line">orderService.method();<span class="comment">//调用本类中另一个事务方法</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h1 id="2023-x2F-2-x2F-3"><a href="#2023-x2F-2-x2F-3" class="headerlink" title="2023&#x2F;2&#x2F;3"></a>2023&#x2F;2&#x2F;3</h1><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><ul><li><p>CAP原则又称CAP定理，CAP分别代表分布式系统的三个可能拥有的特性：</p><ol><li><strong>一致性（Consistency）</strong>：这一特性是指在分布式系统中的所有数据备份，在同一时刻应该是同样的值。（等同于所有节点拥有同一份最新的数据副本）</li><li><strong>可用性（Availability）</strong>：这一特性是指在集群中一部分节点故障之后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li><li><strong>分区容错性（Partition tolerance）</strong>：大多数分布式系统都分布在多个子网络上，每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败，比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。分区容错性要求系统的部分节点或者网络出现故障之后仍能对外提供服务，也就是<strong>部分故障不影响整体使用</strong>。</li></ol></li><li><p>CAP原则指的是，在同一个分布式系统中，上面这三个特性最多只能同时实现两个，<strong>不可能三者兼顾</strong>。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230203193842541.png" alt="image-20230203193842541"></p></li><li><p><strong>一般来说，分区容错无法避免，因此可以认为CAP的P总是成立</strong>，除非是单机应用，没有任何网络通信。<strong>CAP定理告诉我们，在满足P的前提下，剩下的C和A无法同时做到</strong>。其实想想也很容易理解，如果一个集群中有三个节点，这三个节点之间互相连接，而突然1、2节点之间的通信链路故障了，造成2、3节点之间无法通信，由于分区容错性，部分故障不影响系统整体的使用，不妨假设在出故障之后，又有更新请求打过来，但是由于2、3节点无法通信，所以只有1、2节点对数据进行了更新，在这种情况下，如果要是说满足C也就是一致性的话，我们就只能访问1、2节点，无法访问3节点，这样就不满足A也就是可用性了；如果要是说满足A也就是可用性的话，我们可以访问1、2、3节点，但是只有1、2节点的数据是最新的，3节点的数据还是老数据，这样又不满足C也就是一致性了。所以剩下的C和A只能二选一，两者不可兼得，具体使用哪种方案还是得看具体情况。</p></li><li><p>在分布式系统中实现数据一致性的算法有raft算法、paxos算法等</p></li></ul><h2 id="raft算法"><a href="#raft算法" class="headerlink" title="raft算法"></a>raft算法</h2><ul><li>这是一种用来在分布式系统中实现数据一致性的算法，有个网站上有个动画解释地很通俗易懂：<a href="http://thesecretlivesofdata.com/raft/%E3%80%82">http://thesecretlivesofdata.com/raft/。</a></li><li>raft算法有两个关键点，一是领导选举，二是日志复制。</li><li><strong>这个算法只能用来解决分布式系统的一致性，不能解决可用性</strong>，因为如果发生分区错误，且各分区的节点数量是相同的，那么整个分布式系统永远都不会有Leader被选出，整个系统就变成了不可用状态，但是由于分区容错性，各节点还是可以访问的，只不过返回的都是系统不可用的状态。</li></ul><h3 id="领导选举（Leader-Election）"><a href="#领导选举（Leader-Election）" class="headerlink" title="领导选举（Leader Election）"></a>领导选举（Leader Election）</h3><ol><li>集群中的每个节点都有<strong>三种状态</strong>，第一种状态是Follower（随从），第二种状态是Candidate（候选人），第三种状态是Leader（领导）</li><li>一开始所有的节点都是Follower，然后所有的集群节点开始一个随机时间（一般在150ms到300ms）的自旋，自旋结束之后，如果它还没有收到来自Candidate的投票请求或者是Leader的心跳维持请求，那么当前这个节点就会变成Candidate。</li><li>成为Candidate的节点会向所有其他节点发出投票请求，它自己也会为自己投一票，当其它节点收到投票请求之后，它们会先重置自旋时间，如果它还没有投过票，那么它就会向Candidate进行回复，Candidate收到的回复数就是别的节点的投票数，加上自己给自己投的一票，如果总票数大于一半节点数（这也是一个系统只有一个Leader的原因），那么当前这个Candidate就会变成Leader。</li><li>之后所有对系统的修改请求都会先通过Leader，并且Leader会重复在一个小于最小自旋时间的时间段之后向所有的Follower发送心跳维持请求，当Follower接收到心跳维持请求之后，Follower会重置自己的自旋时间并向Leader回复心跳。</li><li>在这之后，如果Leader宕掉了，那么Follower就会收不到心跳维持请求，它的自旋时间就不会被重置，直到有一个Follower的自旋时间到了，它会再重复上面的过程变成新的Leader。</li><li>如果有两个节点同时变成Candidate怎么办？那这两个Candidate会同时向所有其他节点（包括另一个Candidate）发送投票请求，同时再给自己一个随机的自旋时间，如果其他节点投过票了就不能再投了（Candidate默认投自己一票），否则就会投给那个先到的请求的节点，得到票数之后如果有一个节点的票数大于一半的节点，那么它就会变成Leader，如果没有，那么等着它们的自旋时间结束之后再来一轮，重复这个过程直到选出Leader（正是因为只有票数大于一半的节点才会变成Leader，所以系统中才只会有一个Leader）。</li></ol><h3 id="日志复制（Log-Replication）"><a href="#日志复制（Log-Replication）" class="headerlink" title="日志复制（Log Replication）"></a>日志复制（Log Replication）</h3><ol><li>在进行过领导选举的过程之后，系统已经选出了一个Leader，之后所有对系统的修改请求都会先经过Leader，Leader会把修改要进行的操作记录到自己的日志中，注意此时这个<strong>日志的内容还未提交</strong>，因此系统中不会发生任何改变。</li><li>然后Leader<strong>通过心跳维持请求</strong>把自己的日志内容复制一份发给他的所有Follower，这些Follower也把这个日志的内容记录到自己的日志中。</li><li>每当Follower把日志写完了，就<strong>通过心跳</strong>回复Leader，当Leader接到一半以上节点的回复之后，就会把日志的修改进行提交，也就是说系统会真正发生改变。</li><li>然后Leader会向客户端回复表示系统已经完成了修改，<strong>在下一次发送心跳维持请求</strong>的时候Leader会通知其他的Follower也进行日志的提交，当所有Follower都提交完毕之后，整个系统的数据就保持了一致性。</li><li>如果之后整个集群发生分区错误被分割成了多个分区，那么各个分区都会通过领导选举算法选出一个领导，那么此时如何保证集群的一致性呢？只有拥有一半以上节点的分区（后称主分区）才会提交日志，别的分区只是进行了日志复制，当所有分区合并的时候，Leader就会只剩下主分区的Leader，然后Leader将自己的日志复制给所有的节点，那些次分区的日志会回滚并向客户端抛异常。&#x2F;&#x2F;todo 这个地方存疑，一些细节还不是很清楚。</li></ol><h2 id="大多数情况下在分布式系统中使用AP两个特性"><a href="#大多数情况下在分布式系统中使用AP两个特性" class="headerlink" title="大多数情况下在分布式系统中使用AP两个特性"></a>大多数情况下在分布式系统中使用AP两个特性</h2><ul><li>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到99.999…%（N个9），即<strong>保证分区容错性和可用性，舍弃一致性</strong>，但是有的服务也对一致性有一定的要求，所以有人提出了BASE理论。</li></ul><h2 id="强一致性、弱一致性、最终一致性"><a href="#强一致性、弱一致性、最终一致性" class="headerlink" title="强一致性、弱一致性、最终一致性"></a>强一致性、弱一致性、最终一致性</h2><ul><li>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是<strong>强一致性</strong>。如果能容忍后续的部分或者全部访问不到，则是<strong>弱一致性</strong>。如果经过一段时间后要求能访问到更新后的数据，则是<strong>最终一致性</strong>。</li></ul><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><ul><li><strong>基本可用（Basically Available）</strong>：基本可用是<strong>指分布式系统在出现故障的时候，允许损失部分可用性</strong>（例如响应时间、功能上的可用性）。需要注意的是，<strong>基本可用绝不等价于系统不可用</strong>。<ul><li><strong>响应时间上的损失</strong>：正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了 1~2 秒。</li><li><strong>功能上的损失</strong>：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</li></ul></li><li><strong>软状态（ Soft State）</strong>：软状态是<strong>指允许系统存在中间状态，而该中间状态不会影响系统整体可用性</strong>。分布式存储中一般一份数据会有多个副本，<strong>允许不同副本同步的延时就是软状态的体现</strong>。mysql replication 的异步复制也是一种体现。</li><li><strong>最终一致性（ Eventual Consistency）</strong>：最终一致性是<strong>指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态</strong>。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</li></ul><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><ol><li>PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，<strong>事务的参数按照加入的事务为准</strong>，该设置是最常用的设置。</li><li>PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</li><li>PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li><li>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</li><li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。</li></ol><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><ul><li><p><strong>在分布式系统下，业务逻辑通常不是自己所在的模块单独完成的，而是通过很多模块之间远程调用组成一个业务处理链来完成一个业务</strong>，而这会造成很多的问题，分布式事务就是这样的处理业务的模式下的一个很普遍且严重的问题。</p></li><li><p>在一个业务处理链中，可能有一个或者多个模块出现问题，<strong>只要业务处理链上有一个模块出现问题，那么这个业务处理链对数据库做的所有操作都要回滚，分布式事务就是用来实现这个效果的</strong>，之前用过的@Transactional注解只能对被他修饰的那个方法起作用，无法对整个业务处理链起作用。</p></li><li><p><strong>产生分布式事务问题的最大原因就是网络问题</strong>，因为分布式的系统依赖于多个模块之间的网络通信，我们很难保证网络什么时候出问题什么时候不出问题。</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230203154404398.png" alt="image-20230203154404398"></p></li></ul><h3 id="解决方案-对业务处理链上的所有节点方法加本地事务"><a href="#解决方案-对业务处理链上的所有节点方法加本地事务" class="headerlink" title="解决方案-对业务处理链上的所有节点方法加本地事务"></a>解决方案-对业务处理链上的所有节点方法加本地事务</h3><ul><li><strong>我们可以对业务处理链上的所有处理节点的方法都加上事务注解，但是这样做也会有问题，第一是操作比较繁琐，第二是远程服务调用完成后当前服务出现问题，那就只回滚了当前服务对数据库的操作，明显不对，第三是很难覆盖到所有出错的情况（远程服务假失败问题）</strong>，比如一个节点虽然没抛出异常，但是由于这个节点的超时，使得远程调用这个节点的上一个节点得到了节点失败的消息，从而触发它的数据库回滚操作，但是那个超时的节点的数据库却没有回滚，这样就造成了数据库中数据的不一致性，这可能是因为我们的疏忽，没有给他写超时的处理逻辑，但是这样的问题还有很多很多，想要做的面面俱到是比较困难的，所以这种方式不推荐使用。</li></ul><h3 id="柔性事务和刚性事务"><a href="#柔性事务和刚性事务" class="headerlink" title="柔性事务和刚性事务"></a>柔性事务和刚性事务</h3><ul><li><strong>刚性事务</strong>：遵循<strong>ACID原则</strong>，具有<strong>强一致性</strong>。</li><li><strong>柔性事务</strong>：遵循<strong>BASE理论</strong>，具有<strong>最终一致性</strong>。与刚性事务不同，柔性事务允许一定时间内不同节点的数据不一致，但要求这些节点的数据最终一致。</li></ul><h3 id="解决方案-刚性事务-2PC模式"><a href="#解决方案-刚性事务-2PC模式" class="headerlink" title="解决方案-刚性事务-2PC模式"></a>解决方案-刚性事务-2PC模式</h3><ul><li><p>这是<strong>数据库原生支持</strong>的2PC（2 phase commit <strong>二阶提交</strong>）模式，<strong>又叫做XA Transactions</strong>，该模式要求<strong>除了在模块本地有本地资源管理器来管理本地事务外，还有个统一的事务管理器来管理所有模块的事务</strong>，<strong>XA是一个两阶段提交协议</strong>，该协议分为以下两个阶段：</p><ol><li>第一阶段：事务协调器要求每个涉及到事务的数据库<strong>预提交（precommit）此操作，并反应是否可以提交</strong>。</li><li>第二阶段：事务协调器要求每个数据库<strong>提交数据，其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分内容</strong>。</li></ol><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230204174729136.png" alt="image-20230204174729136"></p></li><li><p>XA协议<strong>比较简单</strong>，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低。</p></li><li><p>但是XA协议的<strong>性能不理想</strong>，特别是在并发量很高的业务处理链路，XA无法满足高并发场景的需求。</p></li><li><p>XA 目前在商业数据库支持的比较理想，<strong>在mysql数据库中支持的不太理想</strong>，mysql 的XA 实现，没有记录 prepare 阶段日志，主备切换回导致主库与备库数据不一致。</p></li><li><p><strong>许多 nosql 也没有支持 XA</strong>，这让 XA 的应用场景变得非常狭隘。</p></li><li><p>也有 <strong>3PC，引入了超时机制（无论协调者还是参与者，在向对方发送请求后，若长时间未收到回应则做出相应处理）</strong></p></li></ul><h3 id="解决方案-柔性事务-TCC事务补偿型方案"><a href="#解决方案-柔性事务-TCC事务补偿型方案" class="headerlink" title="解决方案-柔性事务-TCC事务补偿型方案"></a>解决方案-柔性事务-TCC事务补偿型方案</h3><ul><li><p>TCC的三个字符实际上就是指Try、Confirm、Cancel方法，也就是说这种方案要求我们在写一个和数据库进行交互的逻辑的时候要写三个方法，这三个方法分别代表准备数据（try）、提交数据（confirm）、回滚数据（cancel）的逻辑，这样全局事务管理器就能通过调用事务的这些方法来统一管理所有事务的状态了，一开始的时候全局事务管理器让所有事务准备数据（调用对应事务的try方法），然后提交数据（调用对应事务的confirm方法），如果有任何一个事务出现问题，那么事务管理器会让所有的事务回滚数据（调用对应事务的cancel方法）：</p><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230204181024543.png" alt="image-20230204181024543"></p></li><li><p>也是大体分成三个阶段：</p><ol><li>一阶段<strong>prepare行为</strong>：调用自定义的<strong>try方法</strong></li><li>二阶段<strong>commit行为</strong>：调用自定义的<strong>confirm方法</strong></li><li>三阶段<strong>rollback行为</strong>：调用自定义的<strong>cancel方法</strong></li></ol></li><li><p>从本质上看，就是<strong>我们自定义了事务的声明周期方法以供全局事务管理器进行调用</strong>，所谓的<strong>TCC模式，是指支持把自定义的分支事务纳入到全局事务的管理中</strong>。</p></li></ul><h3 id="解决方案-柔性事务-最大努力通知型方案"><a href="#解决方案-柔性事务-最大努力通知型方案" class="headerlink" title="解决方案-柔性事务-最大努力通知型方案"></a>解决方案-柔性事务-最大努力通知型方案</h3><ul><li>抽象地来说其实就是<strong>一个终端按照规律不停向别的终端发送消息，直到所有终端都回复表示自己已经收到了消息</strong>。</li><li>在分布式事务场景中具体来说就是，<strong>在事务失败的时候，对于已经完成的事务，事务管理器会按规律进行通知它们，直到所有已经完成的事务都返回表示自己已经收到，然后收到消息的已经完成的事务会进行回滚</strong>（&#x2F;&#x2F;todo 回滚是在发送收到之前还是之后？），不保证数据一定能通知成功，但会提供可查询操作接口进行核对。</li><li>这种方案<strong>主要用在与第三方系统通讯时，通常使用MQ进行实现</strong>，比如：调用微信或支付宝支付后的支付结果通知。这种方案也是结合 MQ 进行实现，例如：通过 MQ 发送 http 请求，设置最大通知次数。达到通知次数后即不再通知。</li><li>案例：银行通知、商户通知等（各大交易业务平台间的商户通知：多次通知、查询校对、对账文件），支付宝的支付成功异步回调</li></ul><h3 id="解决方案-柔性事务-可靠消息-最终一致性方案（异步确保型）"><a href="#解决方案-柔性事务-可靠消息-最终一致性方案（异步确保型）" class="headerlink" title="解决方案-柔性事务-可靠消息+最终一致性方案（异步确保型）"></a>解决方案-柔性事务-可靠消息+最终一致性方案（异步确保型）</h3><ul><li>和上面那个差不多，具体到分布式事务的场景就是<strong>在事务失败的时候异步发送消息有规律地通知已经完成的事务进行回滚</strong>(&#x2F;&#x2F;todo 不知道这个解释对不对)。异步的通知决定了这种方案是柔性的，同时异步的解决方案还能提高并发性能。</li><li>实现：业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。</li></ul><h1 id="2023-x2F-2-x2F-4"><a href="#2023-x2F-2-x2F-4" class="headerlink" title="2023&#x2F;2&#x2F;4"></a>2023&#x2F;2&#x2F;4</h1><h2 id="Seata解决分布式事务"><a href="#Seata解决分布式事务" class="headerlink" title="Seata解决分布式事务"></a>Seata解决分布式事务</h2><h3 id="Seata是什么"><a href="#Seata是什么" class="headerlink" title="Seata是什么"></a>Seata是什么</h3><ul><li>Seata是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata为用户<strong>提供了AT（Auto Transaction 自动事务）、TCC、SAGA和XA事务模式</strong>，为用户打造一站式的分布式解决方案。</li></ul><h3 id="Seata的工作原理"><a href="#Seata的工作原理" class="headerlink" title="Seata的工作原理"></a>Seata的工作原理</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230204193132779.png" alt="image-20230204193132779"></p><ul><li>调用其他事务的事务是<strong>全局事务</strong>，被调用的事务是<strong>分支事务</strong>。</li><li><strong>TC-事务协调者</strong>：维护全局和分支事务的状态，驱动全局事务提交或回滚。</li><li><strong>TM-事务管理器</strong>：定义全局事务的范围-开始全局事务、提交或回滚全局事务。</li><li><strong>RM-资源管理器</strong>：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li><li><strong>在开启全局事务的时候，TM会先向TC进行报告，然后TC就可以知道全局事务的实时状态且能控制TM了，然后在全局事务调用分支事务的时候，每当调用到一个分支事务，当前的分支事务都会将自己注册到TC中，这样TC也能知道分支事务的实时状态且能控制RM了，这样当某个事务失败后，TC会让所有已经完成的事务也回滚</strong>。</li></ul><h3 id="Seata怎么用"><a href="#Seata怎么用" class="headerlink" title="Seata怎么用"></a>Seata怎么用</h3><ul><li><p>首先如果要用Seata的<strong>AT模式</strong>应该<strong>对分布式事务用到的每一个微服务的数据库中创建undo_log表来记录快照以在回滚的时候补偿已经提交的事务</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 注意此处0.3.0+ 增加唯一索引 ux_undo_log</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure></li><li><p>然后<strong>下载事务协调器seata-server，这个东西实际上就是上面提到的TC-事务协调器</strong>：<a href="https://github.com/seata/seata/releases%EF%BC%8C%E8%BF%99%E4%B8%AA%E4%BA%8B%E5%8A%A1%E5%8D%8F%E8%B0%83%E5%99%A8(TC)%E5%AE%9E%E9%99%85%E4%B8%8A%E5%B0%B1%E6%98%AF%E4%B8%8A%E9%9D%A2%E8%AF%B4%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%8C%E9%80%9A%E8%BF%87%E5%AE%83%E6%9D%A5%E5%AF%B9%E5%90%84%E4%BA%8B%E5%8A%A1%E8%BF%9B%E8%A1%8C%E5%8D%8F%E8%B0%83%EF%BC%8C%E8%80%8C%E6%AF%8F%E4%B8%AA%E4%BA%8B%E5%8A%A1%E8%BF%98%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%8C**%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E5%B0%B1%E6%98%AF%E9%80%9A%E8%BF%87%E6%93%8D%E4%BD%9C%E4%BA%8B%E5%8A%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E6%9D%A5%E5%AF%B9%E6%89%80%E6%9C%89%E4%BA%8B%E5%8A%A1%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E7%9A%84**%E3%80%82">https://github.com/seata/seata/releases，这个事务协调器(TC)实际上就是上面说的解决方案中的全局事务管理器，通过它来对各事务进行协调，而每个事务还有自己的事务管理器，**全局事务管理器就是通过操作事务对应的本地事务管理器来对所有事务进行管理的**。</a></p></li><li><p>然后就是引入依赖，引入后<strong>要注意seata-all这个包的版本，这个包的版本决定着我们应该使用什么版本的seata-server</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>然后就是<strong>解压并启动下载好的seata-server</strong>，并<strong>按照自己的需求修改registry.conf注册中心配置和file.conf</strong></p></li><li></li><li><p>最后给分布式的全局事务上标注@GlobalTransactional注解，给分支事务上标注@Transactional注解，然后就能用了。</p></li></ul><h2 id="MQ解决分布式事务"><a href="#MQ解决分布式事务" class="headerlink" title="MQ解决分布式事务"></a>MQ解决分布式事务</h2><ul><li>seata默认用的是AT模式，分为两个阶段，一阶段是业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源；二阶段是异步化提交，如果出现问题，那么会通过一阶段的回滚日志进行反向补偿以达到回滚的目的（&#x2F;&#x2F;todo 还是不太清楚细节）。由于事务之间的隔离级别太高，所以这个模式不满足高并发的业务场景，所以<strong>考虑使用MQ来实现异步的最大努力通知型方案</strong>。</li></ul><h1 id="2023-x2F-2-x2F-6"><a href="#2023-x2F-2-x2F-6" class="headerlink" title="2023&#x2F;2&#x2F;6"></a>2023&#x2F;2&#x2F;6</h1><h2 id="项目开发中dev、test和prod是什么意思"><a href="#项目开发中dev、test和prod是什么意思" class="headerlink" title="项目开发中dev、test和prod是什么意思"></a>项目开发中dev、test和prod是什么意思</h2><ul><li><strong>开发环境（dev）</strong>：开发环境是程序猿们专门用于开发的服务器，配置可以比较随意，为了开发调试方便，一般打开全部错误报告。</li><li><strong>测试环境（test）</strong>：一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产机上。</li><li><strong>生产环境（prod）</strong>：是值<strong>正式提供对外服务</strong>的，一般会关掉错误报告，打开错误日志。</li><li>三个环境也可以说是系统开发的三个阶段：<strong>开发-&gt;测试-&gt;上线</strong>，其中<strong>生产环境也就是通常说的真实环境</strong>。</li></ul><h2 id="如何配置Bean的作用域"><a href="#如何配置Bean的作用域" class="headerlink" title="如何配置Bean的作用域"></a>如何配置Bean的作用域</h2><ul><li><p>Spring中Bean的作用域通常有下面几种：</p><ol><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ol></li><li><p>使用@Scope注解的方式设置Bean的作用域为原型模式，也就是每次用到的时候都创建一个新的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2023-x2F-2-x2F-8"><a href="#2023-x2F-2-x2F-8" class="headerlink" title="2023&#x2F;2&#x2F;8"></a>2023&#x2F;2&#x2F;8</h1><h2 id="ActiveProfiles注解"><a href="#ActiveProfiles注解" class="headerlink" title="@ActiveProfiles注解"></a>@ActiveProfiles注解</h2><ul><li><p>一般作用于测试类上， 用于<strong>声明生效的 Spring 配置文件</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = RANDOM_PORT)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;test&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TestBase</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="2023-x2F-2-x2F-9"><a href="#2023-x2F-2-x2F-9" class="headerlink" title="2023&#x2F;2&#x2F;9"></a>2023&#x2F;2&#x2F;9</h1><h2 id="数据库被人黑了"><a href="#数据库被人黑了" class="headerlink" title="数据库被人黑了"></a>数据库被人黑了</h2><ul><li>谔谔，数据库竟然被人删了，也怪我密码设的太弱了，长个教训，以后可以从下面的这几个方面提高安全性：<ol><li>使用密码生成器生成强密码</li><li>开启mysql的binlog日志，数据库寄了可以通过这个日志来恢复数据</li><li>对外关闭数据库连接的端口，只能通过SSH来对数据库进行连接</li></ol></li></ul><h2 id="数据库无法远程连接"><a href="#数据库无法远程连接" class="headerlink" title="数据库无法远程连接"></a>数据库无法远程连接</h2><ul><li>报错：<code>Access denied for user &#39;root&#39;@&#39;xxx.xxx.xxx.xxx&#39; (using password: YES)</code></li><li>首先确保自己的密码输入正确</li><li>然后就是要打开mysql的远程授权，在mysql中使用命令：**<code>grant all privileges on *.* to root@&#39;%&#39; identified by &#39;root密码&#39;;</code><strong>然后再使用命令</strong><code>flush privileges;</code>**就能开启远程授权了。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;本项目基于尚硅谷的谷粒商城项目，主</summary>
      
    
    
    
    
    <category term="SpringBoot" scheme="https://konjacor.github.io/tags/SpringBoot/"/>
    
    <category term="SpringMVC" scheme="https://konjacor.github.io/tags/SpringMVC/"/>
    
    <category term="SpringCloud" scheme="https://konjacor.github.io/tags/SpringCloud/"/>
    
    <category term="商城" scheme="https://konjacor.github.io/tags/%E5%95%86%E5%9F%8E/"/>
    
    <category term="分布式" scheme="https://konjacor.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="微服务" scheme="https://konjacor.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="SpringCloudAlibaba" scheme="https://konjacor.github.io/tags/SpringCloudAlibaba/"/>
    
    <category term="Docker" scheme="https://konjacor.github.io/tags/Docker/"/>
    
    <category term="实战项目" scheme="https://konjacor.github.io/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="MyBatis" scheme="https://konjacor.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://konjacor.github.io/2022/12/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E9%87%8D%E7%82%B9(%E6%9A%82%E6%97%B6)/"/>
    <id>https://konjacor.github.io/2022/12/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E9%87%8D%E7%82%B9(%E6%9A%82%E6%97%B6)/</id>
    <published>2022-12-20T12:11:43.208Z</published>
    <updated>2024-03-14T13:57:42.440Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><input disabled="" type="checkbox"> </p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1软件危机介绍"><a href="#1软件危机介绍" class="headerlink" title="1软件危机介绍"></a>1软件危机介绍</h2><p>软件危机是指在计算机软件开发和维护过程中所遇到的一系列的严重问题。</p></li><li><p><input disabled="" type="checkbox"> </p><h2 id="2软件危机的典型表现（简单看一下）"><a href="#2软件危机的典型表现（简单看一下）" class="headerlink" title="2软件危机的典型表现（简单看一下）"></a>2软件危机的典型表现（简单看一下）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="3消除软件危机的途径（4条）（简答题）"><a href="#3消除软件危机的途径（4条）（简答题）" class="headerlink" title="3消除软件危机的途径（4条）（简答题）"></a>3消除软件危机的途径（4条）（简答题）</h2><p>①首先要对计算机软件有着正确的认识。</p><p>②要意识到软件开发不应该是某些个体劳动的神秘技术，而应该是组织良好、管理严密、各类人员协同配合、共同完成的项目工程。</p><p>③要坚持推广和使用在实践过程中总结出来的成功的技术和方法，并不断探索更好更高效的技术和方法。</p><p>④要开发和使用个好的软件工具。</p><p>总之，消除软件危机一方面要有相应的技术措施，也要有相应的组织管理措施。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="4软件工程的基本原理（7条）（简答）"><a href="#4软件工程的基本原理（7条）（简答）" class="headerlink" title="4软件工程的基本原理（7条）（简答）"></a>4软件工程的基本原理（7条）（简答）</h2><p>①使用分阶段的生命周期计划严格管理。</p><p>②要坚持进行阶段性评审。</p><p>③实行严格的产品控制。</p><p>④要使用现代程序设计技术。</p><p>⑤结果应能清楚地审查。</p><p>⑥开发小组的人员应该少而精。</p><p>⑦应该承认改进软件工程实践的重要性。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="5软件工程的方法学三要素（填空）以及目前使用的最广泛地两个软件工程方法学（填空）"><a href="#5软件工程的方法学三要素（填空）以及目前使用的最广泛地两个软件工程方法学（填空）" class="headerlink" title="5软件工程的方法学三要素（填空）以及目前使用的最广泛地两个软件工程方法学（填空）"></a>5软件工程的方法学三要素（填空）以及目前使用的最广泛地两个软件工程方法学（填空）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="6软件生命周期三个时期以及阶段"><a href="#6软件生命周期三个时期以及阶段" class="headerlink" title="6软件生命周期三个时期以及阶段"></a>6软件生命周期三个时期以及阶段</h2><ol><li>问题分析</li><li>可行性研究</li><li>需求分析</li><li>概要设计</li><li>详细设计</li><li>编码和单元测试</li><li>综合测试</li><li>运行维护</li></ol></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="7几个软件过程的模型"><a href="#7几个软件过程的模型" class="headerlink" title="7几个软件过程的模型"></a>7几个软件过程的模型</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-研究可行性的三个方面（填空）"><a href="#1-研究可行性的三个方面（填空）" class="headerlink" title="1.研究可行性的三个方面（填空）"></a>1.研究可行性的三个方面（填空）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-数据字典的用途（三条）（简答）"><a href="#2-数据字典的用途（三条）（简答）" class="headerlink" title="2.数据字典的用途（三条）（简答）"></a>2.数据字典的用途（三条）（简答）</h2><p>①数据字典最重要的用途是作为分析阶段的工具。</p><p>②数据字典中每个数据元素的控制信息都是很有价值的。</p><p>③数据字典是开发数据库的第一步，也是很有价值的一步。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="3-成本估计的三个估算技术"><a href="#3-成本估计的三个估算技术" class="headerlink" title="3.成本估计的三个估算技术"></a>3.成本估计的三个估算技术</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-需求分析的三个模型即对应的图"><a href="#1-需求分析的三个模型即对应的图" class="headerlink" title="1.需求分析的三个模型即对应的图"></a>1.需求分析的三个模型即对应的图</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-E-R图的符号"><a href="#2-E-R图的符号" class="headerlink" title="2.E-R图的符号"></a>2.E-R图的符号</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="3-复印机的题"><a href="#3-复印机的题" class="headerlink" title="3.复印机的题"></a>3.复印机的题</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-形式化的三个常用的方法"><a href="#1-形式化的三个常用的方法" class="headerlink" title="1.形式化的三个常用的方法"></a>1.形式化的三个常用的方法</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="2-形式化优点（可能只考小结里的一个）"><a href="#2-形式化优点（可能只考小结里的一个）" class="headerlink" title="2.形式化优点（可能只考小结里的一个）"></a>2.形式化优点（可能只考小结里的一个）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-耦合是啥，划分"><a href="#1-耦合是啥，划分" class="headerlink" title="1.耦合是啥，划分"></a>1.耦合是啥，划分</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-内聚是啥，划分"><a href="#2-内聚是啥，划分" class="headerlink" title="2.内聚是啥，划分"></a>2.内聚是啥，划分</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="3-启发规则（7条）-（简答）"><a href="#3-启发规则（7条）-（简答）" class="headerlink" title="3.启发规则（7条）                 （简答）"></a>3.启发规则（7条）                 （简答）</h2><p>①改变软件结构提高模块的独立性。</p><p>②模块的规模应该适中</p><p>③深度、宽度、扇入和扇出都应该适当。</p><p>④模块的作用域应该在控制域之内。</p><p>⑤应该力争降低模块接口的复杂程度。</p><p>⑥设计单入口和单出口的模块。</p><p>⑦模块的功能应该可以预测。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="4-信息流的类型（填空）"><a href="#4-信息流的类型（填空）" class="headerlink" title="4.信息流的类型（填空）"></a>4.信息流的类型（填空）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-三种基本的控制结构（填空）"><a href="#1-三种基本的控制结构（填空）" class="headerlink" title="1.三种基本的控制结构（填空）"></a>1.三种基本的控制结构（填空）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-系统响应时间的两个重要属性（填空）"><a href="#2-系统响应时间的两个重要属性（填空）" class="headerlink" title="2.系统响应时间的两个重要属性（填空）"></a>2.系统响应时间的两个重要属性（填空）</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="3-过程设计工具"><a href="#3-过程设计工具" class="headerlink" title="3.过程设计工具"></a>3.过程设计工具</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="4-计算环形复杂度（需要三种方法P141P142题）"><a href="#4-计算环形复杂度（需要三种方法P141P142题）" class="headerlink" title="4.计算环形复杂度（需要三种方法P141P142题）"></a>4.计算环形复杂度（需要三种方法P141P142题）</h2></li><li><p><input disabled="" type="checkbox"> <img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20240314215717270.png" alt="image-20240314215717270"></p></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-通常把编码和测试统称为实现（填空）"><a href="#1-通常把编码和测试统称为实现（填空）" class="headerlink" title="1.通常把编码和测试统称为实现（填空）"></a>1.通常把编码和测试统称为实现（填空）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-软件测试的步骤"><a href="#2-软件测试的步骤" class="headerlink" title="2.软件测试的步骤"></a>2.软件测试的步骤</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="3-代码审查分工（组长应该是啥样的（选择））"><a href="#3-代码审查分工（组长应该是啥样的（选择））" class="headerlink" title="3.代码审查分工（组长应该是啥样的（选择））"></a>3.代码审查分工（组长应该是啥样的（选择））</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="4-题P166-P168"><a href="#4-题P166-P168" class="headerlink" title="4.题P166~P168"></a>4.题P166~P168</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="5-黑盒技术的题（P173）"><a href="#5-黑盒技术的题（P173）" class="headerlink" title="5.黑盒技术的题（P173）"></a>5.黑盒技术的题（P173）</h2></li><li><p><input disabled="" type="checkbox"> </p><h2 id="6-题P187"><a href="#6-题P187" class="headerlink" title="6.题P187"></a>6.题P187</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-四类维护活动（填空）"><a href="#1-四类维护活动（填空）" class="headerlink" title="1.四类维护活动（填空）"></a>1.四类维护活动（填空）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-面向对象的三种模型以及工具"><a href="#1-面向对象的三种模型以及工具" class="headerlink" title="1.面向对象的三种模型以及工具"></a>1.面向对象的三种模型以及工具</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-属性可见性（没有默认的可见性）"><a href="#2-属性可见性（没有默认的可见性）" class="headerlink" title="2.属性可见性（没有默认的可见性）"></a>2.属性可见性（没有默认的可见性）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1></li><li><p><input disabled="" type="checkbox"> </p><h2 id="无"><a href="#无" class="headerlink" title="无"></a>无</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-类构件的重用方式（填空）"><a href="#1-类构件的重用方式（填空）" class="headerlink" title="1.类构件的重用方式（填空）"></a>1.类构件的重用方式（填空）</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h1></li><li><p><input disabled="" type="checkbox"> </p><h2 id="无-1"><a href="#无-1" class="headerlink" title="无"></a>无</h2></li><li><p><input disabled="" type="checkbox"> </p><h1 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h1></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="1-代码行技术的优缺点-（简答）"><a href="#1-代码行技术的优缺点-（简答）" class="headerlink" title="1.代码行技术的优缺点                                   （简答）"></a>1.代码行技术的优缺点                                   （简答）</h2><p>（1）优点</p><p>①代码是所有的软件开发都要有的产品。</p><p>②很容易计算代码行数</p><p>（2）缺点</p><p>①源码知识软件配置的一部分，使用源码的规模来代表整体软件的规模似乎不是很合理。</p><p>②不同的语言实现同一个软件所用到的代码行数不同。</p><p>③代码行技术不适合用于非过程性的语言。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="2-工作量估算的三种模型（选择，混入一个别的）"><a href="#2-工作量估算的三种模型（选择，混入一个别的）" class="headerlink" title="2.工作量估算的三种模型（选择，混入一个别的）"></a>2.工作量估算的三种模型（选择，混入一个别的）</h2></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="3-民主制程序员组的优点（简答）"><a href="#3-民主制程序员组的优点（简答）" class="headerlink" title="3.民主制程序员组的优点（简答）"></a>3.民主制程序员组的优点（简答）</h2><p>①使组员们对发现程序错误抱有积极地态度，这种积极的态度有利于更快的发现程序中的错误，产生高质量的代码。</p><p>②组员们拥有充足民主，组内具有高度凝聚力，小组的学术氛围浓厚，有利于攻克技术难关。</p></li><li><p><input checked="" disabled="" type="checkbox"> </p><h2 id="4-正式的技术复查包括-走查-和-审查（填空）"><a href="#4-正式的技术复查包括-走查-和-审查（填空）" class="headerlink" title="4.正式的技术复查包括  走查   和   审查（填空）"></a>4.正式的技术复查包括  走查   和   审查（填空）</h2></li></ul><p><img src="file:///D:\Softwares\QQ\Recv\2470152347\Image\Group2\7P~3\7P~38J{HQOM8VAVFBOVT1KN.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt; &lt;/p&gt;
&lt;h1 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h1&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;in</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://konjacor.github.io/2022/12/20/hello-world/"/>
    <id>https://konjacor.github.io/2022/12/20/hello-world/</id>
    <published>2022-12-20T12:11:43.202Z</published>
    <updated>2022-12-20T12:11:43.202Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>EffectiveJava读后整理</title>
    <link href="https://konjacor.github.io/2022/12/07/EffectiveJava%E8%AF%BB%E5%90%8E%E6%95%B4%E7%90%86/"/>
    <id>https://konjacor.github.io/2022/12/07/EffectiveJava%E8%AF%BB%E5%90%8E%E6%95%B4%E7%90%86/</id>
    <published>2022-12-07T08:23:35.000Z</published>
    <updated>2023-02-11T12:43:17.674Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul><li>这书也读了一段时间了，一直没时间整理，之后抽空整理一下吧，本身这本书就是通过一条条对读者Java编程的建议构成的，所以整理起来也比较容易。</li><li>我感觉这书里面表达的思想是很好的，但是就是中文翻译太烂了，经常翻译地让人摸不着头脑，但是里面的思想绝对是值得读者反复阅读揣摩的，我第一次读的时候水平有限，只能看懂一部分，等着自己的能力提升了再看几遍吧。</li><li>在这本书的引言中，作者写到了几个概念，完善了我之前对它们的理解：<strong>API是指类、接口、构造器、成员和序列化形式，程序员通过它们可以访问类、接口或者包</strong>、<strong>使用API编写程序的程序员被称为该API的用户，在类的实现中使用了API的类被称为该API的客户端</strong>、<strong>不严格地讲，一个包的导出API是由该包中的每个公有类或者接口中所有公有的或者受保护的成员和构造器组成</strong>。</li></ul><h1 id="第一条：用静态工厂方法代替构造器"><a href="#第一条：用静态工厂方法代替构造器" class="headerlink" title="第一条：用静态工厂方法代替构造器"></a>第一条：用静态工厂方法代替构造器</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>静态工厂方法可以有名称，相比于重载的构造器来说，明显多种静态工厂方法更能让该api的用户感觉体验更好，因为<strong>用户可以望文生义，看见静态工厂方法的名称就能知道这个方法返回的是哪一种对象</strong>，而如果使用重载的构造器，用户估计要区分半天，最后也不见得能用对。除此之外静态工厂方法在一些情况下还可以减小构造器的粒度，比如我们想要使用同样类型的一组参数创建不同种类的该类的对象，如果使用构造器的话，我们只能通过增加参数数量或者在构造器内部判断参数具体的值来判断应该如何初始化对象，因为参数数量和类型相同的构造器不构成重载；但是使用静态工厂方法的话，我们就可以将所有的情况区分开了，每个静态工厂方法虽然参数的数量和类型相同，但是它们生成的对象却不同，用户可以通过这些静态工厂对象的名字来区分它们。</li><li>使用静态工厂方法不必在每次调用它们的时候创建新对象，构造器一旦调用，对象也一定会随之创建，但是有的时候我们不希望创建对象，我们想用预先创建好的实例，这种情况下使用构造器的话就无法达成我们的目的了。<strong>对于不可变类来说使用静态工厂方法可以使用预先创建好的对象，或者把创建好的对象缓存起来重复利用，从而避免创建不必要的重复对象</strong>。</li><li>使用静态工厂方法代替构造器可以返回该类的任何子类的对象，</li><li>使用静态工厂方法所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值，</li><li>使用静态工厂方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在，</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>类如果不含公有的或者受保护的构造器，就不能被子类化，</li><li>程序员很难发现它们，因为它们不和构造器一样在API文档中被明确地标识出来，程序员要发现它们，大多数情况下是依赖API开发者和程序员之间的约定，</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>静态工厂方法和构造器各有优劣，但是多数情况下静态工厂方法都能代替构造器，所以<strong>在编写一个类的时候应该优先考虑静态工厂方法而不是公共的构造器</strong>。</li></ul><h1 id="第2条：构造器参数过多时要考虑使用构建器"><a href="#第2条：构造器参数过多时要考虑使用构建器" class="headerlink" title="第2条：构造器参数过多时要考虑使用构建器"></a>第2条：构造器参数过多时要考虑使用构建器</h1><ul><li>对于静态工厂方法和构造器来说，它们都不能很好地扩展大量的的可选参数。那么对于可选参数很多的类我们应该怎样编写呢？</li><li>程序员一向习惯采用重叠构造器模式，</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;

&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;这书也读了一段时间了，一直没时间整</summary>
      
    
    
    
    
    <category term="EffectiveJava" scheme="https://konjacor.github.io/tags/EffectiveJava/"/>
    
    <category term="读后整理" scheme="https://konjacor.github.io/tags/%E8%AF%BB%E5%90%8E%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>JUC并发编程</title>
    <link href="https://konjacor.github.io/2022/12/07/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://konjacor.github.io/2022/12/07/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2022-12-07T08:22:54.000Z</published>
    <updated>2022-12-20T12:11:43.195Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
</summary>
      
    
    
    
    
    <category term="JUC工具类" scheme="https://konjacor.github.io/tags/JUC%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    <category term="并发编程" scheme="https://konjacor.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="https://konjacor.github.io/2022/12/07/JVM/"/>
    <id>https://konjacor.github.io/2022/12/07/JVM/</id>
    <published>2022-12-07T08:22:17.000Z</published>
    <updated>2022-12-20T12:11:43.196Z</updated>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/>]]></content>
    
    
      
      
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
</summary>
      
    
    
    
    
    <category term="JVM" scheme="https://konjacor.github.io/tags/JVM/"/>
    
    <category term="Java虚拟机" scheme="https://konjacor.github.io/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
</feed>

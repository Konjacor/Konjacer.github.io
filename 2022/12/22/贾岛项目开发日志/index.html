<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>贾岛项目开发日志 | 孤舟</title><meta name="keywords" content="SpringCloud,SpringBoot,SpringMVC,商城,分布式,微服务,SpringCloudAlibaba,Docker,实战项目,MyBatis"><meta name="author" content="Konjacer,1175590069@qq.com"><meta name="copyright" content="Konjacer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言 本项目基于尚硅谷的谷粒商城项目，主要是做的时候我想根据自己所学的东西对谷粒商城进行一定程度的改造，有点属于自己的特色，做这个项目的过程也是我巩固之前所学知识的一个机会，所以趁这个机会，把开发日志写一下，积累一下实战经验。  2022&#x2F;12&#x2F;23为什么使用微服务的架构风格 微服务的架构风格，实际上就是将一个单独的应用程序拆分成了多个小服务，每个小服务运行在自己的的进程中">
<meta property="og:type" content="article">
<meta property="og:title" content="贾岛项目开发日志">
<meta property="og:url" content="https://konjacor.github.io/2022/12/22/%E8%B4%BE%E5%B2%9B%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/index.html">
<meta property="og:site_name" content="孤舟">
<meta property="og:description" content="前言 本项目基于尚硅谷的谷粒商城项目，主要是做的时候我想根据自己所学的东西对谷粒商城进行一定程度的改造，有点属于自己的特色，做这个项目的过程也是我巩固之前所学知识的一个机会，所以趁这个机会，把开发日志写一下，积累一下实战经验。  2022&#x2F;12&#x2F;23为什么使用微服务的架构风格 微服务的架构风格，实际上就是将一个单独的应用程序拆分成了多个小服务，每个小服务运行在自己的的进程中">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://konjacor.github.io/img/background.jpeg">
<meta property="article:published_time" content="2022-12-22T14:24:37.000Z">
<meta property="article:modified_time" content="2023-04-17T10:48:28.151Z">
<meta property="article:author" content="Konjacer">
<meta property="article:tag" content="SpringCloud">
<meta property="article:tag" content="SpringBoot">
<meta property="article:tag" content="SpringMVC">
<meta property="article:tag" content="商城">
<meta property="article:tag" content="分布式">
<meta property="article:tag" content="微服务">
<meta property="article:tag" content="SpringCloudAlibaba">
<meta property="article:tag" content="Docker">
<meta property="article:tag" content="实战项目">
<meta property="article:tag" content="MyBatis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://konjacor.github.io/img/background.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://konjacor.github.io/2022/12/22/%E8%B4%BE%E5%B2%9B%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '贾岛项目开发日志',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-17 18:48:28'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="孤舟" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/xiaozhai.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">孤舟</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">贾岛项目开发日志</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-22T14:24:37.000Z" title="发表于 2022-12-22 22:24:37">2022-12-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-17T10:48:28.151Z" title="更新于 2023-04-17 18:48:28">2023-04-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="贾岛项目开发日志"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"/>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>本项目基于尚硅谷的谷粒商城项目，主要是做的时候我想根据自己所学的东西对谷粒商城进行一定程度的改造，有点属于自己的特色，做这个项目的过程也是我巩固之前所学知识的一个机会，所以趁这个机会，把开发日志写一下，积累一下实战经验。</li>
</ul>
<h1 id="2022-x2F-12-x2F-23"><a href="#2022-x2F-12-x2F-23" class="headerlink" title="2022&#x2F;12&#x2F;23"></a>2022&#x2F;12&#x2F;23</h1><h2 id="为什么使用微服务的架构风格"><a href="#为什么使用微服务的架构风格" class="headerlink" title="为什么使用微服务的架构风格"></a>为什么使用微服务的架构风格</h2><ul>
<li>微服务的架构风格，实际上就是将一个单独的应用程序拆分成了多个小服务，每个小服务运行在自己的的进程中，并且它们之间使用轻量级的通信机制，通常是HTTP API，这些服务是围绕着应用的业务能力来构建的，并且可以独立部署，这些服务可以使用不同的编程语言编写、可以使用不同的数据存储技术，并且所有服务之间保持着最低限度的集中式管理。简而言之：<strong>微服务架构拒绝大型单体应用，基于业务边界进行服务微化拆分，各个服务独立部署运行</strong>。</li>
<li>使用微服务的架构风格使得项目获得了很好的可扩展性，再需要添加新功能的时候只需要把精力集中在开发新服务上即可，不用把精力花费在之前的代码上，这就是使用微服务解耦带来的好处之一，除此之外使用微服务的架构风格遇到错误和故障可以将其隔离以防止这些错误蔓延到别的服务模块，微服务带来的好处还有很多，但是同时它也给运维人员、开发人员等提出了新的挑战，比如：我该如何做到高可用呢？我该如何在分布式的事务中保证数据的一致性？服务被调用的时候中间的某个服务出现了错误，我该怎么办？我该怎么才能找到错误的服务？对于这些服务我该使用什么样的部署方案？我该如何对流量进行监控和限制？等等诸如此类的问题。</li>
</ul>
<h2 id="集群、分布式和节点"><a href="#集群、分布式和节点" class="headerlink" title="集群、分布式和节点"></a>集群、分布式和节点</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223142832425.png" alt="image-20221223142832425"></p>
<h2 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223143038851.png" alt="image-20221223143038851"></p>
<ul>
<li>使用HTTP+JSON的方式来进行远程调用的好处在于他们提供的天然的跨平台性，JSON可以在任何平台上被编码或是解码，而对于大多数编程语言来说，他们都有对应的发送HTTP请求的方法。</li>
</ul>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223143343097.png" alt="image-20221223143343097"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223143418977.png" alt="image-20221223143418977"></p>
<ul>
<li>不要让某台机器太忙或者太闲</li>
</ul>
<h2 id="服务注册-x2F-发现中心"><a href="#服务注册-x2F-发现中心" class="headerlink" title="服务注册&#x2F;发现中心"></a>服务注册&#x2F;发现中心</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223143510152.png" alt="image-20221223143510152"></p>
<ul>
<li>将服务的消费者和服务的生产者解耦，引入中间件进行服务的管理。</li>
</ul>
<h2 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223143814126.png" alt="image-20221223143814126"></p>
<ul>
<li>将配置和服务解耦，引入中间件集中管理微服务的配置信息。</li>
</ul>
<h2 id="服务熔断和服务降级"><a href="#服务熔断和服务降级" class="headerlink" title="服务熔断和服务降级"></a>服务熔断和服务降级</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223144306392.png" alt="image-20221223144306392"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223144331911.png" alt="image-20221223144331911"></p>
<ul>
<li>熔断器有半开机制，在熔断器打开后的一个时间窗口后，熔断器开始变成半开状态，尝试将流量放行，如果要是放行的流量返回了正常的结果，那么熔断器就会尝试关闭。</li>
<li>服务降级可以看作是服务熔断后的一种处理方式。</li>
</ul>
<h2 id="API网关"><a href="#API网关" class="headerlink" title="API网关"></a>API网关</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223144626739.png" alt="image-20221223144626739"></p>
<ul>
<li>拦截所有打过来的请求，先做断言，断言成功之后，做过滤，最后再进行路由。</li>
</ul>
<h2 id="完整服务架构图"><a href="#完整服务架构图" class="headerlink" title="完整服务架构图"></a>完整服务架构图</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223145200445.png" alt="image-20221223145200445"></p>
<h2 id="微服务划分图"><a href="#微服务划分图" class="headerlink" title="微服务划分图"></a>微服务划分图</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223145837732.png" alt="image-20221223145837732"></p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223153607206.png" alt="image-20221223153607206"></p>
<ul>
<li>虚拟化的容器，里面通过镜像装好了各种软件，镜像可以从Docker的hub上获取，软件可以在Docker中运行，因为软件的运行时环境都被打包到镜像中了，通过镜像安装后，软件就具备了在docker中运行的能力，各软件的运行环境相互隔离，一个出问题不会影响另外一个。</li>
<li>用这个技术安装软件非常方便，省去了在linux上安装软件的一系列繁琐的步骤。</li>
</ul>
<h2 id="租了个腾讯云服务器"><a href="#租了个腾讯云服务器" class="headerlink" title="租了个腾讯云服务器"></a>租了个腾讯云服务器</h2><ul>
<li>用来做后面的部署工作啥的，centos7.6系统，自带了个docker，4核8g，100gSSD。</li>
</ul>
<h2 id="使用docker安装mysql-5-7"><a href="#使用docker安装mysql-5-7" class="headerlink" title="使用docker安装mysql 5.7"></a>使用docker安装mysql 5.7</h2><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><ul>
<li><p>有了云服务器和docker之后，安装这些软件就变得非常容易了，只需要在云服务器上运行**<code>sudo docker pull mysql:5.7</code><strong>就能下载了，下载别的软件的时候这个命令的格式基本不变，不过要注意的是，</strong>如果要指定下载软件镜像的版本，应该在镜像名称的后面加个冒号然后指定版本，如果不加冒号则默认下载最新版**：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223163407228.png" alt="image-20221223163407228"></p>
</li>
</ul>
<h3 id="查看已经下载的镜像"><a href="#查看已经下载的镜像" class="headerlink" title="查看已经下载的镜像"></a>查看已经下载的镜像</h3><ul>
<li><p>然后可以通过**<code>sudo docker images</code><strong>命令来</strong>查看已经下载的所有镜像**：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223163502237.png" alt="image-20221223163502237"></p>
</li>
</ul>
<h3 id="创建实例并启动"><a href="#创建实例并启动" class="headerlink" title="创建实例并启动"></a>创建实例并启动</h3><ul>
<li><p>使用如下的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>

<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223173136099.png" alt="image-20221223173136099"></p>
<p><strong>最后产生的是该实例的id</strong>。</p>
</li>
<li><p>参数说明：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223164759780.png" alt="image-20221223164759780"></p>
</li>
<li><p>从这里也能看出来<strong>docker中的部分冒号一般充当映射的作用，冒号前面的是运行docker的宿主机的内容，冒号后面的是docker这个虚拟容器中的内容</strong>，明白了这个看很多docker命令就了然许多了。</p>
</li>
<li><p>所谓<strong>目录挂载-v</strong>就是<strong>将一个目录挂载到另一个目录下，这样在访问被挂载到的目录的时候就相当于访问到了挂载目录，实际上是用软连接（快捷方式）实现的</strong>，这样就省得每次想要修改实例内部的文件的时候都要进实例中修改了,<strong>在挂载目录之前为了防止出现权限不够的问题，最好是先用命令<code>sudo chmod -R 777 目录路径</code>来提升相关目录的权限</strong>。</p>
</li>
<li><p>关于<strong>端口映射-p</strong>，由于<strong>mysql是跑在docker里面的3306端口上的</strong>，从外面无法访问，所以我们<strong>需要将docker里的3306端口和其宿主机的3306端口进行一个映射，这样外面在访问宿主机的3306端口的时候就能访问到docker的3306端口了</strong>。</p>
</li>
<li><p>至于<strong>设置实例名称–name</strong>，实例名称之后可以当作实例的唯一标识，那一串实例id也可以当作实例的唯一标识，但是用实例名称作为标识方便多了不是吗？</p>
</li>
<li><p><strong>-d就是从后台启动</strong>，后面要写<strong>镜像名:版本号</strong></p>
</li>
</ul>
<h3 id="查看某个实例的日志"><a href="#查看某个实例的日志" class="headerlink" title="查看某个实例的日志"></a>查看某个实例的日志</h3><ul>
<li><p>使用命令**<code>docker logs 实例名或实例id</code>**来查看某个实例的日志：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223205722266.png" alt="image-20221223205722266"></p>
</li>
</ul>
<h3 id="查看docker中正在运行的软件"><a href="#查看docker中正在运行的软件" class="headerlink" title="查看docker中正在运行的软件"></a>查看docker中正在运行的软件</h3><ul>
<li><p>使用**<code>docker ps -a</code><strong>命令来</strong>查看当前docker中所有状态的软件，包括正在运行的和已经终止的<strong>；使用</strong><code>docker ps</code><strong>命令来</strong>查看当前docker中正在运行的软件**：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223173216375.png" alt="image-20221223173216375"></p>
</li>
</ul>
<h3 id="停止docker实例"><a href="#停止docker实例" class="headerlink" title="停止docker实例"></a>停止docker实例</h3><ul>
<li><p>使用**<code>docker stop 实例名或实例id</code><strong>来</strong>将一个实例从正在运行状态变成已经终止的状态<strong>，注意</strong>停止docker实例的运行并不代表着删除docker实例**，停止docker实例运行后还可以通过启动docker实例来让其恢复运行，而删除docker实例后就这个实例就永远不能启动了，要想跑实例就必须再创建一个实例：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223191435300.png" alt="image-20221223191435300"></p>
</li>
</ul>
<h3 id="启动docker实例"><a href="#启动docker实例" class="headerlink" title="启动docker实例"></a>启动docker实例</h3><ul>
<li><p>使用**<code>docker start 实例名或实例id</code>**来将一个状态是终止状态的实例启动：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221223191618624.png" alt="image-20221223191618624"></p>
</li>
</ul>
<h3 id="重启docker实例"><a href="#重启docker实例" class="headerlink" title="重启docker实例"></a>重启docker实例</h3><ul>
<li>使用**<code>docker restart 实例名或实例id</code>**来将一个状态是运行状态的实例重新启动。</li>
</ul>
<h3 id="删除docker容器"><a href="#删除docker容器" class="headerlink" title="删除docker容器"></a>删除docker容器</h3><ul>
<li>有的实例已经没有在运行了，但是其容器还存在绑定着一些资源，我们想将其移除，可以使用**<code>docker rm 实例ID或实例名</code>**来将其删除。</li>
</ul>
<h3 id="删除docker本地镜像"><a href="#删除docker本地镜像" class="headerlink" title="删除docker本地镜像"></a>删除docker本地镜像</h3><ul>
<li>首先可以通过**<code>docker images</code><strong>来查看本地镜像名称及id，然后可以通过</strong><code>docker rmi 镜像名或镜像id</code>**来删除本地镜像。</li>
</ul>
<h3 id="进入docker正在运行的实例内部"><a href="#进入docker正在运行的实例内部" class="headerlink" title="进入docker正在运行的实例内部"></a>进入docker正在运行的实例内部</h3><ul>
<li>由于<strong>docker实例有一个软件完整的运行环境，所以它本质上拥有一个完整的linux目录结构（以linux系统下的docker来说</strong>），我们可以通过**<code>docker exec -it 实例名或实例id /bin/bash</code>**进入到这个实例的内部的操作台，然后就可以对实例的内部进行操作了，操作就和linux一样，毕竟是个linux环境。</li>
<li>也可以修改最后一部分以运行实例内部中的其他东西。</li>
<li>通过**<code>exit</code>**命令从实例内部的操作台中退出到外面。</li>
</ul>
<h3 id="让对应的容器开机自启动实例"><a href="#让对应的容器开机自启动实例" class="headerlink" title="让对应的容器开机自启动实例"></a>让对应的容器开机自启动实例</h3><ul>
<li>使用命令**<code>sudo docker update 容器id或容器名 --restart=always</code>**来配置开机自启动。</li>
</ul>
<h3 id="创建mysql的配置文件"><a href="#创建mysql的配置文件" class="headerlink" title="创建mysql的配置文件"></a>创建mysql的配置文件</h3><ul>
<li><p>在刚才挂载的宿主机上的目录下新建配置文件my.cnf(用**<code>touch 文件名</code><strong>或者</strong><code>vim/vi 文件名</code>**都行)填入以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">init_connect=&#x27;SET collation_connection = utf8_unicode_ci&#x27;</span><br><span class="line">init_connect=&#x27;SET NAMES utf8&#x27;</span><br><span class="line">character-set-server=utf8</span><br><span class="line">collation-server=utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启mysql实例，如果想要验证是否真的产生了配置文件可以进入实例内部的对应目录下查看。</p>
</li>
</ul>
<h3 id="查看各实例占用资源的情况"><a href="#查看各实例占用资源的情况" class="headerlink" title="查看各实例占用资源的情况"></a>查看各实例占用资源的情况</h3><ul>
<li>可以使用<code>docker stats</code>命令来进行查看。</li>
</ul>
<h3 id="将docker容器中的内容复制到指定位置"><a href="#将docker容器中的内容复制到指定位置" class="headerlink" title="将docker容器中的内容复制到指定位置"></a>将docker容器中的内容复制到指定位置</h3><ul>
<li>使用命令**<code>docker container cp 容器名:容器内部目录 目标目录</code>**来实现。</li>
</ul>
<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><ul>
<li>SSH（Secure Shell） 是较可靠，<strong>专为远程登录会话和其他网络服务提供安全性的协议</strong>，利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题，这是因为SSH相较于其他的传输协议来说对数据进行了加密处理。</li>
<li>我们<strong>通常使用实现SSH协议的软件来实现远程数据传输、远程连接等操作</strong>，这个连接操作<strong>可以使用基于密钥的安全验证</strong>的，<strong>也可以使用基于口令的安全验证</strong>。</li>
</ul>
<h2 id="在本地使用Navicat通过SSH协议连接到服务器上的mysql数据库"><a href="#在本地使用Navicat通过SSH协议连接到服务器上的mysql数据库" class="headerlink" title="在本地使用Navicat通过SSH协议连接到服务器上的mysql数据库"></a>在本地使用Navicat通过SSH协议连接到服务器上的mysql数据库</h2><ul>
<li>出于安全考虑，我们不使用基于口令的安全验证方式，实际上腾讯云服务器上ssh协议的配置文件中也是默认将这种方式关闭的，我们使用基于密钥的安全验证。</li>
</ul>
<h3 id="创建密钥"><a href="#创建密钥" class="headerlink" title="创建密钥"></a>创建密钥</h3><ul>
<li>SSH协议通常使用基于密钥的安全验证方式，所以我们要先在腾讯云控制台上新建一个密钥，公钥会显示在控制台，而密钥会下载到本地。</li>
</ul>
<h3 id="将密钥绑定到服务器实例上"><a href="#将密钥绑定到服务器实例上" class="headerlink" title="将密钥绑定到服务器实例上"></a>将密钥绑定到服务器实例上</h3><ul>
<li>就是把刚才创建的SSH公钥绑定到服务器上，这样别的主机就可以使用那个SSH公钥对应的私钥来向服务器发起SSH连接。</li>
</ul>
<h3 id="新建连接"><a href="#新建连接" class="headerlink" title="新建连接"></a>新建连接</h3><ul>
<li>在navicat上新建一个连接，名字随便取，然后数据库的密码填服务器上数据库的密码。</li>
<li>然后配置SSH，勾选使用SSH通道，填写服务器ip，填写用户名，验证方法选公钥，然后私钥选择刚才下载下来的那个文件，通行短语就是每次连接的时候需要输入的口令，自己随便设置一个就行，建议勾选保存通行短语，这样就不用每次连接都输入通行短语了，测试连接，发现可以连通，点击确认即可。</li>
</ul>
<h2 id="使用docker安装redis"><a href="#使用docker安装redis" class="headerlink" title="使用docker安装redis"></a>使用docker安装redis</h2><ul>
<li><p>前面基本和mysql的安装类似，pull的是最新版的</p>
</li>
<li><p>在外面预先创建好redis的配置文件，因为实例中redis一开始可能没有redis.conf，进行挂载目录的时候宿主机的redis.conf可能会被错误的识别为一个目录，所以要在指定位置先创建好redis.conf防止发生歧义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/redis/conf</span><br><span class="line">touch /mydata/redis/conf/redis.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建实例并启动的命令，最后一句是表示让redis-server按照对应路径下的配置文件进行启动，要预先在外面对应位置创建好redis.conf文件，注意这个redis.conf文件存在的目录在不同版本的redis中有区别，具体按安装的redis版本为准：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 6379:6379 --name redis \</span><br><span class="line">-v /mydata/redis/data:/data \</span><br><span class="line">-v /mydata/redis/conf/redis.conf:/usr/local/etc/redis/redis.conf \</span><br><span class="line">-d redis /usr/local/bin/redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用**<code>docker exec -it redis redis-cli</code>**可以打开redis实例中的redis-cli</p>
</li>
<li><p>在redis的配置文件中添加<strong>appendonly yes</strong>，配置让redis使用aof的方式持久化数据</p>
</li>
<li><p>可以在本地<strong>使用Redis Desktop Manager来远程访问redis</strong>，也是用SSH连接，和前面的Navicat类似，这里就不赘述了，但是注意这个软件用到了服务器上的6379端口，所以要先把6379端口开放之后才能连接上。</p>
</li>
</ul>
<h2 id="在IDEA中搭建各种模块"><a href="#在IDEA中搭建各种模块" class="headerlink" title="在IDEA中搭建各种模块"></a>在IDEA中搭建各种模块</h2><ul>
<li><p>先clone下来刚建好的仓库，再创建各个模块</p>
</li>
<li><p>每个模块使用springboot的初始化工具进行初始化，每个一开始都配上web和openfeign的环境</p>
</li>
</ul>
<h1 id="2022-x2F-12-x2F-24"><a href="#2022-x2F-12-x2F-24" class="headerlink" title="2022&#x2F;12&#x2F;24"></a>2022&#x2F;12&#x2F;24</h1><h2 id="设置项目的-gitignore文件"><a href="#设置项目的-gitignore文件" class="headerlink" title="设置项目的.gitignore文件"></a>设置项目的.gitignore文件</h2><ul>
<li><p>两个星号**指所有子目录及其递归结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">target/</span><br><span class="line">pom.xml.tag</span><br><span class="line">pom.xml.releaseBackup</span><br><span class="line">pom.xml.versionsBackup</span><br><span class="line">pom.xml.next</span><br><span class="line">release.properties</span><br><span class="line">dependency-reduced-pom.xml</span><br><span class="line">buildNumber.properties</span><br><span class="line">.mvn/timing.properties</span><br><span class="line"># https://github.com/takari/maven-wrapper#usage-without-binary-jar</span><br><span class="line">.mvn/wrapper/maven-wrapper.jar</span><br><span class="line"></span><br><span class="line">**/mvnw</span><br><span class="line">**/mvnw.cmd</span><br><span class="line">**/.mvn</span><br><span class="line">**/target/</span><br><span class="line">.idea</span><br><span class="line">**/.gitignore</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="IDEA中Project-Structure中的Facets配置"><a href="#IDEA中Project-Structure中的Facets配置" class="headerlink" title="IDEA中Project Structure中的Facets配置"></a>IDEA中Project Structure中的Facets配置</h2><ul>
<li><p>这个配置实际上就是在告诉IDEA怎么去处理你的对应模块，比如说我给一个模块设置了一个spring的Facets，那么IDEA就知道使用对待spring模块的方式来对待我的这个模块，每个模块可以配置多个Facets，并且每个Facets可以进行相应的配置从而来让IDEA帮我们配置关于这个模块的一些东西：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221224154946122.png" alt="image-20221224154946122"></p>
</li>
</ul>
<h2 id="PowerDesigner"><a href="#PowerDesigner" class="headerlink" title="PowerDesigner"></a>PowerDesigner</h2><ul>
<li>这个软件是用来设计数据库的</li>
<li>所有表无论关系多么复杂都不应该建立外键，外键关联非常消耗数据库的性能</li>
<li>可以用这个软件针对设计出来的数据库导出sql文件（Database-generate database选项）</li>
</ul>
<h2 id="启动报错：java-程序包org-aspectj-lang不存在"><a href="#启动报错：java-程序包org-aspectj-lang不存在" class="headerlink" title="启动报错：java: 程序包org.aspectj.lang不存在"></a>启动报错：java: 程序包org.aspectj.lang不存在</h2><ul>
<li>可能是springboot版本的问题，改个版本试下</li>
</ul>
<h2 id="前端项目下载依赖"><a href="#前端项目下载依赖" class="headerlink" title="前端项目下载依赖"></a>前端项目下载依赖</h2><ul>
<li>可以通过**<code>npm install</code>**命令来下载一个前端项目所需要的依赖文件。</li>
</ul>
<h2 id="前端项目运行"><a href="#前端项目运行" class="headerlink" title="前端项目运行"></a>前端项目运行</h2><ul>
<li>使用**<code>npm run dev</code>**来运行前端项目</li>
</ul>
<h2 id="查看windows系统的端口占用"><a href="#查看windows系统的端口占用" class="headerlink" title="查看windows系统的端口占用"></a>查看windows系统的端口占用</h2><ul>
<li>使用**<code>netstat -ano</code>**命令查看所有端口的占用情况，再根据详细信息中的PID从任务管理器中找到对应的应用。</li>
</ul>
<h2 id="关于子模块的依赖问题"><a href="#关于子模块的依赖问题" class="headerlink" title="关于子模块的依赖问题"></a>关于子模块的依赖问题</h2><ul>
<li>一般来说子模块用到的依赖应该在父模块声明方便管理，然后子模块再声明一次。</li>
<li>其实也可以将子模块都用得到的依赖放到common模块中，然后子模块引入common模块，省的在子模块中再声明一次了就。</li>
</ul>
<h2 id="关于maven的版本问题"><a href="#关于maven的版本问题" class="headerlink" title="关于maven的版本问题"></a>关于maven的版本问题</h2><ul>
<li>用IDEA的话maven尽量用3.6.3的版本吧，这个版本的maven对各个版本的IDEA都挺兼容的，我感觉我从远程下载不下来jar包是因为我maven版本太高了的原因，我现在是3.8.6，我去试试低版本。</li>
<li>好像也不太行，总之还是尽量用第二梯队的吧，啥东西也是别无脑上最新版。</li>
</ul>
<h1 id="2022-x2F-12-x2F-27"><a href="#2022-x2F-12-x2F-27" class="headerlink" title="2022&#x2F;12&#x2F;27"></a>2022&#x2F;12&#x2F;27</h1><h2 id="关于有些jar包无法从远程仓库下载"><a href="#关于有些jar包无法从远程仓库下载" class="headerlink" title="关于有些jar包无法从远程仓库下载"></a>关于有些jar包无法从远程仓库下载</h2><ul>
<li><p>首先排除一下网络问题</p>
</li>
<li><p>然后可能是你这个jar包在你配置的那个仓库中没有，你需要重新配置一个有那个jar包的仓库的镜像，至于怎么知道这个jar包在哪个仓库中有，可以从中央仓库中搜索，然后点下面这几个标签之一就能查看标签对应的仓库地址了：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221227202945652.png" alt="image-20221227202945652"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221227203005023.png" alt="image-20221227203005023"></p>
</li>
<li><p>如果还是不能解决的话，也可以手动下载然后根据gav地址配置到本地的maven仓库中。</p>
</li>
<li><p>最后就是记得使用解决方案之后clean一下maven，不然可能还是爆红。</p>
</li>
</ul>
<h1 id="2022-x2F-12-x2F-28"><a href="#2022-x2F-12-x2F-28" class="headerlink" title="2022&#x2F;12&#x2F;28"></a>2022&#x2F;12&#x2F;28</h1><h2 id="关于mybatis-plus的代码生成器的依赖"><a href="#关于mybatis-plus的代码生成器的依赖" class="headerlink" title="关于mybatis-plus的代码生成器的依赖"></a>关于mybatis-plus的代码生成器的依赖</h2><ul>
<li><p>搞了半天终于搞定了mybatis-plus代码生成器的依赖，依赖列表如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mybatis-plus.version</span>&gt;</span>3.1.2<span class="tag">&lt;/<span class="name">mybatis-plus.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mybatis-plus-generator.version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">mybatis-plus-generator.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">commons-lang3.version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">commons-lang3.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mysql-connector-java.version</span>&gt;</span>8.0.17<span class="tag">&lt;/<span class="name">mysql-connector-java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.1.13<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">velocity-engine-core.version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">velocity-engine-core.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--mybatis-plus 持久层--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis-plus代码生成器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus-generator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 代码生成器依赖的某个工具类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;commons-lang3.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql数据库驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql-connector-java.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--阿里druid连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- velocity 模板引擎, Mybatis Plus 代码生成器需要 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.velocity/velocity-engine-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;velocity-engine-core.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="关于数据库表的一些设计规范"><a href="#关于数据库表的一些设计规范" class="headerlink" title="关于数据库表的一些设计规范"></a>关于数据库表的一些设计规范</h2><ul>
<li>根据《阿里巴巴开发手册》中提到的，<strong>每张表应该都有id、gmt_create（记录创建时间）、gmt_modified（记录修改时间）字段</strong>，说明：其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1（或者用varchar 19存，每次使用雪花算法自动生成19位uuid）。gmt_create、gmt_modified 的类型均为 date_time 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</li>
<li>还可以<strong>创建is_deleted字段来标识当前记录是否被逻辑删除</strong>，开发的时候可以配置逻辑删除插件来对这个字段实现自动化操作，并且<strong>应该让被逻辑删除的记录无法被查到</strong>。</li>
</ul>
<h2 id="关于spring-boot-maven-plugin"><a href="#关于spring-boot-maven-plugin" class="headerlink" title="关于spring-boot-maven-plugin"></a>关于spring-boot-maven-plugin</h2><ul>
<li>这个插件如果要是配置到pom文件中，那么在maven进行构建的时候就会去找这个pom文件管辖范围下的程序入口main，所以如果父工程没有程序入口main，就不要引入这个插件，不然在执行maven的生命周期时会报错。</li>
</ul>
<h2 id="maven执行install的时候报单元测试错误"><a href="#maven执行install的时候报单元测试错误" class="headerlink" title="maven执行install的时候报单元测试错误"></a>maven执行install的时候报单元测试错误</h2><ul>
<li><p>可以在下面这个地方设置成跳过单元测试的模式，设置完成后再执行就好了：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221228183630929.png" alt="image-20221228183630929"></p>
</li>
</ul>
<h2 id="IDEA有时包明明存在但是运行程序时总是报找不到某个包"><a href="#IDEA有时包明明存在但是运行程序时总是报找不到某个包" class="headerlink" title="IDEA有时包明明存在但是运行程序时总是报找不到某个包"></a>IDEA有时包明明存在但是运行程序时总是报找不到某个包</h2><ul>
<li><p>首先尝试刷新Maven，有的时候IDE会抽风导致很多包明明存在但却没有被加载。</p>
</li>
<li><p>再者有可能是IDEA的bug，可以在下面这个地方将IDE的构建&#x2F;运行操作委托给maven，不过设置了这个之后不保证以后不会出什么问题，所以解决问题之后能改回来就尽量改回来吧：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221228184212604.png" alt="image-20221228184212604"></p>
</li>
</ul>
<h1 id="2022-x2F-12-x2F-29"><a href="#2022-x2F-12-x2F-29" class="headerlink" title="2022&#x2F;12&#x2F;29"></a>2022&#x2F;12&#x2F;29</h1><h2 id="记录一种奇怪的依赖引入方式"><a href="#记录一种奇怪的依赖引入方式" class="headerlink" title="记录一种奇怪的依赖引入方式"></a>记录一种奇怪的依赖引入方式</h2><ul>
<li><p>在处理依赖的时候发现了一种比较奇怪的依赖引入方式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个结构的依赖我翻了翻之前的博客，没发现有相关的解释，值为pom的type标签和值为import的scope标签也从来没见过，上网搜了搜，基本可以将这个东西理解成一个比较方便引入的整体，需要引入的时候直接往pom里一粘，具体的解释目前还不得而知。（如果原pom本来就有dependencyManagement标签怎么办？如果要是父pom中引入了这种格式的依赖，那子pom应该以怎样的格式引入这样的依赖？type标签和scope标签的值到底是什么含义？）</p>
</li>
</ul>
<h2 id="关于nacos-2-x版本无法访问的问题"><a href="#关于nacos-2-x版本无法访问的问题" class="headerlink" title="关于nacos 2.x版本无法访问的问题"></a>关于nacos 2.x版本无法访问的问题</h2><ul>
<li><p>在服务器的docker上安装了nacos-server的2.0.2版本，但是在本地启动springboot的服务却报错无法连接到nacos-server，但是在本地的浏览器上访问服务器的8848端口下的nacos目录是可以访问的，就奇了怪了，后来搜索了一下才知道，原来<strong>2.x版本的nacos-server还用到了9848（8848+1000）和9849（8848+1001）两个端口，这两个端口号不是固定的是通过主服务端口加上一个固定的偏移量得来的</strong>，所以在docker启动镜像的时候要用多个-p命令同时指定三个端口的映射：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221229172729337.png" alt="image-20221229172729337"></p>
</li>
</ul>
<h2 id="关于在nacos配置中心上做配置"><a href="#关于在nacos配置中心上做配置" class="headerlink" title="关于在nacos配置中心上做配置"></a>关于在nacos配置中心上做配置</h2><ul>
<li><p>配置中心的命名空间可以用来隔离不同的服务，也可以用来隔离不同的开发环境，也可以自定义隔离规则，在命名空间下还有组可以进行环境隔离，要想指定特定的命名空间和组，需要在bootstrap配置文件中进行相关配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置命名空间,填的是命名空间的id</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.namespace</span>=<span class="string">coupon</span></span><br><span class="line"><span class="comment">#配置组，填的是组名</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.group</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个配置文件中的内容过多的话，可以将一个配置文件拆成多个配置文件，每一个配置文件各司其职，不过这样的方式需要最后在本地的bootstrap配置文件中进行配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置配置中心上自定义名称的配置文件，可以把很长的配置文件拆分开放到配置中心上，然后在这里配置读取</span></span><br><span class="line"><span class="comment">#中心上的配置文件名称</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[0].data-id</span>=<span class="string">datasource.yaml</span></span><br><span class="line"><span class="comment">#设置组</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[0].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="comment">#开启刷新以保证服务可以事实获取到最新的改动</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[0].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[1].data-id</span>=<span class="string">mybatis.yaml</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[1].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[1].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[2].data-id</span>=<span class="string">other.yaml</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[2].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[2].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2022-x2F-12-x2F-30"><a href="#2022-x2F-12-x2F-30" class="headerlink" title="2022&#x2F;12&#x2F;30"></a>2022&#x2F;12&#x2F;30</h1><h2 id="如何排除不想加载的包"><a href="#如何排除不想加载的包" class="headerlink" title="如何排除不想加载的包"></a>如何排除不想加载的包</h2><ol>
<li><p>可以在pom文件中使用exclusions-exclusion标签来对指定jar包进行排除</p>
</li>
<li><p>也可以在@SpringBootApplication注解中设置exclude参数，实参应该是某个AutoConfiguration的class对象，比如想要排除数据源相关的包：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="2023-x2F-1-x2F-1"><a href="#2023-x2F-1-x2F-1" class="headerlink" title="2023&#x2F;1&#x2F;1"></a>2023&#x2F;1&#x2F;1</h1><h2 id="关于使用mybatis-plus查不出数据的问题"><a href="#关于使用mybatis-plus查不出数据的问题" class="headerlink" title="关于使用mybatis-plus查不出数据的问题"></a>关于使用mybatis-plus查不出数据的问题</h2><ul>
<li>首先检查@TableId注解，看看数据库的id和实体类的id是否一致</li>
<li>也有可能是@TableLogic注解导致的，因为注解上@TableLogic注解后默认这个字段不能为空，此时要是数据库中的数据这个字段为空，那就查不出来。</li>
<li>总而言之大部分是实体类和数据库表的字段参数不一致造成的。</li>
</ul>
<h2 id="在实体类中添加数据库表中不存在的字段"><a href="#在实体类中添加数据库表中不存在的字段" class="headerlink" title="在实体类中添加数据库表中不存在的字段"></a>在实体类中添加数据库表中不存在的字段</h2><ul>
<li>需要加上**<code>@TableField(exist = false)</code>**注解。</li>
<li>不过更规范的做法应该是再写一个VO类，然后使用bean拷贝。</li>
</ul>
<h2 id="在VScode中添加vue代码模板"><a href="#在VScode中添加vue代码模板" class="headerlink" title="在VScode中添加vue代码模板"></a>在VScode中添加vue代码模板</h2><ul>
<li><p>首先点击<strong>文件-首选项-配置用户代码片段</strong>，然后点击<strong>新建全局代码片段文件</strong>，然后<strong>将模板复制进去或者自己写一个模板</strong>，其中<strong>prefix属性就是你输入prefix属性对应的值会提示产生这个代码片段</strong>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Print to console&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;&lt;!-- $1 --&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;template&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;div class=&#x27;$2&#x27;&gt;$5&lt;/div&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;/template&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;script&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//这里可以导入其他文件（比如：组件，工具js，第三方插件js，json文件，图片文件等等）&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//例如：import 《组件名称》 from &#x27;《组件路径》&#x27;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;export default &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//import引入的组件需要注入到对象中才能使用&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;components: &#123;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;data() &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//这里存放数据&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;return &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//监听属性 类似于data概念&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;computed: &#123;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//监控data中的数据变化&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;watch: &#123;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//方法集合&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;methods: &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//生命周期 - 创建完成（可以访问当前this实例）&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;created() &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;//生命周期 - 挂载完成（可以访问DOM元素）&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;mounted() &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;beforeCreate() &#123;&#125;, //生命周期 - 创建之前&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;beforeMount() &#123;&#125;, //生命周期 - 挂载之前&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;beforeUpdate() &#123;&#125;, //生命周期 - 更新之前&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;updated() &#123;&#125;, //生命周期 - 更新之后&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;beforeDestroy() &#123;&#125;, //生命周期 - 销毁之前&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;destroyed() &#123;&#125;, //生命周期 - 销毁完成&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;activated() &#123;&#125;, //如果页面有keep-alive缓存功能，这个函数会触发&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;/script&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;style scoped&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="string">&quot;&lt;/style&gt;&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;生成vue模板&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http-get请求&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;httpget&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="string">&quot;this.\\$http(&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;url: this.\\$http.adornUrl(&#x27;&#x27;),&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;method: &#x27;get&#x27;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;params: this.\\$http.adornParams(&#123;&#125;)&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;&#125;).then((&#123; data &#125;) =&gt; &#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;&#125;)&quot;</span></span><br><span class="line">	<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;httpGET请求&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;http-post请求&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;httppost&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="string">&quot;this.\\$http(&#123;&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;url: this.\\$http.adornUrl(&#x27;&#x27;),&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;method: &#x27;post&#x27;,&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;data: this.\\$http.adornData(data, false)&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="string">&quot;&#125;).then((&#123; data &#125;) =&gt; &#123; &#125;);&quot;</span> </span><br><span class="line">	<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;httpPOST请求&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2023-x2F-1-x2F-2"><a href="#2023-x2F-1-x2F-2" class="headerlink" title="2023&#x2F;1&#x2F;2"></a>2023&#x2F;1&#x2F;2</h1><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><ul>
<li><p>由于某些软件的CORS（Cross-Origin Resource Sharing 跨域资源共享）policy的设置，使得我们在跨域访问资源的时候会出现禁止跨域访问资源的问题，<strong>协议、域名、端口其中有一个不同都会产生跨域</strong>，详细解释：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS%E3%80%82">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS。</a></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230102142732589.png" alt="image-20230102142732589"></p>
</li>
<li><p>对于这样的跨域问题我们可以从两个方向着手解决：</p>
<ol>
<li><p>其一是使用nginx将项目部署为同一域</p>
</li>
<li><p>其二是在跨域访问的响应资源的http报文header中写明当次请求允许跨域，可以在网关中配置跨域过滤器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> CorsWebFilter <span class="title function_">corsWebFilter</span><span class="params">()</span>&#123;<span class="comment">//配置跨域过滤器，让资源允许被跨域访问</span></span><br><span class="line">    <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">    <span class="type">CorsConfiguration</span> <span class="variable">corsConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line"></span><br><span class="line">    corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);<span class="comment">//允许所有带有头部的资源被跨域访问</span></span><br><span class="line">    corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);<span class="comment">//允许资源被所有访问方式跨域访问</span></span><br><span class="line">    corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);<span class="comment">//允许资源被所有域名跨域访问</span></span><br><span class="line">    corsConfiguration.setAllowCredentials(<span class="literal">true</span>);<span class="comment">//允许cookie资源跨域访问</span></span><br><span class="line"></span><br><span class="line">    source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,corsConfiguration);<span class="comment">//对于任意资源路径进行跨域配置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完上面这些之后，资源在返回的时候就会经过过滤器，在资源的响应header上加上我们配置的字段，浏览器看到之后自然就会将该资源放行。</p>
</li>
</ol>
</li>
</ul>
<h2 id="如何初始化并启动一个前端项目"><a href="#如何初始化并启动一个前端项目" class="headerlink" title="如何初始化并启动一个前端项目"></a>如何初始化并启动一个前端项目</h2><ol>
<li>使用<strong>npm init</strong>命令初始化项目目录</li>
<li>使用<strong>npm install</strong>命令安装package.json文件中写的依赖</li>
<li>使用<strong>npm run dev</strong>命令启动项目</li>
</ol>
<h1 id="2023-x2F-1-x2F-3"><a href="#2023-x2F-1-x2F-3" class="headerlink" title="2023&#x2F;1&#x2F;3"></a>2023&#x2F;1&#x2F;3</h1><h2 id="项目中如何进行文件存储"><a href="#项目中如何进行文件存储" class="headerlink" title="项目中如何进行文件存储"></a>项目中如何进行文件存储</h2><ul>
<li><p>如果项目需要我们进行文件存储，我们应该怎么办？</p>
</li>
<li><p>首先我们能想到的是在后端创建一个目录，专门用来存放前端传过来的文件，但是这样有个问题，就是后端在部署为集群的时候，前端对于后端的访问肯定是负载均衡的，所以前端不一定将文件存放到哪个集群节点中，访问的时候也不一定访问哪个集群节点，并不能保证文件一定会被读取到。</p>
</li>
<li><p>再者我们可以创建一个专门的文件服务器来对文件进行存储，直接将文件传给文件服务器，这样可以保证存储的文件可以被读取到，但是我们自己搭建的文件服务器难免会出现一些问题，而且我们还要拿出专门的时间去对其进行维护。所以我们可以使用云存储功能，去购买别人公司的云存储功能，我们只需要将我们的程序和公司的接口对接就能实现云存储的功能了，而且公司里有专业的运维人员来维护，我们只要掏钱就行了。</p>
</li>
<li><p>那么我们应该采取什么样的策略来实现文件存储呢？是前端将文件传给后端，然后后端再交给云服务器吗？这样可以实现，但是这样做后端的压力过大，仅仅是处理文件上传请求就已经占用了后端太多的资源，所以我们<strong>可以利用用户端的资源来上传文件，后端要做的只是返回一个签名，前端带着这个签名申请将文件上传到云服务器，如果签名被云服务器承认，那么文件就可以从前端直接上传到云服务器上，很明显这样做大大减少了后端的压力</strong>：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230103165550800.png" alt="image-20230103165550800"></p>
</li>
<li><p>springcloud alibaba整合了阿里的OSS服务的SDK并对其进行了封装，我们如果想要使用它的功能，只需要<strong>导入springcloud alibaba的依赖、oss的starter依赖，然后在配置文件中进行身份验证的配置和endpoint的配置，然后在controller中注入OSSClient对象，使用OSSClient对象就可以实现各种操作了</strong>。整合的时候oss的starter依赖尽量和springcloud alibaba的依赖版本相同，不然可能会出现依赖冲突，出现依赖冲突后需要手动exclusion一些包。</p>
</li>
<li><p>前端收到签名后，按照阿里云的文档构造请求体，然后直接给bucket对应的url发post请求即可，文档：<a target="_blank" rel="noopener" href="https://help.aliyun.com/document_detail/31926.html">https://help.aliyun.com/document_detail/31926.html</a></p>
</li>
<li><p>上传文件的时候可以使用UUID+原始文件名组成上传文件名来防止出现命名冲突。</p>
</li>
<li><p>dir目录可以设置成格式化的年月日，这样每天上传的文件都会放到一个对应当天日期的目录中方便管理。</p>
</li>
<li><p>记得在阿里云oss控制台那边配置CORS policy，不然会有跨域问题。</p>
</li>
</ul>
<h1 id="2023-x2F-1-x2F-4"><a href="#2023-x2F-1-x2F-4" class="headerlink" title="2023&#x2F;1&#x2F;4"></a>2023&#x2F;1&#x2F;4</h1><h2 id="后端数据校验"><a href="#后端数据校验" class="headerlink" title="后端数据校验"></a>后端数据校验</h2><h3 id="为什么后端要进行数据校验"><a href="#为什么后端要进行数据校验" class="headerlink" title="为什么后端要进行数据校验"></a>为什么后端要进行数据校验</h3><ul>
<li>虽然前端有进行数据校验，但是如果一些不法分子不通过前端向后端发送数据，比如使用postman等工具，也就绕过了前端的数据校验，所以后端必须再进行一次数据校验以保证系统的安全。</li>
</ul>
<h3 id="关于JSR"><a href="#关于JSR" class="headerlink" title="关于JSR"></a>关于JSR</h3><ul>
<li>JSR是Java Specification Requests的缩写，意思是<strong>Java 规范提案</strong>。是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。</li>
</ul>
<h3 id="关于JSR-303"><a href="#关于JSR-303" class="headerlink" title="关于JSR-303"></a>关于JSR-303</h3><p>JSR-303 是JAVA EE 6 中的一项子规范，叫做<strong>Bean Validation</strong>，是用来校验数据的规范，Hibernate Validator 是 Bean Validation 的参考实现 . Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。</p>
<h3 id="基本数据校验"><a href="#基本数据校验" class="headerlink" title="基本数据校验"></a>基本数据校验</h3><ul>
<li><p>主要是使用JSR-303标准，这套标准规定了java中对各种数据进行校验的标准，各公司对于这套标准的实现提供了多种多样的注解，通过<strong>给实体类属性上面添加对应的校验注解、自定义message提示消息</strong>并且<strong>给想要校验的参数注解上@Valid</strong>来实现对实参数据的校验，实参校验不通过会响应包含自定义message提示消息在内的数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(value = &quot;品牌名&quot;)</span></span><br><span class="line"><span class="meta">@NotBlank(message = &quot;品牌名不能为空&quot;)</span><span class="comment">//数据校验，该字段不能为空，并且至少有一个非空字符</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> PmsBrand entity)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pmsBrandService.save(entity)?Result.ok():Result.error();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果<strong>想要获取校验的结果，可以在被@Valid注解修饰的参数后面紧跟着写一个BindingResult类型的参数，这个参数封装了它前面参数的校验结果</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> PmsBrand entity, BindingResult bindingResult)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取所有元素校验的错误结果</span></span><br><span class="line">        bindingResult.getFieldErrors().forEach(item-&gt;&#123;</span><br><span class="line">            <span class="comment">//获取到错误信息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> item.getDefaultMessage();</span><br><span class="line">            <span class="comment">//获取错误的属性的名字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> item.getField();</span><br><span class="line">            map.put(field,message);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> Result.error().code(<span class="number">400</span>).message(<span class="string">&quot;提交的数据不合法&quot;</span>).data(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pmsBrandService.save(entity)?Result.ok():Result.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想要<strong>自定义数据校验的规则，可以使用@Pattern注解，其中的regexp属性支持正则表达式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(value = &quot;检索首字母&quot;)</span></span><br><span class="line"><span class="meta">@NotEmpty</span></span><br><span class="line"><span class="meta">@Pattern(regexp = &quot;/^[a-zA-Z]$/&quot;,message = &quot;检索首字母必须是一个字母&quot;)</span><span class="comment">//自定义的数据校验，可以写正则表达式</span></span><br><span class="line"><span class="keyword">private</span> String firstLetter;</span><br></pre></td></tr></table></figure>
</li>
<li><p>依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hibernate-validator.version</span>&gt;</span>6.0.16.Final<span class="tag">&lt;/<span class="name">hibernate-validator.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--JSR303规范的数据校验实现--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate-validator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="分组数据校验"><a href="#分组数据校验" class="headerlink" title="分组数据校验"></a>分组数据校验</h3><ul>
<li><p>适用于多场景下的复杂校验</p>
</li>
<li><p>上面的校验方式有点问题，那就是<strong>如果我们想要在不同的业务场景下用不同的校验规则，那怎么办呢？</strong>就比如说在我save数据的时候我想要上面那套校验规则，但是现在我想设置一套update数据的校验规则，那该怎么办呢？基于这种情况，我们可以使用分组的数据校验。</p>
</li>
<li><p>首先我们<strong>创建一些空接口来标识不同的场景，也就是表示不同的分组</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.valid;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 19:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AddGroup</span> &#123;<span class="comment">//校验数据时的对应增加数据的情况的分组，只是一个标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.valid;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 19:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UpdateGroup</span> &#123;<span class="comment">//校验数据时的对应更新数据的情况的分组，只是一个标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后我们<strong>根据需要给实体类属性上的数据校验注解的groups属性赋值，表示这个数据校验注解在什么分组下生效</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiModelProperty(value = &quot;品牌id&quot;)</span></span><br><span class="line"><span class="meta">@TableId(value = &quot;brand_id&quot;, type = IdType.ASSIGN_ID)</span></span><br><span class="line"><span class="meta">@NotNull(message = &quot;修改必须指定品牌id&quot;,groups = UpdateGroup.class)</span></span><br><span class="line"><span class="meta">@Null(message = &quot;新增不能指定品牌id&quot;,groups = AddGroup.class)</span></span><br><span class="line"><span class="keyword">private</span> String brandId;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后我们<strong>在controller的参数中使用<code>@Validated(&#123;分组接口1.class,...&#125;)</code>注解来表示对被修饰的数据是以什么分组来进行校验，只有对应分组的数据校验注解会在这次数据校验中生效</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@Validated(&#123;AddGroup.class&#125;)</span> <span class="meta">@RequestBody</span> PmsBrand entity)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pmsBrandService.save(entity)?Result.ok():Result.error();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果属性上的<strong>数据校验注解没有指定groups，那么在参数中指定以某个分组进行数据校验的时候，没有指定groups的数据校验注解就无效</strong>。</p>
</li>
</ul>
<h3 id="自定义数据校验"><a href="#自定义数据校验" class="headerlink" title="自定义数据校验"></a>自定义数据校验</h3><ul>
<li><p>有时提供的数据校验注解无法很好的完成任务，这个时候我们就需要自定义数据校验逻辑来满足我们的需求。</p>
</li>
<li><p>首先我们需要<strong>编写一个自定义的校验注解，包括自定义的错误信息配置文件</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.valid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.TYPE_USE;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 20:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span><span class="comment">//与生成java文档相关，被这个元注解修饰的注解可以被很好地显示在文档中</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123; &#125;)</span><span class="comment">//该校验注解使用哪些校验器进行校验，可以绑定多个校验器以适配不同的场景</span></span><br><span class="line"><span class="meta">@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span><span class="comment">//该注解可以标识在哪些位置</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span><span class="comment">//让该注解在运行时能被获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListValue &#123;<span class="comment">//用来校验数据是否是指定的数据集中的数据</span></span><br><span class="line">    <span class="comment">//注解的属性就是在写注解的时候可以在小括号中指定的那些属性</span></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;com.konjacer.mallisland.common.valid.ListValue.message&#125;&quot;</span>;<span class="comment">//错误信息去哪取，默认是从classpath下的ValidationMessages.properties配置文件中取，我们可以自己写一个这样的配置文件放在classpath下，让它从我们自己的配置文件中取对应的值</span></span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//分组数据校验功能，若指定了分组，则该注解只对指定分组的数据校验生效</span></span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//和负载相关</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] vals() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//指定校验数据可以是哪些数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ValidationMessages.properties</span></span><br><span class="line"><span class="attr">com.konjacer.mallisland.common.valid.ListValue.message</span>=<span class="string">必须提交指定的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后我们需要<strong>编写一个自定义的校验器</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.valid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidator;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintValidatorContext;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 20:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListValueConstraintValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;ListValue,Integer&gt; &#123;<span class="comment">//实现接口的第一个类型参数是用在哪个注解上，第二个是处理什么类型的数据</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//用来判断数据在不在给定的数据中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ListValue constraintAnnotation)</span> &#123;<span class="comment">//初始化方法</span></span><br><span class="line">        <span class="comment">//ConstraintValidator.super.initialize(constraintAnnotation);</span></span><br><span class="line">        <span class="type">int</span>[] vals = constraintAnnotation.vals();<span class="comment">//获取在使用注解时传入的数据，是从ListValue注解中拿到的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> val : vals)&#123;</span><br><span class="line">            set.add(val);<span class="comment">//把给定的数据给set</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 需要校验的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context context in which the constraint is evaluated</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否校验成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(Integer value, ConstraintValidatorContext context)</span> &#123;<span class="comment">//判断是否校验成功</span></span><br><span class="line">        <span class="keyword">return</span> set.contains(value);<span class="comment">//判断被修饰的属性的值在不在给定的数据中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后我们应该<strong>关联自定义的校验器和自定义的校验注解</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.valid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.Constraint;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Payload;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.TYPE_USE;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 20:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span><span class="comment">//与生成java文档相关，被这个元注解修饰的注解可以被很好地显示在文档中</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123;ListValueConstraintValidator.class&#125;)</span><span class="comment">//该校验注解使用哪些校验器进行校验，可以绑定多个校验器以适配不同的场景</span></span><br><span class="line"><span class="meta">@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span><span class="comment">//该注解可以标识在哪些位置</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span><span class="comment">//让该注解在运行时能被获取</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ListValue &#123;<span class="comment">//用来校验数据是否是指定的数据集中的数据</span></span><br><span class="line">    <span class="comment">//注解的属性就是在写注解的时候可以在小括号中指定的那些属性</span></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;com.konjacer.mallisland.common.valid.ListValue.message&#125;&quot;</span>;<span class="comment">//错误信息去哪取，默认是从classpath下的ValidationMessages.properties配置文件中取，我们可以自己写一个这样的配置文件放在classpath下，让它从我们自己的配置文件中取对应的值</span></span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//分组数据校验功能，若指定了分组，则该注解只对指定分组的数据校验生效</span></span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//和负载相关</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] vals() <span class="keyword">default</span> &#123; &#125;;<span class="comment">//指定校验数据可以是哪些数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="NotBlank、-NotNull、-NotEmpty、-NonNull四者之间的区别"><a href="#NotBlank、-NotNull、-NotEmpty、-NonNull四者之间的区别" class="headerlink" title="@NotBlank、@NotNull、@NotEmpty、@NonNull四者之间的区别"></a>@NotBlank、@NotNull、@NotEmpty、@NonNull四者之间的区别</h3><p>1.@NotNull：<strong>一般用在基本类型上</strong>，不能为null，但可以为空字符串</p>
<p>2.@NotEmpty：<strong>一般用在集合类上</strong>，不能为null，并且长度必须大于0</p>
<p>3.@NotBlank：<strong>只能作用在String上</strong>，不能为null，而且调用trim()后（去掉头尾空格），长度必须大于0</p>
<p>4.@NonNull：<strong>在方法或构造函数的参数上使用，</strong>生成一个空值检查语句</p>
<h3 id="Validated注解和-Valid注解的区别"><a href="#Validated注解和-Valid注解的区别" class="headerlink" title="@Validated注解和@Valid注解的区别"></a>@Validated注解和@Valid注解的区别</h3><h2 id="项目中的系统状态码使用规范"><a href="#项目中的系统状态码使用规范" class="headerlink" title="项目中的系统状态码使用规范"></a>项目中的系统状态码使用规范</h2><ul>
<li>状态码应该是一个<strong>5位的数字</strong></li>
<li>状态码的<strong>前两位表示业务场景或者对应的模块，最后三位表示状态类型</strong>，比如：01200可以定义为向01场景的请求成功。</li>
<li>应该<strong>将状态码定义为枚举类型</strong>，<strong>在封装统一返回类型的对象时，不要使用数字、字符串等的字面量，应该使用状态码枚举类中定义过的对象</strong>。</li>
</ul>
<h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><ul>
<li><p>让各个方法来处理异常未免有点太过于繁琐，所以可以设置一个异常处理中心，<strong>所有的异常均由这个异常处理中心进行处理</strong>，实际上也是一个解耦的思想，将异常处理和具体业务方法解耦，在这个异常处理中心中可以<strong>写方法和具体的异常进行绑定，这样每当对应的异常被抛出，异常中心对应的方法就会将对应的异常处理掉</strong>。</p>
</li>
<li><p>除了设置相对精确的异常和方法的映射外，<strong>对于没有方法与之对应的异常，我们应该写一个方法对他们进行兜底处理</strong>，如果没有匹配到任何一个异常处理方法，那就使用兜底的方法。</p>
</li>
<li><p>结合上面写的数据校验的处理，我们认为<strong>将数据校验的处理放到controller中是非常繁琐的，所以我们可以考虑将其迁移到异常处理中心中做统一的处理</strong>，<strong>由于数据校验失败的时候会抛异常，所以我们只要针对对应的异常绑定对应的处理方法就行了</strong>，这样我们在controller中就可以只关注于处理业务请求，而无需分心在处理数据校验失败的情况了。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.konjacer.mallisland.commonutils.Result;</span><br><span class="line"><span class="keyword">import</span> com.konjacer.mallisland.commonutils.ResultCode;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindingResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ValidationException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-04 17:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestControllerAdvice(basePackages = &quot;com.konjacer.mallisland.product.controller&quot;)</span><span class="comment">//注册为异常处理中心并且返回的数据转换为json，参数配置的是异常处理中心生效范围</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallislandExceptionHandler</span> &#123;<span class="comment">//统一处理所有的异常</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span><span class="comment">//指定处理什么异常</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">VaildExceptionHandler</span><span class="params">(MethodArgumentNotValidException exception)</span>&#123;<span class="comment">//指定的异常被抛出时这个方法就会处理它</span></span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> exception.getBindingResult();<span class="comment">//获取参数校验结果</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//获取所有元素校验的错误结果</span></span><br><span class="line">        bindingResult.getFieldErrors().forEach(item-&gt;&#123;</span><br><span class="line">            <span class="comment">//获取到错误信息</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> item.getDefaultMessage();</span><br><span class="line">            <span class="comment">//获取错误的属性的名字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> item.getField();</span><br><span class="line">            map.put(field,message);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> Result.error()</span><br><span class="line">                .code(ResultCode.VALID_ERROR.getCode())</span><br><span class="line">                .message(ResultCode.VALID_ERROR.getMessage())</span><br><span class="line">                .data(<span class="string">&quot;data&quot;</span>,map);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Throwable.class)</span><span class="comment">//如过没有找到对应的异常处理方法就兜底处理</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">ExceptionHandler</span><span class="params">(Throwable throwable)</span>&#123;</span><br><span class="line">        log.error(<span class="string">&quot;错误：&quot;</span>,throwable);<span class="comment">//日志输出具体的异常信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.error()</span><br><span class="line">                .code(ResultCode.UNKNOW_ERROR.getCode())</span><br><span class="line">                .message(ResultCode.UNKNOW_ERROR.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="配置实体类字段自动填充后没有效果"><a href="#配置实体类字段自动填充后没有效果" class="headerlink" title="配置实体类字段自动填充后没有效果"></a>配置实体类字段自动填充后没有效果</h2><ul>
<li><p>自动填充的相关注解有：**<code>@TableField(fill = FieldFill.INSERT)</code>、<code>@TableField(fill = FieldFill.UPDATE)</code>、<code>@TableField(fill = FieldFill.INSERT_UPDATE)</code>、<code>@TableField(fill = FieldFill.DEFAULT)</code><strong>，他们分别代表：</strong>插入时填充、更新时填充、插入和更新时填充、默认不填充**。</p>
</li>
<li><p>除了写注解之外，还需要进行配置，<strong>需要新建一个实现MetaObjectHandler接口的类，然后在其中配置自动填充的规则，并将该类注册到IOC容器中</strong>，然后自动填充的注解才能生效。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.konjacer.mallisland.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2023-01-03 15:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;<span class="comment">//配置被插入时自动填充的注解修饰的属性自动填充的值</span></span><br><span class="line">        <span class="comment">//用属性名称而不是字段名称</span></span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;gmtCreate&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;gmtModified&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;isDeleted&quot;</span>,<span class="number">0</span>,metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;<span class="comment">//配置被更新时自动填充的注解修饰的属性自动填充的值</span></span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;gmtModified&quot;</span>,<span class="keyword">new</span> <span class="title class_">Date</span>(),metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2023-x2F-1-x2F-5"><a href="#2023-x2F-1-x2F-5" class="headerlink" title="2023&#x2F;1&#x2F;5"></a>2023&#x2F;1&#x2F;5</h1><h2 id="SPU和SKU"><a href="#SPU和SKU" class="headerlink" title="SPU和SKU"></a>SPU和SKU</h2><h3 id="SPU（Standard-Product-Unit-标准化产品单元）"><a href="#SPU（Standard-Product-Unit-标准化产品单元）" class="headerlink" title="SPU（Standard Product Unit 标准化产品单元）"></a>SPU（Standard Product Unit 标准化产品单元）</h3><ul>
<li>是商品信息聚合的最小单位，是一组可复用、易于检索的标准化信息的集合，该集合描述了一个产品的特性。</li>
<li>比如红米Note9 pro 1亿像素摄像头 钛合金外壳 产自于中国…这些信息就是SPU，是一个产品的<strong>基本属性（规格参数）</strong>，因为任何一个红米Note9 pro手机都拥有以上特性，我们用这些信息聚合成了一个产品。</li>
<li>可以通过SPU的属性值来对具体产品进行搜索。</li>
</ul>
<h3 id="SKU（Stock-Keeping-Unit-最小库存单元）"><a href="#SKU（Stock-Keeping-Unit-最小库存单元）" class="headerlink" title="SKU（Stock Keeping Unit 最小库存单元）"></a>SKU（Stock Keeping Unit 最小库存单元）</h3><ul>
<li>上面SPU还有一些没有提到的特性，比如手机的颜色、内存等，这些属性都不是产品固定的，而是可以选择的，也叫<strong>销售属性</strong>，比如我可以选择内存是8g，颜色是蓝色，这些属性一旦被具体确定下来，那么这个具体的产品就是一个SKU，可以直接通过这些属性的值定位到库存中的具体存货。</li>
</ul>
<h2 id="JsonInclude注解"><a href="#JsonInclude注解" class="headerlink" title="@JsonInclude注解"></a>@JsonInclude注解</h2><ul>
<li>可以用在实体类的属性上，来标识这个实体类属性在什么条件下才可以被转换为json数据，比如**<code>@JsonInclude(JsonInclude.Include.NON_EMPTY)</code><strong>就标识</strong>当被其修饰的属性不为空的时候，那个属性才会被转换成json数据的一部分，如果为空，那么最后返回的json数据中就不包含这个字段**。</li>
<li>还有其他参数，可以看源码。</li>
</ul>
<h1 id="2023-x2F-1-x2F-6"><a href="#2023-x2F-1-x2F-6" class="headerlink" title="2023&#x2F;1&#x2F;6"></a>2023&#x2F;1&#x2F;6</h1><h2 id="EnableTransactionManagement"><a href="#EnableTransactionManagement" class="headerlink" title="@EnableTransactionManagement"></a>@EnableTransactionManagement</h2><ul>
<li>可以在配置类中写上这个注解，表示<strong>开启事务功能</strong>，<strong>之后可以通过在访问数据库的方法上添加<code>@Transactional</code>注解来标识该方法是事务方法，可以对里面操作数据库的部分新建一个事务来进行处理</strong>。</li>
<li>如果只添加@Transactional注解无法生效，需要用@EnableTransactionManagement注解开启事务功能才能生效。</li>
<li>大部分功能都是需要先用注解开启，然后使用相应注解才生效的。</li>
</ul>
<h2 id="数据库表的冗余存储"><a href="#数据库表的冗余存储" class="headerlink" title="数据库表的冗余存储"></a>数据库表的冗余存储</h2><ul>
<li>在进行数据存储的时候，<strong>为了避免多次单表查询带来的性能问题，我们可以将一些常用字段冗余存储到某一张表中，但是这样做必须保证增删改的时候，要保证数据的一致性</strong>，不能表里的数据都删了，冗余字段还有那个被删的数据，这样是不对的，所以对关联表进行增删改的时候要注意将数据同步到别的表的冗余字段中。</li>
</ul>
<h2 id="不要使用多表联查"><a href="#不要使用多表联查" class="headerlink" title="不要使用多表联查"></a>不要使用多表联查</h2><ul>
<li>使用笛卡尔积的多表联查对于效率来说是毁灭性打击。</li>
</ul>
<h2 id="target目录下没有mapper的xml文件"><a href="#target目录下没有mapper的xml文件" class="headerlink" title="target目录下没有mapper的xml文件"></a>target目录下没有mapper的xml文件</h2><ul>
<li><p>这个问题我找了好几个小时才解决，解决的过程中我对服务的运行又有了新的认识。</p>
</li>
<li><p>问题出现在我在启动服务之后测试自己写的sql语句，在调用mapper的时候它报错，大意就是没有找到和mapper绑定的xml文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.ibatis.binding.BindingException: Invalid bound statement (not found) ......</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后因为项目运行的时候，环境实际上是和开发环境的目录不一样嘛，<strong>服务运行的时候是用的target输出目录下的目录结构</strong>，然后我就去target下找，找到mapper目录后一看，xml文件一个都没导入进来，那运行的时候找不到xml文件也就不难理解了。</p>
</li>
<li><p>我这开发时目录结构好像和主流的方案不太一样，我这个mapper的xml文件没有放到resources目录下，我这用代码生成器生成的，xml文件全在mapper目录下放着，如果要是xml文件在resouces目录下，根据maven的默认build策略，这些xml文件应该会被build在运行时环境的classes目录下（我也不确定，之后验证一下回来改）。但是我这xml文件在java路径下放着，<strong>根据maven的默认build策略，maven只会把java路径下的所有java文件给build，别的文件不会被build，所以xml文件全没被build</strong>。</p>
</li>
<li><p>那么怎么样才能让xml文件被build呢？主要是<strong>需要在服务对应的pom文件中的build标签中写明在build的时候需要额外添加一些什么文件，maven在build项目的时候默认只会把java目录下的java文件给build，所以我们应该显式告诉它java目录下的xml文件也需要被build</strong>，配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 如果不配置resource，mapper.xml文件不会被加载到target，就会报找不到的错误。 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置打包规则，告诉maven在java目录下还要额外build什么文件 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果有了上面的配置，原本默认的将resource中的文件打包操作就会被覆盖掉，所以需要手动指定--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--打包规则，打包时将resource文件夹下的配置文件排除，注意只有打包的时候使用，平时要注释掉--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- &lt;excludes&gt;--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--      &lt;exclude&gt;**/*.properties&lt;/exclude&gt;--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--      &lt;exclude&gt;**/*.yml&lt;/exclude&gt;--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!--      &lt;exclude&gt;**/*.yaml&lt;/exclude&gt;--&gt;</span></span><br><span class="line">             <span class="comment">&lt;!-- &lt;/excludes&gt;--&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这样xml文件就被build到classes文件中了，位置和开发时的位置相同，但是，重新启动服务之后，测试接口，发现还是有问题，还是报同样的错误，所以我推断<strong>可能是mybatis-plus找xml文件位置的默认配置的问题，mp默认配置找xml文件的目录是<code>classpath*:/mapper/**/*.xml</code>，这意味着它会找所有包的classes目录下的mapper目录下的所有子目录下的xml文件，但是我这些xml文件不在这个路径下，所以应该将其改成<code>classpath:/**/mapper/**/*.xml</code>，因为mapper目录不直接在classes根目录下，所以classes目录和mapper目录之间应该用<code>**</code>来表示</strong>，改完之后就能正常运行了：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置mybatis-plus的mapper的xml文件的位置，默认是classpath*:/mapper/**/*.xml，classpath后面的*代表除了自己的classpath，引入的jar包的classpath也会被检索</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/**/mapper/**/*.xml</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="java-Object的划分"><a href="#java-Object的划分" class="headerlink" title="java Object的划分"></a>java Object的划分</h2><h3 id="PO（persistent-object）持久对象"><a href="#PO（persistent-object）持久对象" class="headerlink" title="PO（persistent object）持久对象"></a>PO（persistent object）持久对象</h3><ul>
<li>PO就是<strong>对应数据库中某个表中的一条记录，多个记录可以用PO的集合</strong>，PO中应该不包含任何对数据库的操作。</li>
</ul>
<h3 id="DO（Domain-Object）领域对象"><a href="#DO（Domain-Object）领域对象" class="headerlink" title="DO（Domain Object）领域对象"></a>DO（Domain Object）领域对象</h3><ul>
<li>就是<strong>从现实世界中抽象出来的有形或者无形的业务实体</strong>。</li>
</ul>
<h3 id="TO（Transfer-Object）数据传输对象"><a href="#TO（Transfer-Object）数据传输对象" class="headerlink" title="TO（Transfer Object）数据传输对象"></a>TO（Transfer Object）数据传输对象</h3><ul>
<li><strong>不同的应用程序之间传输的对象</strong></li>
</ul>
<h3 id="DTO（Data-Transfer-Object）数据传输对象"><a href="#DTO（Data-Transfer-Object）数据传输对象" class="headerlink" title="DTO（Data Transfer Object）数据传输对象"></a>DTO（Data Transfer Object）数据传输对象</h3><ul>
<li>这个概念来源于J2EE的设计模式，原来的目的是为了EJB 的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，<strong>泛指用于展示层与服务层之间的数据传输的对象</strong>。</li>
</ul>
<h3 id="VO（Value-Object-x2F-View-Object）值对象-x2F-视图对象"><a href="#VO（Value-Object-x2F-View-Object）值对象-x2F-视图对象" class="headerlink" title="VO（Value  Object&#x2F;View Object）值对象&#x2F;视图对象"></a>VO（Value  Object&#x2F;View Object）值对象&#x2F;视图对象</h3><ul>
<li>通常用于业务层之间的数据传递，和 PO一样也是仅仅包含数据而已。但应是<strong>抽象出的业务对象，可以和表对应，也可以不</strong>，这根据业务的需要。用new关键字创建，由GC回收的。</li>
<li>或者叫View Object视图对象，vo的结构由具体的业务视图决定。</li>
<li>接收页面传递来的数据，封装成对象；将业务处理完成的对象，封装成页面要用的数据，都是VO。</li>
</ul>
<h3 id="BO（business-object）业务对象"><a href="#BO（business-object）业务对象" class="headerlink" title="BO（business object）业务对象"></a>BO（business object）业务对象</h3><ul>
<li>从业务模型的角度看，见 UML元件领域模型中的领域对象。封装业务逻辑的java对象，通过调用DAO方法，结合PO,VO进行业务操作。business object:业务对象，主要作用是<strong>把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象</strong>。比如一个简历，有教育经历、工作经历、社会关系等等。我们可以把教育经历对应一个 PO，工作经历对应一个PO，社会关系对应一个 PO。建立一个对应简历的 BO对象处理简历，每个BO包含这些PO。这样处理业务逻辑时，我们就可以针对BO去处理。</li>
</ul>
<h3 id="POJO（plain-ordinary-java-object）简单无规则java对象"><a href="#POJO（plain-ordinary-java-object）简单无规则java对象" class="headerlink" title="POJO（plain ordinary java object）简单无规则java对象"></a>POJO（plain ordinary java object）简单无规则java对象</h3><ul>
<li>传统意义的 java对象。就是说在一些Object&#x2F;Relation Mapping工具中，能够做到维护数据库表记录的 PO完全是一个符合Java Bean规范的纯 Java对象，没有增加别的属性和方法。我的理解就是最基本的 java Bean ，只有属性字段及setter和 getter方法。</li>
<li>POJO是 DO&#x2F;DTO&#x2F;BO&#x2F;VO 的统称。</li>
</ul>
<h3 id="DAO（data-access-object）数据访问对象"><a href="#DAO（data-access-object）数据访问对象" class="headerlink" title="DAO（data access object）数据访问对象"></a>DAO（data access object）数据访问对象</h3><ul>
<li>是一个 sun 的一个标准 J2EE设计模式，这个模式中有个接口就是DAO，它负责持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和PO 结合使用，DAO中包含了各种数据库的操作方法。通过它的方法，结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO，提供数据库的CRUD 操作。</li>
</ul>
<h2 id="复制VO的数据到Entity"><a href="#复制VO的数据到Entity" class="headerlink" title="复制VO的数据到Entity"></a>复制VO的数据到Entity</h2><ul>
<li>可以<strong>使用spring包中的BeanUtils工具类的copyProperties方法，可以将VO中的元素赋值给Entity，不过要注意，只有具有相同名称的属性才会被赋值，名字不相同或者不存在的属性都不会被赋值</strong>。</li>
</ul>
<h1 id="2023-x2F-1-x2F-7"><a href="#2023-x2F-1-x2F-7" class="headerlink" title="2023&#x2F;1&#x2F;7"></a>2023&#x2F;1&#x2F;7</h1><h2 id="使用符合场景的wrapper"><a href="#使用符合场景的wrapper" class="headerlink" title="使用符合场景的wrapper"></a>使用符合场景的wrapper</h2><ul>
<li>查询的时候用QueryWrapper，更新的时候用UpdateWrapper。</li>
</ul>
<h2 id="使用-RequestParam接收query参数"><a href="#使用-RequestParam接收query参数" class="headerlink" title="使用@RequestParam接收query参数"></a>使用@RequestParam接收query参数</h2><ul>
<li><p>可以指定或不指定value参数来接收单个对应的query参数，如果指定value，则将和value名称相同的query参数的值赋值给注解修饰的属性，如果不指定value，则将和被修饰的变量名称相同的query参数的值赋值给被修饰的属性。也可以指定require的值，如果为true说明这个属性不能接收不到参数，如果为false，说明这个属性允许接收不到参数，默认为true：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestParam(value = &quot;page&quot;,required = false)</span> Long current</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以直接修饰一个Map&lt;String,String&gt;类型的属性params，query参数会全部放到那里面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestParam</span> Map&lt;String,String&gt; params</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Mapper中的selectCount方法"><a href="#Mapper中的selectCount方法" class="headerlink" title="Mapper中的selectCount方法"></a>Mapper中的selectCount方法</h2><ul>
<li>根据wrapper中的条件，统计符合条件的记录数量。</li>
</ul>
<h2 id="批量删除的动态sql"><a href="#批量删除的动态sql" class="headerlink" title="批量删除的动态sql"></a>批量删除的动态sql</h2><ul>
<li><p>可以用动态sql，遍历所有想要删除的数据的条件拼接在where后面，找到所有符合条件的数据一起删除：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;deleteBatchRelation&quot;</span>&gt;</span></span><br><span class="line">    UPDATE `pms_attr_attrgroup_relation` SET is_deleted=1 WHERE</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;entities&quot;</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">separator</span>=<span class="string">&quot; OR &quot;</span>&gt;</span></span><br><span class="line">        (attr_id=#&#123;item.attrId&#125; AND attr_group_id=#&#123;item.attrGroupId&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="每一层结构做了什么事"><a href="#每一层结构做了什么事" class="headerlink" title="每一层结构做了什么事"></a>每一层结构做了什么事</h2><ul>
<li>Controller用来处理请求，接收和校验数据</li>
<li>Service接收Controller传来的数据，进行业务逻辑的处理</li>
<li>Controller接收Service处理完的数据，封装与页面进行交互的VO</li>
</ul>
<h1 id="2023-x2F-1-x2F-8"><a href="#2023-x2F-1-x2F-8" class="headerlink" title="2023&#x2F;1&#x2F;8"></a>2023&#x2F;1&#x2F;8</h1><h2 id="基于OpenFeign的远程调用"><a href="#基于OpenFeign的远程调用" class="headerlink" title="基于OpenFeign的远程调用"></a>基于OpenFeign的远程调用</h2><ul>
<li><p>首先要使用Feign的远程调用功能要先<strong>在配置类中使用注解<code>@EnableFeignClients</code>开启这个功能，并指定远程调用接口的所在包目录，这一个注解的本质实际上是把指定位置的所有被@FeignClient注解修饰的bean注册到ioc容器中</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.konjacer.mallisland.product.feign&quot;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后<strong>在对应的目录下创建接口，用对应的注解<code>@FeignClient</code>修饰这个接口，注解中的参数是被远程调用的服务在服务注册中心的服务名</strong>，这个远程调用可以过网关也可以不过网关，注意修改下面的uri就行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;mallisland-coupon&quot;)</span><span class="comment">//这是个声明式远程调用客户端，里面的方法远程调用了别的模块的方法，注解里面要指明想要调用的服务在服务注册中心里的名称</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后<strong>在新建的接口中写远程调用的方法，用注解告知方法远程调用的路径，方法签名尽量和要调用的方法的签名相同</strong>，不过理论上<strong>在参数上用了<code>@RequestBody</code>注解的话，TO就会被转为json放到请求体中然后发送给远程服务，别的注解的效果类推</strong>，所以如果能保证接收方能接收发送方的json数据，那就没啥问题，不过方法签名还是尽量相同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/coupon/sms-coupon/memberGetCoupons&quot;)</span><span class="comment">//地址要写全，就是通过这个地址来进行远程调用</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">memberGetCoupons</span><span class="params">(<span class="meta">@RequestBody</span> SpuBoundTo spuBoundTo)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后就可以<strong>在想用的地方注入对应的远程调用接口，然后通过注入的bean调用相应的方法来实现远程调用，不过一定要保证被调用的方法在服务注册中心中能找到</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">CouponFeignService couponFeignService;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SpuBoundTo</span> <span class="variable">spuBoundTo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpuBoundTo</span>();</span><br><span class="line">    couponFeignService.memberGetCoupons(spuBoundTo);</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="在IDEA中同时启动多个服务"><a href="#在IDEA中同时启动多个服务" class="headerlink" title="在IDEA中同时启动多个服务"></a>在IDEA中同时启动多个服务</h2><ul>
<li><p>首先点击Edit Configurations：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230108173107813.png" alt="image-20230108173107813"></p>
</li>
<li><p>然后新建一个Compound：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230108173201032.png" alt="image-20230108173201032"></p>
</li>
<li><p>在新建的Compound中添加想要一起启动的服务，并且可以对他们的启动做自定义的配置：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230108173439649.png" alt="image-20230108173439649"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230108173502497.png" alt="image-20230108173502497"></p>
</li>
<li><p>之后启动对应的Compound就能同时启动多个服务了：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230108173552108.png" alt="image-20230108173552108"></p>
</li>
</ul>
<h2 id="配置json数据中日期数据的格式"><a href="#配置json数据中日期数据的格式" class="headerlink" title="配置json数据中日期数据的格式"></a>配置json数据中日期数据的格式</h2><ul>
<li><p>可以在springboot的配置文件中做以下配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#配置json数据中日期数据的格式</span></span><br><span class="line">  <span class="attr">jackson:</span></span><br><span class="line">    <span class="attr">date-format:</span> <span class="string">yyyy-MM-dd</span> <span class="string">HH:mm:ss</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="配置日志等级"><a href="#配置日志等级" class="headerlink" title="配置日志等级"></a>配置日志等级</h2><ul>
<li><p>可以在springboot的配置文件中做以下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#设置指定包下的日志级别</span><br><span class="line">logging:</span><br><span class="line">  level:</span><br><span class="line">    com.konjacer: info</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2023-x2F-1-x2F-10"><a href="#2023-x2F-1-x2F-10" class="headerlink" title="2023&#x2F;1&#x2F;10"></a>2023&#x2F;1&#x2F;10</h1><h2 id="linux中在命令上下载网络内容"><a href="#linux中在命令上下载网络内容" class="headerlink" title="linux中在命令上下载网络内容"></a>linux中在命令上下载网络内容</h2><ul>
<li>可以使用wget工具来进行下载，但是在使用wget之前需要使用**<code>sudo yum install wget</code>**安装wget</li>
<li>安装完之后通过**<code>wget &lt;url&gt;</code>**命令来从指定的url中下载文件</li>
</ul>
<h2 id="linux修改目录的权限"><a href="#linux修改目录的权限" class="headerlink" title="linux修改目录的权限"></a>linux修改目录的权限</h2><ul>
<li>可以使用**<code>sudo chmod -R 777 目录路径</code><strong>来将一个目录以及其中的所有子目录的文件改成最高权限777，</strong>-R是recursion递归的意思**，意思就是会递归地设置权限。</li>
</ul>
<h2 id="linux解压文件"><a href="#linux解压文件" class="headerlink" title="linux解压文件"></a>linux解压文件</h2><ul>
<li>可以使用unzip工具，没有可以用yum命令**<code>sudo yum install unzip</code>**下载一个。</li>
<li>通过**<code>unzip -d 目标目录 文件名</code>**命令来将指定文件解压到指定目录下。</li>
</ul>
<h1 id="2023-x2F-1-x2F-11"><a href="#2023-x2F-1-x2F-11" class="headerlink" title="2023&#x2F;1&#x2F;11"></a>2023&#x2F;1&#x2F;11</h1><h2 id="为什么有些包导入后里面的某些包和预期的不太一样"><a href="#为什么有些包导入后里面的某些包和预期的不太一样" class="headerlink" title="为什么有些包导入后里面的某些包和预期的不太一样"></a>为什么有些包导入后里面的某些包和预期的不太一样</h2><ul>
<li><p>可能是springboot项目的pom文件中对这些包有版本管理，导致这个版本传递到了后来的那些包中，要想修改，只需要<strong>先找到springboot的pom文件</strong>：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230111164504024.png" alt="image-20230111164504024"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230111164523772.png" alt="image-20230111164523772"></p>
</li>
<li><p>在springboot的pom文件中找到对应的那个包后<strong>将那个包的版本控制变量在当前项目的pom文件中进行重写即可</strong>。</p>
</li>
</ul>
<h2 id="ES中的nested类型"><a href="#ES中的nested类型" class="headerlink" title="ES中的nested类型"></a>ES中的nested类型</h2><ul>
<li>官方释义：这个nested类型是object一种数据类型，<strong>允许对象数组以相互独立的方式进行索引</strong></li>
<li>在设置一个索引（index）的映射（mapping）的时候，如果不将type设置成nested，那么这个属性在存放有结构的数据比如某种对象的时候，es在底层就会对这个对象进行扁平化处理，对象中相同的属性值会被一同放入到一个数组中进行维护，而查的时候也是基于那个维护的数组，这样做会产生很多问题。</li>
<li>所以为了防止有结构的属性被扁平化处理，在做映射的时候应该把存放非基本数据类型的数据的属性的type设置成nested。</li>
<li>在查询nested类型的数据的时候也不能和普通数据一样查询，要显示声明我要查的是nested类型的数据，详见官方文档。</li>
</ul>
<h2 id="ES的倒排索引"><a href="#ES的倒排索引" class="headerlink" title="ES的倒排索引"></a>ES的倒排索引</h2><ul>
<li>就是对一堆文本进行分词处理（把文本划分成词），然后记录每个分词在哪个文本中出现过，这样找的时候就能利用关键词来找到关键词出现过的文本了。（&#x2F;&#x2F;todo 至于分词怎么存。。。字典树？我暂时不清楚，之后清楚了再来改）</li>
</ul>
<h2 id="ES存储数据的结构"><a href="#ES存储数据的结构" class="headerlink" title="ES存储数据的结构"></a>ES存储数据的结构</h2><ul>
<li>最大的一层叫index也就是索引，再小一层叫type也就是类型（已经弃用，最好不要再用），再小一层叫doc也就是文档，每个文档就相当于mysql中的一个数据库中的一个表的一个记录，文档中还有各种各样的属性。</li>
</ul>
<h2 id="ES设置-x2F-修改索引的映射"><a href="#ES设置-x2F-修改索引的映射" class="headerlink" title="ES设置&#x2F;修改索引的映射"></a>ES设置&#x2F;修改索引的映射</h2><p>- </p>
<ul>
<li>索引的映射理论上来讲设置了之后是不能变的，所以如果想要修改索引的映射，方法就是重新创建一个索引，然后在新索引中设置想要的映射，然后做数据迁移，把之前索引的数据迁移到新索引中。</li>
</ul>
<h2 id="ES查询数据"><a href="#ES查询数据" class="headerlink" title="ES查询数据"></a>ES查询数据</h2><ul>
<li>通过DSL（结构化查询）语句来进行查询，es帮我们把功能都暴露成rest风格的接口了，所以如果我们想要查询ES中的数据，那么我们只需要写一个json格式的DSL来表明我们的需求，然后给ES服务发送相应的请求，那么ES就会回复给我们想要的数据。</li>
<li>具体DSL语句的写法可以参照官方文档。</li>
<li>一个复杂的DSL中可能同时存在：模糊匹配、过滤、排序、分页、高亮显示、聚合分析等要求，所以在学习的时候可以对准这几个部分来进行学习。</li>
</ul>
<h2 id="ES聚合分析"><a href="#ES聚合分析" class="headerlink" title="ES聚合分析"></a>ES聚合分析</h2><ul>
<li>对于聚合分析，实际上就是根据聚合条件来将查询到的数据进行逻辑分组，因为是逻辑分组，所以不同聚合之间肯定是可以有重复数据，聚合之中可以有子聚合，子聚合用的数据是父聚合的结果，要类比的话，就像mysql中的group by。</li>
</ul>
<h1 id="2023-x2F-1-x2F-12"><a href="#2023-x2F-1-x2F-12" class="headerlink" title="2023&#x2F;1&#x2F;12"></a>2023&#x2F;1&#x2F;12</h1><h2 id="统一返回类使用泛型处理的好处"><a href="#统一返回类使用泛型处理的好处" class="headerlink" title="统一返回类使用泛型处理的好处"></a>统一返回类使用泛型处理的好处</h2><ul>
<li>首先就是<strong>有更好的可读性</strong>，可以使开发人员一眼就能看出这个统一返回类中存放的是什么类型的数据。</li>
<li>再者就是<strong>方便数据的提取</strong>，如果要是统一返回类作为远程调用接口的返回值，那么我们拿到远程调用的结果后想要从统一返回类中将数据提取出来，如果不用泛型，那么为了提取其中的数据我们会进行一系列的显式类型转换操作，还有可能去判断类型的正确性，使用了泛型之后，这种的问题将不复存在，因为编译器自动帮你把这些活儿干了，如果我们将错误的数据放进去，编译都过不了，api的客户端拿到数据之后开箱即用，无需更多操作，提升了开发效率。</li>
</ul>
<h2 id="lambda表达式和stream流式编程中使用的外部变量必须为final"><a href="#lambda表达式和stream流式编程中使用的外部变量必须为final" class="headerlink" title="lambda表达式和stream流式编程中使用的外部变量必须为final"></a>lambda表达式和stream流式编程中使用的外部变量必须为final</h2><ul>
<li>经常会出现类似这样的错误：<code>Variable used in lambda expression should be final or effectively final</code>，这主要是因为在lambda表达式或者stream流式编程中使用了外部非final的变量，为什么会有这种规定呢？</li>
<li>这个具体原因我也不太清楚，不过大体上好像是为了保护数据的一致性而规定的。</li>
<li>所以以后在lambda表达式和stream流式编程中使用非final的外部变量的时候，要先在外面声明一个final的副本，然后在lambda表达式或stream流式编程中使用那个副本就可以了。</li>
</ul>
<h1 id="2023-x2F-1-x2F-13"><a href="#2023-x2F-1-x2F-13" class="headerlink" title="2023&#x2F;1&#x2F;13"></a>2023&#x2F;1&#x2F;13</h1><h2 id="SpringBoot整合ElasticSearch"><a href="#SpringBoot整合ElasticSearch" class="headerlink" title="SpringBoot整合ElasticSearch"></a>SpringBoot整合ElasticSearch</h2><ul>
<li><p>首先要引入依赖，依赖版本要和es的版本一致，如果出现写的版本一致，但是实际上引入的es版本不一致的情况，可以参照2023&#x2F;1&#x2F;11的”为什么有些包导入后里面的某些包和预期的不太一样“来在本地pom重写springboot的pom的properties中的对应包的version属性来解决：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">elasticsearch-rest-high-level-client.version</span>&gt;</span>7.4.2<span class="tag">&lt;/<span class="name">elasticsearch-rest-high-level-client.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--操作elasticsearch的java client--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;elasticsearch-rest-high-level-client.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后在配置类中进行相关的配置，主要是<strong>构造Bean交给Spring和构造一个通用的设置项</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallislandElasticSearchConfig</span> &#123;<span class="comment">//elasticsearch的配置类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestOptions COMMON_OPTIONS;<span class="comment">//elasticsearch通用的设置项</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        RequestOptions.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> RequestOptions.DEFAULT.toBuilder();<span class="comment">//使用默认规则</span></span><br><span class="line"><span class="comment">//        builder.addHeader(&quot;Authorization&quot;, &quot;Bearer &quot; + TOKEN);</span></span><br><span class="line"><span class="comment">//        builder.setHttpAsyncResponseConsumerFactory(</span></span><br><span class="line"><span class="comment">//                new HttpAsyncResponseConsumerFactory</span></span><br><span class="line"><span class="comment">//                        .HeapBufferedResponseConsumerFactory(30 * 1024 * 1024 * 1024));</span></span><br><span class="line">        COMMON_OPTIONS = builder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">esRestClient</span><span class="params">()</span>&#123;<span class="comment">//创建Bean交给Spring</span></span><br><span class="line">        <span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;101.42.35.83&quot;</span>,<span class="number">9200</span>,<span class="string">&quot;http&quot;</span>)<span class="comment">//es的地址</span></span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后注入Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RestHighLevelClient restHighLevelClient;<span class="comment">//用来操作es</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>以一个批量保存为例，展示基本用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">productStatusUp</span><span class="params">(List&lt;SkuEsModel&gt; skuEsModels)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//给es中建立索引product,建立好映射关系</span></span><br><span class="line">    <span class="comment">//给es中保存这些数据</span></span><br><span class="line">    <span class="type">BulkRequest</span> <span class="variable">bulkRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">    skuEsModels.forEach(model-&gt;&#123;</span><br><span class="line">        <span class="comment">//构造保存请求并加入bulk请求中</span></span><br><span class="line">        <span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(EsConstant.IndexName.PRODUCT.getName());</span><br><span class="line">        indexRequest.id(model.getSkuId());<span class="comment">//设置id</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> JSON.toJSONString(model);<span class="comment">//实体转json</span></span><br><span class="line">        indexRequest.source(source, XContentType.JSON);<span class="comment">//设置内容为json数据，记得设置内容类型（第二个参数）</span></span><br><span class="line">        bulkRequest.add(indexRequest);<span class="comment">//加入bulk批量操作中</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">BulkResponse</span> <span class="variable">bulkResponse</span> <span class="operator">=</span> restHighLevelClient.bulk(bulkRequest, MallislandElasticSearchConfig.COMMON_OPTIONS);<span class="comment">//bulk方法批量操作，记得第二个参数写配置在配置类中的通用设置</span></span><br><span class="line">    <span class="comment">//如果批量操作错误则处理错误</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> bulkResponse.hasFailures();<span class="comment">//是否有错误</span></span><br><span class="line">    List&lt;String&gt; collect = Arrays.stream(bulkResponse.getItems()).map(item-&gt; item.getId()).collect(Collectors.toList());</span><br><span class="line">    log.error(<span class="string">&quot;商品上架错误，上架错误的商品编号分别为：&#123;&#125;&quot;</span>,collect);</span><br><span class="line">    <span class="keyword">return</span> !b;<span class="comment">//取反返回更符合正常逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Feign的调用流程"><a href="#Feign的调用流程" class="headerlink" title="Feign的调用流程"></a>Feign的调用流程</h2><ol>
<li><p>构造请求数据，将对象转为json数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RequestTemplate</span> <span class="variable">template</span> <span class="operator">=</span> buildTemplateFromArgs.create(argv);</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送请求进行执行，执行成功后会解码响应数据:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">executeAndDecode(template);</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行请求会有重试机制，在执行之前会new一个重试器，通过重试器的重试策略来决定是否重试，伪代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">   	<span class="keyword">try</span>&#123;</span><br><span class="line">   		executeAndDecode(tempLate);</span><br><span class="line">       &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">   		<span class="keyword">try</span>&#123;</span><br><span class="line">               retryer.continueOrPropagate(e);</span><br><span class="line">           &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">               <span class="keyword">throw</span> ex;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">## 一个没有进行前后端分离的架构</span><br><span class="line"></span><br><span class="line">- 静态资源扔到nginx中，然后视图用模板引擎（模板引擎，这里特指用于Web开发的模板引擎，是**为了使用户界面与业务数据/内容分离而产生的**，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的文档。模板引擎的**基本机理就是替换/转换，将指定的标签转换为需要的业务数据，将指定的伪语句按照某种流程来变换输出**。）写好，**所有的静态资源去nginx中取**：</span><br><span class="line"></span><br><span class="line">  ![image-<span class="number">20230113193900265</span>](https:<span class="comment">//konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230113193900265.png)</span></span><br><span class="line"></span><br><span class="line">## 引入Thymeleaf模板引擎</span><br><span class="line"></span><br><span class="line">- 首先要引入依赖，版本最好和boot的版本一致：</span><br><span class="line"></span><br><span class="line">  ```xml</span><br><span class="line">  &lt;spring-boot-starter-thymeleaf.version&gt;<span class="number">2.3</span><span class="number">.4</span>.RELEASE&lt;/spring-boot-starter-thymeleaf.version&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!--thymeleaf模板引擎--&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;spring-boot-starter-thymeleaf.version&#125;&lt;/version&gt;</span><br><span class="line">  &lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>在配置文件中关闭thymeleaf的缓存以在开发阶段保证其可见性：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">thymeleaf:</span></span><br><span class="line">    <span class="comment">#关闭thymeleaf的缓存以在开发期间看到实时效果</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SpringMVC的自动配置类WebMvcAutoConfiguration中默认约定静态资源都放在classpath的static&#x2F;public&#x2F;resources&#x2F;templates下，可以直接被访问到。</p>
</li>
<li><p>thymeleaf默认约定当controller方法返回string的时候，视图解析器会进行拼串处理，会定位资源到prefix+返回值+suffix，默认的prefix是“classpath:&#x2F;templates&#x2F;”，默认的suffix是“.html”，页面资源默认从templates中取。</p>
</li>
<li><p>为了保证项目结构的清晰，我们也约定，页面文件都放在templates下，然后页面用到的静态资源放到static下。</p>
</li>
<li><p>springboot约定，在访问项目的时候，如果有，会默认先找index.html页面来进行显示。</p>
</li>
<li><p>在开发时如果想要不重启服务器而实时更新页面，可以引入dev-tools使用热部署功能，修改完thymeleaf的页面后直接ctrl+shift+f9重新编译页面即可，如果是其他比如对配置的修改，还是手动重启下吧！不过开发后端的时候不建议开dev-tools，因为频繁的自动重启会使得开发效率低下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2023-x2F-1-x2F-14"><a href="#2023-x2F-1-x2F-14" class="headerlink" title="2023&#x2F;1&#x2F;14"></a>2023&#x2F;1&#x2F;14</h1><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><ul>
<li><p><strong>正向代理服务器帮客户端去访问客户端想要访问的服务器，在收到结果之后再返回给客户端，也就是说正向代理服务器是在偏客户端这一边的</strong>。比如我想访问谷歌，但是我没办法直接访问到谷歌，所以我可以租一个正向代理服务器，每次我访问谷歌，我都会给那个正向代理服务器发送请求让那个正向代理服务器帮我去访问谷歌：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230114191838794.png" alt="image-20230114191838794"></p>
</li>
<li><p><strong>反向代理帮服务器接收客户端的请求，再把请求转发给对应的服务器，也就是反向代理服务器是在偏服务器这一边的</strong>。比如我要访问一个域名，这个域名可能是服务端的反向代理服务器的地址，是个公网ip，这样我就先访问到了服务端的反向代理服务器，然后反向代理服务器再帮我把我的请求转发给我真正想要访问的内网服务器，主打一个<strong>屏蔽内网服务器的信息和负载均衡地访问</strong>：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230114192302868.png" alt="image-20230114192302868"></p>
</li>
</ul>
<h2 id="nginx配置文件结构"><a href="#nginx配置文件结构" class="headerlink" title="nginx配置文件结构"></a>nginx配置文件结构</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230114200634788.png" alt="image-20230114200634788"></p>
<ul>
<li><p>查看nginx.conf文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到里面是没有server块的，这是因为其中使用到了include语句，server块在被include的文件中。</p>
</li>
<li><p>找到conf.d&#x2F;default.conf，也可以写别的扩展名为conf的文件，从上面的include语句中也能看出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  /var/log/nginx/log/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    proxy_pass   http://127.0.0.1;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">    #</span><br><span class="line">    #location ~ \.php$ &#123;</span><br><span class="line">    #    root           html;</span><br><span class="line">    #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    #    fastcgi_index  index.php;</span><br><span class="line">    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">    #    include        fastcgi_params;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">    # deny access to .htaccess files, if Apache&#x27;s document root</span><br><span class="line">    # concurs with nginx&#x27;s one</span><br><span class="line">    #</span><br><span class="line">    #location ~ /\.ht &#123;</span><br><span class="line">    #    deny  all;</span><br><span class="line">    #&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>server块中的server_name参数是干什么用的？每当我们从浏览器输入ip或者域名访问一个服务器的时候，http的请求报文中会携带一个host字段，这个字段就是记录着我们输入的ip或域名，而server_name会对请求报文中的host字段进行匹配，如果匹配成功，则会执行我们在下面指定的操作。</p>
</li>
</ul>
<h2 id="如何解决nginx转发的时候会丢掉原本请求报文的一些字段"><a href="#如何解决nginx转发的时候会丢掉原本请求报文的一些字段" class="headerlink" title="如何解决nginx转发的时候会丢掉原本请求报文的一些字段"></a>如何解决nginx转发的时候会丢掉原本请求报文的一些字段</h2><ul>
<li>nginx在对请求进行转发的时候会丢掉很多原本请求报文中存在的一些字段，比如host字段等，为了在nginx转发后获取这些字段，我们需要对nginx进行配置，可以在server块中的location块中使用<code>proxy_pass url</code>来设置满足条件的请求转发到哪里，通常配合和server同级的upstream块使用；使用<code>proxy_set_header Host $host;</code>来给转发的请求加头的Host字段，$host是取出当前请求的host字段的值。</li>
</ul>
<h2 id="使用nginx搭建域名访问环境"><a href="#使用nginx搭建域名访问环境" class="headerlink" title="使用nginx搭建域名访问环境"></a>使用nginx搭建域名访问环境</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230114205112366.png" alt="image-20230114205112366"></p>
<h2 id="通过JMeter压力测试来尝试对项目进行优化"><a href="#通过JMeter压力测试来尝试对项目进行优化" class="headerlink" title="通过JMeter压力测试来尝试对项目进行优化"></a>通过JMeter压力测试来尝试对项目进行优化</h2><ul>
<li><p>JMeter去apache官网下一个就行，选择编辑-添加-线程（用户）-线程组来添加一组测试，配置线程属性后，右键那个新建的测试可以选择添加一些取样器和监听器，运行就点上面那个运行按钮，清除记录就点那些带扫帚的按钮：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115154428987.png" alt="image-20230115154428987"></p>
</li>
<li><p>对页面压测的时候可以勾选下图中的那个选项，来把加载静态资源的时间也统计在里面：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115170421371.png" alt="image-20230115170421371"></p>
</li>
<li><p>影响项目性能的考虑点包括：数据库、应用程序、中间件、网络和操作系统等方面</p>
</li>
<li><p>在进行优化前应该先考虑自己的应用属于CPU密集型（大量计算）还是IO密集型（大量IO），我记得线程池线程数量的设置也受这两种类型的影响，<strong>CPU密集型的线程数应该设置为N（核心线程数）+1，IO密集型的线程数应该设置为2N（核心线程数）</strong>：</p>
<blockquote>
<p><strong>如果我们设置的线程池数量太小的话，如果同一时间有大量任务&#x2F;请求需要处理，可能会导致大量的请求&#x2F;任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务&#x2F;请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。</strong></p>
<p><strong>但是，如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</strong></p>
<p>有一个简单并且适用面比较广的公式：</p>
<ul>
<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I&#x2F;O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I&#x2F;O 交互，而线程在处理 I&#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I&#x2F;O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
<p><strong>如何判断是 CPU 密集任务还是 IO 密集任务？</strong></p>
<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。</p>
<hr>
<p>著作权归所有 原文链接：<a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/java-thread-pool-summary.html">https://javaguide.cn/java/concurrent/java-thread-pool-summary.html</a></p>
</blockquote>
</li>
<li><p>对于CPU密集型应用的优化，我们可以尝试优化代码的逻辑和算法；对于IO密集型应用的优化，我们可以尝试优化代码逻辑，比如优化掉循环多次IO的代码。对于这两种应用有一种通用的优化方式，就是加强对应的硬件，CPU密集型就加强CPU、多CPU并发处理等，IO密集型就加强硬盘、内存，添加缓存等。</p>
</li>
<li><p>尝试让项目少进行Full GC（这里指old GC也就是只对老年代GC，有的时候Full GC还代指所有代的GC，这个就具体情况具体分析了），因为Full GC速度很慢</p>
</li>
</ul>
<h1 id="2023-x2F-1-x2F-15"><a href="#2023-x2F-1-x2F-15" class="headerlink" title="2023&#x2F;1&#x2F;15"></a>2023&#x2F;1&#x2F;15</h1><h2 id="在IDEA中给某个服务配置jvm参数"><a href="#在IDEA中给某个服务配置jvm参数" class="headerlink" title="在IDEA中给某个服务配置jvm参数"></a>在IDEA中给某个服务配置jvm参数</h2><ul>
<li><p>点击Edit Configurations：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115150549616.png" alt="image-20230115150549616"></p>
</li>
<li><p>在里面选择自己想要配置jvm参数的服务，在对应位置写上自己想要配置的参数即可：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115150702257.png" alt="image-20230115150702257"></p>
</li>
<li><p>配置堆的最大最小值时，分配的大小要接着命令的后面写，不要有空格，不要有冒号或等号，就是紧接着写，所以为啥要这样写呢，是有什么原因还是规定？</p>
</li>
</ul>
<h2 id="通过监视java进程以分析其各种指标从而做出优化"><a href="#通过监视java进程以分析其各种指标从而做出优化" class="headerlink" title="通过监视java进程以分析其各种指标从而做出优化"></a>通过监视java进程以分析其各种指标从而做出优化</h2><ul>
<li><p>可以使用jdk自带的工具<strong>jconsole和jvisualvm</strong>，推荐使用后者，后者是前者的加强版。</p>
</li>
<li><p>在配置了环境变量的情况下，在控制台直接输入jvisualvm来启动这个工具：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115153518894.png" alt="image-20230115153518894"></p>
</li>
<li><p>监视线程的部分如下图所示：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115153907989.png" alt="image-20230115153907989"></p>
<p>其中左下角的图例分别是：</p>
<p>运行：正在运行的线程</p>
<p>休眠：执行了sleep()方法的线程</p>
<p>等待：执行了wait()方法的线程，说明该线程正在等待其他线程的结果</p>
<p>驻留：线程池中空闲的线程</p>
<p>监视：被阻塞的线程，说明该线程正在等待别的线程释放锁以获得共享资源</p>
</li>
<li><p>如果还想让jvisualvm监视别的东西，比如gc，我们可以给jvisualvm安装插件，点击工具-插件，但是我们点击检查更新的时候可能会报无法连接的错误：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115154833965.png" alt="image-20230115154833965"></p>
<p>怎么解决呢？</p>
<p>首先我们去jvisualvm的插件官网：<a target="_blank" rel="noopener" href="https://visualvm.github.io/pluginscenters.html%EF%BC%9A">https://visualvm.github.io/pluginscenters.html：</a></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115155229067.png" alt="image-20230115155229067"></p>
<p>查看我们装的jdk版本：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115155258812.png" alt="image-20230115155258812"></p>
<p>然后找到和我们的jdk版本匹配的url点进去，复制最上面的那个url：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115155428020.png" alt="image-20230115155428020"></p>
<p>然后回到jvisualvm的插件那里，点击设置-编辑，换上我们刚才复制的url后点确定：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115155540658.png" alt="image-20230115155540658"></p>
<p>然后就可以正常使用了。</p>
<p>选择自己想要安装的插件就可以了，这里主要是安装一下visual gc插件以监视gc的整个过程：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115155716557.png" alt="image-20230115155716557"></p>
<p>安装完后重启就能看到新的选项了：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115161309220.png" alt="image-20230115161309220"></p>
</li>
<li><p>从上图中也可以看到老年代Full GC（这里指old GC也就是只对老年代GC，有的时候Full GC还代指所有代的GC，这个就具体情况具体分析了）了3次花费的时间比新生代Eden区Minor GC了14次花费的时间还要长不少，这也印证了之前说的，老年代的GC效率很低，尽量少让老年代GC。</p>
</li>
</ul>
<h2 id="JVM分析与调优"><a href="#JVM分析与调优" class="headerlink" title="JVM分析与调优"></a>JVM分析与调优</h2><ul>
<li><p>在分析阶段，我们可以通过JMeter来对服务的各个环节来进行压测，最好是分成单独的压测和组合的压测，这样得到的结果可以汇总成一个表格，通过表格来判断我们应该从哪里着手进行优化：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115195332580.png" alt="image-20230115195332580"></p>
</li>
<li><p>中间件越多，性能损失越大，大多都损失在网络交互了，如果想要优化，可以先从中间件入手，优化中间件，提高中间件的吞吐量，再者可以从网络传输的部分入手，可以采用更好的网线、采用更高效的网络传输协议等</p>
</li>
<li><p>业务的优化可以考虑以下几个方面：DB（数据库）优化、静态资源访问优化、模板渲染速度优化（前后不分离的话）、业务逻辑优化（比如在循环中查表的问题）</p>
</li>
<li><p>对于数据库的优化，无非就是优化数据库查表的效率，<strong>数据量大的时候</strong>，对主键进行查询的时候效率比较高，那是因为主键有索引，对别的没有索引的字段进行查询的话，数据库会进行全表查询，在数据量比较大的时候这种查询的效率非常低，所以为了优化数据库的查询效率，我们可以<strong>考虑给查询得多的字段加上索引来加速查询</strong>：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115171845911.png" alt="image-20230115171845911"></p>
</li>
<li><p>有的时候通过jvisualvm可以看出来，整个服务的性能瓶颈出现在老年代的频繁GC，所以针对这个问题我们可以修改jvm的启动设置，手动给jvm设置内存：</p>
<ul>
<li>-Xmx用来设置堆的最大占用内存，例：<code>-Xmx100m</code></li>
<li>-Xms用来设置堆的最小占用内存，例：<code>-Xms100m</code></li>
<li>-Xmn用来设置堆中新生代的占用内存，JVM官方推荐新生代占整个堆的3&#x2F;8，其中Eden:S0:S1 &#x3D; 8:1:1，例：<code>-Xmn30m</code></li>
<li>未完待续……</li>
</ul>
</li>
</ul>
<h2 id="Nginx动静分离"><a href="#Nginx动静分离" class="headerlink" title="Nginx动静分离"></a>Nginx动静分离</h2><ul>
<li><p>为了对访问静态数据这一步进行优化，我们可以选择将静态资源全部放到nginx中，这样每当我们需要静态资源的时候，找nginx要就可以了，而不用发请求向后端要了，相当于把从nginx到后端的这段链路优化掉了，服务能腾出不少线程来专注为动态请求服务，能提升不少吞吐量：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115181112309.png" alt="image-20230115181112309"></p>
</li>
<li><p>所以以后可以将项目用到的所有静态资源全部放到nginx中，对静态资源的访问请求都应该由nginx直接返回。</p>
</li>
<li><p>首先把static下的文件全部放到服务器的nginx挂载的外部文件夹html中，这个文件夹是被nginx的保存静态资源的目录挂载的。</p>
</li>
<li><p>然后修改index.html中的访问静态资源的路径，都要在原路径前面加上一个&#x2F;static&#x2F;，这个&#x2F;static&#x2F;是准备在nginx中进行配置的，如果要是访问路径以&#x2F;static&#x2F;开头，那么nginx就要把请求转到指定的地方，所以这个&#x2F;static&#x2F;也可以自定义。</p>
</li>
<li><p>然后修改nginx的配置文件，主要就是加一个location做静态资源请求的转发映射：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以/static/开头的请求全部转到root下</span></span><br><span class="line">location /static/ &#123;</span><br><span class="line">    root   /usr/share/nginx/html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后给ngxin发以&#x2F;static&#x2F;开头的静态资源请求，都会被nginx转发到nginx的静态资源目录中查找并返回对应的资源。</p>
</li>
</ul>
<h2 id="缓存的使用"><a href="#缓存的使用" class="headerlink" title="缓存的使用"></a>缓存的使用</h2><ul>
<li><p>当我们将大部分优化手段都做了一遍之后，如果还想提高系统的吞吐量，那么我们可以引入缓存，减少查数据库的次数。</p>
</li>
<li><p>哪些数据适合放入缓存？</p>
<ol>
<li><strong>即时性、数据一致性要求不高</strong>的</li>
<li><strong>访问量大且更新频率不高</strong>的数据（读多，写少）</li>
</ol>
</li>
<li><p>读缓存使用流程：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230115224124283.png" alt="image-20230115224124283"></p>
</li>
<li><p>至于缓存的实现，可以是多种多样的，比如最简单的就是本地缓存，写个map装东西，在访问数据库之前先看看想要的数据在map中有没有，如果有就直接取，如果没有就查数据库，但是这样做会有很多问题，首先就是如果服务部署成一个集群，那么多个本地缓存的数据一致性难以保证，并且我们自己写的缓存很难有生产级别的缓存淘汰机制等，并且本地缓存和代码耦合度太高，后续难以维护，可读性也乏善可陈。</p>
</li>
<li><p>我们想要的缓存实现，应该是<strong>解耦的，稳定的，并且能在集群部署的情况下保证缓存之间的数据的一致性，并且应该有优秀的缓存淘汰算法可供我们进行选择</strong>。</p>
</li>
<li><p>综上所述，我们需要的应该是一个缓存中间件，所有服务更新缓存都是更新在中间件中，并且中间件还支持集群部署，这样就解决了缓存之间数据一致性的问题，中间件本身还是解耦的，并且还有多样的数据淘汰策略可供我们选择，缓存中间件有很多，redis挺好用，那就用redis。</p>
</li>
</ul>
<h1 id="2023-x2F-1-x2F-16"><a href="#2023-x2F-1-x2F-16" class="headerlink" title="2023&#x2F;1&#x2F;16"></a>2023&#x2F;1&#x2F;16</h1><h2 id="关于父项目管理子项目依赖的版本的问题"><a href="#关于父项目管理子项目依赖的版本的问题" class="headerlink" title="关于父项目管理子项目依赖的版本的问题"></a>关于父项目管理子项目依赖的版本的问题</h2><ul>
<li>如果父项目的dependency不写version，那么子项目是获取不到父项目的依赖版本的，即使是父项目的dependency的version能从它的父项目中得到，今天踩坑了&#x3D; &#x3D;。</li>
</ul>
<h2 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h2><ul>
<li><p>首先就是引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring-boot-starter-data-redis.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring-boot-starter-data-redis.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--redis--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后就是在配置文件中进行配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="comment">#配置redis的主机地址和端口</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">111.111</span><span class="number">.111</span><span class="number">.111</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后我们看看redis的AutoConfiguration类：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116151143755.png" alt="image-20230116151143755"></p>
<p>里面有两个注入到spring IOC容器中的bean，前者是和对象操作相关的，后者是和字符串操作相关的，我们<strong>使用缓存存放的数据一般都是json格式的数据</strong>，所以用后面的bean多一些。</p>
</li>
<li><p>使用StringRedisTemplate来操作redis，总的来说就是先获取对redis的某个数据结构的操作对象，然后再用那个获得的操作对象来执行一系列对于指定数据结构的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedis</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//获得对value的操作对象</span></span><br><span class="line">	ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue();</span><br><span class="line">	<span class="comment">//执行保存操作</span></span><br><span class="line">	ops.set(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world_&quot;</span>+ UUID.randomUUID().toString());</span><br><span class="line">	<span class="comment">//执行查询操作</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> ops.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;保存的key为hello的value是：&quot;</span>+hello);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以使用RedisDesktopManager软件来可视化地查看远端服务器上redis中存放的数据：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116154522095.png" alt="image-20230116154522095"></p>
</li>
<li><p>为了防止有人偷偷连上我们的redis做一些乱七八糟的操作，我们可以在redis的client中使用<code>config set requirepass 密码</code>设置密码，登录client的时候要使用<code>AUTH 密码</code>来进行登录，记得改一下RedisDesktopManager的客户端连接的设置，把那密码给写上，不然连不上；然后还要在项目的配置文件中设置一下spring.redis.password属性的值以让我们的项目也能成功连接上redis。</p>
</li>
<li><p>之后对于想要从数据库中查找符合存放在redis中要求的数据之前，要先检查一下缓存中有没有，如果有直接拿，如果没有再查数据库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTree</span><span class="params">()</span>&#123;<span class="comment">//给listWithTree方法加入缓存后的逻辑</span></span><br><span class="line">    <span class="comment">//给缓存中存放的是对象转成的json数据，拿出的也是json数据需要转成对象，有天然的跨平台性，这是序列化与反序列化的一种实现</span></span><br><span class="line">    <span class="comment">//尝试从redis中取想要的数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">catelogData</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;catelogData&quot;</span>);<span class="comment">//字面量按说应该抽成常量，这里只是为了方便</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(catelogData))&#123;<span class="comment">//如果redis中没有我们想要的数据，那么我们才从数据库中查,并将查到的结果加入缓存中</span></span><br><span class="line">        List&lt;PmsCategory&gt; result = listWithTreeFromDb();<span class="comment">//从数据库中查</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">store</span> <span class="operator">=</span> JSON.toJSONString(result);<span class="comment">//将结果转成json数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;catelogData&quot;</span>,store);<span class="comment">//将json数据存入redis</span></span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//返回从数据库中查到的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果redis中有我们想要的数据，那么我们可以反序列化之后直接使用</span></span><br><span class="line">    <span class="comment">//Json反序列化操作，注意第二个参数作为类型令牌的使用</span></span><br><span class="line">    List&lt;PmsCategory&gt; result = JSON.parseObject(catelogData,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;PmsCategory&gt;&gt;()&#123;&#125;);</span><br><span class="line">    log.info(<span class="string">&quot;是从redis中取的结果~&quot;</span>);</span><br><span class="line">    <span class="comment">//返回反序列化后的结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeFromDb</span><span class="params">()</span> &#123;<span class="comment">//原listWithTree方法</span></span><br><span class="line">    <span class="comment">//查出所有分类</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * baseMapper就相当于这个service对应的mapper，</span></span><br><span class="line"><span class="comment">     * 因为看上面继承了ServiceImpl，</span></span><br><span class="line"><span class="comment">     * 其中这个service对应的mapper被当作泛型的类型参数传进去了，</span></span><br><span class="line"><span class="comment">     * 而里面有个泛型参数类型的变量就是baseMapper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;PmsCategory&gt; data = baseMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//todo 组装成树形结构</span></span><br><span class="line">    <span class="comment">//找到所有的一级分类</span></span><br><span class="line">    List&lt;PmsCategory&gt; level1Menu = data.stream()</span><br><span class="line">            .filter(pmsCategory -&gt; pmsCategory.getParentCid().equals(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">            .map(menu -&gt; &#123;</span><br><span class="line">                menu.setChildren(getChildren(data,menu));</span><br><span class="line">                <span class="keyword">return</span> menu;</span><br><span class="line">            &#125;)</span><br><span class="line">            .sorted(Comparator.comparingInt(PmsCategory::getSort))<span class="comment">//Comparator封装了比较两个int变量的Comparator，直接传个方法引用告知其如何从元素中取得int变量即可</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> level1Menu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在对使用了缓存的方法进行压测的时候可能会出现的堆外内存溢出的问题：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116164117198.png" alt="image-20230116164117198"></p>
</li>
</ul>
<h2 id="高并发环境下缓存失效的问题"><a href="#高并发环境下缓存失效的问题" class="headerlink" title="高并发环境下缓存失效的问题"></a>高并发环境下缓存失效的问题</h2><h3 id="缓存穿透（大流量查一个不存在的数据）"><a href="#缓存穿透（大流量查一个不存在的数据）" class="headerlink" title="缓存穿透（大流量查一个不存在的数据）"></a>缓存穿透（大流量查一个不存在的数据）</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116165314128.png" alt="image-20230116165314128"></p>
<ul>
<li>就是查询一个不存在的数据，导致每次查询都要查数据库，缓存形同虚设，数据库的查询压力会增大，直至崩溃。所以针对数据库中不存在的结果，我们可以在查了数据库之后，<strong>把这个不存在的结果当作空值存在redis中并设置一定的过期时间</strong>，这样短时间内针对这个不存在的结果的查询，就会走缓存，数据库就不会有那么大的压力了。</li>
</ul>
<h3 id="缓存雪崩（流量高峰时缓存中的数据短时间内同时过期）"><a href="#缓存雪崩（流量高峰时缓存中的数据短时间内同时过期）" class="headerlink" title="缓存雪崩（流量高峰时缓存中的数据短时间内同时过期）"></a>缓存雪崩（流量高峰时缓存中的数据短时间内同时过期）</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116165905379.png" alt="image-20230116165905379"></p>
<h3 id="缓存击穿（热点数据在流量高峰期失效）"><a href="#缓存击穿（热点数据在流量高峰期失效）" class="headerlink" title="缓存击穿（热点数据在流量高峰期失效）"></a>缓存击穿（热点数据在流量高峰期失效）</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116170154726.png" alt="image-20230116170154726"></p>
<h2 id="分布式的情况下如何加锁"><a href="#分布式的情况下如何加锁" class="headerlink" title="分布式的情况下如何加锁"></a>分布式的情况下如何加锁</h2><ul>
<li><p>如果要是使用本地锁，使用this作为锁，那么作为单机应用来说是完全没有问题的，因为spring中的bean是单例的，可以保证每次的这个this是同一个对象。</p>
</li>
<li><p>但是如果要是分布式的情况下，不同的节点有不同的spring IOC容器，这样使用本地锁this无法将所有节点全部锁住，所以我们为了应对这个问题，可以使用分布式锁，不过这玩意儿性能比较低，其实仔细一想，如果分布式的情况下使用本地锁，无非也就是多放了几个请求进去嘛，无可厚非，所以这个分布式锁的使用情况就具体情况具体分析了，适用于那种大型分布式系统，那种集群节点很多的那种，如果能带来更高的性能就用，可以压测试试。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116171855477.png" alt="image-20230116171855477"></p>
</li>
<li><p>分布式锁基本原理，无非也就是把获取锁的这部分抽出来，怎么实现无所谓，关键是要和服务解耦：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116181622257.png" alt="image-20230116181622257"></p>
</li>
<li><p>我们可以使用redis的天然特性来去实现这个加锁操作，最简单的说就是每个线程到了redis，先set一个值，如果这个值没有设置，那么他设置了，他就可以进行下面的操作，如果要是值已经设置了，说明有线程已经到过了，那当前的线程就没有抢到锁，可以使用redis的命令setnx也就是指定的key没有值的情况下才进行set，不然就不进行set，这就是分布式锁的基本原理，类似于乐观锁：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116185358324.png" alt="image-20230116185358324"></p>
</li>
<li><p>上一个阶段中存在一个问题，如果出现问题导致redis锁没有释放，那么redis锁就一直不能被获取，就死锁了，也就是<strong>无法保证业务的原子性</strong>，针对这样的问题，我们可以给redis锁设置一个自动过期时间，一段时间过后，就算没有用程序将redis锁释放，过期时间到了锁就会被自动释放：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116190133025.png" alt="image-20230116190133025"></p>
</li>
<li><p>上个阶段中也有问题，万一在设置过期时间之前，突然断电了，那么过期时间没能设置，又死锁了，针对这种情况，我们可以把设置过期时间和获取锁的操作一起进行，让他们变成一个原子操作，这样就能解决这个问题：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116190717037.png" alt="image-20230116190717037"></p>
</li>
<li><p>上面这个阶段又有问题，问题出现在删除锁的情况下，万一一个持有锁的服务超时了，锁被自动释放掉了，然后别的线程拿到了锁，但是最后那个超时的服务又要执行删除锁的操作，这样就导致别人的锁被他删掉了，为了解决这个问题，我们给redis锁的值设置为uuid，这样每个人最后删除的时候总是尝试删除自己的锁：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116193241172.png" alt="image-20230116193241172"></p>
</li>
<li><p>上面这个阶段还是有问题，问题就在于我们无法保证最后获取锁的值并检查和释放锁这两个操作的原子性，这会导致什么后果呢，如果一个线程去redis查了自己的锁，在数据返回的时候，锁过期了，别的又加了锁，再之后这个数据到达本地，判断也通过了，就会执行释放锁的操作，又释放成别人的锁了。根据redis官方的说法，解决这个问题需要使用lua脚本以保证这些操作的一致性：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116193559497.png" alt="image-20230116193559497"></p>
</li>
<li><p>总结一下就是，使用redis做分布式锁，需要注意保证设置过期时间并加锁和检查是否是自己的锁并解锁的操作的原子性，还需要保证加锁的值是各线程特有的，前者是使用redis的语法保证原子性，后者是通过使用lua脚本保证原子性，以下是对之前代码的分布式锁实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTree</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listWithTreeByRedisLock();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeByRedisLock</span><span class="params">()</span>&#123;<span class="comment">//用redis实现分布式锁，不过查出来的内容没放缓存呢还</span></span><br><span class="line">    <span class="comment">//分布式锁，去redis中set相同key的值，谁set成功了谁就拿到锁了，可以执行后面的内容，没拿到锁的进行睡眠并自旋，直到拿到锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID().toString();<span class="comment">//这是为了防止误删别人的锁，所以每个人设置锁的值都应该是唯一的，最后删除锁之前也要检查是不是自己的再删</span></span><br><span class="line">    <span class="comment">//尝试获取redis锁，使用的那个方法可以保证设置过期时间和设置值的操作是原子的，具体执行的语句应该是setnx Key Value EX 300 NX</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lock</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lock&quot;</span>,uuid,<span class="number">300</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span>(lock)&#123;<span class="comment">//如果拿到了锁，就执行下面的操作</span></span><br><span class="line">        log.info(<span class="string">&quot;获取分布式锁成功&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> listWithTreeFromDb();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;<span class="comment">//在finally中解锁，保证锁会被解掉</span></span><br><span class="line">            <span class="comment">//保证了检查锁和解锁两个操作原子性的lua脚本</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">            <span class="comment">//删除锁,第一个参数是封装的脚本，泛型是返回值类型，redis删除成功返回1，删除不成功返回0，所以是个long，第二个参数是顺序的所有脚本中用到的key，第三个参数是顺序的所有脚本中用到的value</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">ifDeleted</span> <span class="operator">=</span> stringRedisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;Long&gt;(script,Long.class),Arrays.asList(<span class="string">&quot;lock&quot;</span>),uuid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果没有拿到锁，就睡眠并自旋</span></span><br><span class="line">        log.info(<span class="string">&quot;获取分布式锁失败，将在一定时间后重试&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">&quot;出现异常：&#123;&#125;&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listWithTreeByRedisLock();<span class="comment">//递归自旋，感觉不如提到前面做循环自旋，这个太占栈空间了。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeByLocalLock</span><span class="params">()</span>&#123;<span class="comment">//给listWithTree方法加入缓存后的逻辑,用的是本地锁</span></span><br><span class="line">    <span class="comment">//给缓存中存放的是对象转成的json数据，拿出的也是json数据需要转成对象，有天然的跨平台性，这是序列化与反序列化的一种实现</span></span><br><span class="line">    <span class="comment">//todo 空结果缓存：解决缓存穿透 随机过期时间：解决缓存雪崩 加锁：解决缓存击穿</span></span><br><span class="line">    <span class="comment">//尝试从redis中取想要的数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">catelogData</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;catelogData&quot;</span>);<span class="comment">//字面量按说应该抽成常量，这里只是为了方便</span></span><br><span class="line">    List&lt;PmsCategory&gt; result = <span class="literal">null</span>;<span class="comment">//最后要返回的结果</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(catelogData))&#123;<span class="comment">//如果redis中没有我们想要的数据，那么我们才从数据库中查,并将查到的结果加入缓存中</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;<span class="comment">//加本地锁以防止缓存穿透，把存入缓存的代码也放进来，防止缓存还没更新的时候下一个请求到了然后做出错误的判断</span></span><br><span class="line">            catelogData = stringRedisTemplate.opsForValue().get(<span class="string">&quot;catelogData&quot;</span>);<span class="comment">//再查一遍缓存用于双重校验</span></span><br><span class="line">            <span class="keyword">if</span>(!StringUtils.isEmpty(catelogData))&#123;<span class="comment">//双重校验，如果缓存中有数据了，就不用从数据库中查了</span></span><br><span class="line">                <span class="comment">//Json反序列化操作，注意第二个参数作为类型令牌的使用</span></span><br><span class="line">                result = JSON.parseObject(catelogData,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;PmsCategory&gt;&gt;()&#123;&#125;);</span><br><span class="line">                log.info(<span class="string">&quot;查redis~&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;查数据库~&quot;</span>);</span><br><span class="line">            result = listWithTreeFromDb();<span class="comment">//从数据库中查</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">store</span> <span class="operator">=</span> JSON.toJSONString(result);<span class="comment">//将结果转成json数据</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;catelogData&quot;</span>,store);<span class="comment">//将json数据存入redis</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//返回从数据库中查到的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果redis中有我们想要的数据，那么我们可以反序列化之后直接使用</span></span><br><span class="line">    <span class="comment">//Json反序列化操作，注意第二个参数作为类型令牌的使用</span></span><br><span class="line">    result = JSON.parseObject(catelogData,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;PmsCategory&gt;&gt;()&#123;&#125;);</span><br><span class="line">    log.info(<span class="string">&quot;查redis~&quot;</span>);</span><br><span class="line">    <span class="comment">//返回反序列化后的结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeFromDb</span><span class="params">()</span> &#123;<span class="comment">//原listWithTree方法</span></span><br><span class="line">    <span class="comment">//查出所有分类</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * baseMapper就相当于这个service对应的mapper，</span></span><br><span class="line"><span class="comment">     * 因为看上面继承了ServiceImpl，</span></span><br><span class="line"><span class="comment">     * 其中这个service对应的mapper被当作泛型的类型参数传进去了，</span></span><br><span class="line"><span class="comment">     * 而里面有个泛型参数类型的变量就是baseMapper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;PmsCategory&gt; data = baseMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//todo 组装成树形结构</span></span><br><span class="line">    <span class="comment">//找到所有的一级分类</span></span><br><span class="line">    List&lt;PmsCategory&gt; level1Menu = data.stream()</span><br><span class="line">            .filter(pmsCategory -&gt; pmsCategory.getParentCid().equals(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">            .map(menu -&gt; &#123;</span><br><span class="line">                menu.setChildren(getChildren(data,menu));</span><br><span class="line">                <span class="keyword">return</span> menu;</span><br><span class="line">            &#125;)</span><br><span class="line">            .sorted(Comparator.comparingInt(PmsCategory::getSort))<span class="comment">//Comparator封装了比较两个int变量的Comparator，直接传个方法引用告知其如何从元素中取得int变量即可</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> level1Menu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于原子加锁和解锁我们可以抽取成工具类，但是分布式锁有更专业的工具，下面会介绍到。</p>
</li>
</ul>
<h2 id="本地锁的时序问题"><a href="#本地锁的时序问题" class="headerlink" title="本地锁的时序问题"></a>本地锁的时序问题</h2><ul>
<li><p>本地锁的范围一定要考虑清楚，就拿上面写的那个查数据库的逻辑来说，如果要是将结果放入缓存的操作在锁外面，那么在一个线程释放锁之后，另一个线程进入代码块并判断缓存中有没有数据，由于数据还没来得及放入缓存，所以这个地方自然是返回false，那这个线程就又查了一遍数据库，所以锁的范围一定要考虑清楚，应该把放缓存的代码放到加锁的代码块中。</p>
</li>
<li><p>而且如果要是放入缓存的操作只是发一个网络请求就向下执行的话，我们还应该考虑网络延迟等因素的影响，所以最保险的做法我感觉是在最后用while循环判断缓存是否已经更新，如果更新了再释放锁。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116173314106.png" alt="image-20230116173314106"></p>
</li>
</ul>
<h2 id="对上面的代码进行加本地锁以防止缓存击穿"><a href="#对上面的代码进行加本地锁以防止缓存击穿" class="headerlink" title="对上面的代码进行加本地锁以防止缓存击穿"></a>对上面的代码进行加本地锁以防止缓存击穿</h2><ul>
<li><p>一定考虑清楚锁的范围，还有别忘了双重校验：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">StringRedisTemplate stringRedisTemplate;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTree</span><span class="params">()</span>&#123;<span class="comment">//给listWithTree方法加入缓存后的逻辑</span></span><br><span class="line">    <span class="comment">//给缓存中存放的是对象转成的json数据，拿出的也是json数据需要转成对象，有天然的跨平台性，这是序列化与反序列化的一种实现</span></span><br><span class="line">    <span class="comment">//todo 空结果缓存：解决缓存穿透 随机过期时间：解决缓存雪崩 加锁：解决缓存击穿</span></span><br><span class="line">    <span class="comment">//尝试从redis中取想要的数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">catelogData</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;catelogData&quot;</span>);<span class="comment">//字面量按说应该抽成常量，这里只是为了方便</span></span><br><span class="line">    List&lt;PmsCategory&gt; result = <span class="literal">null</span>;<span class="comment">//最后要返回的结果</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(catelogData))&#123;<span class="comment">//如果redis中没有我们想要的数据，那么我们才从数据库中查,并将查到的结果加入缓存中</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;<span class="comment">//加本地锁以防止缓存穿透，把存入缓存的代码也放进来，防止缓存还没更新的时候下一个请求到了然后做出错误的判断</span></span><br><span class="line">            catelogData = stringRedisTemplate.opsForValue().get(<span class="string">&quot;catelogData&quot;</span>);<span class="comment">//再查一遍缓存用于双重校验</span></span><br><span class="line">            <span class="keyword">if</span>(!StringUtils.isEmpty(catelogData))&#123;<span class="comment">//双重校验，如果缓存中有数据了，就不用从数据库中查了</span></span><br><span class="line">                <span class="comment">//Json反序列化操作，注意第二个参数作为类型令牌的使用</span></span><br><span class="line">                result = JSON.parseObject(catelogData,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;PmsCategory&gt;&gt;()&#123;&#125;);</span><br><span class="line">                log.info(<span class="string">&quot;查redis~&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">&quot;查数据库~&quot;</span>);</span><br><span class="line">            result = listWithTreeFromDb();<span class="comment">//从数据库中查</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">store</span> <span class="operator">=</span> JSON.toJSONString(result);<span class="comment">//将结果转成json数据</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(<span class="string">&quot;catelogData&quot;</span>,store);<span class="comment">//将json数据存入redis</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//返回从数据库中查到的结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果redis中有我们想要的数据，那么我们可以反序列化之后直接使用</span></span><br><span class="line">    <span class="comment">//Json反序列化操作，注意第二个参数作为类型令牌的使用</span></span><br><span class="line">    result = JSON.parseObject(catelogData,<span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;PmsCategory&gt;&gt;()&#123;&#125;);</span><br><span class="line">    log.info(<span class="string">&quot;查redis~&quot;</span>);</span><br><span class="line">    <span class="comment">//返回反序列化后的结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeFromDb</span><span class="params">()</span> &#123;<span class="comment">//原listWithTree方法</span></span><br><span class="line">    <span class="comment">//查出所有分类</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * baseMapper就相当于这个service对应的mapper，</span></span><br><span class="line"><span class="comment">     * 因为看上面继承了ServiceImpl，</span></span><br><span class="line"><span class="comment">     * 其中这个service对应的mapper被当作泛型的类型参数传进去了，</span></span><br><span class="line"><span class="comment">     * 而里面有个泛型参数类型的变量就是baseMapper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;PmsCategory&gt; data = baseMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//todo 组装成树形结构</span></span><br><span class="line">    <span class="comment">//找到所有的一级分类</span></span><br><span class="line">    List&lt;PmsCategory&gt; level1Menu = data.stream()</span><br><span class="line">            .filter(pmsCategory -&gt; pmsCategory.getParentCid().equals(<span class="string">&quot;0&quot;</span>))</span><br><span class="line">            .map(menu -&gt; &#123;</span><br><span class="line">                menu.setChildren(getChildren(data,menu));</span><br><span class="line">                <span class="keyword">return</span> menu;</span><br><span class="line">            &#125;)</span><br><span class="line">            .sorted(Comparator.comparingInt(PmsCategory::getSort))<span class="comment">//Comparator封装了比较两个int变量的Comparator，直接传个方法引用告知其如何从元素中取得int变量即可</span></span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> level1Menu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>压力测试：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116175914279.png" alt="image-20230116175914279"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116175847264.png" alt="image-20230116175847264"></p>
<p>可以看到只查了一次数据库，所以这个锁在单机情况下是有作用的。</p>
</li>
</ul>
<h2 id="用IDEA模拟集群"><a href="#用IDEA模拟集群" class="headerlink" title="用IDEA模拟集群"></a>用IDEA模拟集群</h2><ul>
<li><p>可以在想要模拟集群的服务上右键，选择copy configuration，然后换个端口号，改改配置，多搞几个一起启动就行了：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116180519759.png" alt="image-20230116180519759"></p>
</li>
</ul>
<h1 id="2023-x2F-1-x2F-17"><a href="#2023-x2F-1-x2F-17" class="headerlink" title="2023&#x2F;1&#x2F;17"></a>2023&#x2F;1&#x2F;17</h1><h2 id="自旋锁（Spin-Lock）"><a href="#自旋锁（Spin-Lock）" class="headerlink" title="自旋锁（Spin Lock）"></a>自旋锁（Spin Lock）</h2><ul>
<li>就是没拿到锁的时候自己在那转，直到拿到锁，可以用循环或者递归实现。</li>
</ul>
<h2 id="可重入锁（Reentrant-Lock）"><a href="#可重入锁（Reentrant-Lock）" class="headerlink" title="可重入锁（Reentrant Lock）"></a>可重入锁（Reentrant Lock）</h2><ul>
<li><del>假设有两个方法分别是方法a和方法b，方法b在方法a中，他们都想加同一把锁，如果要是不可重入锁，那么在a拿到锁之后，b就会无限等待，就死锁了；如果是可重入锁，那么当a拿到锁后，它里面的方法b在某种情况下也可以拿到a锁，避免了死锁问题，所以为了避免死锁问题，我们的锁应该都尽量设计成可重入锁</del>。</li>
<li>可重入锁是指可以被已经获取该锁的线程重新获取，可以防止递归的时候出现死锁的情况。</li>
</ul>
<h2 id="公平锁（Fair-Lock）"><a href="#公平锁（Fair-Lock）" class="headerlink" title="公平锁（Fair Lock）"></a>公平锁（Fair Lock）</h2><ul>
<li>就是一个线程拿到锁之后，又有很多线程想要拿锁，在之前拿到锁的线程释放锁之后，那些后来的线程会按照一定的顺序来拿锁而非抢占，这就是公平锁。释放锁后进行抢占的那是非公平锁。</li>
</ul>
<h2 id="读写锁（ReadWrite-Lock）"><a href="#读写锁（ReadWrite-Lock）" class="headerlink" title="读写锁（ReadWrite Lock）"></a>读写锁（ReadWrite Lock）</h2><ul>
<li><p>如果一个线程拿着写锁在修改数据，而另一个线程想要拿读锁读取数据，那么它是拿不到的，只有当写锁被释放之后，它才能拿到读锁，这样就保证了读线程读到的都是最新的数据。</p>
</li>
<li><p>同样，如果一个线程拿着读锁在读取数据，而另一个线程想要拿写锁修改数据，那么它是拿不到的，只有当读锁被释放之后，它才能拿到写锁。</p>
</li>
<li><p>如果要是很多线程并发读取数据（写锁在释放状态），那么他们拿的是共享读锁，可以一起读，类似于无锁的状态。</p>
</li>
<li><p>如果要是很多线程并发修改数据（读锁在释放状态），那么他们要拿排他&#x2F;互斥写锁，不能一起写。</p>
</li>
<li><p>也就是<strong>共享读，排他&#x2F;独享&#x2F;互斥写</strong>，<strong>读写不兼容，读读兼容，写写不兼容</strong>。</p>
</li>
<li><p>读写锁总是成对出现，写锁控制着读锁，只要写锁没释放，读锁就要等待；读锁没释放，写锁也要等待。</p>
</li>
<li><p>这其实设计操作系统中读者和写者的问题，可以再去翻翻书。</p>
</li>
<li><p><strong>对于频繁读，偶尔写的业务场景，加读写锁对性能影响不大</strong>。</p>
</li>
<li><p>代码示例：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117154614171.png" alt="image-20230117154614171"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117154650048.png" alt="image-20230117154650048"></p>
</li>
</ul>
<h2 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h2><ul>
<li><p>信号量的值是个数字，每当一个线程拿到这个锁，信号量就减1，只要信号量不为0，来的线程就能拿到锁，当信号量减为0时，再想获得这个锁就要等待或者不拿锁了直接走掉。</p>
</li>
<li><p>可以用作分布式限流等操作中。</p>
</li>
<li><p>代码示例：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117154926261.png" alt="image-20230117154926261"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117154943639.png" alt="image-20230117154943639"></p>
</li>
</ul>
<h2 id="闭锁（CountDownLatch）"><a href="#闭锁（CountDownLatch）" class="headerlink" title="闭锁（CountDownLatch）"></a>闭锁（CountDownLatch）</h2><ul>
<li><p>有多个线程可以同时拿着闭锁，但是只有当所有的线程都释放闭锁之后，闭锁才会被释放。</p>
</li>
<li><p>应用场景：加载多个配置，需要加载完所有的配置才能走下一步。</p>
</li>
<li><p>代码示例：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117155137552.png" alt="image-20230117155137552"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117155150238.png" alt="image-20230117155150238"></p>
</li>
</ul>
<h2 id="最好把注入的对象名写成把他注册到spring-IOC容器中的那个方法的名字"><a href="#最好把注入的对象名写成把他注册到spring-IOC容器中的那个方法的名字" class="headerlink" title="最好把注入的对象名写成把他注册到spring IOC容器中的那个方法的名字"></a>最好把注入的对象名写成把他注册到spring IOC容器中的那个方法的名字</h2><ul>
<li>相当于那个组件的id，增强可读性</li>
</ul>
<h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><ul>
<li><p>这是一个封装了很多分布式操作的包，用它我们可以很轻松的实现分布式锁（包括上面写的那些锁，方法名字和上面写的那些锁的名字差不多）、分布式对象等高级操作。</p>
</li>
<li><p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">redisson.version</span>&gt;</span>3.12.0<span class="tag">&lt;/<span class="name">redisson.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--redisson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;redisson.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>虽然它有starter，可以进行自动配置，但是我们还是手动配置一下以获取更深的理解，给它新建一个配置类进行配置，最后返回的是一个RedissonClient实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRedissonConfig</span> &#123;<span class="comment">//redisson的配置类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(destroyMethod = &quot;shutdown&quot;)</span></span><br><span class="line">    RedissonClient <span class="title function_">redisson</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">//创建配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://101.42.35.83:6379&quot;</span>);</span><br><span class="line">        <span class="comment">//根据config创建RedissonClient实例</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>它的所有操作都是通过RedissonClient的实例来做的，所以以后用的时候，注入RedissonClient，然后用就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RedissonClient redisson;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/testRedisson&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">testRedisson</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">myLock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;myLock&quot;</span>);<span class="comment">//获取一把锁，参数是锁的名字，通过名字区分不同的锁，名字相同的就是同一把锁</span></span><br><span class="line">    myLock.lock();<span class="comment">//加锁,获取不到锁的线程会被阻塞</span></span><br><span class="line">    <span class="keyword">try</span>&#123;<span class="comment">//锁的ttl会利用看门狗自动续期，不用担心业务时间长锁会过期，默认ttl为30s，也不用担心程序挂掉之后不会解锁</span></span><br><span class="line">        System.out.println(<span class="string">&quot;加锁成功，执行业务...&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">        Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">//如果业务结束，那么看门狗不会再给锁的ttl续期</span></span><br><span class="line">        System.out.println(<span class="string">&quot;解锁...&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">        myLock.unlock();<span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(redisson);</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果是正常的，没有获得锁的线程会阻塞，之前的线程放开锁后马上开始竞争锁：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116232306338.png" alt="image-20230116232306338"></p>
<p>在redis中能看到锁：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116232334579.png" alt="image-20230116232334579"></p>
</li>
<li><p>可以发现加锁后，一个任务运行的时候出现错误没能解锁之后，另外一个任务仍然能拿到锁，这是因为<strong>redisson在redis中加锁的时候设置了过期时间TTL，默认是30s，也就是一个看门狗时间</strong>，而这个TTL也没那么简单，TTL会被监视，<strong>如果业务还在运行中，那么这个TTL会在1&#x2F;3个看门狗时间也就是10s后自动续期到一个看门狗时间也就是30s，一直重复直到业务完成或宕掉；如果业务没有在运行了，TTL就不会做自动续期，最后TTL减到0锁被淘汰</strong>：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117143059296.png" alt="image-20230117143059296"></p>
</li>
<li><p>但是<strong>如果在使用锁的时候显式地指定了过期时间，那么看门狗机制会失效</strong>，虽然我也不知道它为啥这样设计…</p>
</li>
<li><p>不过<strong>自动续期TTL会造成性能的损失</strong>，所以之后在用的时候最好还是显式指定超时时间。</p>
</li>
<li><p>redisson中有上面写的那些锁的实现，名字和那些锁的名字差不多，<strong>带try的方法是尝试获取锁的时候不阻塞，不带try的方法是尝试获取锁的时候阻塞</strong>。</p>
</li>
<li><p>用redisson再改造一下昨天写的代码，看着简洁多了，不过<strong>在给锁命名的时候要注意锁的粒度问题</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTreeByRedissonLock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//新建分布式锁</span></span><br><span class="line">    <span class="comment">//起名的时候涉及锁的粒度越细，速度越快，粒度越大，速度越慢</span></span><br><span class="line">    <span class="comment">//可以按照具体的服务名以及缓存内容等给锁起名，保证锁的粒度合理</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">myLock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;product-listWithTree-lock&quot;</span>);</span><br><span class="line">    myLock.lock(<span class="number">30</span>,TimeUnit.SECONDS);<span class="comment">//上锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listWithTreeFromDb();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        myLock.unlock();<span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="缓存数据一致性问题"><a href="#缓存数据一致性问题" class="headerlink" title="缓存数据一致性问题"></a>缓存数据一致性问题</h2><ul>
<li>缓存里面的数据如何和数据库中的数据保持一致？</li>
</ul>
<h3 id="双写模式"><a href="#双写模式" class="headerlink" title="双写模式"></a>双写模式</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117161428127.png" alt="image-20230117161428127"></p>
<ul>
<li>就是写完数据库之后再改缓存，但是这样比较麻烦，而且在高并发的情况下缓存中可能出现脏数据，可以通过加锁解决；或者系统允许有一定的脏数据存在，因为脏数据一段时间过后会被淘汰，再查数据库更新的缓存就是最新的了。</li>
<li>但是这种方案是虽然读最新数据可能有延迟，但是整体是满足最终一致性的。</li>
</ul>
<h3 id="失效模式"><a href="#失效模式" class="headerlink" title="失效模式"></a>失效模式</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117162628865.png" alt="image-20230117162628865"></p>
<ul>
<li>就是写完数据库，把对应的缓存删掉，直到下一次有请求主动查数据库来更新缓存。</li>
<li>还是会有读脏数据的情况出现，具体情况就是左边那个图，可以通过加锁来解决。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>解决方案无非就是给<strong>缓存数据加上过期时间，保证并发读写的时候加读写锁</strong>，不过这样数据在缓存中更新会产生一定程度的延迟，所以说那些需要频繁写，并且对实时性要求很高的数据，就不要放缓存了，直接查数据库就行了。</p>
</li>
<li><p>永远记住，<strong>缓存只用来保证最终一致性</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117162901916.png" alt="image-20230117162901916"></p>
</li>
<li><p>不过完全解决缓存数据的一致性也可以使用阿里的Canal中间件，Canal会伪装成mysql的一个从服务器，可以通过订阅来监听mysql的变化，一旦mysql发生变化，Canal马上就会去更新缓存，这样我们就把更新缓存的操作和业务代码解耦了；同时Canal也可以做大数据分析，它可以同时订阅多个数据库中的表，每当订阅的表发生改变，Canal就动态分析计算出一个新的表，之后我们可以操作这个新的表来实现一些功能，比如用户智能推荐功能：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117163401840.png" alt="image-20230117163401840"></p>
</li>
<li><p>该项目最终决定采用<strong>失效模式+读写锁</strong>来保证缓存和数据库的数据一致性：</p>
<ul>
<li>缓存的所有数据都有过期时间，数据过期后下一次查询触发主动更新</li>
<li>读写数据的时候，加上分布式的读写锁，对于频繁读，偶尔写的场景，加读写锁对系统的性能影响不大。</li>
</ul>
</li>
</ul>
<h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><ul>
<li><p>为了简化我们使用缓存的操作，spring专门抽取了一个包来<strong>统一不同的缓存技术以供我们进行使用</strong>，这就是Spring Cache。</p>
</li>
<li><p>Spring Cache中主要定义了两个接口，<strong>Cache和CacheManager</strong>，<strong>CacheMannager根据使用的缓存实现不同有很多种实现，其中管理着相同缓存实现下各种各样的根据我们逻辑划分的缓存组件，不过它只是相当于用来定义缓存规则的，其中存放的缓存组件才是真正帮我们crud数据的</strong>：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117171457073.png" alt="image-20230117171457073"></p>
</li>
</ul>
<h3 id="整合Spring-Cache"><a href="#整合Spring-Cache" class="headerlink" title="整合Spring Cache"></a>整合Spring Cache</h3><ul>
<li><p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring-boot-starter-cache.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring-boot-starter-cache.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--spring cache--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-starter-cache.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看其自动配置类CacheAutoConfiguration，发现它会导入RedisCacheConfiguration等配置类，并且自动配置好了redis的缓存管理器RedisCacheManager：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(CacheProperties.class)</span><span class="comment">//这里面配置的都是在配置文件中可以进行配置的东西</span></span><br><span class="line"><span class="comment">//----------------------------------------</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CacheConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">		CacheType[] types = CacheType.values();</span><br><span class="line">		String[] imports = <span class="keyword">new</span> <span class="title class_">String</span>[types.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">			imports[i] = CacheConfigurations.getConfigurationClass(types[i]);<span class="comment">//在这里通过所有缓存的配置类得到了所有类型的缓存</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> imports;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------</span></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">getConfigurationClass</span><span class="params">(CacheType cacheType)</span> &#123;</span><br><span class="line">	Class&lt;?&gt; configurationClass = MAPPINGS.get(cacheType);<span class="comment">//根据缓存类型做映射</span></span><br><span class="line">	Assert.state(configurationClass != <span class="literal">null</span>, () -&gt; <span class="string">&quot;Unknown cache type &quot;</span> + cacheType);</span><br><span class="line">	<span class="keyword">return</span> configurationClass.getName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;CacheType, Class&lt;?&gt;&gt; MAPPINGS;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	Map&lt;CacheType, Class&lt;?&gt;&gt; mappings = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(CacheType.class);</span><br><span class="line">	mappings.put(CacheType.GENERIC, GenericCacheConfiguration.class);</span><br><span class="line">	mappings.put(CacheType.EHCACHE, EhCacheCacheConfiguration.class);</span><br><span class="line">	mappings.put(CacheType.HAZELCAST, HazelcastCacheConfiguration.class);</span><br><span class="line">	mappings.put(CacheType.INFINISPAN, InfinispanCacheConfiguration.class);</span><br><span class="line">	mappings.put(CacheType.JCACHE, JCacheCacheConfiguration.class);</span><br><span class="line">	mappings.put(CacheType.COUCHBASE, CouchbaseCacheConfiguration.class);</span><br><span class="line">	mappings.put(CacheType.REDIS, RedisCacheConfiguration.class);<span class="comment">//在这儿</span></span><br><span class="line">	mappings.put(CacheType.CAFFEINE, CaffeineCacheConfiguration.class);</span><br><span class="line">	mappings.put(CacheType.SIMPLE, SimpleCacheConfiguration.class);</span><br><span class="line">	mappings.put(CacheType.NONE, NoOpCacheConfiguration.class);</span><br><span class="line">	MAPPINGS = Collections.unmodifiableMap(mappings);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="meta">@Bean</span><span class="comment">//向容器中注册了RedisCacheManager</span></span><br><span class="line">RedisCacheManager <span class="title function_">cacheManager</span><span class="params">(CacheProperties cacheProperties, CacheManagerCustomizers cacheManagerCustomizers,</span></span><br><span class="line"><span class="params">		ObjectProvider&lt;org.springframework.data.redis.cache.RedisCacheConfiguration&gt; redisCacheConfiguration,</span></span><br><span class="line"><span class="params">		ObjectProvider&lt;RedisCacheManagerBuilderCustomizer&gt; redisCacheManagerBuilderCustomizers,</span></span><br><span class="line"><span class="params">		RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line">	<span class="type">RedisCacheManagerBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(</span><br><span class="line">			determineConfiguration(cacheProperties, redisCacheConfiguration, resourceLoader.getClassLoader()));</span><br><span class="line">	List&lt;String&gt; cacheNames = cacheProperties.getCacheNames();</span><br><span class="line">	<span class="keyword">if</span> (!cacheNames.isEmpty()) &#123;</span><br><span class="line">		builder.initialCacheNames(<span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(cacheNames));</span><br><span class="line">	&#125;</span><br><span class="line">	redisCacheManagerBuilderCustomizers.orderedStream().forEach((customizer) -&gt; customizer.customize(builder));</span><br><span class="line">	<span class="keyword">return</span> cacheManagerCustomizers.customize(builder.build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在配置文件中配置使用redis作为缓存：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在配置类上开启缓存功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span><span class="comment">//开启缓存功能</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后就可以使用注解来实现功能了：</p>
<ol>
<li>@Cacheable：用在方法上，触发将方法返回的数据保存到缓存的操作</li>
<li>@CacheEvict：用在方法上，触发将方法返回的数据从缓存中删除的操作，可以用作失效模式</li>
<li>@CachePut：用在方法上，在不影响方法执行的情况下更新缓存为方法的返回值，可以用作双写模式</li>
<li>@Caching：用在方法上，组合以上多个操作</li>
<li>@CacheConfig：用在类上，在类的级别共享缓存的相同配置</li>
</ol>
</li>
<li><p>对昨天写的代码用这种方式加缓存，比之前的代码简洁了不是一点半点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般每一个需要缓存的数据我们都来指定要放到哪个名字的逻辑分区中，推荐按照业务类型分区</span></span><br><span class="line"><span class="meta">@Cacheable(&#123;&quot;product-category&quot;&#125;)</span><span class="comment">//代表当前方法的结果需要缓存，如果缓存中有，那么方法可以直接不用调用，然后去缓存中取数据；如果缓存中没有，会调用方法，最后把方法的结果放入缓存中。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;PmsCategory&gt; <span class="title function_">listWithTree</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> listWithTreeFromDb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230117183129988.png" alt="image-20230117183129988"></p>
</li>
</ul>
<h3 id="Cacheable注解"><a href="#Cacheable注解" class="headerlink" title="@Cacheable注解"></a>@Cacheable注解</h3><ul>
<li><p>@Cacheable的默认行为：</p>
<ol>
<li>如果缓存中存在数据，那么方法直接不执行，直接用缓存中的数据</li>
<li>缓存的key默认自动生成，缓存默认的名字是分区名::SimpleKey []</li>
<li>缓存的value，默认使用jdk的序列化机制，将序列化后的数据存到redis中</li>
<li>默认TTL为-1</li>
</ol>
</li>
<li><p>可以用注解中的key属性来指定生成的缓存的key，不过这个属性接收的是一个spEL表达式，这个表达式的语法可以去官方找：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key属性的参数是一个spEL表达式，下面这个表达式的意思是取方法的名字作为参数</span></span><br><span class="line"><span class="meta">@Cacheable(value = &#123;&quot;product-category&quot;&#125;,key = &quot;#root.method.name&quot;)</span><span class="comment">//value参数指定的是分组，key参数指定的是向redis中存放的key的名字</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定缓存数据的TTL，可以在配置文件中统一修改，但是这样做可能会引起缓存雪崩，怎样把定义缓存TTL的粒度降下去呢?</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="comment">#设置缓存类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="comment">#设置ttl为300000毫秒</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="number">300000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将数据保存为json格式怎么搞，要实现这个比较麻烦，通过追踪源码可以得知，spring cache会加载默认的RedisCacheConfiguration，所以我们只需要重新写一个RedisCacheConfiguration加入到Spring IOC容器中覆盖掉之前的那个即可，不过我们自定义后，就不走自动配置那条路了，所以要把自动配置的内容再写一份到我们自定义的那个配置类中以让配置文件中的配置生效，为了方便拿到配置文件中的数据，我们还应该把相应的属性类和当前的配置类进行绑定，这是springboot的内容，我有点不太熟练：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span><span class="comment">//开启缓存功能</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(CacheProperties.class)</span><span class="comment">//为了用CacheProperties，这是springboot的内容</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCacheConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//参数会自动从容器中找</span></span><br><span class="line">    RedisCacheConfiguration <span class="title function_">redisCacheConfiguration</span><span class="params">(CacheProperties cacheProperties)</span>&#123;<span class="comment">//其实容器中有这个，但是我们这样做相当于把之前那个存在的重写了，看源码可以得知，由于走这儿了就不走自动配置了，所以在配置文件中的配置也要写到这里来</span></span><br><span class="line">        <span class="type">RedisCacheConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> RedisCacheConfiguration.defaultCacheConfig();<span class="comment">//新建一个RedisCacheConfiguration</span></span><br><span class="line">        config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>()));<span class="comment">//指定key的序列化方式为string</span></span><br><span class="line">        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">GenericFastJsonRedisSerializer</span>()));<span class="comment">//指定value的序列化方式为json</span></span><br><span class="line">        CacheProperties.<span class="type">Redis</span> <span class="variable">redisProperties</span> <span class="operator">=</span> cacheProperties.getRedis();<span class="comment">//得到redis的配置</span></span><br><span class="line">        <span class="comment">//将配置文件中的所有内容生效，以下大部分内容来自源码</span></span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getTimeToLive() != <span class="literal">null</span>) &#123;</span><br><span class="line">            config = config.entryTtl(redisProperties.getTimeToLive());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (redisProperties.getKeyPrefix() != <span class="literal">null</span>) &#123;</span><br><span class="line">            config = config.prefixCacheNameWith(redisProperties.getKeyPrefix());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isCacheNullValues()) &#123;</span><br><span class="line">            config = config.disableCachingNullValues();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!redisProperties.isUseKeyPrefix()) &#123;</span><br><span class="line">            config = config.disableKeyPrefix();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有几个常用配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="comment">#设置缓存类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="comment">#设置ttl为300000毫秒</span></span><br><span class="line">      <span class="attr">time-to-live:</span> <span class="number">300000</span></span><br><span class="line">      <span class="comment">#设置缓存key的前缀，如果不设置则默认使用缓存组件的名字，可以设置开启或不开启</span></span><br><span class="line">	  <span class="attr">key-prefix:</span> <span class="string">CACHE_</span></span><br><span class="line">	  <span class="attr">use-key-prefix:</span> <span class="literal">true</span></span><br><span class="line">	  <span class="comment">#是否缓存空值，开启可以避免缓存穿透</span></span><br><span class="line">	  <span class="attr">cache-null-values:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="CacheEvict注解"><a href="#CacheEvict注解" class="headerlink" title="@CacheEvict注解"></a>@CacheEvict注解</h3><ul>
<li><p>可以<strong>用在更新&#x2F;删除数据的方法上，每次数据更新都会删掉它的缓存，直到下一次查库主动更新缓存，这样其实就是失效模式的实现</strong>。</p>
</li>
<li><p>删除单个key：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(value = &quot;category&quot;,key = &quot;listWithTree&quot;)</span><span class="comment">//value指定分区，key指定要删除的key的名字</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果有一些场景需要删除多个key（比如级联删除）怎么办？有两个方法：</p>
<ol>
<li><p>首先可以用之间介绍到的@Caching方法组合多个@CacheEvict注解来实现删除多个key：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Caching(evict = &#123;</span></span><br><span class="line"><span class="meta">    @CacheEvict(value = &quot;category&quot;,key = &quot;listWithTree&quot;),</span></span><br><span class="line"><span class="meta">    @CacheEvict(value = &quot;category&quot;,key = &quot;listWithTree2&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后就是可以在@CacheEvict注解中给allEntries属性设置为true，这样它就会把那个分区中的所有缓存都删掉，这个分区只是在spring中标识，其中存着那个key属于哪个分区，实际上redis中不存在什么分区什么的，所以才叫它逻辑分区嘛，所以以后我们尽量把数据分好区，这样删的时候也好删：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheEvict(value = &quot;category&quot;,allEntries = true)</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>推荐开启key的前缀，这样存的key在RedisDesktopManager中会以树形呈现，每一段之间用冒号隔开，比较方便查看。</p>
</li>
</ul>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ul>
<li><strong>在类层面上使用@CacheConfig注解来指定cacheNames</strong>，这样在类中的和缓存相关的注解的cacheNames就都是它指定的了，因此，我们只需要<strong>在方法层面上的注解指定key</strong>就可以了，key可以使用SpEL表达式，比如：”#user.id”就是读取方法参数中名为user的参数中的id变量。<strong>在redis中缓存的key的结构是：”cacheNames::key”</strong></li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>解决<strong>缓存穿透</strong>问题：在配置文件中配置允许缓存空数据：<code>spring.cache.redis.cache-null-values=true</code></li>
<li>解决<strong>缓存击穿</strong>问题：<ol>
<li>自己写本地锁或者是用redisson的分布式锁</li>
<li>将@Cacheable注解的sync属性设置为true，不过其中给的实现是本地锁：<code>@Cacheable(value = &#123;&quot;product-category&quot;&#125;,key = &quot;#root.method.name&quot;,sync = true)</code></li>
</ol>
</li>
<li>解决<strong>缓存雪崩</strong>问题：给数据加上随机的过期时间，给数据加过期时间可以在配置文件中进行配置，时间的单位是毫秒：<code>spring.cache.redis.time-to-live=30000</code></li>
<li>解决<strong>缓存和数据库的一致性</strong>问题：<ol>
<li>读写加锁</li>
<li>引入Canal中间件，感知到MySQL的更新后去更新缓存</li>
<li>对于读少写多的数据，直接去数据库查就行了</li>
</ol>
</li>
<li>对于<strong>常规数据</strong>（读多写少，及时性、一致性要求不高的数据），可以使用Spring Cache，使用的时候对于写模式往往是只要有过期时间就足够了。</li>
<li>对于<strong>特殊数据</strong>，只能具体问题具体分析了，需要特殊的设计，可以结合前面的Redisson分布式锁以及JUC本地锁来实现。</li>
</ul>
<h1 id="2023-x2F-1-x2F-18"><a href="#2023-x2F-1-x2F-18" class="headerlink" title="2023&#x2F;1&#x2F;18"></a>2023&#x2F;1&#x2F;18</h1><h2 id="看到句名言"><a href="#看到句名言" class="headerlink" title="看到句名言"></a>看到句名言</h2><ul>
<li>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</li>
</ul>
<h1 id="2023-x2F-1-x2F-19"><a href="#2023-x2F-1-x2F-19" class="headerlink" title="2023&#x2F;1&#x2F;19"></a>2023&#x2F;1&#x2F;19</h1><h2 id="尝试提前给前端向后端传的数据约定好解析方式"><a href="#尝试提前给前端向后端传的数据约定好解析方式" class="headerlink" title="尝试提前给前端向后端传的数据约定好解析方式"></a>尝试提前给前端向后端传的数据约定好解析方式</h2><ul>
<li>有一些表示我们可以做一下提前的约定，然后后端按照约定去解析条件，比如我想要从前端用一个变量传递一个数字区间到后端，那么我们可以约定这个变量是string的，然后这个string中有两个数字，数字之间用一个下划线分开，那两个数字就是左右边界，那么后端就根据这个约定来解析这个条件后再去做一些操作。</li>
<li>总而言之就是，对于那些前端不好表达的条件，我们可以提前做个约定，约定一下这样的数据前端怎样表示，后端怎样解析，之后我们就可以按照这样的约定去实现对应的功能了。</li>
</ul>
<h2 id="如何完成一个ES的查询"><a href="#如何完成一个ES的查询" class="headerlink" title="如何完成一个ES的查询"></a>如何完成一个ES的查询</h2><ul>
<li>首先根据需求设计出<strong>DSL语句</strong>、<strong>设计VO类封装查询条件</strong></li>
<li>然后在java的service层方法中<strong>使用es提供的api（主要是一些builder）根据DSL语句和传过来的VO查询条件实例结合约定来构建查询</strong></li>
<li>最后就是<strong>执行，然后解析返回的结果</strong>，可以<strong>把解析的结果封装成一个返回结果的实体类</strong>，用于视图数据</li>
</ul>
<h2 id="尝试在VO中使用静态内部类"><a href="#尝试在VO中使用静态内部类" class="headerlink" title="尝试在VO中使用静态内部类"></a>尝试在VO中使用静态内部类</h2><ul>
<li>如果有些类型从逻辑上是属于这个vo，那么我们可以在这个vo中写静态内部类来表示这些类型，从逻辑上看比较合理，维护起来也方便。</li>
</ul>
<h1 id="2023-x2F-1-x2F-20"><a href="#2023-x2F-1-x2F-20" class="headerlink" title="2023&#x2F;1&#x2F;20"></a>2023&#x2F;1&#x2F;20</h1><h2 id="初始化线程的四种方式"><a href="#初始化线程的四种方式" class="headerlink" title="初始化线程的四种方式"></a>初始化线程的四种方式</h2><ol>
<li><p>继承Thread，重写run方法，然后new实例调用start方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread01</span>();</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;这里是main方法线程~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Thread01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用继承Thread类的方式来初始化线程~&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程启动,线程id为：&quot;</span>+<span class="built_in">this</span>.getId());</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;这里是&quot;</span>+<span class="built_in">this</span>.getId()+<span class="string">&quot;号线程~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现Runnable接口，重写run方法，然后把它的实例当作参数传入Thread实例的构造器中，最后用Thread实例调用start方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable01</span>());</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;这里是main方法线程~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Runnable01</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用实现Runnable接口的方式来初始化线程~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现Callable接口+FutureTask（可以拿到返回结果，可以处理异常）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable01</span>());<span class="comment">//也可以接收Runnable的实现类</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        t1.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程返回结果是：&quot;</span>+futureTask.get());<span class="comment">//这个是等待线程执行完毕之后获取结果,当前线程会阻塞在这里</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;这里是main方法线程~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Callable01</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;<span class="comment">//Callable接口的泛型是线程返回值类型</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用实现Runnable接口的方式来初始化线程~&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程启动,线程id为：&quot;</span>+Thread.currentThread().getId());</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程池，每个系统中只有少数线程池，<strong>项目业务中所有的多线程异步任务都应该交给线程池执行</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;()</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        pool.execute(<span class="keyword">new</span> <span class="title class_">Runnable01</span>());</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;这里是main方法线程~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li>第1、2种方式不能得到返回值，第3、4种方式可以得到返回值。</li>
<li>第1、2、3种方式都不能控制资源，第4种方式可以控制资源，性能稳定。</li>
<li>总之，以后业务中所有异步任务都用第4种方式处理，也就是使用线程池。</li>
</ul>
<h2 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h2><ul>
<li><strong>降低资源的消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>：因为线程池中的线程数没有超过线程池的最大线程数时，有的线程处于等待分配任务的状态，当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h2 id="线程池（ThreadPoolExecutor）详解"><a href="#线程池（ThreadPoolExecutor）详解" class="headerlink" title="线程池（ThreadPoolExecutor）详解"></a>线程池（ThreadPoolExecutor）详解</h2><ul>
<li>jdk给我们提供了比较简单的创建线程池的方法，那就是使用Executors类中的方法来创建一些预配置好的线程池，但是阿里巴巴开发手册中不推荐这样的创建方式，主要原因是里面的大部分方法创建的线程池都有OOM的风险，而且几乎不能让程序员能够更深入地理解线程池的各种参数。所以<strong>阿里巴巴开发手册中推荐使用原生创建线程池的方式ThreadPoolExecutor，所有的参数都由自己来进行设置，降低OOM的概率，并且还能加深对于线程池参数的理解</strong>，所以下面的内容都是在详解ThreadPoolExecutor。</li>
<li>值得注意的是，线程池的存在会阻塞住使用线程池的那个线程，所以程序会一直等待任务直至线程池销毁程序才会结束。</li>
</ul>
<h3 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h3><ol>
<li><strong>int corePoolSize</strong>：核心线程数，这些线程按需创建，也就是<strong>懒加载</strong>，一开始没有核心线程创建，直到有任务过来，核心线程被创建，但是任务结束后，核心线程即使空闲也不会销毁（除非设置了核心线程的存活时间），而是重新等待异步任务的到来。当线程池中new的线程数达到核心线程数之后，再有任务过来，任务就会被装到等待队列中，等待核心线程空闲，一旦核心线程有空闲，那么等待队列就会pop出一个任务使用空闲的核心线程来执行。</li>
<li><strong>int maximumPoolSize</strong>：最大线程数，在核心线程都忙碌且任务队列也满着的情况下，如果有任务再来，那么任务队列会pop一个任务，创建一个新的线程去执行它，并把刚来的任务放到任务队列中，刚才新创建的线程不属于核心线程，因为在创建它的时候核心线程已经满了，它也并非是永久存在的，因为第三个参数就是设置了核心线程外空闲线程的存活时间，一旦过了存活时间，这些多出来的<strong>空闲</strong>线程就会被自动销毁以达到控制资源的目的。<strong>最大线程数包括核心线程数</strong>，也就是说还能额外创建的线程数等于最大线程数-核心线程数</li>
<li><strong>long keepAliveTime</strong>：非核心<strong>空闲</strong>线程的存活时间，一旦非核心线程<strong>空闲的时间</strong>达到我们设置的值，那么那个非核心空闲线程就会被摧毁，这样可以达到控制资源的目的。换句话说，这是多余的空闲线程在终止前等待新任务的最长时间。</li>
<li><strong>TimeUnit unit</strong>：时间单位，就是上一个参数的时间单位（秒、毫秒、分啥的），这个没啥好说的</li>
<li><strong>BlockingQueue&lt;Runnable&gt; workQueue</strong>：阻塞队列，这个就是用来指定当核心线程数满且都在忙碌的情况下新来的任务应该装到的任务队列，一旦有线程空闲，那么队列中就会pop出一个任务来使用空闲线程执行。<strong>一定要指定队列大小</strong>，一些阻塞队列的默认容量是int的最大值，在任务数量很多的情况下可能会出现OOM。</li>
<li><strong>ThreadFactory threadFactory</strong>：线程的创建工厂，用于线程池创建新线程的时候，有默认实现（不填该参数或者用Executors.defaultThreadFactory()获得），如果想要自定义可以自己写一个。</li>
<li><strong>RejectedExecutionHandler handler</strong>：拒绝策略，就是指定当线程池和任务队列都满了的情况下，再来任务应该如何处理，有默认实现，默认是使用丢弃策略（不填该参数或者用new ThreadPoolExecutor.AbortPolicy()获得），就是线程池和任务队列都满了的情况下会直接丢弃后来的任务。还有直接调用任务的run方法（这样就是同步而非异步调用了，使用的线程是跑线程池的那个线程）的策略等。</li>
</ol>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120164900396.png" alt="image-20230120164900396"></p>
<h2 id="CompletableFuture异步编排"><a href="#CompletableFuture异步编排" class="headerlink" title="CompletableFuture异步编排"></a>CompletableFuture异步编排</h2><ul>
<li>在我们执行异步任务的时候，可能出现一种情况，就是多个异步任务之间有一定的执行顺序，比如有两个异步任务A、B，异步任务B的执行依赖于异步任务A的返回值，那么这两个异步任务的执行就会有个先后顺序，我们需要对这些异步任务进行编排以让他们按照我们想要的顺序进行执行，那么我们怎么才能实现这种操作呢？可以使用CompletableFuture来做异步编排，这是JDK1.8之后新增的内容。</li>
<li>Future&lt;T&gt;接口：定义异步操作的结果，可以<strong>获取异步结果</strong>。</li>
<li>CompletableFuture就像js中的Promise一样，本质上都是封装了一个有逻辑的异步任务，然后通过链式编程有条不紊地编排任务并执行。</li>
<li>这个类中基本所有的api的返回值类型都是CompletableFuture，这就为我们<strong>链式编排异步任务</strong>提供了方便，<strong>其中的异步方法产生的效果都是针对这一整个异步任务链来说的</strong>，比如后面的allOf方法，并不是说所有异步任务都执行完后再执行当前线程，而是所有的异步任务都执行完后再执行返回的CompletableFuture之后的链上的操作，本质上它还是异步的，和当前线程没有关系。</li>
</ul>
<h3 id="创建异步对象"><a href="#创建异步对象" class="headerlink" title="创建异步对象"></a>创建异步对象</h3><ul>
<li><p>CompletableFuture提供了四个静态方法来创建一个异步操作：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120175236094.png" alt="image-20230120175236094"></p>
</li>
<li><p>可以从上面看到，<strong>runAsync方法是没有返回结果的，supplyAsync方法是有返回结果的</strong>。</p>
</li>
<li><p>传入的异步操作<strong>会用默认的线程池执行，但是也可以传入自定义的线程池，让异步任务用自定义的线程池执行</strong>。</p>
</li>
<li><p><strong>Runnable和Supplier都是函数式接口</strong>，所以这些方法都<strong>可以使用lambda表达式来作为参数</strong>。</p>
</li>
<li><p>runAsync方法使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        CompletableFuture.runAsync(()-&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程~&quot;</span>);</span><br><span class="line">        &#125;,pool);</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>supplyAsync方法使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面那些方法最后都会返回一个Completable类型的结果，我们可以使用这个返回值的方法来做异步编排，就类似于js中的Future中的then方法、error方法啥的</p>
</li>
</ul>
<h3 id="计算完成时的回调方法"><a href="#计算完成时的回调方法" class="headerlink" title="计算完成时的回调方法"></a>计算完成时的回调方法</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120185615279.png" alt="image-20230120185615279"></p>
<ul>
<li><p><strong>whenComplete</strong>可以处理正常和异常的<strong>计算结果</strong>，<strong>exceptionally</strong>处理<strong>异常情况</strong>，带async后缀的是指这个方法仍是交给线程池来异步执行，不带async后缀的就是使用当前线程同步执行。</p>
</li>
<li><p>非常非常非常像js的异步编程，whenComplete就类似js中Promise的then方法，exceptionally就类似js中Promise的error方法。</p>
</li>
<li><p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">0</span>;</span><br><span class="line">        &#125;, pool).whenComplete((res,exception)-&gt;&#123;<span class="comment">//可以获取返回值和异常，但是无法修改返回数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;异步任务成功完成,结果是：&quot;</span>+res+<span class="string">&quot;异常是：&quot;</span>+exception);</span><br><span class="line">        &#125;).exceptionally(exception-&gt;<span class="number">10</span>);<span class="comment">//感知异常，可以修改返回数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="handle方法"><a href="#handle方法" class="headerlink" title="handle方法"></a>handle方法</h3><ul>
<li><p>可对结果做最后的处理，可以处理异常，可以改变返回值等，聚合了之前whenComplete和exceptionally方法的功能。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120190826146.png" alt="image-20230120190826146"></p>
</li>
<li><p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">2</span>;</span><br><span class="line">        &#125;, pool).handle((res,err)-&gt;&#123;</span><br><span class="line">            <span class="keyword">if</span> (res!=<span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="线程串行化方法"><a href="#线程串行化方法" class="headerlink" title="线程串行化方法"></a>线程串行化方法</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120192513872.png" alt="image-20230120192513872">、</p>
<ul>
<li><p>这些方法实际上就可以解决我们之前提出的那个问题，就是如何保证A、B两个异步方法的执行顺序。</p>
</li>
<li><p><strong>thenApply方法</strong>：当一个线程依赖另一个线程的返回结果时，获取上一个任务返回的结果，进行相应操作后，返回当前任务的返回值。带async的是异步执行。</p>
</li>
<li><p><strong>thenAccept方法</strong>：接收上一个任务的返回结果，并消费这个结果进行相应的操作，当前任务无返回结果。带async的是异步执行。</p>
</li>
<li><p><strong>thenRun方法</strong>：无法接收上一个任务的返回结果，上一个任务执行完成后，执行当前任务，当前任务无返回值。带async的是异步执行。</p>
</li>
<li><p>以上方法都在上一个任务执行结束后执行。</p>
</li>
<li><p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程~&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;第一个方法执行~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">0</span>;</span><br><span class="line">        &#125;, pool).thenApply(res-&gt;&#123;<span class="comment">//拿到上一个任务的返回值，做操作，然后再返回，好像Stream的转换流...</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第二个方法执行~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        &#125;).exceptionally(err-&gt;<span class="string">&quot;10&quot;</span>);<span class="comment">//中间任何一个任务出现问题都会直接跳到这里来</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>之前的whenComplete和exceptionally方法都是针对整个异步方法链的，方法链中任何一个地方出现异常都会直接跳到最后的exceptionally方法。</p>
</li>
</ul>
<h3 id="两任务组合-都完成后执行第三个任务"><a href="#两任务组合-都完成后执行第三个任务" class="headerlink" title="两任务组合-都完成后执行第三个任务"></a>两任务组合-都完成后执行第三个任务</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120195142611.png" alt="image-20230120195142611"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120195207076.png" alt="image-20230120195207076"></p>
<ul>
<li><p><strong>thenCombine方法</strong>：组合两个异步任务，获取两个异步任务的返回结果，处理第三个任务，并返回第三个任务的返回结果。带async的是异步执行第三个任务。</p>
</li>
<li><p><strong>thenAcceptBoth方法</strong>：组合两个异步任务，获取两个异步任务的返回结果，处理第三个任务，第三个任务没有返回值。带async的是异步执行第三个任务。</p>
</li>
<li><p><strong>runAfterBoth方法</strong>：组合两个异步任务，不获取两个异步任务的返回结果，处理第三个任务，第三个任务没有返回值。带async的是异步执行第三个任务。</p>
</li>
<li><p><strong>任务三是在以上方法的参数中定义的</strong>。</p>
</li>
<li><p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程1~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">2</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程2~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">5</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future03 = future01.thenCombineAsync(future02,(e1,e2)-&gt;e1+e2,pool).exceptionally(err-&gt;<span class="number">10</span>);<span class="comment">//任务1、2都结束后任务3才开始,这个方法任务3可以拿到任务1、2的返回值，并且任务3也能有返回值</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future03.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="两任务组合-一个任务完成后执行第三个任务"><a href="#两任务组合-一个任务完成后执行第三个任务" class="headerlink" title="两任务组合-一个任务完成后执行第三个任务"></a>两任务组合-一个任务完成后执行第三个任务</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120214254090.png" alt="image-20230120214254090"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120214317865.png" alt="image-20230120214317865"></p>
<ul>
<li><p><strong>applyToEither方法</strong>：两个任务中有一个任务完成后，获取它的返回值，处理第三个任务，并有新的返回值。带async的是异步执行第三个任务。</p>
</li>
<li><p><strong>acceptEither方法</strong>：两个任务中有一个任务完成后，获取它的返回值，处理第三个任务，没有新的返回值。带async的是异步执行第三个任务。</p>
</li>
<li><p><strong>runAfterEither方法</strong>：两个任务中有一个任务完成后，不获取它的返回值，处理第三个任务，没有新的返回值。带async的是异步执行第三个任务。</p>
</li>
<li><p><strong>任务一、二的返回值类型要相同</strong>，不然任务三都不知道怎么接收上一个任务的参数了。</p>
</li>
<li><p><strong>任务三是在以上方法的参数中定义的</strong>。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//睡上一觉模拟第一个任务执行较慢，看看任务3能否在任务2结束后顺利执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程1~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">2</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程2~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">5</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line">        </span><br><span class="line">        CompletableFuture&lt;Integer&gt; future03 = future01.applyToEitherAsync(future02,e-&gt;e,pool).exceptionally(err-&gt;<span class="number">10</span>);<span class="comment">//任务1、2的其中一个任务结束后任务3就会开始,这个方法任务3可以拿到先结束的那个任务的返回值，并且任务3也能有返回值</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;新线程的返回值是：&quot;</span>+future03.get());<span class="comment">//阻塞获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="多任务组合"><a href="#多任务组合" class="headerlink" title="多任务组合"></a>多任务组合</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230120220345334.png" alt="image-20230120220345334"></p>
<ul>
<li><p><strong>allOf方法</strong>：等待所有任务都完成后，再执行返回的CompletableFuture后面的操作，不能获取任务的返回值。</p>
</li>
<li><p><strong>anyOf方法</strong>：只要有一个任务完成，就执行返回的CompletableFuture后面的操作，可以获取第一个完成的任务的返回值。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//睡上一觉模拟第一个任务执行较慢，看看任务3能否在任务2结束后顺利执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程1~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">2</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程2~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">5</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future03 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程3~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Void&gt; future04 = CompletableFuture.allOf(future01, future02, future03);<span class="comment">//必须所有任务都执行完，才可以执行future04后面的操作</span></span><br><span class="line">        future04.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            <span class="number">20</span>,</span><br><span class="line">            <span class="number">30</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(),</span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()<span class="comment">//淘汰策略</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的开始~&quot;</span>);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future01 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);<span class="comment">//睡上一觉模拟第一个任务执行较慢，看看任务3能否在任务2结束后顺利执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程1~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">2</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future02 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程2~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">5</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Integer&gt; future03 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是个新线程3~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>/<span class="number">10</span>;</span><br><span class="line">        &#125;, pool);</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Object&gt; future04 = CompletableFuture.anyOf(future01, future02, future03);<span class="comment">//只要有一个任务执行完，那么就可以执行future04后面的操作了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最先执行完的那个任务的返回值是：&quot;</span>+future04.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;main方法所在线程的结束~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="使用异步编排来获取一个网页的资源"><a href="#使用异步编排来获取一个网页的资源" class="headerlink" title="使用异步编排来获取一个网页的资源"></a>使用异步编排来获取一个网页的资源</h2><ul>
<li>如果获取网页资源的操作都是同步的，那么加载一个页面需要的时间是很长的，所以我们可以使用异步的方法来加载网页资源，这样网页资源加载完成的时间就只取决于所有异步操作中最慢的那个了，但是由于加载资源的异步操作可能有顺序上的要求，所以我们要对这些异步请求资源的方法来进行异步编排来保证最终结果的正确性。</li>
</ul>
<h1 id="2023-x2F-1-x2F-23"><a href="#2023-x2F-1-x2F-23" class="headerlink" title="2023&#x2F;1&#x2F;23"></a>2023&#x2F;1&#x2F;23</h1><h2 id="快速定位网页元素在代码中的位置"><a href="#快速定位网页元素在代码中的位置" class="headerlink" title="快速定位网页元素在代码中的位置"></a>快速定位网页元素在代码中的位置</h2><ul>
<li>页面跑起来之后打开浏览器的开发者工具（摁f12），然后点最左上角的按钮（审查元素），然后点击想要定位的元素，就能跳转到指定元素在代码中对应的位置了。</li>
</ul>
<h2 id="ToString注解"><a href="#ToString注解" class="headerlink" title="@ToString注解"></a>@ToString注解</h2><ul>
<li>是lombok中的一个注解，将该注解写在类上，可以自动生成该类的toString方法。</li>
</ul>
<h2 id="如何在MyBatis的xml文件中引用一个内部类"><a href="#如何在MyBatis的xml文件中引用一个内部类" class="headerlink" title="如何在MyBatis的xml文件中引用一个内部类"></a>如何在MyBatis的xml文件中引用一个内部类</h2><ul>
<li><p>MyBatis的xml文件的标签中的很多属性都要求给一个完全类路径的参数，别的类没啥问题，但是<strong>如果要是使用到内部类，那么在传参的时候最后一个分隔符不能用“.”，而应该用“$”</strong>，要不然就会报无法解析那个内部类的错误。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;SpuItemAttrGroupVo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.konjacer.mallisland.product.entity.vo.SkuItemVo$SpuItemAttrGroupVo&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="对于有嵌套属性的返回值使用MyBatis的自定义结果集封装"><a href="#对于有嵌套属性的返回值使用MyBatis的自定义结果集封装" class="headerlink" title="对于有嵌套属性的返回值使用MyBatis的自定义结果集封装"></a>对于有嵌套属性的返回值使用MyBatis的自定义结果集封装</h2><ul>
<li><p>对于写在xml文件中的sql语句的<strong>有嵌套属性的返回值</strong>，我们应该创建一个resultMap并在crud标签的<strong>resultMap属性</strong>指定成我们自定义的resultMap，这样做可以使得查出来的数据能够准确地映射到我们指定的位置，其中的嵌套属性中的数据我们需要手动和查出来的数据作映射，这样查出来的数据就可以映射到嵌套属性中了。如果不使用自定义的resultMap，那么mybatis不知道怎么把查出来的结果和返回值中的嵌套属性做映射，返回的结果就会出错。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--返回值中有嵌套属性的，要声明自定义的结果集来作为最后的返回值，不然mybatis不知道怎么把数据映射到嵌套属性中。注意内部类完全路径的写法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;SpuItemAttrGroupVo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.konjacer.mallisland.product.entity.vo.SkuItemVo$SpuItemAttrGroupVo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;groupName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;attr_group_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置其中的集合属性的映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;attrs&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.konjacer.mallisland.product.entity.vo.SkuItemVo$SpuBaseAttrVo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;attr_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;attrName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;attr_value&quot;</span> <span class="attr">property</span>=<span class="string">&quot;attrValue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--resultType声明的是返回的集合类型里面元素的类型--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--此处的联表查询只是为了熟悉操作，真正开发时尽量不要使用联表查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAttrGroupWithAttrsBySpuId&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">&quot;SpuItemAttrGroupVo&quot;</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">        pav.`spu_id`,ag.`attr_group_name`,ag.`attr_group_id`,</span><br><span class="line">        aar.`attr_id`,attr.`attr_id`,pav.`attr_value`</span><br><span class="line">    FROM `pms_attr_group` ag</span><br><span class="line">        LEFT JOIN `pms_attr_attrgroup_relation` aar ON aar.`attr_group_id` = ag.`attr_group_id`</span><br><span class="line">        LEFT JOIN `pms_attr` attr ON attr.`attr_id` = aar.`attr_id`</span><br><span class="line">        LEFT JOIN `pms_product_attr_value` pav ON pav.`attr_id` = attr.`attr_id`</span><br><span class="line">    WHERE ag.catelog_id = #&#123;catalogId&#125; AND pav.`spu_id` = #&#123;spuId&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="将对应的配置和实体类进行绑定"><a href="#将对应的配置和实体类进行绑定" class="headerlink" title="将对应的配置和实体类进行绑定"></a>将对应的配置和实体类进行绑定</h2><ul>
<li><p>先导入一个包以开启和配置相关的代码提示，不导入这个包也不影响后续的操作：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启springboot和配置相关的代码提示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>需要用到注解**<code>@ConfigurationProperties</code><strong>，该注解可以把配置文件中指定前缀的配置和被其修饰的类绑定，类中的</strong>非静态属性<strong>可以通过</strong>前缀和属性名**在配置文件中进行配置。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mallisland.thread&quot;)</span><span class="comment">//指定要绑定的前缀</span></span><br><span class="line"><span class="meta">@Component</span><span class="comment">//注册到IOC容器中方便后续使用</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolConfigProperties</span> &#123;<span class="comment">//配置实体类</span></span><br><span class="line">    <span class="keyword">private</span> Integer coreSize;</span><br><span class="line">    <span class="keyword">private</span> Integer maxSize;</span><br><span class="line">    <span class="keyword">private</span> Integer keepAliveTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置线程池的相关属性，用的是自定义的配置实体类，使用前缀+属性名来对实体类中的属性进行配置</span></span><br><span class="line"><span class="attr">mallisland:</span></span><br><span class="line">  <span class="attr">thread:</span></span><br><span class="line">    <span class="attr">core-size:</span> <span class="number">20</span></span><br><span class="line">    <span class="attr">max-size:</span> <span class="number">200</span></span><br><span class="line">    <span class="attr">keep-alive-time:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>要想使用自定义的配置实体类，可以使用相应注解将其加入到ioc容器中。还有一点就是，<strong>被@Bean修饰的方法的参数可以自动注入，不需要任何额外的注解</strong>，使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">threadPool</span><span class="params">(ThreadPoolConfigProperties pool)</span>&#123;<span class="comment">//参数自动注入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            pool.getCoreSize(),</span><br><span class="line">            pool.getMaxSize(),</span><br><span class="line">            pool.getKeepAliveTime(),</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100000</span>),</span><br><span class="line">            Executors.defaultThreadFactory(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">            );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>除了将自定义的配置实体类加入到ioc容器中外，还可以通过给<strong>配置类</strong>加上**<code>@EnableConfigurationProperties</code>**注解来开启对应的配置实体类，将指定的类注入到ioc容器中，使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ThreadPoolConfigProperties.class)</span><span class="comment">//开启使用指定的配置实体类，将指定的类注册进ioc容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ThreadPoolExecutor <span class="title function_">threadPool</span><span class="params">(ThreadPoolConfigProperties pool)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                pool.getCoreSize(),</span><br><span class="line">                pool.getMaxSize(),</span><br><span class="line">                pool.getKeepAliveTime(),</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="number">100000</span>),</span><br><span class="line">                Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="给模块添加一个线程池"><a href="#给模块添加一个线程池" class="headerlink" title="给模块添加一个线程池"></a>给模块添加一个线程池</h2><ul>
<li>可以<strong>在配置类中new一个线程池通过@Bean注解注册到ioc容器中</strong></li>
<li>然后线程池的参数应该是可在配置文件中配置的，所以我们要<strong>写一个配置实体类来表示我们允许配置的属性</strong></li>
<li>然后<strong>将配置实体类和对应前缀的配置绑定</strong>，这样以后我们就能通过在配置文件中配置的方式来改变配置实体类中的属性值了</li>
<li>然后我们<strong>将配置实体类注册到ioc容器中</strong>，之后就可以在创建线程池的方法中使用配置实体类的属性值作为线程池的参数了。</li>
</ul>
<h2 id="对业务逻辑进行异步编排优化示例"><a href="#对业务逻辑进行异步编排优化示例" class="headerlink" title="对业务逻辑进行异步编排优化示例"></a>对业务逻辑进行异步编排优化示例</h2><ul>
<li><p>其中第2、3、4个任务只依赖于第1个任务的返回值，第5个任务不依赖任何返回值，除了第1个任务外都没有返回值，所以先异步执行任务1、5（无先后顺序），然后得到1的返回值后再异步执行任务2、3、4（无先后顺序），最后通过<strong>使用allOf方法和get方法阻塞直到所有任务完成（真正起到阻塞当前线程的是get方法，allof方法只是阻塞了异步任务链）</strong>然后返回结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> SkuItemVo <span class="title function_">item</span><span class="params">(String skuId)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">SkuItemVo</span> <span class="variable">skuItemVo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SkuItemVo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sku基本信息获取,查pms_sku_info</span></span><br><span class="line">    CompletableFuture&lt;PmsSkuInfo&gt; infoFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="type">PmsSkuInfo</span> <span class="variable">info</span> <span class="operator">=</span> getById(skuId);</span><br><span class="line">        skuItemVo.setInfo(info);</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取spu的销售属性组合，依赖于第一个任务的返回值</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; saleAttrFuture = infoFuture.thenAcceptAsync((res) -&gt; &#123;</span><br><span class="line">        List&lt;SkuItemVo.SkuItemSaleAttrVo&gt; saleAttrVos = pmsSkuSaleAttrValueService.getSaleAttrsBySpuId(res.getSpuId());</span><br><span class="line">        skuItemVo.setSaleAttr(saleAttrVos);</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取spu的介绍,查pms_spu_info_desc，依赖于第一个任务的返回值</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; descFuture = infoFuture.thenAcceptAsync((res) -&gt; &#123;</span><br><span class="line">        <span class="type">PmsSpuInfoDesc</span> <span class="variable">spuInfoDescEntity</span> <span class="operator">=</span> pmsSpuInfoDescService.getById(res.getSpuId());</span><br><span class="line">        skuItemVo.setDesp(spuInfoDescEntity);</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取spu的规格参数信息，依赖于第一个任务的返回值</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; baseAttrFuture = infoFuture.thenAcceptAsync((res) -&gt; &#123;</span><br><span class="line">        List&lt;SkuItemVo.SpuItemAttrGroupVo&gt; attrGroupVos = pmsAttrGroupService.getAttrGroupWithAttrsBySpuId(res.getSpuId(), res.getCatalogId());</span><br><span class="line">        skuItemVo.setGroupAttrs(attrGroupVos);</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取sku的图片信息，查pms_sku_images</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; imageFuture = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        List&lt;PmsSkuImages&gt; images = pmsSkuImagesService.getImagesBySkuId(skuId);</span><br><span class="line">        skuItemVo.setImages(images);</span><br><span class="line">    &#125;, threadPool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞等待直到所有任务都完成，后面的get方法是必须的，不然没有阻塞当前线程的效果，会还没等任务都完成就返回了，因为这里的allOf方法是针对异步任务链来说的，本质上allOf还是异步任务</span></span><br><span class="line">    CompletableFuture</span><br><span class="line">            .allOf(infoFuture,saleAttrFuture,descFuture,baseAttrFuture,imageFuture)</span><br><span class="line">            .get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> skuItemVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2023-x2F-1-x2F-24"><a href="#2023-x2F-1-x2F-24" class="headerlink" title="2023&#x2F;1&#x2F;24"></a>2023&#x2F;1&#x2F;24</h1><h2 id="注册组件的时候一定使用准确的注解"><a href="#注册组件的时候一定使用准确的注解" class="headerlink" title="注册组件的时候一定使用准确的注解"></a>注册组件的时候一定使用准确的注解</h2><ul>
<li>就是某一层的组件往ioc容器里注册的时候就应该使用对应层的注册组件的注解，比如Controller层用@Controller注解，Service层用@Service注解，dao层用@Repository，普通的组件用@Component。</li>
<li>之前一直以为这四个注解完全相同，现在才直到<strong>这些组件或多或少都会有一点自己特化的功能（比如被@Controller 注解的bean会被spring-mvc框架所使用；被@Repository 注解的bean会被作为持久层操作（数据库）的bean来使用），有的时候用错可能会出问题，所以一定要保证使用的注解是对应层的注解</strong>。</li>
</ul>
<h2 id="使用SpringMVC的内容配置视图映射"><a href="#使用SpringMVC的内容配置视图映射" class="headerlink" title="使用SpringMVC的内容配置视图映射"></a>使用SpringMVC的内容配置视图映射</h2><ul>
<li><p>省的写页面跳转的Controller了，代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallislandWebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;<span class="comment">//配置视图映射</span></span><br><span class="line">        registry.addViewController(<span class="string">&quot;/login.html&quot;</span>).setViewName(<span class="string">&quot;login&quot;</span>);<span class="comment">//设置视图名称会结合themeleaf中的前后缀形成完整的跳转路径</span></span><br><span class="line">        registry.addViewController(<span class="string">&quot;/reg.html&quot;</span>).setViewName(<span class="string">&quot;reg&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>值得注意的是这种映射方式只有get方式才能访问到，因为要进行转发，而转发的对象要求使用get方式进行访问。</p>
</li>
</ul>
<h2 id="整合阿里云短信服务（SMS）"><a href="#整合阿里云短信服务（SMS）" class="headerlink" title="整合阿里云短信服务（SMS）"></a>整合阿里云短信服务（SMS）</h2><ul>
<li><p>其实就是跟着官网的api文档来，然后一步步修修改改，核心代码抽一抽，解解耦，做做组件，映射一下组件的非静态属性到配置文件，指不定哪天官网又改了调用api的方式了，所以下面的内容仅供参考。</p>
</li>
<li><p>先<strong>在第三方服务的模块中整合阿里云短信服务并暴露接口</strong></p>
</li>
<li><p>首先根据官网的提示，先引入SMS服务用到的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--阿里云短信服务的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dysmsapi20170525<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后把官网给的示例代码改改做成一个ioc组件，把一些可配置的内容抽出去变成非静态属性，并将它们和配置文件中指定的前缀绑定，这样我们就可以在配置文件中配置这些内容了。<strong>本质上这个服务还是向阿里云的指定域名发送请求</strong>，请求参数可以自定义以实现不同的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.cloud.alicloud&quot;)</span><span class="comment">//和配置文件指定前缀的配置进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下五个变量做成可配置的，从配置文件中读取值赋值给属性是基于属性的set方法的，所以类上要加@Data注解</span></span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> <span class="string">&quot;dysmsapi.aliyuncs.com&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">templateCode</span> <span class="operator">=</span> <span class="string">&quot;SMS_154950909&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">signName</span> <span class="operator">=</span> <span class="string">&quot;阿里云短信测试&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用AK&amp;SK初始化账号Client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> com.aliyun.dysmsapi20170525.Client <span class="title function_">createClient</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        com.aliyun.teaopenapi.models.<span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.teaopenapi.models.Config()</span><br><span class="line">                <span class="comment">// 必填，您的 AccessKey ID</span></span><br><span class="line">                .setAccessKeyId(accessKey)</span><br><span class="line">                <span class="comment">// 必填，您的 AccessKey Secret</span></span><br><span class="line">                .setAccessKeySecret(secretKey);</span><br><span class="line">        <span class="comment">// 访问的域名</span></span><br><span class="line">        config.endpoint = endpoint;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.dysmsapi20170525.Client(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSmsCode</span><span class="params">(String phoneNum,String code)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//System.out.println(accessKey+&quot; &quot;+secretKey);</span></span><br><span class="line">        <span class="comment">// 工程代码泄露可能会导致AccessKey泄露，并威胁账号下所有资源的安全性。以下代码示例仅供参考，建议使用更安全的 STS 方式，更多鉴权访问方式请参见：https://help.aliyun.com/document_detail/378657.html</span></span><br><span class="line">        com.aliyun.dysmsapi20170525.<span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> createClient();</span><br><span class="line">        com.aliyun.dysmsapi20170525.models.<span class="type">SendSmsRequest</span> <span class="variable">sendSmsRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.dysmsapi20170525.models.SendSmsRequest();</span><br><span class="line">        <span class="comment">//设置请求参数</span></span><br><span class="line">        sendSmsRequest</span><br><span class="line">                .setPhoneNumbers(phoneNum)<span class="comment">//电话号码</span></span><br><span class="line">                .setSignName(signName)<span class="comment">//短信签名名称</span></span><br><span class="line">                .setTemplateCode(templateCode)<span class="comment">//短信模板Code</span></span><br><span class="line">                .setTemplateParam(<span class="string">&quot;&#123;\&quot;code\&quot;:\&quot;&quot;</span>+code+<span class="string">&quot;\&quot;&#125;&quot;</span>);<span class="comment">//短信模板变量对应的实际值</span></span><br><span class="line">        com.aliyun.teautil.models.<span class="type">RuntimeOptions</span> <span class="variable">runtime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.aliyun.teautil.models.RuntimeOptions();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 复制代码运行请自行打印 API 的返回值</span></span><br><span class="line">            <span class="type">SendSmsResponse</span> <span class="variable">sendSmsResponse</span> <span class="operator">=</span> client.sendSmsWithOptions(sendSmsRequest, runtime);</span><br><span class="line">            System.out.println(sendSmsResponse.getStatusCode()+<span class="string">&quot; &quot;</span>+sendSmsResponse.getBody().getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TeaException error) &#123;</span><br><span class="line">            <span class="comment">// 如有需要，请打印 error</span></span><br><span class="line">            System.out.println(error);</span><br><span class="line">            com.aliyun.teautil.Common.assertAsString(error.message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception _error) &#123;</span><br><span class="line">            <span class="type">TeaException</span> <span class="variable">error</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeaException</span>(_error.getMessage(), _error);</span><br><span class="line">            <span class="comment">// 如有需要，请打印 error</span></span><br><span class="line">            System.out.println(error);</span><br><span class="line">            com.aliyun.teautil.Common.assertAsString(error.message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面这个Component还能做优化，上面这样的写法虽然它整体是单例的，但是<strong>每次调用其中的方法时都会重新创建一个相同的client对象，这样就造成了性能的浪费，所以可以把重复创建的那个对象放到配置类中当成Bean注册给IOC容器，这样就能保证调用方法时不会重新创建对象（利用了Bean默认作用域是单例模式生成的性质）</strong>。</p>
</li>
<li><p>然后就是<strong>在第三方服务模块向外提供服务接口</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sms&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgController</span> &#123;<span class="comment">//阿里云短信服务的Controller</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SmsComponent smsComponent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供给别的服务进行调用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> phone 电话号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code 想发的验证码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/sendCode&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone,<span class="meta">@RequestParam(&quot;code&quot;)</span> String code)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//System.out.println(phone);</span></span><br><span class="line">        smsComponent.sendSmsCode(phone,code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后就是<strong>在认证中心使用服务接口向外提供短信发送的接口</strong>，要考虑的问题很多，比如说验证码要再次检查怎么办？验证码有效时间10分钟怎么搞？验证码60s内不能重复发送怎么搞？接口防刷怎么搞？可以通过引入redis解决部分问题，第一个问题可以解决，把验证码存到redis中，验证的时候直接拿就行；第二个问题也好解决，就是给放入缓存的数据加上ttl，到期就被淘汰，验证码也就失效了；第三个问题可以在存放验证码的时候，后缀带上个系统时间，然后每次发验证码的时候都检查当前时间是不是在缓存的时间的60s开外，如果不在，直接返回失败信息；最后一个问题之后再解决把：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ThirdFeignService thirdFeignService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/sms/sendCode&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone)</span>&#123;</span><br><span class="line">        <span class="comment">//todo 接口防刷</span></span><br><span class="line">        <span class="comment">//防止同一个手机号在60s内再发送验证码，我们可以给验证码带上系统时间的后缀，再想发的时候检查缓存中验证码的时间是否在60s之前。进来先检查这个</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">redisCode</span> <span class="operator">=</span> redisTemplate.opsForValue().get(AuthServerConstant.SmsConstant.SMS_CODE_CACHE_PREFIX.getValue()+phone);</span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.isEmpty(redisCode)) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">timeBefore</span> <span class="operator">=</span> Long.parseLong(redisCode.split(<span class="string">&quot;_&quot;</span>)[<span class="number">1</span>]);<span class="comment">//获取缓存中记录的上次添加验证码到缓存的时间</span></span><br><span class="line">            <span class="keyword">if</span> (System.currentTimeMillis() - timeBefore &lt; <span class="number">60000</span>) &#123;<span class="comment">//如果这次请求在上次请求的60s内，直接失败</span></span><br><span class="line">                <span class="keyword">return</span> Result</span><br><span class="line">                        .error()</span><br><span class="line">                        .code(ResultCode.SMS_CODE_EXCEPTION.getCode())</span><br><span class="line">                        .message(ResultCode.SMS_CODE_EXCEPTION.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取随机四位数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> String.valueOf((<span class="type">int</span>)(Math.random()*<span class="number">9000</span>+<span class="number">1000</span>));</span><br><span class="line">        <span class="comment">//为了验证码的再次校验，验证码暂时存到redis中,key是服务前缀+手机号防止撞key，value是验证码，要带上ttl，一般验证码不是都是几分钟就过期嘛</span></span><br><span class="line">        <span class="comment">//给验证码带上系统时间后缀，方便下次请求时检验请求是否是在60s之内发送的</span></span><br><span class="line">        redisTemplate.opsForValue().set(AuthServerConstant.SmsConstant.SMS_CODE_CACHE_PREFIX.getValue()+phone,code+<span class="string">&quot;_&quot;</span>+System.currentTimeMillis(),<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">        <span class="comment">//远程调用发送验证码的方法</span></span><br><span class="line">        thirdFeignService.sendCode(phone,code);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="给缓存到redis中的数据的key增加前缀"><a href="#给缓存到redis中的数据的key增加前缀" class="headerlink" title="给缓存到redis中的数据的key增加前缀"></a>给缓存到redis中的数据的key增加前缀</h2><ul>
<li>这个可以<strong>避免key的冲突</strong>，比如说我想缓存一个手机号的key，但是很多个服务都想要缓存这个key，那么我们在缓存的时候就产生了key的冲突，所以解决方法就是，每个服务有自己的缓存前缀（可以写成常量），无论是向redis中写还是查，都带着这个前缀来标识自己是哪个服务缓存的数据，这样在缓存或者查询的时候就不会产生key冲突了。</li>
</ul>
<h1 id="2023-x2F-1-x2F-25"><a href="#2023-x2F-1-x2F-25" class="headerlink" title="2023&#x2F;1&#x2F;25"></a>2023&#x2F;1&#x2F;25</h1><h2 id="MD5盐值加密"><a href="#MD5盐值加密" class="headerlink" title="MD5盐值加密"></a>MD5盐值加密</h2><h3 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h3><ul>
<li>即Message Digest Algorithm 5，是一种信息摘要算法</li>
<li><strong>压缩性</strong>：任意长度的数据，算出的MD5值的长度可以固定</li>
<li><strong>容易计算</strong>：从原数据计算出MD5值很容易</li>
<li><strong>抗修改性</strong>：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大的区别</li>
<li><strong>强抗碰撞性</strong>：想找到两个不同的数据使它们具有相同的MD5值，是非常困难的</li>
<li><strong>不可逆性</strong>：无法通过MD5值推算出原数据，网上那些所谓的MD5解析，是利用MD5值的抗修改性，从彩虹表（一个用于加密散列函数 逆运算的预先计算好的表 ）中查已经计算出的MD5的值对应的明文，遇到彩虹表中没有的MD5值，它就无法解析了。</li>
</ul>
<h3 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a>加盐</h3><ul>
<li>直接向数据库中存放MD5值就很安全吗？比裸奔是安全不少，但是还不够，因为<strong>黑客有可能拿着数据库中的MD5值去彩虹表中查，万一有些人设置的密码强度不够，那么很容易密码就会被破解出来</strong>。</li>
<li>所以不能单纯使用计算出的MD5值，我们可以<strong>通过生成随机数与明文数据进行组合后再计算MD5值（也就是给数据加盐），将最后计算出的结果作为存放在数据库中的数据</strong>。</li>
<li>而对于加的盐值，我们也得找地方存，<strong>可以存在数据库中，但是这样的话，黑客破解数据库后很容易就能取得盐值</strong>。也可以存到最后生成的MD5值中，spring家的<strong>BCryptPasswordEncoder</strong>类中的encode方法是<strong>将盐值存放到了最后生成的密文中</strong>，也就是说，通过特定的操作，可以从最后的密文中分离出盐值，这样做安全性就很高了，因为<strong>黑客并不知道怎么分离盐值，就算黑客得到了盐值，由于盐值是随机的，黑客无法利用已有的彩虹表，必须从头开始构建一个彩虹表来进行暴力破解，大大加大了黑客的破解成本</strong>。</li>
<li>在<strong>进行数据校验的时候我们需要组合盐值和用户输入数据之后再去计算MD5值进行校验</strong>。</li>
</ul>
<h2 id="用户注册后端实现"><a href="#用户注册后端实现" class="headerlink" title="用户注册后端实现"></a>用户注册后端实现</h2><ul>
<li><p>先在认证中心过了验证码的验证，然后远程调用会员模块的接口来将用户的数据存到数据库中。</p>
</li>
<li><p>细节还挺多的，首先就是<strong>后端校验数据，收集校验错误信息</strong>；然后就是<strong>从redis中拿验证码来和用户传过来的做对比校验，涉及验证码过期和验证码不匹配的情况，验证通过后要删除缓存（令牌机制）</strong>；然后就是<strong>远程调用用户模块来进行注册，可能成功也可能失败</strong>，用户注册的时候密码不能使用明文存储，使用spring家提供的<strong>BCryptPasswordEncoder</strong>类来做<strong>MD5盐值加密</strong>。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/regist&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">regist</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> UserRegistVo vo, BindingResult bindingResult)</span>&#123;</span><br><span class="line">    <span class="comment">//todo 重定向携带数据，利用session原理。将数据放到session中。只要跳到下一个页面取出这个数据后，session里面的数据就会删掉</span></span><br><span class="line">    <span class="comment">//todo 分布式下的session问题</span></span><br><span class="line">    <span class="keyword">if</span>(bindingResult.hasErrors())&#123;</span><br><span class="line">        <span class="comment">//收集所有错误信息，构造成一个map</span></span><br><span class="line">        Map&lt;String,String&gt; errors = bindingResult.getFieldErrors()</span><br><span class="line">                .stream()</span><br><span class="line">                .collect(Collectors.toMap(FieldError::getField,FieldError::getDefaultMessage));</span><br><span class="line">        <span class="keyword">return</span> Result.error().data(<span class="string">&quot;errors&quot;</span>,errors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//校验验证码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> vo.getCode();</span><br><span class="line">    <span class="type">String</span> <span class="variable">redisResult</span> <span class="operator">=</span> redisTemplate.opsForValue().get(AuthServerConstant.SmsConstant.SMS_CODE_CACHE_PREFIX.getValue()+vo.getPhone());</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isEmpty(redisResult))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error().message(<span class="string">&quot;验证码已过期&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!code.equals(redisResult.split(<span class="string">&quot;_&quot;</span>)[<span class="number">0</span>]))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.error().message(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//验证码校验成功后删除验证码,令牌机制，只用一次</span></span><br><span class="line">    redisTemplate.delete(AuthServerConstant.SmsConstant.SMS_CODE_CACHE_PREFIX.getValue()+vo.getPhone());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用远程服务进行注册,可能成功也可能失败</span></span><br><span class="line">    <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> memberFeignService.regist(vo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>会员模块中保存用户数据的Service层方法，<strong>主要关注MD5盐值加密和自定义异常抛出</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UmsMemberLevelMapper umsMemberLevelMapper;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">regist</span><span class="params">(MemberRegistVo vo)</span> <span class="keyword">throws</span> PhoneExistException,UsernameExistException&#123;</span><br><span class="line">    <span class="type">UmsMember</span> <span class="variable">member</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UmsMember</span>();</span><br><span class="line">    <span class="comment">//设置默认等级</span></span><br><span class="line">    <span class="comment">//UmsMemberLevel level = umsMemberLevelMapper.getDefaultLevel();</span></span><br><span class="line">    <span class="comment">//member.setLevelId(level.getId());</span></span><br><span class="line">    <span class="comment">//设置传过来的那些数据</span></span><br><span class="line">    <span class="comment">//检查用户名和手机号是否唯一</span></span><br><span class="line">    <span class="keyword">if</span>(checkPhoneUnique(vo.getPhone()))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">PhoneExistException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(checkUsernameUnique(vo.getUsername()))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameExistException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    member.setUsername(vo.getUsername());</span><br><span class="line">    member.setMobile(vo.getPhone());</span><br><span class="line">    <span class="comment">//密码要进行加密存储,MD5加盐加密,spring家这个加盐算法就是能从最后的结果中解析出盐值来，但是怎么解析不知道，安全性就在这里体现</span></span><br><span class="line">    <span class="type">BCryptPasswordEncoder</span> <span class="variable">passwordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">encode</span> <span class="operator">=</span> passwordEncoder.encode(vo.getPassword());</span><br><span class="line">    member.setPassword(encode);</span><br><span class="line">    <span class="comment">//设置其他的默认信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> save(member);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPhoneUnique</span><span class="params">(String phone)</span>&#123;<span class="comment">//返回手机号是否存在，true就是已经存在，false就是不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.baseMapper.selectCount(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;UmsMember&gt;().eq(<span class="string">&quot;mobile&quot;</span>,phone))&gt;<span class="number">0</span>;<span class="comment">//查满足条件的记录的数量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkUsernameUnique</span><span class="params">(String username)</span>&#123;<span class="comment">//返回用户名是否存在，true就是已经存在，false就是不存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.baseMapper.selectCount(<span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;UmsMember&gt;().eq(<span class="string">&quot;username&quot;</span>,username))&gt;<span class="number">0</span>;<span class="comment">//查满足条件的记录的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>会员模块中保存用户数据的Controller层方法，<strong>主要关注针对不同异常使用相应的错误码返回</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/regist&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">regist</span><span class="params">(<span class="meta">@RequestBody</span> MemberRegistVo vo)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> umsMemberService.regist(vo)?Result.ok():Result.error();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (PhoneExistException e)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">return</span> Result</span><br><span class="line">                .error()</span><br><span class="line">                .code(ResultCode.PHONE_EXIST_EXCEPTION.getCode())</span><br><span class="line">                .message(ResultCode.PHONE_EXIST_EXCEPTION.getMessage());</span><br><span class="line">    &#125;<span class="keyword">catch</span> (UsernameExistException e)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">return</span> Result</span><br><span class="line">                .error()</span><br><span class="line">                .code(ResultCode.USERNAME_EXIST_EXCEPTION.getCode())</span><br><span class="line">                .message(ResultCode.USERNAME_EXIST_EXCEPTION.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="通过使用自定义异常-Service层-和自定义错误码-Controller层-来处理程序出现的问题"><a href="#通过使用自定义异常-Service层-和自定义错误码-Controller层-来处理程序出现的问题" class="headerlink" title="通过使用自定义异常(Service层)和自定义错误码(Controller层)来处理程序出现的问题"></a>通过使用自定义异常(Service层)和自定义错误码(Controller层)来处理程序出现的问题</h2><ul>
<li><p>如果一个<strong>Service层的方法会发生很多问题，那么首先应该把这些问题对应的自定义异常抛出去，抛给Controller层</strong>；然后<strong>Controller针对不同的异常类型给统一返回对象设置对应异常类型的错误码</strong>。</p>
</li>
<li><p>这样做是因为<strong>Controller层是后端数据离开该模块的最后一层，应该使用统一返回对象来进行返回，从而可以让别的模块或者前端来解析使用，在这一层抛异常不合适</strong>。而<strong>Service层的数据是返回给Controller层的，它抛的异常Controller层也能接收到，所以可以向外抛异常</strong>。</p>
</li>
<li><p>这个用法在上一组业务代码中有体现。</p>
</li>
<li><p>自定义异常示例：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230125195746070.png" alt="image-20230125195746070"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFailedException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoginFailedException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;用户账号或密码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="配置文件不起作用"><a href="#配置文件不起作用" class="headerlink" title="配置文件不起作用"></a>配置文件不起作用</h2><ul>
<li>可能是配置文件没有被build，检查配置文件是否被build进了classes目录，如果没有，应该在pom文件中显式声明将其加入要build的文件中。</li>
</ul>
<h2 id="开启mybatis-plus的日志打印"><a href="#开启mybatis-plus的日志打印" class="headerlink" title="开启mybatis-plus的日志打印"></a>开启mybatis-plus的日志打印</h2><ul>
<li><p>在配置文件中进行配置，打印的内容可以看到具体执行的sql语句：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置mybatis-plus的mapper位置，默认是classpath*:/mapper/**/*.xml，classpath后面的*代表除了自己的classpath，引入的jar包的classpath也会被检索</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/**/mapper/**/*.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment">#开启打印mybatis运行日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="用户登录后端实现"><a href="#用户登录后端实现" class="headerlink" title="用户登录后端实现"></a>用户登录后端实现</h2><ul>
<li><p>这个比较简单了就，主要就是注意使用<strong>BCryptPasswordEncoder</strong>类的match方法来验证密码，然后注意Service层和Controller层的<strong>抛接发问题处理模型（Service层抛异常，Controller层接异常，Controller层发错误码出去）</strong>。</p>
</li>
<li><p>先走认证中心，然后认证中心远程调用用户模块的登录方法。</p>
</li>
<li><p>认证中心的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> UserLoginVo vo)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> memberFeignService.login(vo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户模块的Controller层方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> MemberLoginVo vo)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">UmsMember</span> <span class="variable">member</span> <span class="operator">=</span> umsMemberService.login(vo);</span><br><span class="line">        <span class="keyword">return</span> Result.ok().data(<span class="string">&quot;data&quot;</span>,member);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(LoginFailedException e)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">        <span class="keyword">return</span> Result</span><br><span class="line">                .error()</span><br><span class="line">                .code(ResultCode.LOGIN_FAILED_EXCEPTION.getCode())</span><br><span class="line">                .message(ResultCode.LOGIN_FAILED_EXCEPTION.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户模块的Service层方法（忘给数据的isDeleted属性加上自动填充注解导致好长时间都没有查出数据蚌）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UmsMember <span class="title function_">login</span><span class="params">(MemberLoginVo vo)</span> <span class="keyword">throws</span> LoginFailedException&#123;</span><br><span class="line">    <span class="comment">//System.out.println(vo.getLoginacct()+&quot; &quot;+vo.getPassword());</span></span><br><span class="line">    <span class="comment">//用户用username和phone登录都行</span></span><br><span class="line">    QueryWrapper&lt;UmsMember&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.eq(<span class="string">&quot;username&quot;</span>,vo.getLoginacct()).or().eq(<span class="string">&quot;mobile&quot;</span>,vo.getLoginacct());</span><br><span class="line">    <span class="comment">//System.out.println(wrapper.getSqlComment());</span></span><br><span class="line">    <span class="type">UmsMember</span> <span class="variable">member</span> <span class="operator">=</span> <span class="built_in">this</span>.baseMapper.selectOne(wrapper);</span><br><span class="line">    <span class="comment">//System.out.println(member);</span></span><br><span class="line">    <span class="comment">//用户不存在的情况处理一下</span></span><br><span class="line">    <span class="keyword">if</span>(member==<span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LoginFailedException</span>();</span><br><span class="line">    <span class="comment">//匹配密码，不匹配直接抛异常</span></span><br><span class="line">    <span class="type">BCryptPasswordEncoder</span> <span class="variable">passwordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    <span class="keyword">if</span>(!passwordEncoder.matches(vo.getPassword(),member.getPassword()))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LoginFailedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> member;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="社交登录"><a href="#社交登录" class="headerlink" title="社交登录"></a>社交登录</h2><ul>
<li>可以在登录界面提供第三方的登录，这样可以避免用户进行繁琐的注册流程，而且这些第三方平台使用的人一般也挺多，相当于变相利用第三方平台的大流量。</li>
<li>通过社交登录，就相当于我们利用用户在第三方平台上的一些信息，给这个用户自动注册了一个账号，注册的这个账号的一些信息是我们通过社交登录拿到的第三方平台上的这个用户的信息。</li>
</ul>
<h2 id="OAuth2-0"><a href="#OAuth2-0" class="headerlink" title="OAuth2.0"></a>OAuth2.0</h2><ul>
<li><p>OAuth（开放授权）：是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或者分享他们数据的所有内容。</p>
</li>
<li><p>OAuth2.0：与用户相关的OpenAPI（例如获取用户信息，动态同步，照片，日志，分享等），为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式地向用户征求授权。</p>
</li>
<li><p>官方版流程：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230125231614349.png" alt="image-20230125231614349"></p>
</li>
<li><p>比较准确的流程应该是：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230125231716917.png" alt="image-20230125231716917"></p>
<p>用户在输入完自己的第三方平台的登录信息之后，请求会发给第三方服务的服务器进行认证，认证通过之后会给用户想要登录的网站发送一个code，网站拿到这个code之后可以使用它向第三方服务器申请一个access_token，code一般只能用一次，网站拿到这个access_token之后，就可以拿着这个access_token去找qq存放用户开放信息的服务器请求用户开放数据来做相应的操作了，access_token一般可以使用多次，但有过期时间。</p>
</li>
</ul>
<h1 id="2023-x2F-1-x2F-26"><a href="#2023-x2F-1-x2F-26" class="headerlink" title="2023&#x2F;1&#x2F;26"></a>2023&#x2F;1&#x2F;26</h1><h2 id="使用第三方登录"><a href="#使用第三方登录" class="headerlink" title="使用第三方登录"></a>使用第三方登录</h2><ul>
<li>各第三方平台一般都会有他们对应的开放平台，其中提供很多开放的功能、api啥的 ，那想要用哪家的第三方登录功能就要去对应的开放平台去申请使用，申请完成之后，跟着开放平台上的文档一步步走就行了。</li>
</ul>
<h2 id="比较方便的封装了发送http请求的包"><a href="#比较方便的封装了发送http请求的包" class="headerlink" title="比较方便的封装了发送http请求的包"></a>比较方便的封装了发送http请求的包</h2><ul>
<li>可以用apache的HTTPUtils或者用restTemplate</li>
</ul>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><ul>
<li><p>时序图(Sequence Diagram)，又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。</p>
</li>
<li><p>也就是说可以用时序图来表示多个对象之间的交互关系</p>
</li>
<li><p>纵轴代表时间，横轴代表各种对象&#x2F;角色，对象下面的虚线是该对象的生命线，该对象的活动可以在生命线上用一个小矩形体现，这种小矩形叫控制焦点，对象之间发送同步消息用一条实线和实心箭头表示，发送异步消息用一条实线和一个大于号表示，返回消息用一条虚线和小于号表示，自关联的消息就是用箭头指向自己。</p>
</li>
<li><p>第三方登录的时序图示例：</p>
<img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126163007555.png" alt="image-20230126163007555"  />

<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126162933956.png" alt="image-20230126162933956"></p>
</li>
<li><p>另一个时序图示例：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126151828420.png" alt="image-20230126151828420"></p>
</li>
</ul>
<h2 id="Session原理"><a href="#Session原理" class="headerlink" title="Session原理"></a>Session原理</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126164612737.png" alt="image-20230126164612737"></p>
<ul>
<li>由于<strong>http协议是无状态的，所以为了记录用户的状态使用户不必要每次都进行登录等重复操作，我们需要用到session技术</strong>，下面以登录场景举例，后台在处理用户的登录请求时，会<strong>将用户的状态存放在一个session中（可以想象session为一个map），所有session由一个sessionManager统一管理，之后服务器会命令浏览器保存一下这个用户的sessionId，浏览器就会保存，实际上这就是cookie，之后浏览器访问服务器都会带上它存储的cookie，cookie中有这个用户的sessionId等信息，服务器拿到之后就从sessionManager中找到对应的session，获取用户的状态从而将会话恢复到之前的状态</strong>。</li>
<li>就像是去银行卡办理业务一样，浏览器是客户，服务器是银行，客户进入银行存钱（session），银行发给客户一个银行卡（cookie）作为用户的凭证，这样每次用户来存钱银行都能正确处理。</li>
</ul>
<h2 id="Session共享问题"><a href="#Session共享问题" class="headerlink" title="Session共享问题"></a>Session共享问题</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126165443562.png" alt="image-20230126165443562"></p>
<ul>
<li>单机服务使用session没啥大问题，但是如果这个服务是个分布式的服务，问题就会出现，<strong>由于session是存放在受理用户对应操作的那个服务器上的，别的服务器没有用户的那个session，那么用户在使用别的服务器的服务的时候，那些服务器无法拿到用户的session</strong>。</li>
<li>比如用户在认证中心完成了登录，然后转到了主业务的服务器使用相应的服务，那么主业务的服务器是没有用户的session的，也就无法恢复用户的状态。再者如果用户都是使用的同一个服务，但是这个服务是集群部署，用户的请求经过负载均衡打在了同一服务的不同主机上，也没法保证提供服务的主机中有用户的session。这两个情景下的问题都是分布式下的session共享问题。</li>
</ul>
<h3 id="解决方案-session复制"><a href="#解决方案-session复制" class="headerlink" title="解决方案-session复制"></a>解决方案-session复制</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230126170507748.png" alt="image-20230126170507748"></p>
<ul>
<li>这个优缺点都很明显，优点就是tomcat原生支持，配置起来简单；缺点就是session同步需要占用网络带宽、集群中节点数量太多的话单个节点会占用太多的空间来存储所有节点的session。</li>
<li>所以一般不用这种方法。</li>
</ul>
<h3 id="解决方案-客户端存储"><a href="#解决方案-客户端存储" class="headerlink" title="解决方案-客户端存储"></a>解决方案-客户端存储</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230127144611512.png" alt="image-20230127144611512"></p>
<ul>
<li>这种方法就是把session信息全都存到客户端的cookie中，不可能会用这种方法，安全性太低，而且cookie有长度限制，信息一多了就放不下了。</li>
</ul>
<h3 id="解决方案-hash一致性"><a href="#解决方案-hash一致性" class="headerlink" title="解决方案-hash一致性"></a>解决方案-hash一致性</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230127145021102.png" alt="image-20230127145021102"></p>
<ul>
<li>就是用户首次访问负载均衡服务器的时候，给用户的ip做一个hash，得到用户ip的hash值，然后再根据负载均衡给他分配服务器，以后只要还是这个ip过来访问，那么我们就给他转到和之前相同的服务器。</li>
<li>缺点就是服务器断电、服务器增减、用户ip改变等情况session会失效，不过这都是小概率事件。</li>
</ul>
<h3 id="解决方案-统一存储"><a href="#解决方案-统一存储" class="headerlink" title="解决方案-统一存储"></a>解决方案-统一存储</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230127145706059.png" alt="image-20230127145706059"></p>
<ul>
<li>来点儿名言：计算机中的问题没有什么是加一个中间层无法解决的。所以加一层装所有的session即可。不过就是增加了一次网络调用，读取速度比直接从内存中读取慢很多。</li>
</ul>
<h3 id="解决方案-子域session共享"><a href="#解决方案-子域session共享" class="headerlink" title="解决方案-子域session共享"></a>解决方案-子域session共享</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230127150420849.png" alt="image-20230127150420849"></p>
<ul>
<li>上面那个解决方案还有一些问题，就是当服务让浏览器存cookie的时候，默认的域名往往是子域名，这就导致浏览器只有访问对应的子域名的时候会带上cookie。</li>
<li>所以在上一个方案的基础上，我们应该在让浏览器存cookie的时候，手动声明域名为父域名以扩大cookie的作用域。</li>
</ul>
<h1 id="2023-x2F-1-x2F-27"><a href="#2023-x2F-1-x2F-27" class="headerlink" title="2023&#x2F;1&#x2F;27"></a>2023&#x2F;1&#x2F;27</h1><h2 id="Spring-Session"><a href="#Spring-Session" class="headerlink" title="Spring Session"></a>Spring Session</h2><ul>
<li>spring家给的session解决方案，不过现在前后端分离的项目好像不怎么用这种技术了，等我先研究研究现在的主流解决方案之后再回来搞这一块儿。&#x2F;&#x2F;todo</li>
<li>只要http协议还是无状态的协议，session技术就不会被淘汰。</li>
</ul>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><ul>
<li><p>Json Web Token（JWT）是为了网络应用环境间传递声明而执行的一种基于JSON的开发标准（RFC 7519），该token被设计为紧凑且安全的，特别适用于分布式站点的单点登陆（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
</li>
<li><p>总之，<strong>这个技术相当于把之前存在服务端的用户状态session转移到了用户端上</strong>，也就是说使用jwt生成的json对象中有用户的状态，我们把这个json对象叫做token，token存在客户端中，客户端想要从服务端申请数据的时候，就带上这个token，这样服务端就能从这个token中拆解出信息，从而对这个用户进行认证。这样<strong>服务端就不用保存任何session了，不用去考虑怎样解决分布式下的session共享问题了，将用户状态和服务端解耦，很明显对服务端的可扩展性是有提升的</strong>。</p>
</li>
<li><p>JWT的认证流程图：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230216230348282.png" alt="image-20230216230348282"></p>
</li>
</ul>
<h3 id="session和jwt的区别"><a href="#session和jwt的区别" class="headerlink" title="session和jwt的区别"></a>session和jwt的区别</h3><ol>
<li>session 存储在服务端占用服务器资源，而 JWT 存储在客户端</li>
<li>session 存储在 Cookie 中，存在伪造跨站请求伪造攻击的风险</li>
<li>session 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用</li>
<li>存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性</li>
</ol>
<h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><ul>
<li>就是如果要是一个公司下面有很多个项目，那么我们期望实现一处登录，处处登录，比如一个公司有个商城项目，还有个在线视频网站项目，那么我们期望用户注册的时候，只需要注册这个公司的账号，然后就能登录这个公司旗下的所有项目，并且在其中一个项目登录了账号之后，再访问另外一个项目就不用重复登录了，这样的功能就是单点登录功能-一次登录可以访问多个应用。</li>
<li>这个要练习起来比较吃环境，不大好办，之后再搞吧。&#x2F;&#x2F;todo</li>
</ul>
<h1 id="2023-x2F-1-x2F-28"><a href="#2023-x2F-1-x2F-28" class="headerlink" title="2023&#x2F;1&#x2F;28"></a>2023&#x2F;1&#x2F;28</h1><h2 id="使用alt-insert来在IDEA中快速创建预制代码块"><a href="#使用alt-insert来在IDEA中快速创建预制代码块" class="headerlink" title="使用alt+insert来在IDEA中快速创建预制代码块"></a>使用alt+insert来在IDEA中快速创建预制代码块</h2><ul>
<li>这个快捷键还挺好用的，可以快速创建构造器、重写方法、实现方法等。</li>
</ul>
<h2 id="使用拦截器来判断用户的状态"><a href="#使用拦截器来判断用户的状态" class="headerlink" title="使用拦截器来判断用户的状态"></a>使用拦截器来判断用户的状态</h2><ul>
<li><p><strong>拦截器是spring mvc中的内容，它可以在Controller层的方法调用之前、调用之后、页面渲染之后执行相应的操作</strong>，所以如果我们想每次执行业务方法之前判断用户的状态，可以自定义一个拦截器。</p>
</li>
<li><p>拦截器可以单独放在一个包中，自定义的拦截器要实现spring提供的<strong>HandlerInterceptor</strong>接口，然后根据需求重写接口中的不同方法，返回true是放行请求，返回false是拦截请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;<span class="comment">//返回true是放行请求，返回false是拦截请求</span></span><br><span class="line">        <span class="keyword">return</span> HandlerInterceptor.<span class="built_in">super</span>.preHandle(request, response, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想要让拦截器工作，还需要让他注册到ioc容器中让其生效并设置其可以拦截的请求，对于mvc相关的配置，我们可以新建一个实现了<strong>WebMvcConfigurer</strong>接口的配置类，然后在配置类中通过重写相应的方法来进行相关的配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartWebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//将自定义的拦截器使用注册器注册到容器中并让其生效，指定其可以拦截的请求为所有请求</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">CartInterceptor</span>())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="使用ThreadLocal在同一个线程共享数据"><a href="#使用ThreadLocal在同一个线程共享数据" class="headerlink" title="使用ThreadLocal在同一个线程共享数据"></a>使用ThreadLocal在同一个线程共享数据</h2><ul>
<li><p>当有请求到达tomcat的时候，tomcat就会用一个线程来处理这个请求，从拦截器到controller到service到dao最后再返回来，这一串都在同一个线程，这样我们就可以使用JDK的ThreadLocal来在这一个线程中共享数据。</p>
</li>
<li><p>比如在拦截器中取得了一些数据，把这些数据做到ThreadLocal对象后，在进行后面的操作的时候就可以很容易地取出这些数据了。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230128182826838.png" alt="image-20230128182826838"></p>
</li>
<li><p>使用ThreadLocal可以新建一个它的泛型，对外开放，再调用其set方法来维护一个对象，一个ThreadLocal只能维护一个对象，用的时候使用get方法取出ThreadLocal维护的对象。</p>
</li>
<li><p>使用ThreadLocal的好处就是可以实现线程隔离，<strong>每个线程都有一个属于自己的ThreadLocalMap&lt;ThreadLocal&lt;T&gt;,Object&gt;<strong>，这个类是ThreadLocal的内部类，</strong>ThreadLocalMap维护着当前线程的所有ThreadLocal对象对应的对象</strong>，这样<strong>每次使用ThreadLocal的get方法取出对象的时候，实际上是从本线程的ThreadLocalMap中取那个ThreadLocal对应的那个对象，这样就实现了线程之间的隔离</strong>，同理，<strong>使用ThreadLocal的set方法的时候也是在本线程的ThreadLocalMap中set进ThreadLocal和那个对象组成的键值对</strong>。</p>
</li>
<li><p>ThreadLocal的set方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//得到当前线程的对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//得到线程对象的ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);<span class="comment">//向当前线程的ThreadLocalMap中存放当前ThreadLocal对应的对象</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ThreadLocal的get方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();<span class="comment">//得到当前线程的对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);<span class="comment">//得到线程对象的ThreadLocalMap</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);<span class="comment">//从当前线程的ThreadLocalMap中获得当前ThreadLocal对应的对象</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Docker安装RabbitMQ"><a href="#Docker安装RabbitMQ" class="headerlink" title="Docker安装RabbitMQ"></a>Docker安装RabbitMQ</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230128192259784.png" alt="image-20230128192259784"></p>
<ul>
<li>从15672端口进rabbitmq的可视化管理界面，用户名和密码默认都是guest</li>
<li>客户端使用高级消息队列协议（AMQP）来和rabbitmq进行交互的端口是5672端口</li>
<li>rabbitmq支持导出和导入配置文件，这让配置的迁移变得简单</li>
</ul>
<h1 id="2023-x2F-1-x2F-30"><a href="#2023-x2F-1-x2F-30" class="headerlink" title="2023&#x2F;1&#x2F;30"></a>2023&#x2F;1&#x2F;30</h1><h2 id="RabbitMQ的工作原理"><a href="#RabbitMQ的工作原理" class="headerlink" title="RabbitMQ的工作原理"></a>RabbitMQ的工作原理</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029093829448.png" alt="image-20221029093829448"></p>
<ul>
<li><strong>Broker（代理）</strong>：<strong>接收和分发消息的应用</strong>，RabbitMQ Server 就是 Message Broker。</li>
<li><strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP（协议）的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。<strong>当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</strong>。</li>
<li><strong>Connection</strong>：<strong>publisher／consumer 和 broker 之间的 TCP 连接</strong>。</li>
<li><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。<strong>Channel 是在 connection 内部建立的逻辑连接</strong>，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的Connection极大减少了操作系统建立TCP connection的开销</strong>。</li>
<li><strong>Exchange</strong>：message 到达 broker 的第一站，<strong>根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去</strong>。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</li>
<li><strong>Queue</strong>：<strong>消息最终被送到这里等待 consumer 取走</strong>。</li>
<li><strong>Binding</strong>：<strong>exchange 和 queue 之间的虚拟连接</strong>，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</li>
</ul>
<h2 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><ul>
<li><p>首先引入高级消息队列的场景启动器：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring-boot-starter-amqp.version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">spring-boot-starter-amqp.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--高级消息队列的场景启动器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-starter-amqp.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引入场景启动器后RabbitAutoConfiguration就会自动生效，它会<strong>向容器中自动注册RabbitTemplate、AmqpAdmin、CachingConnectionFactory、RabbitMessagingTemplate对象</strong>，并且<strong>所有属性都可以通过前缀为“spring.rabbitmq”的配置项来在配置文件中进行配置</strong>。</p>
</li>
</ul>
<h3 id="进行配置"><a href="#进行配置" class="headerlink" title="进行配置"></a>进行配置</h3><ul>
<li><p>在配置文件中进行配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定rabbitmq的主机地址和连接端口</span></span><br><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">konjacer.com</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="comment">#配置virtual-host，这个和namespace的概念差不多，是用来做不同用户之间的隔离的</span></span><br><span class="line"><span class="attr">spring.rabbitmq.virtual-host</span>=<span class="string">/</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="开启注解"><a href="#开启注解" class="headerlink" title="开启注解"></a>开启注解</h3><ul>
<li>使用**@EnableRabbit**来启动高级消息队列的功能</li>
</ul>
<h3 id="增删组件"><a href="#增删组件" class="headerlink" title="增删组件"></a>增删组件</h3><ul>
<li><p>对于<strong>RabbitMQ中的交换机、队列、Binding等组件的增删操作可以使用之前向容器中注册的AmqpAdmin对象来做</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">AmqpAdmin amqpAdmin;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAmqpAdmin</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//创建Exchange交换机</span></span><br><span class="line">	<span class="type">DirectExchange</span> <span class="variable">directExchange</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;test-exchange&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>);</span><br><span class="line">	amqpAdmin.declareExchange(directExchange);</span><br><span class="line">	<span class="comment">//创建Queue队列,exclusive如果是true那么只有一个连接可以连接到这个队列</span></span><br><span class="line">	<span class="type">Queue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;test-queue&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line">	amqpAdmin.declareQueue(queue);</span><br><span class="line">	<span class="comment">//创建Binding绑定关系来绑定交换机和队列,将指定的交换机和目的地（可以是交换机也可以是队列,在第二个参数中声明）进行绑定，使用routingKey作为指定的路由键</span></span><br><span class="line">	<span class="type">Binding</span> <span class="variable">binding</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Binding</span>(<span class="string">&quot;test-queue&quot;</span>, Binding.DestinationType.QUEUE,<span class="string">&quot;test-exchange&quot;</span>,<span class="string">&quot;test&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">	amqpAdmin.declareBinding(binding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><ul>
<li><p>如果想要<strong>进行收发消息的相关操作，我们可以使用之前注册到容器中的RabbitTemplate对象</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRabbitTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="comment">//发送消息,会使用到序列化机制将对象写出去,默认使用java的序列化机制,所以如果发送的消息是个对象，那么对象对应的类必须实现序列化接口Serializable</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">	rabbitTemplate.convertAndSend(<span class="string">&quot;test-exchange&quot;</span>,<span class="string">&quot;test&quot;</span>,msg);</span><br><span class="line">	<span class="comment">//更改默认的序列化机制需要在ioc容器中添加另外一个消息转换器以覆盖默认的消息转换器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果想要更改默认的写出对象的序列化机制，可以<strong>在配置类中向ioc容器中添加一个新的json消息转换器以覆盖默认的转换器，这样以后就是将对象转换成json数据写出了</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;<span class="comment">//将json的消息转换器放到ioc容器中，这样以后在发送对象消息的时候，对象会被序列化成json数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><ul>
<li><p>主要是通过两个注解来实现消息的接收，首先就是**@RabbitListener<strong>注解，这个注解可以修饰方法和类，其中queue属性可以声明要监听的队列名称，如果要是修饰方法，那么被监听的队列中来了新消息后被修饰的方法会接收到新的消息；如果要是这个注解修饰类，那么被监听的队列中来了新消息之后，类中被</strong>@RabbitHandler**注解修饰的方法会根据消息类型和自己的形参类型来接收消息（如果类型相同就接收）。</p>
</li>
<li><p>一般都是用**@RabbitListener<strong>注解修饰类，然后用</strong>@RabbitHandler<strong>注解修饰类中的方法，这样可以</strong>细化接收消息方法的粒度，每个方法只接收符合自己实参类型的消息<strong>，注意</strong>方法中可以选择三个接收参数**：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;test-queue&quot;&#125;)</span><span class="comment">//声明要监听的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OmsOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OmsOrderMapper, OmsOrder&gt; <span class="keyword">implements</span> <span class="title class_">OmsOrderService</span> &#123;</span><br><span class="line">    <span class="comment">//一个队列可以很多消费者来同时监听，只要消费者收到消息，队列就会删除消息，所以一个消息只会被一个消费者接收到，默认是轮询接收策略</span></span><br><span class="line">    <span class="comment">//只有当一个消息完全处理完（即方法运行结束），才可以接收下一个消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span><span class="comment">//声明该方法为消息处理方法，如果有消息到达类上注解中声明的要监听的队列，那么被@RabbitHandler注解修饰的方法会根据消息对象的类型和形参类型来选择接收（两者类型相同就接收）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">            Message msg,</span></span><br><span class="line"><span class="params">            OmsOrderService omsOrderService,</span></span><br><span class="line"><span class="params">            Channel channel</span></span><br><span class="line"><span class="params">    )</span>&#123;<span class="comment">//可选三个参数接收：原生消息类型Message封装了消息（消息头+消息体），除了消息本身还有很多其他信息，第二个参数写消息中的对象的类可以直接接收到消息对象，第三个参数可以获取到客户端和mq之间连接中的进行消息交互的channel</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span>+msg+<span class="string">&quot; &quot;</span>+<span class="string">&quot;接收到的消息内容对象：&quot;</span>+omsOrderService);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个队列可以很多消费者来同时监听，只要消费者收到消息，队列就会删除消息，所以<strong>一个消息只会被一个消费者接收到</strong>，默认是轮询接收策略。</p>
</li>
<li><p><strong>只有当一个消息完全处理完（即方法运行结束），对应的方法才可以接收下一个消息</strong>。</p>
</li>
</ul>
<h2 id="RabbitMQ消息确认机制-可靠抵达"><a href="#RabbitMQ消息确认机制-可靠抵达" class="headerlink" title="RabbitMQ消息确认机制-可靠抵达"></a>RabbitMQ消息确认机制-可靠抵达</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230130173903685.png" alt="image-20230130173903685"></p>
<ul>
<li>为了保证消息的可靠抵达，我们可以在channel中使用事务机制，所有步骤都成功了之后整体才会成功，但是这样做性能下降很严重。我们还可以使用消息确认机制来实现消息的可靠抵达，这种方案性能损耗较小。</li>
</ul>
<h3 id="开启ConfirmCallback回调"><a href="#开启ConfirmCallback回调" class="headerlink" title="开启ConfirmCallback回调"></a>开启ConfirmCallback回调</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230130174647641.png" alt="image-20230130174647641"></p>
<ul>
<li><p>是<strong>生产者的消息成功到达Broker的回调方法</strong>，要想开启这个方法，可以<strong>在配置文件中进行相应的配置</strong>：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启从生产者到Broker的消息成功到达回调，开启后消息成功从生产者到Broker后RabbitTemplate会调用对应的回调方法ConfirmCallback，所以如果我们想要定制这个回调方法，需要改一下RabbitTemplate中的参数然后再把它扔回ioc容器</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后<strong>在配置文件中定制一下rabbitTemplate，给里面塞一个自定义的ConfirmCallback方法</strong>，这样之后消息从生产者到Broker之后，rabbitTemplate就会调用我们自定义的ConfirmCallback回调方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;<span class="comment">//将json的消息转换器放到ioc容器中，这样以后在发送对象消息的时候，对象会被序列化成json数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制rabbitTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span><span class="comment">//在MyRabbitConfig对象的构造器执行完之后再执行这个方法，为的是让RabbitTemplate先装载完毕？2023-03-11：这个是在选择构造器，实例化，依赖注入，处理相关aware类的重写方法之后执行，所以在执行的时候，rabbitTemplate已经被注入了，可以直接使用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRabbitTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自定义消息从生产者到Broker的成功回调</span></span><br><span class="line"><span class="comment">         * 只要消息从生产者到Broker，ack就等于true</span></span><br><span class="line"><span class="comment">         * correlationData：当前消息的唯一关联数据（这个是消息的唯一id），发送的时候最好带上这个参数（要能唯一标识一个消息，可以是uuid），这样方便后面识别消息，也方便存数据库</span></span><br><span class="line"><span class="comment">         * ack：消息是否成功收到</span></span><br><span class="line"><span class="comment">         * cause：失败的原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(((correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;correlationData:&quot;</span>+correlationData+<span class="string">&quot;ack:&quot;</span>+ack+<span class="string">&quot;cause:&quot;</span>+cause);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="开启ReturnCallback回调"><a href="#开启ReturnCallback回调" class="headerlink" title="开启ReturnCallback回调"></a>开启ReturnCallback回调</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230130210051832.png" alt="image-20230130210051832"></p>
<ul>
<li><p>是<strong>消息未能从交换机传到队列中的回调方法</strong>，要想启用这个方法，可以在配置文件中进行设置，下面<strong>还设置开启了一个消息到达队列的回调方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#开启消息未能从交换机传到队列的回调方法</span><br><span class="line">spring.rabbitmq.publisher-returns=<span class="literal">true</span></span><br><span class="line">#只要抵达队列，优先以异步的方式回调ReturnConfirm方法</span><br><span class="line">spring.rabbitmq.template.mandatory=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后就是在RabbitTemplate中自定义上面开启的两个回调方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;<span class="comment">//将json的消息转换器放到ioc容器中，这样以后在发送对象消息的时候，对象会被序列化成json数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定制rabbitTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span><span class="comment">//在MyRabbitConfig对象的构造器执行完之后再执行这个方法，为的是让RabbitTemplate先装载完毕？</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRabbitTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自定义消息从生产者到Broker的成功回调</span></span><br><span class="line"><span class="comment">         * 只要消息从生产者到Broker，ack就等于true</span></span><br><span class="line"><span class="comment">         * correlationData：当前消息的唯一关联数据（这个是消息的唯一id），发送的时候最好带上这个参数（要能唯一标识一个消息，可以是uuid），这样方便后面识别消息，也方便存数据库</span></span><br><span class="line"><span class="comment">         * ack：消息是否成功收到</span></span><br><span class="line"><span class="comment">         * cause：失败的原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(((correlationData, ack, cause) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;correlationData:&quot;</span>+correlationData+<span class="string">&quot;ack:&quot;</span>+ack+<span class="string">&quot;cause:&quot;</span>+cause);</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自定义消息未抵达队列的回调</span></span><br><span class="line"><span class="comment">         * message：投递失败的消息的详细信息</span></span><br><span class="line"><span class="comment">         * replyCode：回复的状态码</span></span><br><span class="line"><span class="comment">         * replyText：回复的文本内容</span></span><br><span class="line"><span class="comment">         * exchange：当时这个消息是从哪个交换机发出去的</span></span><br><span class="line"><span class="comment">         * routingKey：当时这个消息用的哪个路由键</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;失败的消息：&quot;</span>+message);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="开启ack消息确认机制"><a href="#开启ack消息确认机制" class="headerlink" title="开启ack消息确认机制"></a>开启ack消息确认机制</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230131161537978.png" alt="image-20230131161537978"></p>
<ul>
<li><p>是<strong>消息从队列到消费者的回调，有ack和nack&#x2F;reject三种回调，ack是逻辑上消息处理成功，nack&#x2F;reject是逻辑上消息处理失败</strong>，消费者客户端在不同的时间执行这两个回调时”处理成功&#x2F;失败“有不同的意义，需要具体情况具体分析，<strong>默认是自动确认的，只要消息被消费者接收到，那么即使消息没有被处理完（也就是接收消息的方法没有运行完）消费者客户端也会自动确认ack，服务端收到确认ack后就会移除对应的消息</strong>。</p>
</li>
<li><p>上面说的<strong>这种只要接收到消息就自动确认的机制是有很大问题的，会造成消息的丢失</strong>，比如消费者收到了很多消息，对于这些消息消费者都回复了ack，服务端收到ack后就把队列中的消息删除了，但是消费者在处理完一部分消息后宕机了，那么那些没有处理完的消息就丢失了，队列里也没了，因为服务端收到ack后就把对应的消息删掉了。</p>
</li>
<li><p>所以要解决上面说的那种问题，我们<strong>可以采用手动确认，也就是处理消息的方法结束之后，我们再手动向服务端发送ack</strong>，这样就能保证服务端接收到ack并删除对应消息的时候，消息已经再消费者客户端处理完毕了，<strong>解决了上面那种情况下消息丢失的问题</strong>。<strong>在手动确认模式下，只要我们没有调用ack，那么服务端中对应的消息就一直是unchecked状态，即使消费者宕机消息也不会丢失，而是会变成ready状态，当下一次有新的消费者连接到这个队列的时候，消息就会被重新发给消费者</strong>。要想采用手动确认，首先要在配置文件中进行相关的配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#手动ack消息</span><br><span class="line">spring.rabbitmq.listener.simple.acknowledge-mode=manual</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后就是在处理消息的方法中手动调用channel的一些有ack&#x2F;nack&#x2F;reject功能的方法来告知服务端消息的处理情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---------------------------------------ack消息处理完毕------------------------------------</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;test-queue&quot;&#125;)</span><span class="comment">//声明要监听的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OmsOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OmsOrderMapper, OmsOrder&gt; <span class="keyword">implements</span> <span class="title class_">OmsOrderService</span> &#123;</span><br><span class="line">    <span class="comment">//一个队列可以很多消费者来同时监听，只要消费者收到消息，队列就会删除消息，所以一个消息只会被一个消费者接收到，默认是轮询接收策略</span></span><br><span class="line">    <span class="comment">//只有当一个消息完全处理完（即方法运行结束），才可以接收下一个消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span><span class="comment">//声明该方法为消息处理方法，如果有消息到达类上注解中声明的要监听的队列，那么被@RabbitHandler注解修饰的方法会根据消息对象的类型和形参类型来选择接收（两者类型相同就接收）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">            Message msg,</span></span><br><span class="line"><span class="params">            OmsOrderService omsOrderService,</span></span><br><span class="line"><span class="params">            Channel channel</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> IOException &#123;<span class="comment">//可选三个参数接收：原生消息类型Message封装了消息（消息头+消息体），除了消息本身还有很多其他信息，第二个参数写消息中的对象的类可以直接接收到消息对象，第三个参数可以获取到客户端和mq之间连接中的进行消息交互的channel</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span>+msg+<span class="string">&quot; &quot;</span>+<span class="string">&quot;接收到的消息内容对象：&quot;</span>+omsOrderService);</span><br><span class="line">        <span class="comment">//手动确认ack表示消息已经处理完毕，服务端可以把对应的消息删掉了</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> msg.getMessageProperties().getDeliveryTag();<span class="comment">//获取消息在队列中的编号，用于ack</span></span><br><span class="line">        channel.basicAck(deliveryTag,<span class="literal">false</span>);<span class="comment">//第一个参数是消息在队列中的编号，用于服务端找到对应的消息，第二个参数为是否批量删除，false表示这个ack只ack对应的那一条消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------nack/reject拒收消息------------------------------------</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &#123;&quot;test-queue&quot;&#125;)</span><span class="comment">//声明要监听的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OmsOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;OmsOrderMapper, OmsOrder&gt; <span class="keyword">implements</span> <span class="title class_">OmsOrderService</span> &#123;</span><br><span class="line">    <span class="comment">//一个队列可以很多消费者来同时监听，只要消费者收到消息，队列就会删除消息，所以一个消息只会被一个消费者接收到，默认是轮询接收策略</span></span><br><span class="line">    <span class="comment">//只有当一个消息完全处理完（即方法运行结束），才可以接收下一个消息</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span><span class="comment">//声明该方法为消息处理方法，如果有消息到达类上注解中声明的要监听的队列，那么被@RabbitHandler注解修饰的方法会根据消息对象的类型和形参类型来选择接收（两者类型相同就接收）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMessage</span><span class="params">(</span></span><br><span class="line"><span class="params">            Message msg,</span></span><br><span class="line"><span class="params">            OmsOrderService omsOrderService,</span></span><br><span class="line"><span class="params">            Channel channel</span></span><br><span class="line"><span class="params">    )</span> <span class="keyword">throws</span> IOException &#123;<span class="comment">//可选三个参数接收：原生消息类型Message封装了消息（消息头+消息体），除了消息本身还有很多其他信息，第二个参数写消息中的对象的类可以直接接收到消息对象，第三个参数可以获取到客户端和mq之间连接中的进行消息交互的channel</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span>+msg+<span class="string">&quot; &quot;</span>+<span class="string">&quot;接收到的消息内容对象：&quot;</span>+omsOrderService);</span><br><span class="line">        <span class="type">long</span> <span class="variable">deliveryTag</span> <span class="operator">=</span> msg.getMessageProperties().getDeliveryTag();<span class="comment">//获取消息在队列中的编号，用于ack</span></span><br><span class="line">        <span class="comment">//手动调用nack/reject表示拒收消息,第一个参数是消息在队列中的编号，第二个参数为是否批量拒绝，第三个参数为是否将拒收的消息重新入队，如果是false，则直接删除掉对应的消息</span></span><br><span class="line">        channel.basicNack(deliveryTag,<span class="literal">false</span>,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2023-x2F-1-x2F-31"><a href="#2023-x2F-1-x2F-31" class="headerlink" title="2023&#x2F;1&#x2F;31"></a>2023&#x2F;1&#x2F;31</h1><h2 id="RabbitMQ延时队列实现定时任务"><a href="#RabbitMQ延时队列实现定时任务" class="headerlink" title="RabbitMQ延时队列实现定时任务"></a>RabbitMQ延时队列实现定时任务</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230131170636690.png" alt="image-20230131170636690"></p>
<p>- </p>
<h2 id="Feign远程调用丢失请求头的问题"><a href="#Feign远程调用丢失请求头的问题" class="headerlink" title="Feign远程调用丢失请求头的问题"></a>Feign远程调用丢失请求头的问题</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230131191229994.png" alt="image-20230131191229994"></p>
<ul>
<li><p>简而言之就是<strong>Feign在进行远程调用的时候会创建一个新的request，这个request中啥也没有，然后再根据远程调用方法的参数向request的请求体等地方塞数据</strong>，但是由于远程调用方法传的只是数据，所以Feign新建的request只能得到数据，无法得到别的东西，自然就无法得到服务收到的请求的请求头等信息。</p>
</li>
<li><p>所以我们应该在feign新建request完成之前，给request设置好它的请求头。通过feign运行过程的源码可以得知，在feign新建request完成之前会执行多个拦截器，所以我们可以<strong>编写一个feign中用到的拦截器，在拦截器中手动给feign构造的requestTemplate中加入当前收到的请求的请求头</strong>。那么如何给拦截器共享请求头呢？由于拦截器和收到请求的服务是在同一个线程中，所以当然<strong>可以使用ThreadLocal进行数据共享</strong>；<strong>也可以使用spring给我们封装的当前线程的请求数据，使用RequestContextHolder.getRequestAttributes()来获取</strong>，RequestContextHolder中维护了很多当前线程请求的上下文数据，这个底层就是用ThreadLocal实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MallislandFeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean(&quot;requestInterceptor&quot;)</span><span class="comment">//设置这个bean的标识符</span></span><br><span class="line">    <span class="keyword">public</span> RequestInterceptor <span class="title function_">requestInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> template -&gt; &#123;</span><br><span class="line">            <span class="comment">//通过RequestContextHolder拿到当前线程收到的请求</span></span><br><span class="line">            <span class="type">ServletRequestAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">            <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> attributes.getRequest();<span class="comment">//获取请求</span></span><br><span class="line">            <span class="comment">//获得当前线程收到请求的cookie</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">cookie</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Cookie&quot;</span>);</span><br><span class="line">            <span class="comment">//把当前线程收到请求的cookie放到feign构造的requestTemplate中</span></span><br><span class="line">            template.header(<span class="string">&quot;Cookie&quot;</span>,cookie);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>所以解决后整个流程应该是这样的：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230131195252805.png" alt="image-20230131195252805"></p>
</li>
</ul>
<h2 id="异步情况下Feign丢失上下文的问题"><a href="#异步情况下Feign丢失上下文的问题" class="headerlink" title="异步情况下Feign丢失上下文的问题"></a>异步情况下Feign丢失上下文的问题</h2><ul>
<li><p>在上面加上拦截器的情况下，对Feign的远程调用方法进行异步调用的时候，Feign构造的request又出现了没有header的情况，这是什么问题呢？这是<strong>因为异步任务换了线程了，异步任务所在的线程无法获取到别的线程的ThreadLocal中的数据</strong>：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230131202603266.png" alt="image-20230131202603266"></p>
</li>
<li><p>解决方法很简单，<strong>只需要在CompletableFuture的方法参数中写的异步任务流程的lambda中手动添加上主线程的数据即可</strong>，可以在主线程使用RequestContextHolder的getRequestAttributes方法拿到数据，然后再在异步任务流程的lambda中使用使用RequestContextHolder的setRequestAttributes方法设置数据，RequestContextHolder底层是基于ThreadLocal实现的，所以不同线程有不同的RequestContextHolder。</p>
</li>
</ul>
<h1 id="2023-x2F-2-x2F-2"><a href="#2023-x2F-2-x2F-2" class="headerlink" title="2023&#x2F;2&#x2F;2"></a>2023&#x2F;2&#x2F;2</h1><h2 id="对数据库非主属性的唯一性约束"><a href="#对数据库非主属性的唯一性约束" class="headerlink" title="对数据库非主属性的唯一性约束"></a>对数据库非主属性的唯一性约束</h2><ul>
<li>可以给那个属性添加唯一索引，这样可以保证那个属性值的唯一性，但是唯一索引的效率可能偏低？</li>
</ul>
<h2 id="接口的幂等性"><a href="#接口的幂等性" class="headerlink" title="接口的幂等性"></a>接口的幂等性</h2><h3 id="什么是幂等性"><a href="#什么是幂等性" class="headerlink" title="什么是幂等性"></a>什么是幂等性</h3><ul>
<li>接口幂等性就是<strong>用户对于同一操作发起的一次请求或者多次请求的结果是一致的</strong>，不会因为多次点击而产生了副作用。</li>
</ul>
<h3 id="哪些情况下需要保证接口的幂等性"><a href="#哪些情况下需要保证接口的幂等性" class="headerlink" title="哪些情况下需要保证接口的幂等性"></a>哪些情况下需要保证接口的幂等性</h3><ol>
<li>用户多次点击同一个按钮（也就是用户多次调用同一个接口）</li>
<li>用户回退页面后再次进行提交</li>
<li>微服务之间进行互相调用，由于网络问题导致请求失败，feign触发重试机制</li>
<li>其他业务情况</li>
</ol>
<h3 id="什么情况下不需要保证接口的幂等性"><a href="#什么情况下不需要保证接口的幂等性" class="headerlink" title="什么情况下不需要保证接口的幂等性"></a>什么情况下不需要保证接口的幂等性</h3><ul>
<li>以SQL为例，有些操作是天然幂等的，比如crud一些固定的值、带主键的insert。</li>
<li>而有些SQL却不是幂等的，比如update一个值让其+1，或者是insert一个不带主键的元素（可以重复被insert）。</li>
</ul>
<h2 id="接口幂等性的解决方案"><a href="#接口幂等性的解决方案" class="headerlink" title="接口幂等性的解决方案"></a>接口幂等性的解决方案</h2><h3 id="token令牌机制"><a href="#token令牌机制" class="headerlink" title="token令牌机制"></a>token令牌机制</h3><ul>
<li>服务端提供了发送token的接口。我们在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取token，<strong>服务器会把token保存在redis中</strong>。</li>
<li>然后调用业务接口请求的时候，把token携带到后端，<strong>token一般放在请求头部</strong>。</li>
<li>服务器判断token是否在redis中存在，如果存在表示这是第一次请求，删除token，继续执行业务。</li>
<li>如果判断token不存在redis中，就表示当前的操作是重复操作，直接返回重复标记给客户端，这样就保证了业务代码不被重复执行。</li>
</ul>
<h4 id="危险性"><a href="#危险性" class="headerlink" title="危险性"></a>危险性</h4><ol>
<li><p>先删除token还是后删除token？</p>
<ul>
<li>先删除可能导致第一次请求过来删除token后，业务没能处理完成，进行重试的时候，带的是之前的token，但是之前的token已经被删掉了，所以业务就无法被处理完成了。</li>
<li>后删除可能导致在处理的过程中，服务闪断，出现超时，token没能被删除，别人继续重试的时候，由于token还存在，所以服务又会被处理一次。</li>
<li>所以<strong>在使用token的时候，最好是设计成先删除token，如果业务调用失败，就重新获取新的token再次请求</strong>。</li>
</ul>
</li>
<li><p>token的获取、比较和删除操作的整体必须是原子性的</p>
<ul>
<li><p>这个问题比较好理解，如果这三个操作的整体不是原子性的，那么在高并发的情况下可能会产生业务的重复处理（一个时间段可能同时有很多线程拿到了那个token并进行比较）。</p>
</li>
<li><p>可以使用lua脚本完成这个操作：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[<span class="number">1</span>])==ARGV[<span class="number">1</span>] <span class="keyword">then</span> <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>]) <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="各种锁机制"><a href="#各种锁机制" class="headerlink" title="各种锁机制"></a>各种锁机制</h3><h4 id="数据库悲观锁"><a href="#数据库悲观锁" class="headerlink" title="数据库悲观锁"></a>数据库悲观锁</h4><ul>
<li>例：select * from xxxx where id &#x3D; 1 for update;</li>
<li>悲观锁使用时一般伴随事务一起使用，数据锁定时间可能会很长，需要根据实际情况选用。另外要注意的是，id 字段一定是主键或者唯一索引，不然可能造成锁表的结果，处理起来会非常麻烦。</li>
</ul>
<h4 id="数据库乐观锁"><a href="#数据库乐观锁" class="headerlink" title="数据库乐观锁"></a>数据库乐观锁</h4><ul>
<li>这种方法适合用在更新的场景中，例：update t_goods set count &#x3D; count -1 , version &#x3D; version + 1 where good_id&#x3D;2 and version &#x3D; 1</li>
<li>根据 version 版本，也就是在操作库存前先获取当前商品的 version 版本号，然后操作的时候带上此 version 号。我们梳理下，我们第一次操作库存时，得到 version 为1，调用库存服务version 变成了 2；但返回给订单服务出现了问题，订单服务又一次发起调用库存服务，当订单服务传入的 version 还是 1，再执行上面的 sql 语句时，就不会执行；因为version 已经变为 2 了，where 条件就不成立。这样就保证了不管调用几次，只会真正的处理一次。乐观锁主要使用于处理读多写少的问题。</li>
</ul>
<h4 id="业务层分布式锁"><a href="#业务层分布式锁" class="headerlink" title="业务层分布式锁"></a>业务层分布式锁</h4><ul>
<li>如果多个机器可能在同一时间同时处理相同的数据，比如多台机器定时任务都拿到了相同数据处理，我们就可以加分布式锁，锁定此数据，处理完成后释放锁。获取到锁的必须先判断这个数据是否被处理过。</li>
</ul>
<h3 id="各种唯一约束"><a href="#各种唯一约束" class="headerlink" title="各种唯一约束"></a>各种唯一约束</h3><h4 id="数据库唯一约束"><a href="#数据库唯一约束" class="headerlink" title="数据库唯一约束"></a>数据库唯一约束</h4><ul>
<li>插入数据，应该按照唯一索引进行插入，比如订单号，相同的订单就不可能有两条记录插入。我们在数据库层面防止重复。</li>
<li>这个机制是利用了数据库的主键唯一约束的特性，解决了在 insert 场景时幂等问题。但主键的要求不是自增的主键，这样就需要业务生成全局唯一的主键。</li>
<li>如果是分库分表场景下，路由规则要保证相同请求下，落地在同一个数据库和同一表中，要不然数据库主键约束就不起效果了，因为是不同的数据库和表主键不相关。</li>
</ul>
<h4 id="用redis的set数据结构防重"><a href="#用redis的set数据结构防重" class="headerlink" title="用redis的set数据结构防重"></a>用redis的set数据结构防重</h4><ul>
<li>很多数据需要处理，只能被处理一次，比如我们可以计算数据的 MD5 将其放入redis 的set，每次处理数据，先看这个 MD5 是否已经存在，存在就不处理</li>
</ul>
<h3 id="防重表"><a href="#防重表" class="headerlink" title="防重表"></a>防重表</h3><ul>
<li>使用订单号 orderNo 做为去重表的唯一索引，把唯一索引插入去重表，再进行业务操作，且他们在同一个事务中。这个保证了重复请求时，因为去重表有唯一约束，导致请求失败，避免了幂等问题。这里要注意的是，去重表和业务表应该在同一库中，这样就保证了在同一个事务，即使业务操作失败了，也会把去重表的数据回滚。这个很好的保证了数据一致性。</li>
<li>之前的redis的set防重也是这个道理。</li>
</ul>
<h3 id="全局请求唯一id"><a href="#全局请求唯一id" class="headerlink" title="全局请求唯一id"></a>全局请求唯一id</h3><ul>
<li>调用接口时，生成一个唯一 id，redis 将数据保存到集合中（去重），存在即处理过。可以使用 nginx 设置每一个请求的唯一 id：<code>proxy_set_header X-Request-Id $request_id;</code></li>
</ul>
<h2 id="使用token令牌机制解决接口幂等性"><a href="#使用token令牌机制解决接口幂等性" class="headerlink" title="使用token令牌机制解决接口幂等性"></a>使用token令牌机制解决接口幂等性</h2><ul>
<li>在给需要用到幂等性接口的前端返回数据的时候生成一个token，给前端发一份，给redis中存一份。举例来说，给redis中存的时候，key可以用固定前缀+用户id，这样能保证一个用户在同一时间内只能完成一个订单。</li>
<li>在进行token验证的时候要注意两点，第一是<strong>要验证完token后要先删掉token再处理业务，这是为了防止业务重复处理</strong>；第二是<strong>要保证获取、比较、删除token这三步整体的原子性，这是为了防止在高并发的情况下导致的业务重复处理</strong>，保证三步完整性的lua脚本：**<code>if redis.call(&#39;get&#39;,KEYS[1])==ARGV[1] then return redis.call(&#39;del&#39;,KEYS[1]) else return 0 end</code>**，使用StringRedisTemplate中的execute方法来执行lua脚本，返回0说明token校验失败，返回1说明token校验成功。</li>
</ul>
<h2 id="Transactional本地事务"><a href="#Transactional本地事务" class="headerlink" title="@Transactional本地事务"></a>@Transactional本地事务</h2><ul>
<li><p>这个注解用于方法上，表明该方法对数据库的操作是一个事务，如果要是<strong>被这个注解修饰的方法中抛了异常，那么这个方法之前对数据库做的操作都会回滚（默认是对抛出的RuntimeException作出相应）</strong>。</p>
</li>
<li><p>可以<strong>通过这个注解的rollbackFor属性指定方法抛出哪些异常时数据库会回滚</strong>。</p>
</li>
<li><p><strong>本地事务只能控制当前服务对数据库操作的回滚，无法控制业务处理链上其他服务对数据库操作的回滚</strong>。</p>
</li>
<li><p>可以<strong>使用isolation属性来调整事务的隔离级别，MySQL的事务隔离级别默认是REPEATABLE-READ（可重复读）</strong>。</p>
</li>
<li><p>可以<strong>使用propagation属性来调整事务的传播行为，MySQL的事务传播行为默认是REQUIRED</strong>。</p>
</li>
<li><p>可以<strong>使用timeout属性来设置事务的超时时间，也就是这个事务如果要是在规定的时间内没有处理完的话，就会回滚数据库操作</strong>。</p>
</li>
<li><p>spring家的事务注解是通过生成代理对象来实现功能的，所以同一个对象内事务方法互调时，被调用的事务方法的注解是默认失效的，因为这样做相当于绕过了代理对象。所以在同一个对象内进行事务方法互调的时候，应该使用代理对象来进行事务方法的调用：</p>
<ol>
<li><p>首先引入aop的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">spring-boot-starter-aop.version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">spring-boot-starter-aop.version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--aop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot-starter-aop.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后<strong>在配置类上用注解开启AspectJ动态代理的功能并对外暴露代理对象</strong>：**<code>@EnableAspectJAutoProxy</code>**，这样以后创建动态代理都是通过AspectJ来进行创建（即使没有实现接口，也能创建，这是它最大的特点），如果不加这个注解，那么动态代理会通过JDK来进行创建。</p>
</li>
<li><p>然后就是在同一个对象内事务方法互调的时候，调用事务方法的时候使用当前类的代理对象来进行调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是在OrderServiceImpl类的一个事务方法内部</span></span><br><span class="line"><span class="type">OrderServiceImpl</span> <span class="variable">orderService</span> <span class="operator">=</span> (OrderService)AopContext.currentProxy();<span class="comment">//获取当前类的代理对象</span></span><br><span class="line">orderService.method();<span class="comment">//调用本类中另一个事务方法</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h1 id="2023-x2F-2-x2F-3"><a href="#2023-x2F-2-x2F-3" class="headerlink" title="2023&#x2F;2&#x2F;3"></a>2023&#x2F;2&#x2F;3</h1><h2 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h2><ul>
<li><p>CAP原则又称CAP定理，CAP分别代表分布式系统的三个可能拥有的特性：</p>
<ol>
<li><strong>一致性（Consistency）</strong>：这一特性是指在分布式系统中的所有数据备份，在同一时刻应该是同样的值。（等同于所有节点拥有同一份最新的数据副本）</li>
<li><strong>可用性（Availability）</strong>：这一特性是指在集群中一部分节点故障之后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li>
<li><strong>分区容错性（Partition tolerance）</strong>：大多数分布式系统都分布在多个子网络上，每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败，比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。分区容错性要求系统的部分节点或者网络出现故障之后仍能对外提供服务，也就是<strong>部分故障不影响整体使用</strong>。</li>
</ol>
</li>
<li><p>CAP原则指的是，在同一个分布式系统中，上面这三个特性最多只能同时实现两个，<strong>不可能三者兼顾</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230203193842541.png" alt="image-20230203193842541"></p>
</li>
<li><p><strong>一般来说，分区容错无法避免，因此可以认为CAP的P总是成立</strong>，除非是单机应用，没有任何网络通信。<strong>CAP定理告诉我们，在满足P的前提下，剩下的C和A无法同时做到</strong>。其实想想也很容易理解，如果一个集群中有三个节点，这三个节点之间互相连接，而突然1、2节点之间的通信链路故障了，造成2、3节点之间无法通信，由于分区容错性，部分故障不影响系统整体的使用，不妨假设在出故障之后，又有更新请求打过来，但是由于2、3节点无法通信，所以只有1、2节点对数据进行了更新，在这种情况下，如果要是说满足C也就是一致性的话，我们就只能访问1、2节点，无法访问3节点，这样就不满足A也就是可用性了；如果要是说满足A也就是可用性的话，我们可以访问1、2、3节点，但是只有1、2节点的数据是最新的，3节点的数据还是老数据，这样又不满足C也就是一致性了。所以剩下的C和A只能二选一，两者不可兼得，具体使用哪种方案还是得看具体情况。</p>
</li>
<li><p>在分布式系统中实现数据一致性的算法有raft算法、paxos算法等</p>
</li>
</ul>
<h2 id="raft算法"><a href="#raft算法" class="headerlink" title="raft算法"></a>raft算法</h2><ul>
<li>这是一种用来在分布式系统中实现数据一致性的算法，有个网站上有个动画解释地很通俗易懂：<a target="_blank" rel="noopener" href="http://thesecretlivesofdata.com/raft/%E3%80%82">http://thesecretlivesofdata.com/raft/。</a></li>
<li>raft算法有两个关键点，一是领导选举，二是日志复制。</li>
<li><strong>这个算法只能用来解决分布式系统的一致性，不能解决可用性</strong>，因为如果发生分区错误，且各分区的节点数量是相同的，那么整个分布式系统永远都不会有Leader被选出，整个系统就变成了不可用状态，但是由于分区容错性，各节点还是可以访问的，只不过返回的都是系统不可用的状态。</li>
</ul>
<h3 id="领导选举（Leader-Election）"><a href="#领导选举（Leader-Election）" class="headerlink" title="领导选举（Leader Election）"></a>领导选举（Leader Election）</h3><ol>
<li>集群中的每个节点都有<strong>三种状态</strong>，第一种状态是Follower（随从），第二种状态是Candidate（候选人），第三种状态是Leader（领导）</li>
<li>一开始所有的节点都是Follower，然后所有的集群节点开始一个随机时间（一般在150ms到300ms）的自旋，自旋结束之后，如果它还没有收到来自Candidate的投票请求或者是Leader的心跳维持请求，那么当前这个节点就会变成Candidate。</li>
<li>成为Candidate的节点会向所有其他节点发出投票请求，它自己也会为自己投一票，当其它节点收到投票请求之后，它们会先重置自旋时间，如果它还没有投过票，那么它就会向Candidate进行回复，Candidate收到的回复数就是别的节点的投票数，加上自己给自己投的一票，如果总票数大于一半节点数（这也是一个系统只有一个Leader的原因），那么当前这个Candidate就会变成Leader。</li>
<li>之后所有对系统的修改请求都会先通过Leader，并且Leader会重复在一个小于最小自旋时间的时间段之后向所有的Follower发送心跳维持请求，当Follower接收到心跳维持请求之后，Follower会重置自己的自旋时间并向Leader回复心跳。</li>
<li>在这之后，如果Leader宕掉了，那么Follower就会收不到心跳维持请求，它的自旋时间就不会被重置，直到有一个Follower的自旋时间到了，它会再重复上面的过程变成新的Leader。</li>
<li>如果有两个节点同时变成Candidate怎么办？那这两个Candidate会同时向所有其他节点（包括另一个Candidate）发送投票请求，同时再给自己一个随机的自旋时间，如果其他节点投过票了就不能再投了（Candidate默认投自己一票），否则就会投给那个先到的请求的节点，得到票数之后如果有一个节点的票数大于一半的节点，那么它就会变成Leader，如果没有，那么等着它们的自旋时间结束之后再来一轮，重复这个过程直到选出Leader（正是因为只有票数大于一半的节点才会变成Leader，所以系统中才只会有一个Leader）。</li>
</ol>
<h3 id="日志复制（Log-Replication）"><a href="#日志复制（Log-Replication）" class="headerlink" title="日志复制（Log Replication）"></a>日志复制（Log Replication）</h3><ol>
<li>在进行过领导选举的过程之后，系统已经选出了一个Leader，之后所有对系统的修改请求都会先经过Leader，Leader会把修改要进行的操作记录到自己的日志中，注意此时这个<strong>日志的内容还未提交</strong>，因此系统中不会发生任何改变。</li>
<li>然后Leader<strong>通过心跳维持请求</strong>把自己的日志内容复制一份发给他的所有Follower，这些Follower也把这个日志的内容记录到自己的日志中。</li>
<li>每当Follower把日志写完了，就<strong>通过心跳</strong>回复Leader，当Leader接到一半以上节点的回复之后，就会把日志的修改进行提交，也就是说系统会真正发生改变。</li>
<li>然后Leader会向客户端回复表示系统已经完成了修改，<strong>在下一次发送心跳维持请求</strong>的时候Leader会通知其他的Follower也进行日志的提交，当所有Follower都提交完毕之后，整个系统的数据就保持了一致性。</li>
<li>如果之后整个集群发生分区错误被分割成了多个分区，那么各个分区都会通过领导选举算法选出一个领导，那么此时如何保证集群的一致性呢？只有拥有一半以上节点的分区（后称主分区）才会提交日志，别的分区只是进行了日志复制，当所有分区合并的时候，Leader就会只剩下主分区的Leader，然后Leader将自己的日志复制给所有的节点，那些次分区的日志会回滚并向客户端抛异常。&#x2F;&#x2F;todo 这个地方存疑，一些细节还不是很清楚。</li>
</ol>
<h2 id="大多数情况下在分布式系统中使用AP两个特性"><a href="#大多数情况下在分布式系统中使用AP两个特性" class="headerlink" title="大多数情况下在分布式系统中使用AP两个特性"></a>大多数情况下在分布式系统中使用AP两个特性</h2><ul>
<li>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到99.999…%（N个9），即<strong>保证分区容错性和可用性，舍弃一致性</strong>，但是有的服务也对一致性有一定的要求，所以有人提出了BASE理论。</li>
</ul>
<h2 id="强一致性、弱一致性、最终一致性"><a href="#强一致性、弱一致性、最终一致性" class="headerlink" title="强一致性、弱一致性、最终一致性"></a>强一致性、弱一致性、最终一致性</h2><ul>
<li>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是<strong>强一致性</strong>。如果能容忍后续的部分或者全部访问不到，则是<strong>弱一致性</strong>。如果经过一段时间后要求能访问到更新后的数据，则是<strong>最终一致性</strong>。</li>
</ul>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><ul>
<li><strong>基本可用（Basically Available）</strong>：基本可用是<strong>指分布式系统在出现故障的时候，允许损失部分可用性</strong>（例如响应时间、功能上的可用性）。需要注意的是，<strong>基本可用绝不等价于系统不可用</strong>。<ul>
<li><strong>响应时间上的损失</strong>：正常情况下搜索引擎需要在 0.5 秒之内返回给用户相应的查询结果，但由于出现故障（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了 1~2 秒。</li>
<li><strong>功能上的损失</strong>：购物网站在购物高峰（如双十一）时，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面。</li>
</ul>
</li>
<li><strong>软状态（ Soft State）</strong>：软状态是<strong>指允许系统存在中间状态，而该中间状态不会影响系统整体可用性</strong>。分布式存储中一般一份数据会有多个副本，<strong>允许不同副本同步的延时就是软状态的体现</strong>。mysql replication 的异步复制也是一种体现。</li>
<li><strong>最终一致性（ Eventual Consistency）</strong>：最终一致性是<strong>指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态</strong>。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</li>
</ul>
<h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><ol>
<li>PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，<strong>事务的参数按照加入的事务为准</strong>，该设置是最常用的设置。</li>
<li>PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</li>
<li>PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li>
<li>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</li>
<li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li>
<li>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 PROPAGATION_REQUIRED 类似的操作。</li>
</ol>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><ul>
<li><p><strong>在分布式系统下，业务逻辑通常不是自己所在的模块单独完成的，而是通过很多模块之间远程调用组成一个业务处理链来完成一个业务</strong>，而这会造成很多的问题，分布式事务就是这样的处理业务的模式下的一个很普遍且严重的问题。</p>
</li>
<li><p>在一个业务处理链中，可能有一个或者多个模块出现问题，<strong>只要业务处理链上有一个模块出现问题，那么这个业务处理链对数据库做的所有操作都要回滚，分布式事务就是用来实现这个效果的</strong>，之前用过的@Transactional注解只能对被他修饰的那个方法起作用，无法对整个业务处理链起作用。</p>
</li>
<li><p><strong>产生分布式事务问题的最大原因就是网络问题</strong>，因为分布式的系统依赖于多个模块之间的网络通信，我们很难保证网络什么时候出问题什么时候不出问题。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230203154404398.png" alt="image-20230203154404398"></p>
</li>
</ul>
<h3 id="解决方案-对业务处理链上的所有节点方法加本地事务"><a href="#解决方案-对业务处理链上的所有节点方法加本地事务" class="headerlink" title="解决方案-对业务处理链上的所有节点方法加本地事务"></a>解决方案-对业务处理链上的所有节点方法加本地事务</h3><ul>
<li><strong>我们可以对业务处理链上的所有处理节点的方法都加上事务注解，但是这样做也会有问题，第一是操作比较繁琐，第二是远程服务调用完成后当前服务出现问题，那就只回滚了当前服务对数据库的操作，明显不对，第三是很难覆盖到所有出错的情况（远程服务假失败问题）</strong>，比如一个节点虽然没抛出异常，但是由于这个节点的超时，使得远程调用这个节点的上一个节点得到了节点失败的消息，从而触发它的数据库回滚操作，但是那个超时的节点的数据库却没有回滚，这样就造成了数据库中数据的不一致性，这可能是因为我们的疏忽，没有给他写超时的处理逻辑，但是这样的问题还有很多很多，想要做的面面俱到是比较困难的，所以这种方式不推荐使用。</li>
</ul>
<h3 id="柔性事务和刚性事务"><a href="#柔性事务和刚性事务" class="headerlink" title="柔性事务和刚性事务"></a>柔性事务和刚性事务</h3><ul>
<li><strong>刚性事务</strong>：遵循<strong>ACID原则</strong>，具有<strong>强一致性</strong>。</li>
<li><strong>柔性事务</strong>：遵循<strong>BASE理论</strong>，具有<strong>最终一致性</strong>。与刚性事务不同，柔性事务允许一定时间内不同节点的数据不一致，但要求这些节点的数据最终一致。</li>
</ul>
<h3 id="解决方案-刚性事务-2PC模式"><a href="#解决方案-刚性事务-2PC模式" class="headerlink" title="解决方案-刚性事务-2PC模式"></a>解决方案-刚性事务-2PC模式</h3><ul>
<li><p>这是<strong>数据库原生支持</strong>的2PC（2 phase commit <strong>二阶提交</strong>）模式，<strong>又叫做XA Transactions</strong>，该模式要求<strong>除了在模块本地有本地资源管理器来管理本地事务外，还有个统一的事务管理器来管理所有模块的事务</strong>，<strong>XA是一个两阶段提交协议</strong>，该协议分为以下两个阶段：</p>
<ol>
<li>第一阶段：事务协调器要求每个涉及到事务的数据库<strong>预提交（precommit）此操作，并反应是否可以提交</strong>。</li>
<li>第二阶段：事务协调器要求每个数据库<strong>提交数据，其中，如果有任何一个数据库否决此次提交，那么所有数据库都会被要求回滚它们在此事务中的那部分内容</strong>。</li>
</ol>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230204174729136.png" alt="image-20230204174729136"></p>
</li>
<li><p>XA协议<strong>比较简单</strong>，而且一旦商业数据库实现了XA协议，使用分布式事务的成本也比较低。</p>
</li>
<li><p>但是XA协议的<strong>性能不理想</strong>，特别是在并发量很高的业务处理链路，XA无法满足高并发场景的需求。</p>
</li>
<li><p>XA 目前在商业数据库支持的比较理想，<strong>在mysql数据库中支持的不太理想</strong>，mysql 的XA 实现，没有记录 prepare 阶段日志，主备切换回导致主库与备库数据不一致。</p>
</li>
<li><p><strong>许多 nosql 也没有支持 XA</strong>，这让 XA 的应用场景变得非常狭隘。</p>
</li>
<li><p>也有 <strong>3PC，引入了超时机制（无论协调者还是参与者，在向对方发送请求后，若长时间未收到回应则做出相应处理）</strong></p>
</li>
</ul>
<h3 id="解决方案-柔性事务-TCC事务补偿型方案"><a href="#解决方案-柔性事务-TCC事务补偿型方案" class="headerlink" title="解决方案-柔性事务-TCC事务补偿型方案"></a>解决方案-柔性事务-TCC事务补偿型方案</h3><ul>
<li><p>TCC的三个字符实际上就是指Try、Confirm、Cancel方法，也就是说这种方案要求我们在写一个和数据库进行交互的逻辑的时候要写三个方法，这三个方法分别代表准备数据（try）、提交数据（confirm）、回滚数据（cancel）的逻辑，这样全局事务管理器就能通过调用事务的这些方法来统一管理所有事务的状态了，一开始的时候全局事务管理器让所有事务准备数据（调用对应事务的try方法），然后提交数据（调用对应事务的confirm方法），如果有任何一个事务出现问题，那么事务管理器会让所有的事务回滚数据（调用对应事务的cancel方法）：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230204181024543.png" alt="image-20230204181024543"></p>
</li>
<li><p>也是大体分成三个阶段：</p>
<ol>
<li>一阶段<strong>prepare行为</strong>：调用自定义的<strong>try方法</strong></li>
<li>二阶段<strong>commit行为</strong>：调用自定义的<strong>confirm方法</strong></li>
<li>三阶段<strong>rollback行为</strong>：调用自定义的<strong>cancel方法</strong></li>
</ol>
</li>
<li><p>从本质上看，就是<strong>我们自定义了事务的声明周期方法以供全局事务管理器进行调用</strong>，所谓的<strong>TCC模式，是指支持把自定义的分支事务纳入到全局事务的管理中</strong>。</p>
</li>
</ul>
<h3 id="解决方案-柔性事务-最大努力通知型方案"><a href="#解决方案-柔性事务-最大努力通知型方案" class="headerlink" title="解决方案-柔性事务-最大努力通知型方案"></a>解决方案-柔性事务-最大努力通知型方案</h3><ul>
<li>抽象地来说其实就是<strong>一个终端按照规律不停向别的终端发送消息，直到所有终端都回复表示自己已经收到了消息</strong>。</li>
<li>在分布式事务场景中具体来说就是，<strong>在事务失败的时候，对于已经完成的事务，事务管理器会按规律进行通知它们，直到所有已经完成的事务都返回表示自己已经收到，然后收到消息的已经完成的事务会进行回滚</strong>（&#x2F;&#x2F;todo 回滚是在发送收到之前还是之后？），不保证数据一定能通知成功，但会提供可查询操作接口进行核对。</li>
<li>这种方案<strong>主要用在与第三方系统通讯时，通常使用MQ进行实现</strong>，比如：调用微信或支付宝支付后的支付结果通知。这种方案也是结合 MQ 进行实现，例如：通过 MQ 发送 http 请求，设置最大通知次数。达到通知次数后即不再通知。</li>
<li>案例：银行通知、商户通知等（各大交易业务平台间的商户通知：多次通知、查询校对、对账文件），支付宝的支付成功异步回调</li>
</ul>
<h3 id="解决方案-柔性事务-可靠消息-最终一致性方案（异步确保型）"><a href="#解决方案-柔性事务-可靠消息-最终一致性方案（异步确保型）" class="headerlink" title="解决方案-柔性事务-可靠消息+最终一致性方案（异步确保型）"></a>解决方案-柔性事务-可靠消息+最终一致性方案（异步确保型）</h3><ul>
<li>和上面那个差不多，具体到分布式事务的场景就是<strong>在事务失败的时候异步发送消息有规律地通知已经完成的事务进行回滚</strong>(&#x2F;&#x2F;todo 不知道这个解释对不对)。异步的通知决定了这种方案是柔性的，同时异步的解决方案还能提高并发性能。</li>
<li>实现：业务处理服务在业务事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消息数据，而不是真正的发送。业务处理服务在业务事务提交之后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才会真正发送。</li>
</ul>
<h1 id="2023-x2F-2-x2F-4"><a href="#2023-x2F-2-x2F-4" class="headerlink" title="2023&#x2F;2&#x2F;4"></a>2023&#x2F;2&#x2F;4</h1><h2 id="Seata解决分布式事务"><a href="#Seata解决分布式事务" class="headerlink" title="Seata解决分布式事务"></a>Seata解决分布式事务</h2><h3 id="Seata是什么"><a href="#Seata是什么" class="headerlink" title="Seata是什么"></a>Seata是什么</h3><ul>
<li>Seata是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata为用户<strong>提供了AT（Auto Transaction 自动事务）、TCC、SAGA和XA事务模式</strong>，为用户打造一站式的分布式解决方案。</li>
</ul>
<h3 id="Seata的工作原理"><a href="#Seata的工作原理" class="headerlink" title="Seata的工作原理"></a>Seata的工作原理</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230204193132779.png" alt="image-20230204193132779"></p>
<ul>
<li>调用其他事务的事务是<strong>全局事务</strong>，被调用的事务是<strong>分支事务</strong>。</li>
<li><strong>TC-事务协调者</strong>：维护全局和分支事务的状态，驱动全局事务提交或回滚。</li>
<li><strong>TM-事务管理器</strong>：定义全局事务的范围-开始全局事务、提交或回滚全局事务。</li>
<li><strong>RM-资源管理器</strong>：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
<li><strong>在开启全局事务的时候，TM会先向TC进行报告，然后TC就可以知道全局事务的实时状态且能控制TM了，然后在全局事务调用分支事务的时候，每当调用到一个分支事务，当前的分支事务都会将自己注册到TC中，这样TC也能知道分支事务的实时状态且能控制RM了，这样当某个事务失败后，TC会让所有已经完成的事务也回滚</strong>。</li>
</ul>
<h3 id="Seata怎么用"><a href="#Seata怎么用" class="headerlink" title="Seata怎么用"></a>Seata怎么用</h3><ul>
<li><p>首先如果要用Seata的<strong>AT模式</strong>应该<strong>对分布式事务用到的每一个微服务的数据库中创建undo_log表来记录快照以在回滚的时候补偿已经提交的事务</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 注意此处0.3.0+ 增加唯一索引 ux_undo_log</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `undo_log` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `branch_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `context` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `rollback_info` longblob <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_created` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `log_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `ext` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`,`branch_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后<strong>下载事务协调器seata-server，这个东西实际上就是上面提到的TC-事务协调器</strong>：<a target="_blank" rel="noopener" href="https://github.com/seata/seata/releases%EF%BC%8C%E8%BF%99%E4%B8%AA%E4%BA%8B%E5%8A%A1%E5%8D%8F%E8%B0%83%E5%99%A8(TC)%E5%AE%9E%E9%99%85%E4%B8%8A%E5%B0%B1%E6%98%AF%E4%B8%8A%E9%9D%A2%E8%AF%B4%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%AD%E7%9A%84%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%8C%E9%80%9A%E8%BF%87%E5%AE%83%E6%9D%A5%E5%AF%B9%E5%90%84%E4%BA%8B%E5%8A%A1%E8%BF%9B%E8%A1%8C%E5%8D%8F%E8%B0%83%EF%BC%8C%E8%80%8C%E6%AF%8F%E4%B8%AA%E4%BA%8B%E5%8A%A1%E8%BF%98%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%EF%BC%8C**%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E5%B0%B1%E6%98%AF%E9%80%9A%E8%BF%87%E6%93%8D%E4%BD%9C%E4%BA%8B%E5%8A%A1%E5%AF%B9%E5%BA%94%E7%9A%84%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E6%9D%A5%E5%AF%B9%E6%89%80%E6%9C%89%E4%BA%8B%E5%8A%A1%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E7%9A%84**%E3%80%82">https://github.com/seata/seata/releases，这个事务协调器(TC)实际上就是上面说的解决方案中的全局事务管理器，通过它来对各事务进行协调，而每个事务还有自己的事务管理器，**全局事务管理器就是通过操作事务对应的本地事务管理器来对所有事务进行管理的**。</a></p>
</li>
<li><p>然后就是引入依赖，引入后<strong>要注意seata-all这个包的版本，这个包的版本决定着我们应该使用什么版本的seata-server</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后就是<strong>解压并启动下载好的seata-server</strong>，并<strong>按照自己的需求修改registry.conf注册中心配置和file.conf</strong></p>
</li>
<li></li>
<li><p>最后给分布式的全局事务上标注@GlobalTransactional注解，给分支事务上标注@Transactional注解，然后就能用了。</p>
</li>
</ul>
<h2 id="MQ解决分布式事务"><a href="#MQ解决分布式事务" class="headerlink" title="MQ解决分布式事务"></a>MQ解决分布式事务</h2><ul>
<li>seata默认用的是AT模式，分为两个阶段，一阶段是业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源；二阶段是异步化提交，如果出现问题，那么会通过一阶段的回滚日志进行反向补偿以达到回滚的目的（&#x2F;&#x2F;todo 还是不太清楚细节）。由于事务之间的隔离级别太高，所以这个模式不满足高并发的业务场景，所以<strong>考虑使用MQ来实现异步的最大努力通知型方案</strong>。</li>
</ul>
<h1 id="2023-x2F-2-x2F-6"><a href="#2023-x2F-2-x2F-6" class="headerlink" title="2023&#x2F;2&#x2F;6"></a>2023&#x2F;2&#x2F;6</h1><h2 id="项目开发中dev、test和prod是什么意思"><a href="#项目开发中dev、test和prod是什么意思" class="headerlink" title="项目开发中dev、test和prod是什么意思"></a>项目开发中dev、test和prod是什么意思</h2><ul>
<li><strong>开发环境（dev）</strong>：开发环境是程序猿们专门用于开发的服务器，配置可以比较随意，为了开发调试方便，一般打开全部错误报告。</li>
<li><strong>测试环境（test）</strong>：一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产机上。</li>
<li><strong>生产环境（prod）</strong>：是值<strong>正式提供对外服务</strong>的，一般会关掉错误报告，打开错误日志。</li>
<li>三个环境也可以说是系统开发的三个阶段：<strong>开发-&gt;测试-&gt;上线</strong>，其中<strong>生产环境也就是通常说的真实环境</strong>。</li>
</ul>
<h2 id="如何配置Bean的作用域"><a href="#如何配置Bean的作用域" class="headerlink" title="如何配置Bean的作用域"></a>如何配置Bean的作用域</h2><ul>
<li><p>Spring中Bean的作用域通常有下面几种：</p>
<ol>
<li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li>
<li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li>
<li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li>
</ol>
</li>
<li><p>使用@Scope注解的方式设置Bean的作用域为原型模式，也就是每次用到的时候都创建一个新的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2023-x2F-2-x2F-8"><a href="#2023-x2F-2-x2F-8" class="headerlink" title="2023&#x2F;2&#x2F;8"></a>2023&#x2F;2&#x2F;8</h1><h2 id="ActiveProfiles注解"><a href="#ActiveProfiles注解" class="headerlink" title="@ActiveProfiles注解"></a>@ActiveProfiles注解</h2><ul>
<li><p>一般作用于测试类上， 用于<strong>声明生效的 Spring 配置文件</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest(webEnvironment = RANDOM_PORT)</span></span><br><span class="line"><span class="meta">@ActiveProfiles(&quot;test&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TestBase</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="2023-x2F-2-x2F-9"><a href="#2023-x2F-2-x2F-9" class="headerlink" title="2023&#x2F;2&#x2F;9"></a>2023&#x2F;2&#x2F;9</h1><h2 id="数据库被人黑了"><a href="#数据库被人黑了" class="headerlink" title="数据库被人黑了"></a>数据库被人黑了</h2><ul>
<li>谔谔，数据库竟然被人删了，也怪我密码设的太弱了，长个教训，以后可以从下面的这几个方面提高安全性：<ol>
<li>使用密码生成器生成强密码</li>
<li>开启mysql的binlog日志，数据库寄了可以通过这个日志来恢复数据</li>
<li>对外关闭数据库连接的端口，只能通过SSH来对数据库进行连接</li>
</ol>
</li>
</ul>
<h2 id="数据库无法远程连接"><a href="#数据库无法远程连接" class="headerlink" title="数据库无法远程连接"></a>数据库无法远程连接</h2><ul>
<li>报错：<code>Access denied for user &#39;root&#39;@&#39;xxx.xxx.xxx.xxx&#39; (using password: YES)</code></li>
<li>首先确保自己的密码输入正确</li>
<li>然后就是要打开mysql的远程授权，在mysql中使用命令：**<code>grant all privileges on *.* to root@&#39;%&#39; identified by &#39;root密码&#39;;</code><strong>然后再使用命令</strong><code>flush privileges;</code>**就能开启远程授权了。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://Konjacor.github.io">Konjacer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://konjacor.github.io/2022/12/22/%E8%B4%BE%E5%B2%9B%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/">https://konjacor.github.io/2022/12/22/%E8%B4%BE%E5%B2%9B%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Konjacor.github.io" target="_blank">孤舟</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SpringCloud/">SpringCloud</a><a class="post-meta__tags" href="/tags/SpringBoot/">SpringBoot</a><a class="post-meta__tags" href="/tags/SpringMVC/">SpringMVC</a><a class="post-meta__tags" href="/tags/%E5%95%86%E5%9F%8E/">商城</a><a class="post-meta__tags" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a><a class="post-meta__tags" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a><a class="post-meta__tags" href="/tags/SpringCloudAlibaba/">SpringCloudAlibaba</a><a class="post-meta__tags" href="/tags/Docker/">Docker</a><a class="post-meta__tags" href="/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/">实战项目</a><a class="post-meta__tags" href="/tags/MyBatis/">MyBatis</a></div><div class="post_share"><div class="social-share" data-image="/img/background.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/20/%E7%BB%BC%E5%90%88%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"><img class="prev-cover" src="/img/background.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">综合知识整理</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/20/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E9%87%8D%E7%82%B9(%E6%9A%82%E6%97%B6)/"><img class="next-cover" src="/img/background.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/07/SpringCloud/" title="SpringCloud"><img class="cover" src="/img/background.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-07</div><div class="title">SpringCloud</div></div></a></div><div><a href="/2022/09/11/SpringBoot%E5%85%A5%E9%97%A8/" title="SpringBoot入门"><img class="cover" src="/img/background.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-11</div><div class="title">SpringBoot入门</div></div></a></div><div><a href="/2022/09/07/SpringMVC%E5%85%A5%E9%97%A8/" title="SpringMVC入门"><img class="cover" src="/img/background.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-07</div><div class="title">SpringMVC入门</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/xiaozhai.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Konjacer</div><div class="author-info__description">真我不拘于形</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">83</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Konjacor" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1175590069@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/Konjacor" target="_blank" title="Gitee"><i class="fa-solid fa-g"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-x2F-12-x2F-23"><span class="toc-number">2.</span> <span class="toc-text">2022&#x2F;12&#x2F;23</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC"><span class="toc-number">2.1.</span> <span class="toc-text">为什么使用微服务的架构风格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">集群、分布式和节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">远程调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">2.4.</span> <span class="toc-text">负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C-x2F-%E5%8F%91%E7%8E%B0%E4%B8%AD%E5%BF%83"><span class="toc-number">2.5.</span> <span class="toc-text">服务注册&#x2F;发现中心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><span class="toc-number">2.6.</span> <span class="toc-text">配置中心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E5%92%8C%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7"><span class="toc-number">2.7.</span> <span class="toc-text">服务熔断和服务降级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API%E7%BD%91%E5%85%B3"><span class="toc-number">2.8.</span> <span class="toc-text">API网关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">2.9.</span> <span class="toc-text">完整服务架构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%88%92%E5%88%86%E5%9B%BE"><span class="toc-number">2.10.</span> <span class="toc-text">微服务划分图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker"><span class="toc-number">2.11.</span> <span class="toc-text">Docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%9F%E4%BA%86%E4%B8%AA%E8%85%BE%E8%AE%AF%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">2.12.</span> <span class="toc-text">租了个腾讯云服务器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85mysql-5-7"><span class="toc-number">2.13.</span> <span class="toc-text">使用docker安装mysql 5.7</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E9%95%9C%E5%83%8F"><span class="toc-number">2.13.1.</span> <span class="toc-text">下载镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%B7%B2%E7%BB%8F%E4%B8%8B%E8%BD%BD%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-number">2.13.2.</span> <span class="toc-text">查看已经下载的镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B%E5%B9%B6%E5%90%AF%E5%8A%A8"><span class="toc-number">2.13.3.</span> <span class="toc-text">创建实例并启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-number">2.13.4.</span> <span class="toc-text">查看某个实例的日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bdocker%E4%B8%AD%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BD%AF%E4%BB%B6"><span class="toc-number">2.13.5.</span> <span class="toc-text">查看docker中正在运行的软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2docker%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.13.6.</span> <span class="toc-text">停止docker实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8docker%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.13.7.</span> <span class="toc-text">启动docker实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%90%AFdocker%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.13.8.</span> <span class="toc-text">重启docker实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4docker%E5%AE%B9%E5%99%A8"><span class="toc-number">2.13.9.</span> <span class="toc-text">删除docker容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4docker%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F"><span class="toc-number">2.13.10.</span> <span class="toc-text">删除docker本地镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5docker%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%86%85%E9%83%A8"><span class="toc-number">2.13.11.</span> <span class="toc-text">进入docker正在运行的实例内部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A9%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AE%B9%E5%99%A8%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.13.12.</span> <span class="toc-text">让对应的容器开机自启动实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAmysql%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.13.13.</span> <span class="toc-text">创建mysql的配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%90%84%E5%AE%9E%E4%BE%8B%E5%8D%A0%E7%94%A8%E8%B5%84%E6%BA%90%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.13.14.</span> <span class="toc-text">查看各实例占用资源的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%E5%A4%8D%E5%88%B6%E5%88%B0%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.13.15.</span> <span class="toc-text">将docker容器中的内容复制到指定位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SSH"><span class="toc-number">2.14.</span> <span class="toc-text">SSH</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%9C%AC%E5%9C%B0%E4%BD%BF%E7%94%A8Navicat%E9%80%9A%E8%BF%87SSH%E5%8D%8F%E8%AE%AE%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84mysql%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">2.15.</span> <span class="toc-text">在本地使用Navicat通过SSH协议连接到服务器上的mysql数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%86%E9%92%A5"><span class="toc-number">2.15.1.</span> <span class="toc-text">创建密钥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E5%AF%86%E9%92%A5%E7%BB%91%E5%AE%9A%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E4%BE%8B%E4%B8%8A"><span class="toc-number">2.15.2.</span> <span class="toc-text">将密钥绑定到服务器实例上</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.15.3.</span> <span class="toc-text">新建连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8docker%E5%AE%89%E8%A3%85redis"><span class="toc-number">2.16.</span> <span class="toc-text">使用docker安装redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8IDEA%E4%B8%AD%E6%90%AD%E5%BB%BA%E5%90%84%E7%A7%8D%E6%A8%A1%E5%9D%97"><span class="toc-number">2.17.</span> <span class="toc-text">在IDEA中搭建各种模块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-x2F-12-x2F-24"><span class="toc-number">3.</span> <span class="toc-text">2022&#x2F;12&#x2F;24</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E9%A1%B9%E7%9B%AE%E7%9A%84-gitignore%E6%96%87%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">设置项目的.gitignore文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDEA%E4%B8%ADProject-Structure%E4%B8%AD%E7%9A%84Facets%E9%85%8D%E7%BD%AE"><span class="toc-number">3.2.</span> <span class="toc-text">IDEA中Project Structure中的Facets配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PowerDesigner"><span class="toc-number">3.3.</span> <span class="toc-text">PowerDesigner</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%EF%BC%9Ajava-%E7%A8%8B%E5%BA%8F%E5%8C%85org-aspectj-lang%E4%B8%8D%E5%AD%98%E5%9C%A8"><span class="toc-number">3.4.</span> <span class="toc-text">启动报错：java: 程序包org.aspectj.lang不存在</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%8B%E8%BD%BD%E4%BE%9D%E8%B5%96"><span class="toc-number">3.5.</span> <span class="toc-text">前端项目下载依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C"><span class="toc-number">3.6.</span> <span class="toc-text">前端项目运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bwindows%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8"><span class="toc-number">3.7.</span> <span class="toc-text">查看windows系统的端口占用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AD%90%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98"><span class="toc-number">3.8.</span> <span class="toc-text">关于子模块的依赖问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Emaven%E7%9A%84%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-number">3.9.</span> <span class="toc-text">关于maven的版本问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-x2F-12-x2F-27"><span class="toc-number">4.</span> <span class="toc-text">2022&#x2F;12&#x2F;27</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%9C%89%E4%BA%9Bjar%E5%8C%85%E6%97%A0%E6%B3%95%E4%BB%8E%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E4%B8%8B%E8%BD%BD"><span class="toc-number">4.1.</span> <span class="toc-text">关于有些jar包无法从远程仓库下载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-x2F-12-x2F-28"><span class="toc-number">5.</span> <span class="toc-text">2022&#x2F;12&#x2F;28</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Emybatis-plus%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84%E4%BE%9D%E8%B5%96"><span class="toc-number">5.1.</span> <span class="toc-text">关于mybatis-plus的代码生成器的依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-number">5.2.</span> <span class="toc-text">关于数据库表的一些设计规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Espring-boot-maven-plugin"><span class="toc-number">5.3.</span> <span class="toc-text">关于spring-boot-maven-plugin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#maven%E6%89%A7%E8%A1%8Cinstall%E7%9A%84%E6%97%B6%E5%80%99%E6%8A%A5%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E9%94%99%E8%AF%AF"><span class="toc-number">5.4.</span> <span class="toc-text">maven执行install的时候报单元测试错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDEA%E6%9C%89%E6%97%B6%E5%8C%85%E6%98%8E%E6%98%8E%E5%AD%98%E5%9C%A8%E4%BD%86%E6%98%AF%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E6%97%B6%E6%80%BB%E6%98%AF%E6%8A%A5%E6%89%BE%E4%B8%8D%E5%88%B0%E6%9F%90%E4%B8%AA%E5%8C%85"><span class="toc-number">5.5.</span> <span class="toc-text">IDEA有时包明明存在但是运行程序时总是报找不到某个包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-x2F-12-x2F-29"><span class="toc-number">6.</span> <span class="toc-text">2022&#x2F;12&#x2F;29</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E4%B8%80%E7%A7%8D%E5%A5%87%E6%80%AA%E7%9A%84%E4%BE%9D%E8%B5%96%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">记录一种奇怪的依赖引入方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Enacos-2-x%E7%89%88%E6%9C%AC%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.2.</span> <span class="toc-text">关于nacos 2.x版本无法访问的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%9C%A8nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E4%B8%8A%E5%81%9A%E9%85%8D%E7%BD%AE"><span class="toc-number">6.3.</span> <span class="toc-text">关于在nacos配置中心上做配置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2022-x2F-12-x2F-30"><span class="toc-number">7.</span> <span class="toc-text">2022&#x2F;12&#x2F;30</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%92%E9%99%A4%E4%B8%8D%E6%83%B3%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8C%85"><span class="toc-number">7.1.</span> <span class="toc-text">如何排除不想加载的包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-1"><span class="toc-number">8.</span> <span class="toc-text">2023&#x2F;1&#x2F;1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8mybatis-plus%E6%9F%A5%E4%B8%8D%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.1.</span> <span class="toc-text">关于使用mybatis-plus查不出数据的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%AD%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-number">8.2.</span> <span class="toc-text">在实体类中添加数据库表中不存在的字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8VScode%E4%B8%AD%E6%B7%BB%E5%8A%A0vue%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF"><span class="toc-number">8.3.</span> <span class="toc-text">在VScode中添加vue代码模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-2"><span class="toc-number">9.</span> <span class="toc-text">2023&#x2F;1&#x2F;2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">9.1.</span> <span class="toc-text">跨域问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B9%B6%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE"><span class="toc-number">9.2.</span> <span class="toc-text">如何初始化并启动一个前端项目</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-3"><span class="toc-number">10.</span> <span class="toc-text">2023&#x2F;1&#x2F;3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8"><span class="toc-number">10.1.</span> <span class="toc-text">项目中如何进行文件存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-4"><span class="toc-number">11.</span> <span class="toc-text">2023&#x2F;1&#x2F;4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C"><span class="toc-number">11.1.</span> <span class="toc-text">后端数据校验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%90%8E%E7%AB%AF%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C"><span class="toc-number">11.1.1.</span> <span class="toc-text">为什么后端要进行数据校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EJSR"><span class="toc-number">11.1.2.</span> <span class="toc-text">关于JSR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EJSR-303"><span class="toc-number">11.1.3.</span> <span class="toc-text">关于JSR-303</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C"><span class="toc-number">11.1.4.</span> <span class="toc-text">基本数据校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C"><span class="toc-number">11.1.5.</span> <span class="toc-text">分组数据校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C"><span class="toc-number">11.1.6.</span> <span class="toc-text">自定义数据校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NotBlank%E3%80%81-NotNull%E3%80%81-NotEmpty%E3%80%81-NonNull%E5%9B%9B%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.1.7.</span> <span class="toc-text">@NotBlank、@NotNull、@NotEmpty、@NonNull四者之间的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Validated%E6%B3%A8%E8%A7%A3%E5%92%8C-Valid%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">11.1.8.</span> <span class="toc-text">@Validated注解和@Valid注解的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%8A%B6%E6%80%81%E7%A0%81%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83"><span class="toc-number">11.2.</span> <span class="toc-text">项目中的系统状态码使用规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">11.3.</span> <span class="toc-text">统一异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%AD%97%E6%AE%B5%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E5%90%8E%E6%B2%A1%E6%9C%89%E6%95%88%E6%9E%9C"><span class="toc-number">11.4.</span> <span class="toc-text">配置实体类字段自动填充后没有效果</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-5"><span class="toc-number">12.</span> <span class="toc-text">2023&#x2F;1&#x2F;5</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SPU%E5%92%8CSKU"><span class="toc-number">12.1.</span> <span class="toc-text">SPU和SKU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SPU%EF%BC%88Standard-Product-Unit-%E6%A0%87%E5%87%86%E5%8C%96%E4%BA%A7%E5%93%81%E5%8D%95%E5%85%83%EF%BC%89"><span class="toc-number">12.1.1.</span> <span class="toc-text">SPU（Standard Product Unit 标准化产品单元）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SKU%EF%BC%88Stock-Keeping-Unit-%E6%9C%80%E5%B0%8F%E5%BA%93%E5%AD%98%E5%8D%95%E5%85%83%EF%BC%89"><span class="toc-number">12.1.2.</span> <span class="toc-text">SKU（Stock Keeping Unit 最小库存单元）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JsonInclude%E6%B3%A8%E8%A7%A3"><span class="toc-number">12.2.</span> <span class="toc-text">@JsonInclude注解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-6"><span class="toc-number">13.</span> <span class="toc-text">2023&#x2F;1&#x2F;6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#EnableTransactionManagement"><span class="toc-number">13.1.</span> <span class="toc-text">@EnableTransactionManagement</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E5%86%97%E4%BD%99%E5%AD%98%E5%82%A8"><span class="toc-number">13.2.</span> <span class="toc-text">数据库表的冗余存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%A1%A8%E8%81%94%E6%9F%A5"><span class="toc-number">13.3.</span> <span class="toc-text">不要使用多表联查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#target%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%B2%A1%E6%9C%89mapper%E7%9A%84xml%E6%96%87%E4%BB%B6"><span class="toc-number">13.4.</span> <span class="toc-text">target目录下没有mapper的xml文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-Object%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">13.5.</span> <span class="toc-text">java Object的划分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PO%EF%BC%88persistent-object%EF%BC%89%E6%8C%81%E4%B9%85%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.5.1.</span> <span class="toc-text">PO（persistent object）持久对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DO%EF%BC%88Domain-Object%EF%BC%89%E9%A2%86%E5%9F%9F%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.5.2.</span> <span class="toc-text">DO（Domain Object）领域对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TO%EF%BC%88Transfer-Object%EF%BC%89%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.5.3.</span> <span class="toc-text">TO（Transfer Object）数据传输对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DTO%EF%BC%88Data-Transfer-Object%EF%BC%89%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.5.4.</span> <span class="toc-text">DTO（Data Transfer Object）数据传输对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VO%EF%BC%88Value-Object-x2F-View-Object%EF%BC%89%E5%80%BC%E5%AF%B9%E8%B1%A1-x2F-%E8%A7%86%E5%9B%BE%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.5.5.</span> <span class="toc-text">VO（Value  Object&#x2F;View Object）值对象&#x2F;视图对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BO%EF%BC%88business-object%EF%BC%89%E4%B8%9A%E5%8A%A1%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.5.6.</span> <span class="toc-text">BO（business object）业务对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POJO%EF%BC%88plain-ordinary-java-object%EF%BC%89%E7%AE%80%E5%8D%95%E6%97%A0%E8%A7%84%E5%88%99java%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.5.7.</span> <span class="toc-text">POJO（plain ordinary java object）简单无规则java对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DAO%EF%BC%88data-access-object%EF%BC%89%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.5.8.</span> <span class="toc-text">DAO（data access object）数据访问对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6VO%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%B0Entity"><span class="toc-number">13.6.</span> <span class="toc-text">复制VO的数据到Entity</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-7"><span class="toc-number">14.</span> <span class="toc-text">2023&#x2F;1&#x2F;7</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%AC%A6%E5%90%88%E5%9C%BA%E6%99%AF%E7%9A%84wrapper"><span class="toc-number">14.1.</span> <span class="toc-text">使用符合场景的wrapper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-RequestParam%E6%8E%A5%E6%94%B6query%E5%8F%82%E6%95%B0"><span class="toc-number">14.2.</span> <span class="toc-text">使用@RequestParam接收query参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mapper%E4%B8%AD%E7%9A%84selectCount%E6%96%B9%E6%B3%95"><span class="toc-number">14.3.</span> <span class="toc-text">Mapper中的selectCount方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%E7%9A%84%E5%8A%A8%E6%80%81sql"><span class="toc-number">14.4.</span> <span class="toc-text">批量删除的动态sql</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8F%E4%B8%80%E5%B1%82%E7%BB%93%E6%9E%84%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B"><span class="toc-number">14.5.</span> <span class="toc-text">每一层结构做了什么事</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-8"><span class="toc-number">15.</span> <span class="toc-text">2023&#x2F;1&#x2F;8</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EOpenFeign%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">15.1.</span> <span class="toc-text">基于OpenFeign的远程调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8IDEA%E4%B8%AD%E5%90%8C%E6%97%B6%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AA%E6%9C%8D%E5%8A%A1"><span class="toc-number">15.2.</span> <span class="toc-text">在IDEA中同时启动多个服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AEjson%E6%95%B0%E6%8D%AE%E4%B8%AD%E6%97%A5%E6%9C%9F%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">15.3.</span> <span class="toc-text">配置json数据中日期数据的格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97%E7%AD%89%E7%BA%A7"><span class="toc-number">15.4.</span> <span class="toc-text">配置日志等级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-10"><span class="toc-number">16.</span> <span class="toc-text">2023&#x2F;1&#x2F;10</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E4%B8%AD%E5%9C%A8%E5%91%BD%E4%BB%A4%E4%B8%8A%E4%B8%8B%E8%BD%BD%E7%BD%91%E7%BB%9C%E5%86%85%E5%AE%B9"><span class="toc-number">16.1.</span> <span class="toc-text">linux中在命令上下载网络内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E4%BF%AE%E6%94%B9%E7%9B%AE%E5%BD%95%E7%9A%84%E6%9D%83%E9%99%90"><span class="toc-number">16.2.</span> <span class="toc-text">linux修改目录的权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6"><span class="toc-number">16.3.</span> <span class="toc-text">linux解压文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-11"><span class="toc-number">17.</span> <span class="toc-text">2023&#x2F;1&#x2F;11</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%9B%E5%8C%85%E5%AF%BC%E5%85%A5%E5%90%8E%E9%87%8C%E9%9D%A2%E7%9A%84%E6%9F%90%E4%BA%9B%E5%8C%85%E5%92%8C%E9%A2%84%E6%9C%9F%E7%9A%84%E4%B8%8D%E5%A4%AA%E4%B8%80%E6%A0%B7"><span class="toc-number">17.1.</span> <span class="toc-text">为什么有些包导入后里面的某些包和预期的不太一样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES%E4%B8%AD%E7%9A%84nested%E7%B1%BB%E5%9E%8B"><span class="toc-number">17.2.</span> <span class="toc-text">ES中的nested类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES%E7%9A%84%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95"><span class="toc-number">17.3.</span> <span class="toc-text">ES的倒排索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">17.4.</span> <span class="toc-text">ES存储数据的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES%E8%AE%BE%E7%BD%AE-x2F-%E4%BF%AE%E6%94%B9%E7%B4%A2%E5%BC%95%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">17.5.</span> <span class="toc-text">ES设置&#x2F;修改索引的映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="toc-number">17.6.</span> <span class="toc-text">ES查询数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES%E8%81%9A%E5%90%88%E5%88%86%E6%9E%90"><span class="toc-number">17.7.</span> <span class="toc-text">ES聚合分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-12"><span class="toc-number">18.</span> <span class="toc-text">2023&#x2F;1&#x2F;12</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E7%B1%BB%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E5%A4%84%E7%90%86%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">18.1.</span> <span class="toc-text">统一返回类使用泛型处理的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cstream%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E5%BF%85%E9%A1%BB%E4%B8%BAfinal"><span class="toc-number">18.2.</span> <span class="toc-text">lambda表达式和stream流式编程中使用的外部变量必须为final</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-13"><span class="toc-number">19.</span> <span class="toc-text">2023&#x2F;1&#x2F;13</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E6%95%B4%E5%90%88ElasticSearch"><span class="toc-number">19.1.</span> <span class="toc-text">SpringBoot整合ElasticSearch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Feign%E7%9A%84%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">19.2.</span> <span class="toc-text">Feign的调用流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-14"><span class="toc-number">20.</span> <span class="toc-text">2023&#x2F;1&#x2F;14</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">20.1.</span> <span class="toc-text">正向代理和反向代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">20.2.</span> <span class="toc-text">nginx配置文件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3nginx%E8%BD%AC%E5%8F%91%E7%9A%84%E6%97%B6%E5%80%99%E4%BC%9A%E4%B8%A2%E6%8E%89%E5%8E%9F%E6%9C%AC%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%97%E6%AE%B5"><span class="toc-number">20.3.</span> <span class="toc-text">如何解决nginx转发的时候会丢掉原本请求报文的一些字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8nginx%E6%90%AD%E5%BB%BA%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E7%8E%AF%E5%A2%83"><span class="toc-number">20.4.</span> <span class="toc-text">使用nginx搭建域名访问环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87JMeter%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E6%9D%A5%E5%B0%9D%E8%AF%95%E5%AF%B9%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="toc-number">20.5.</span> <span class="toc-text">通过JMeter压力测试来尝试对项目进行优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-15"><span class="toc-number">21.</span> <span class="toc-text">2023&#x2F;1&#x2F;15</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8IDEA%E4%B8%AD%E7%BB%99%E6%9F%90%E4%B8%AA%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AEjvm%E5%8F%82%E6%95%B0"><span class="toc-number">21.1.</span> <span class="toc-text">在IDEA中给某个服务配置jvm参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%9B%91%E8%A7%86java%E8%BF%9B%E7%A8%8B%E4%BB%A5%E5%88%86%E6%9E%90%E5%85%B6%E5%90%84%E7%A7%8D%E6%8C%87%E6%A0%87%E4%BB%8E%E8%80%8C%E5%81%9A%E5%87%BA%E4%BC%98%E5%8C%96"><span class="toc-number">21.2.</span> <span class="toc-text">通过监视java进程以分析其各种指标从而做出优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%88%86%E6%9E%90%E4%B8%8E%E8%B0%83%E4%BC%98"><span class="toc-number">21.3.</span> <span class="toc-text">JVM分析与调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nginx%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB"><span class="toc-number">21.4.</span> <span class="toc-text">Nginx动静分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">21.5.</span> <span class="toc-text">缓存的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-16"><span class="toc-number">22.</span> <span class="toc-text">2023&#x2F;1&#x2F;16</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%88%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%AD%90%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%9A%84%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">22.1.</span> <span class="toc-text">关于父项目管理子项目依赖的版本的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E6%95%B4%E5%90%88Redis"><span class="toc-number">22.2.</span> <span class="toc-text">SpringBoot整合Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">22.3.</span> <span class="toc-text">高并发环境下缓存失效的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%88%E5%A4%A7%E6%B5%81%E9%87%8F%E6%9F%A5%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-number">22.3.1.</span> <span class="toc-text">缓存穿透（大流量查一个不存在的数据）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%88%E6%B5%81%E9%87%8F%E9%AB%98%E5%B3%B0%E6%97%B6%E7%BC%93%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9F%AD%E6%97%B6%E9%97%B4%E5%86%85%E5%90%8C%E6%97%B6%E8%BF%87%E6%9C%9F%EF%BC%89"><span class="toc-number">22.3.2.</span> <span class="toc-text">缓存雪崩（流量高峰时缓存中的数据短时间内同时过期）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%88%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E5%9C%A8%E6%B5%81%E9%87%8F%E9%AB%98%E5%B3%B0%E6%9C%9F%E5%A4%B1%E6%95%88%EF%BC%89"><span class="toc-number">22.3.3.</span> <span class="toc-text">缓存击穿（热点数据在流量高峰期失效）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8A%A0%E9%94%81"><span class="toc-number">22.4.</span> <span class="toc-text">分布式的情况下如何加锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E9%94%81%E7%9A%84%E6%97%B6%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-number">22.5.</span> <span class="toc-text">本地锁的时序问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E4%B8%8A%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E8%BF%9B%E8%A1%8C%E5%8A%A0%E6%9C%AC%E5%9C%B0%E9%94%81%E4%BB%A5%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">22.6.</span> <span class="toc-text">对上面的代码进行加本地锁以防止缓存击穿</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8IDEA%E6%A8%A1%E6%8B%9F%E9%9B%86%E7%BE%A4"><span class="toc-number">22.7.</span> <span class="toc-text">用IDEA模拟集群</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-17"><span class="toc-number">23.</span> <span class="toc-text">2023&#x2F;1&#x2F;17</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%88Spin-Lock%EF%BC%89"><span class="toc-number">23.1.</span> <span class="toc-text">自旋锁（Spin Lock）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%88Reentrant-Lock%EF%BC%89"><span class="toc-number">23.2.</span> <span class="toc-text">可重入锁（Reentrant Lock）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%88Fair-Lock%EF%BC%89"><span class="toc-number">23.3.</span> <span class="toc-text">公平锁（Fair Lock）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%88ReadWrite-Lock%EF%BC%89"><span class="toc-number">23.4.</span> <span class="toc-text">读写锁（ReadWrite Lock）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89"><span class="toc-number">23.5.</span> <span class="toc-text">信号量（Semaphore）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E9%94%81%EF%BC%88CountDownLatch%EF%BC%89"><span class="toc-number">23.6.</span> <span class="toc-text">闭锁（CountDownLatch）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A5%BD%E6%8A%8A%E6%B3%A8%E5%85%A5%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%90%8D%E5%86%99%E6%88%90%E6%8A%8A%E4%BB%96%E6%B3%A8%E5%86%8C%E5%88%B0spring-IOC%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E9%82%A3%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%90%8D%E5%AD%97"><span class="toc-number">23.7.</span> <span class="toc-text">最好把注入的对象名写成把他注册到spring IOC容器中的那个方法的名字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redisson"><span class="toc-number">23.8.</span> <span class="toc-text">Redisson</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">23.9.</span> <span class="toc-text">缓存数据一致性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%86%99%E6%A8%A1%E5%BC%8F"><span class="toc-number">23.9.1.</span> <span class="toc-text">双写模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B1%E6%95%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">23.9.2.</span> <span class="toc-text">失效模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">23.9.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Cache"><span class="toc-number">23.10.</span> <span class="toc-text">Spring Cache</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%90%88Spring-Cache"><span class="toc-number">23.10.1.</span> <span class="toc-text">整合Spring Cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cacheable%E6%B3%A8%E8%A7%A3"><span class="toc-number">23.10.2.</span> <span class="toc-text">@Cacheable注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CacheEvict%E6%B3%A8%E8%A7%A3"><span class="toc-number">23.10.3.</span> <span class="toc-text">@CacheEvict注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">23.10.4.</span> <span class="toc-text">最佳实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">23.10.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-18"><span class="toc-number">24.</span> <span class="toc-text">2023&#x2F;1&#x2F;18</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9C%8B%E5%88%B0%E5%8F%A5%E5%90%8D%E8%A8%80"><span class="toc-number">24.1.</span> <span class="toc-text">看到句名言</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-19"><span class="toc-number">25.</span> <span class="toc-text">2023&#x2F;1&#x2F;19</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E6%8F%90%E5%89%8D%E7%BB%99%E5%89%8D%E7%AB%AF%E5%90%91%E5%90%8E%E7%AB%AF%E4%BC%A0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BA%A6%E5%AE%9A%E5%A5%BD%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F"><span class="toc-number">25.1.</span> <span class="toc-text">尝试提前给前端向后端传的数据约定好解析方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E4%B8%80%E4%B8%AAES%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">25.2.</span> <span class="toc-text">如何完成一个ES的查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E5%9C%A8VO%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">25.3.</span> <span class="toc-text">尝试在VO中使用静态内部类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-20"><span class="toc-number">26.</span> <span class="toc-text">2023&#x2F;1&#x2F;20</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">26.1.</span> <span class="toc-text">初始化线程的四种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">26.1.1.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">26.2.</span> <span class="toc-text">线程池的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88ThreadPoolExecutor%EF%BC%89%E8%AF%A6%E8%A7%A3"><span class="toc-number">26.3.</span> <span class="toc-text">线程池（ThreadPoolExecutor）详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0"><span class="toc-number">26.3.1.</span> <span class="toc-text">七大参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">26.3.2.</span> <span class="toc-text">工作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CompletableFuture%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92"><span class="toc-number">26.4.</span> <span class="toc-text">CompletableFuture异步编排</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E5%AF%B9%E8%B1%A1"><span class="toc-number">26.4.1.</span> <span class="toc-text">创建异步对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%AE%8C%E6%88%90%E6%97%B6%E7%9A%84%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95"><span class="toc-number">26.4.2.</span> <span class="toc-text">计算完成时的回调方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handle%E6%96%B9%E6%B3%95"><span class="toc-number">26.4.3.</span> <span class="toc-text">handle方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%B2%E8%A1%8C%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">26.4.4.</span> <span class="toc-text">线程串行化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%90%88-%E9%83%BD%E5%AE%8C%E6%88%90%E5%90%8E%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%89%E4%B8%AA%E4%BB%BB%E5%8A%A1"><span class="toc-number">26.4.5.</span> <span class="toc-text">两任务组合-都完成后执行第三个任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%90%88-%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E5%AE%8C%E6%88%90%E5%90%8E%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%89%E4%B8%AA%E4%BB%BB%E5%8A%A1"><span class="toc-number">26.4.6.</span> <span class="toc-text">两任务组合-一个任务完成后执行第三个任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%BB%84%E5%90%88"><span class="toc-number">26.4.7.</span> <span class="toc-text">多任务组合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92%E6%9D%A5%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">26.5.</span> <span class="toc-text">使用异步编排来获取一个网页的资源</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-23"><span class="toc-number">27.</span> <span class="toc-text">2023&#x2F;1&#x2F;23</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">27.1.</span> <span class="toc-text">快速定位网页元素在代码中的位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ToString%E6%B3%A8%E8%A7%A3"><span class="toc-number">27.2.</span> <span class="toc-text">@ToString注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8MyBatis%E7%9A%84xml%E6%96%87%E4%BB%B6%E4%B8%AD%E5%BC%95%E7%94%A8%E4%B8%80%E4%B8%AA%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">27.3.</span> <span class="toc-text">如何在MyBatis的xml文件中引用一个内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E6%9C%89%E5%B5%8C%E5%A5%97%E5%B1%9E%E6%80%A7%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BD%BF%E7%94%A8MyBatis%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%9C%E9%9B%86%E5%B0%81%E8%A3%85"><span class="toc-number">27.4.</span> <span class="toc-text">对于有嵌套属性的返回值使用MyBatis的自定义结果集封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E5%AF%B9%E5%BA%94%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E5%AE%9E%E4%BD%93%E7%B1%BB%E8%BF%9B%E8%A1%8C%E7%BB%91%E5%AE%9A"><span class="toc-number">27.5.</span> <span class="toc-text">将对应的配置和实体类进行绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%99%E6%A8%A1%E5%9D%97%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">27.6.</span> <span class="toc-text">给模块添加一个线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E6%8E%92%E4%BC%98%E5%8C%96%E7%A4%BA%E4%BE%8B"><span class="toc-number">27.7.</span> <span class="toc-text">对业务逻辑进行异步编排优化示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-24"><span class="toc-number">28.</span> <span class="toc-text">2023&#x2F;1&#x2F;24</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6%E7%9A%84%E6%97%B6%E5%80%99%E4%B8%80%E5%AE%9A%E4%BD%BF%E7%94%A8%E5%87%86%E7%A1%AE%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">28.1.</span> <span class="toc-text">注册组件的时候一定使用准确的注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8SpringMVC%E7%9A%84%E5%86%85%E5%AE%B9%E9%85%8D%E7%BD%AE%E8%A7%86%E5%9B%BE%E6%98%A0%E5%B0%84"><span class="toc-number">28.2.</span> <span class="toc-text">使用SpringMVC的内容配置视图映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%90%88%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1%E6%9C%8D%E5%8A%A1%EF%BC%88SMS%EF%BC%89"><span class="toc-number">28.3.</span> <span class="toc-text">整合阿里云短信服务（SMS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%99%E7%BC%93%E5%AD%98%E5%88%B0redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84key%E5%A2%9E%E5%8A%A0%E5%89%8D%E7%BC%80"><span class="toc-number">28.4.</span> <span class="toc-text">给缓存到redis中的数据的key增加前缀</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-25"><span class="toc-number">29.</span> <span class="toc-text">2023&#x2F;1&#x2F;25</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MD5%E7%9B%90%E5%80%BC%E5%8A%A0%E5%AF%86"><span class="toc-number">29.1.</span> <span class="toc-text">MD5盐值加密</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MD5"><span class="toc-number">29.1.1.</span> <span class="toc-text">MD5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E7%9B%90"><span class="toc-number">29.1.2.</span> <span class="toc-text">加盐</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">29.2.</span> <span class="toc-text">用户注册后端实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8-Service%E5%B1%82-%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E7%A0%81-Controller%E5%B1%82-%E6%9D%A5%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">29.3.</span> <span class="toc-text">通过使用自定义异常(Service层)和自定义错误码(Controller层)来处理程序出现的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8"><span class="toc-number">29.4.</span> <span class="toc-text">配置文件不起作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%90%AFmybatis-plus%E7%9A%84%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0"><span class="toc-number">29.5.</span> <span class="toc-text">开启mybatis-plus的日志打印</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%90%8E%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">29.6.</span> <span class="toc-text">用户登录后端实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BE%E4%BA%A4%E7%99%BB%E5%BD%95"><span class="toc-number">29.7.</span> <span class="toc-text">社交登录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OAuth2-0"><span class="toc-number">29.8.</span> <span class="toc-text">OAuth2.0</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-26"><span class="toc-number">30.</span> <span class="toc-text">2023&#x2F;1&#x2F;26</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95"><span class="toc-number">30.1.</span> <span class="toc-text">使用第三方登录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%96%B9%E4%BE%BF%E7%9A%84%E5%B0%81%E8%A3%85%E4%BA%86%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%85"><span class="toc-number">30.2.</span> <span class="toc-text">比较方便的封装了发送http请求的包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-number">30.3.</span> <span class="toc-text">时序图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Session%E5%8E%9F%E7%90%86"><span class="toc-number">30.4.</span> <span class="toc-text">Session原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Session%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="toc-number">30.5.</span> <span class="toc-text">Session共享问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-session%E5%A4%8D%E5%88%B6"><span class="toc-number">30.5.1.</span> <span class="toc-text">解决方案-session复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8"><span class="toc-number">30.5.2.</span> <span class="toc-text">解决方案-客户端存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-hash%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">30.5.3.</span> <span class="toc-text">解决方案-hash一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E7%BB%9F%E4%B8%80%E5%AD%98%E5%82%A8"><span class="toc-number">30.5.4.</span> <span class="toc-text">解决方案-统一存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E5%AD%90%E5%9F%9Fsession%E5%85%B1%E4%BA%AB"><span class="toc-number">30.5.5.</span> <span class="toc-text">解决方案-子域session共享</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-27"><span class="toc-number">31.</span> <span class="toc-text">2023&#x2F;1&#x2F;27</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Session"><span class="toc-number">31.1.</span> <span class="toc-text">Spring Session</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JWT"><span class="toc-number">31.2.</span> <span class="toc-text">JWT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#session%E5%92%8Cjwt%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">31.2.1.</span> <span class="toc-text">session和jwt的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95"><span class="toc-number">31.3.</span> <span class="toc-text">单点登录</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-28"><span class="toc-number">32.</span> <span class="toc-text">2023&#x2F;1&#x2F;28</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8alt-insert%E6%9D%A5%E5%9C%A8IDEA%E4%B8%AD%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E9%A2%84%E5%88%B6%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">32.1.</span> <span class="toc-text">使用alt+insert来在IDEA中快速创建预制代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8%E6%9D%A5%E5%88%A4%E6%96%AD%E7%94%A8%E6%88%B7%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">32.2.</span> <span class="toc-text">使用拦截器来判断用户的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8ThreadLocal%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="toc-number">32.3.</span> <span class="toc-text">使用ThreadLocal在同一个线程共享数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%AE%89%E8%A3%85RabbitMQ"><span class="toc-number">32.4.</span> <span class="toc-text">Docker安装RabbitMQ</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-30"><span class="toc-number">33.</span> <span class="toc-text">2023&#x2F;1&#x2F;30</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">33.1.</span> <span class="toc-text">RabbitMQ的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E6%95%B4%E5%90%88RabbitMQ"><span class="toc-number">33.2.</span> <span class="toc-text">SpringBoot整合RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-number">33.2.1.</span> <span class="toc-text">引入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E8%A1%8C%E9%85%8D%E7%BD%AE"><span class="toc-number">33.2.2.</span> <span class="toc-text">进行配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E6%B3%A8%E8%A7%A3"><span class="toc-number">33.2.3.</span> <span class="toc-text">开启注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%88%A0%E7%BB%84%E4%BB%B6"><span class="toc-number">33.2.4.</span> <span class="toc-text">增删组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-number">33.2.5.</span> <span class="toc-text">发送消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF"><span class="toc-number">33.2.6.</span> <span class="toc-text">接收消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6-%E5%8F%AF%E9%9D%A0%E6%8A%B5%E8%BE%BE"><span class="toc-number">33.3.</span> <span class="toc-text">RabbitMQ消息确认机制-可靠抵达</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AFConfirmCallback%E5%9B%9E%E8%B0%83"><span class="toc-number">33.3.1.</span> <span class="toc-text">开启ConfirmCallback回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AFReturnCallback%E5%9B%9E%E8%B0%83"><span class="toc-number">33.3.2.</span> <span class="toc-text">开启ReturnCallback回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AFack%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">33.3.3.</span> <span class="toc-text">开启ack消息确认机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-1-x2F-31"><span class="toc-number">34.</span> <span class="toc-text">2023&#x2F;1&#x2F;31</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1"><span class="toc-number">34.1.</span> <span class="toc-text">RabbitMQ延时队列实现定时任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Feign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%A2%E5%A4%B1%E8%AF%B7%E6%B1%82%E5%A4%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">34.2.</span> <span class="toc-text">Feign远程调用丢失请求头的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%83%85%E5%86%B5%E4%B8%8BFeign%E4%B8%A2%E5%A4%B1%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">34.3.</span> <span class="toc-text">异步情况下Feign丢失上下文的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-2-x2F-2"><span class="toc-number">35.</span> <span class="toc-text">2023&#x2F;2&#x2F;2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%9E%E4%B8%BB%E5%B1%9E%E6%80%A7%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7%E7%BA%A6%E6%9D%9F"><span class="toc-number">35.1.</span> <span class="toc-text">对数据库非主属性的唯一性约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">35.2.</span> <span class="toc-text">接口的幂等性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">35.2.1.</span> <span class="toc-text">什么是幂等性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E4%BF%9D%E8%AF%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">35.2.2.</span> <span class="toc-text">哪些情况下需要保证接口的幂等性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BF%9D%E8%AF%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">35.2.3.</span> <span class="toc-text">什么情况下不需要保证接口的幂等性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">35.3.</span> <span class="toc-text">接口幂等性的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#token%E4%BB%A4%E7%89%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">35.3.1.</span> <span class="toc-text">token令牌机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B1%E9%99%A9%E6%80%A7"><span class="toc-number">35.3.1.1.</span> <span class="toc-text">危险性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E9%94%81%E6%9C%BA%E5%88%B6"><span class="toc-number">35.3.2.</span> <span class="toc-text">各种锁机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">35.3.2.1.</span> <span class="toc-text">数据库悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">35.3.2.2.</span> <span class="toc-text">数据库乐观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%B1%82%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">35.3.2.3.</span> <span class="toc-text">业务层分布式锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F"><span class="toc-number">35.3.3.</span> <span class="toc-text">各种唯一约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F"><span class="toc-number">35.3.3.1.</span> <span class="toc-text">数据库唯一约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8redis%E7%9A%84set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%98%B2%E9%87%8D"><span class="toc-number">35.3.3.2.</span> <span class="toc-text">用redis的set数据结构防重</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E9%87%8D%E8%A1%A8"><span class="toc-number">35.3.4.</span> <span class="toc-text">防重表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E8%AF%B7%E6%B1%82%E5%94%AF%E4%B8%80id"><span class="toc-number">35.3.5.</span> <span class="toc-text">全局请求唯一id</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8token%E4%BB%A4%E7%89%8C%E6%9C%BA%E5%88%B6%E8%A7%A3%E5%86%B3%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">35.4.</span> <span class="toc-text">使用token令牌机制解决接口幂等性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transactional%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1"><span class="toc-number">35.5.</span> <span class="toc-text">@Transactional本地事务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-2-x2F-3"><span class="toc-number">36.</span> <span class="toc-text">2023&#x2F;2&#x2F;3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CAP%E5%AE%9A%E7%90%86"><span class="toc-number">36.1.</span> <span class="toc-text">CAP定理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#raft%E7%AE%97%E6%B3%95"><span class="toc-number">36.2.</span> <span class="toc-text">raft算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%86%E5%AF%BC%E9%80%89%E4%B8%BE%EF%BC%88Leader-Election%EF%BC%89"><span class="toc-number">36.2.1.</span> <span class="toc-text">领导选举（Leader Election）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%EF%BC%88Log-Replication%EF%BC%89"><span class="toc-number">36.2.2.</span> <span class="toc-text">日志复制（Log Replication）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%83%85%E5%86%B5%E4%B8%8B%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E4%BD%BF%E7%94%A8AP%E4%B8%A4%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="toc-number">36.3.</span> <span class="toc-text">大多数情况下在分布式系统中使用AP两个特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%81%E5%BC%B1%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%81%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">36.4.</span> <span class="toc-text">强一致性、弱一致性、最终一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BASE%E7%90%86%E8%AE%BA"><span class="toc-number">36.5.</span> <span class="toc-text">BASE理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-number">36.6.</span> <span class="toc-text">事务的传播行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">36.7.</span> <span class="toc-text">分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E5%AF%B9%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E9%93%BE%E4%B8%8A%E7%9A%84%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E6%96%B9%E6%B3%95%E5%8A%A0%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1"><span class="toc-number">36.7.1.</span> <span class="toc-text">解决方案-对业务处理链上的所有节点方法加本地事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%88%9A%E6%80%A7%E4%BA%8B%E5%8A%A1"><span class="toc-number">36.7.2.</span> <span class="toc-text">柔性事务和刚性事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E5%88%9A%E6%80%A7%E4%BA%8B%E5%8A%A1-2PC%E6%A8%A1%E5%BC%8F"><span class="toc-number">36.7.3.</span> <span class="toc-text">解决方案-刚性事务-2PC模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1-TCC%E4%BA%8B%E5%8A%A1%E8%A1%A5%E5%81%BF%E5%9E%8B%E6%96%B9%E6%A1%88"><span class="toc-number">36.7.4.</span> <span class="toc-text">解决方案-柔性事务-TCC事务补偿型方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1-%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5%E5%9E%8B%E6%96%B9%E6%A1%88"><span class="toc-number">36.7.5.</span> <span class="toc-text">解决方案-柔性事务-最大努力通知型方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E6%9F%94%E6%80%A7%E4%BA%8B%E5%8A%A1-%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF-%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%EF%BC%88%E5%BC%82%E6%AD%A5%E7%A1%AE%E4%BF%9D%E5%9E%8B%EF%BC%89"><span class="toc-number">36.7.6.</span> <span class="toc-text">解决方案-柔性事务-可靠消息+最终一致性方案（异步确保型）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-2-x2F-4"><span class="toc-number">37.</span> <span class="toc-text">2023&#x2F;2&#x2F;4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Seata%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">37.1.</span> <span class="toc-text">Seata解决分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Seata%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">37.1.1.</span> <span class="toc-text">Seata是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Seata%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">37.1.2.</span> <span class="toc-text">Seata的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Seata%E6%80%8E%E4%B9%88%E7%94%A8"><span class="toc-number">37.1.3.</span> <span class="toc-text">Seata怎么用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MQ%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">37.2.</span> <span class="toc-text">MQ解决分布式事务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-2-x2F-6"><span class="toc-number">38.</span> <span class="toc-text">2023&#x2F;2&#x2F;6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E4%B8%ADdev%E3%80%81test%E5%92%8Cprod%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">38.1.</span> <span class="toc-text">项目开发中dev、test和prod是什么意思</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">38.2.</span> <span class="toc-text">如何配置Bean的作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-2-x2F-8"><span class="toc-number">39.</span> <span class="toc-text">2023&#x2F;2&#x2F;8</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ActiveProfiles%E6%B3%A8%E8%A7%A3"><span class="toc-number">39.1.</span> <span class="toc-text">@ActiveProfiles注解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2023-x2F-2-x2F-9"><span class="toc-number">40.</span> <span class="toc-text">2023&#x2F;2&#x2F;9</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A2%AB%E4%BA%BA%E9%BB%91%E4%BA%86"><span class="toc-number">40.1.</span> <span class="toc-text">数据库被人黑了</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%97%A0%E6%B3%95%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">40.2.</span> <span class="toc-text">数据库无法远程连接</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/01/07/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" title="毕业设计开发日志"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="毕业设计开发日志"/></a><div class="content"><a class="title" href="/2024/01/07/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/" title="毕业设计开发日志">毕业设计开发日志</a><time datetime="2024-01-07T15:06:39.000Z" title="发表于 2024-01-07 23:06:39">2024-01-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/29/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="编译原理"/></a><div class="content"><a class="title" href="/2023/12/29/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理">编译原理</a><time datetime="2023-12-29T10:15:55.000Z" title="发表于 2023-12-29 18:15:55">2023-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/02/%E8%8B%B1%E8%AF%AD%E4%BD%9C%E6%96%87/" title="英语作文"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="英语作文"/></a><div class="content"><a class="title" href="/2023/12/02/%E8%8B%B1%E8%AF%AD%E4%BD%9C%E6%96%87/" title="英语作文">英语作文</a><time datetime="2023-12-02T05:59:03.000Z" title="发表于 2023-12-02 13:59:03">2023-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/31/%E6%9D%82%E8%B0%88/" title="杂谈"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="杂谈"/></a><div class="content"><a class="title" href="/2023/08/31/%E6%9D%82%E8%B0%88/" title="杂谈">杂谈</a><time datetime="2023-08-31T10:36:51.000Z" title="发表于 2023-08-31 18:36:51">2023-08-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97%EF%BC%88%E5%8D%B7%E4%BA%8C%EF%BC%89-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/" title="软件工程与计算（卷二）-软件开发的技术基础"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="软件工程与计算（卷二）-软件开发的技术基础"/></a><div class="content"><a class="title" href="/2023/08/10/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E8%AE%A1%E7%AE%97%EF%BC%88%E5%8D%B7%E4%BA%8C%EF%BC%89-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/" title="软件工程与计算（卷二）-软件开发的技术基础">软件工程与计算（卷二）-软件开发的技术基础</a><time datetime="2023-08-10T08:06:03.000Z" title="发表于 2023-08-10 16:06:03">2023-08-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/background.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By Konjacer</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
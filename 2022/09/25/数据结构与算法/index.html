<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构与算法 | 孤舟</title><meta name="keywords" content="数据结构,算法"><meta name="author" content="Konjacer,1175590069@qq.com"><meta name="copyright" content="Konjacer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="排序算法常用排序算法的总结和对比一张排序算法的比较图 相关术语解释 稳定：如果 a 原本在 b 前面，而 a&#x3D;b，排序之后 a 仍然在 b 的前面； 不稳定：如果 a 原本在 b 的前面，而 a&#x3D;b，排序之后 a 可能会出现在 b 的后面； 内部排序：所有排序操作都在内存中完成； 外部排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法">
<meta property="og:url" content="https://konjacor.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="孤舟">
<meta property="og:description" content="排序算法常用排序算法的总结和对比一张排序算法的比较图 相关术语解释 稳定：如果 a 原本在 b 前面，而 a&#x3D;b，排序之后 a 仍然在 b 的前面； 不稳定：如果 a 原本在 b 的前面，而 a&#x3D;b，排序之后 a 可能会出现在 b 的后面； 内部排序：所有排序操作都在内存中完成； 外部排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://konjacor.github.io/img/background.jpeg">
<meta property="article:published_time" content="2022-09-25T11:54:24.000Z">
<meta property="article:modified_time" content="2024-08-13T10:04:58.026Z">
<meta property="article:author" content="Konjacer">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://konjacor.github.io/img/background.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://konjacor.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-13 18:04:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="孤舟" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/xiaozhai.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">87</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">孤舟</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-25T11:54:24.000Z" title="发表于 2022-09-25 19:54:24">2022-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-13T10:04:58.026Z" title="更新于 2024-08-13 18:04:58">2024-08-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"/>

<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="常用排序算法的总结和对比"><a href="#常用排序算法的总结和对比" class="headerlink" title="常用排序算法的总结和对比"></a>常用排序算法的总结和对比</h2><h3 id="一张排序算法的比较图"><a href="#一张排序算法的比较图" class="headerlink" title="一张排序算法的比较图"></a>一张排序算法的比较图</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106091748277.png" alt="image-20221106091748277"></p>
<h3 id="相关术语解释"><a href="#相关术语解释" class="headerlink" title="相关术语解释"></a>相关术语解释</h3><ol>
<li>稳定：如果 a 原本在 b 前面，而 a&#x3D;b，排序之后 a 仍然在 b 的前面；</li>
<li>不稳定：如果 a 原本在 b 的前面，而 a&#x3D;b，排序之后 a 可能会出现在 b 的后面；</li>
<li>内部排序：所有排序操作都在内存中完成；</li>
<li>外部排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li>时间复杂度： 一个算法执行所耗费的时间。</li>
<li>空间复杂度：运行完一个程序所需内存的大小。</li>
<li>n: 数据规模</li>
<li>k: “桶”的个数</li>
<li>In-place: 不占用额外内存</li>
<li>Out-place: 占用额外内存</li>
</ol>
<h2 id="新人入坑冒泡排序"><a href="#新人入坑冒泡排序" class="headerlink" title="新人入坑冒泡排序"></a>新人入坑冒泡排序</h2><ul>
<li>这个是典中典了，任何学过算法的人估计都学过这个吧，它简单的算法思想也让他成为了入坑排序算法的最佳选择。</li>
</ul>
<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li>冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,<strong>依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部</strong>，就象水底下的气泡一样逐渐向上冒。</li>
<li>需要两层循环，<strong>每次外层循环都会使得无序区域最大的一个数字到达正确的位置</strong>，对于长度为n的序列，我们只需要将外层循环做n-1次即可使整个序列有序，<strong>内层循环遍历整个序列的无序部分，目的是让目标元素和相邻元素做比较从而将目标元素放到它该在的地方</strong>。</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>由于需要两层循环来实现该算法，并且每层循环都和序列长度n有关，所以它的<strong>时间复杂度是：O(n^2)</strong></li>
</ul>
<h3 id="冒泡过程图解"><a href="#冒泡过程图解" class="headerlink" title="冒泡过程图解"></a>冒泡过程图解</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105225817170.png" alt="image-20221105225817170"></p>
<h3 id="对于冒泡排序的优化"><a href="#对于冒泡排序的优化" class="headerlink" title="对于冒泡排序的优化"></a>对于冒泡排序的优化</h3><ul>
<li>因为排序的过程中，各元素不断接近自己的位置，<strong>如果一趟比较下来没有进行过交换，就说明序列已经有序，就不用做后续的比较操作了</strong>，因此要<strong>在排序过程中设置一个标志 flag 判断元素是否进行过交换，从而减少不必要的比较</strong>。</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-07 20:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//本轮中是否有元素进行过交换，如果没有，说明序列已经有序，可以不用做后面的操作了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//归位n-1个数字即可使数组有序</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n-i;++j)&#123;<span class="comment">//每次内层循环需要的次数由于上次数字归位而递减</span></span><br><span class="line">                <span class="keyword">if</span>(num[j]&gt;num[j+<span class="number">1</span>])&#123;<span class="comment">//交换两数的原地算法,但是这样写在数据很大的情况下有数值溢出风险</span></span><br><span class="line">                    flag = <span class="literal">true</span>;<span class="comment">//标记为本轮进行过元素交换</span></span><br><span class="line">                    num[j] += num[j+<span class="number">1</span>];</span><br><span class="line">                    num[j+<span class="number">1</span>] = num[j] - num[j+<span class="number">1</span>];</span><br><span class="line">                    num[j] -= num[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;<span class="comment">//如果本轮没有进行过元素交换，说明已经有序，后面的操作也就不用做了</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(num[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="先挑后换选择排序"><a href="#先挑后换选择排序" class="headerlink" title="先挑后换选择排序"></a>先挑后换选择排序</h2><ul>
<li>总是和插入排序混掉，这个选择排序是从后面的序列中按一定规则挑出元素来换到前面，而插入排序是从后面的序列中取第一个数然后按一定规则插入到前面，<strong>它们的区别在于选择排序的比较规则体现在后面的序列中，插入排序的比较规则体现在前面的序列中</strong>。</li>
</ul>
<h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li>选择式排序也属于内部排序法，是<strong>从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的</strong>。</li>
</ul>
<h3 id="选择排序思想"><a href="#选择排序思想" class="headerlink" title="选择排序思想"></a>选择排序思想</h3><ul>
<li>选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：<strong>第一次从 arr[0]<del>arr[n-1]中选取最小值，与 arr[0]交换，第二次从 arr[1]</del>arr[n-1]中选取最小值，与 arr[1]交换，第三次从 arr[2]<del>arr[n-1]中选取最小值，与 arr[2]交换，…，第 i 次从 arr[i-1]</del>arr[n-1]中选取最小值，与 arr[i-1]交换，…, 第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值，与 arr[n-2]交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列</strong>。</li>
<li>和冒泡排序相似，也是两层循环，<strong>外层循环跑一次都会让一个元素归位，内层循环遍历后面的无序序列，挑出其中最小的和无序队列的头部元素进行交换</strong>。对于长度为n的序列，外层循环只需要跑n-1次即可使序列有序。</li>
</ul>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>由于是两层循环，还都和序列的长度有关，所以<strong>时间复杂度是O(n^2)的</strong></li>
</ul>
<h3 id="选择排序过程图解"><a href="#选择排序过程图解" class="headerlink" title="选择排序过程图解"></a>选择排序过程图解</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105230143186.png" alt="image-20221105230143186"></p>
<ul>
<li><p>对一个数组的选择排序再进行图解：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105230338223.png" alt="image-20221105230338223"></p>
</li>
</ul>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-07 20:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;++i)&#123;<span class="comment">//归位n-1个数字即可</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> num[i];<span class="comment">//让无序区第一个元素先当min，之后动态更新</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> i;<span class="comment">//最小值对应的坐标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;++j)&#123;<span class="comment">//从后面的无序区域找最小的换到无序区的最前面，外面每循环一次，无序区域就减少一个单位，由于之前默认让无序区的第一元素作为最小值并知晓其坐标，所以就没必要遍历第一个元素了</span></span><br><span class="line">                <span class="keyword">if</span>(min&gt;num[j])&#123;</span><br><span class="line">                    min = num[j];</span><br><span class="line">                    pos = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos!=i) &#123;<span class="comment">//如果最小值不是无序区的头元素就原地算法交换两数，如果忘了判断最小值是不是无序区的头元素，利用原地交换算法就会出错，但是还是那个问题，如果数据过大会数值溢出</span></span><br><span class="line">                num[i] += num[pos];</span><br><span class="line">                num[pos] = num[i] - num[pos];</span><br><span class="line">                num[i] -= num[pos];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(num[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="先取后插插入排序"><a href="#先取后插插入排序" class="headerlink" title="先取后插插入排序"></a>先取后插插入排序</h2><ul>
<li>总是和选择排序混掉，选择排序是从后面的序列中按一定规则挑出元素来换到前面，而插入排序是从后面的序列中取第一个数然后按一定规则插入到前面，<strong>它们的区别在于选择排序的比较规则体现在后面的序列中，插入排序的比较规则体现在前面的序列中</strong>。</li>
</ul>
<h3 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。</li>
</ul>
<h3 id="插入排序思想"><a href="#插入排序思想" class="headerlink" title="插入排序思想"></a>插入排序思想</h3><ul>
<li>插入排序（Insertion Sorting）的基本思想是：<strong>把 n 个待排序的元素看成为一个有序表和一个无序表</strong>，开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，<strong>排序过程中每次从无序表中取出第一个元素，把它的排序码依次与前面有序表元素的排序码进行比较，如果满足给定的条件就进行交换，如果中间某一次没有交换，说明该元素已经归位，这样做能将它插入到有序表中的适当位置，使之成为有序表的一部分</strong>。</li>
<li>也是需要两层循环，<strong>外层循环每循环一次都会将一个无序区的元素归位，内层循环主要是让选中的元素和前面的有序部分进行逐个比较好确定选中的元素应该插入的位置</strong>。</li>
</ul>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>由于还是两层循环，并且每层循环都和序列长度有关，所以<strong>时间复杂度还是O(n^2)的</strong>。</li>
</ul>
<h3 id="插入排序过程图解"><a href="#插入排序过程图解" class="headerlink" title="插入排序过程图解"></a>插入排序过程图解</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105232220474.png" alt="image-20221105232220474"></p>
<h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-07 23:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//第一个元素可以看作已经归位，也就是说刚开始有序区是1，接下来把剩下的n-1个元素插入到有序区即可</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&gt;=<span class="number">0</span>;--j)&#123;<span class="comment">//让无序区的头元素向前（也就是有序区）基于比较来进行移动，中间某一次没移动就说明归位了，退出循环</span></span><br><span class="line">                <span class="keyword">if</span>(num[j]&lt;num[j-<span class="number">1</span>])&#123;<span class="comment">//交换两数的原地算法，还是那个问题，如果数据过大会数值溢出</span></span><br><span class="line">                    num[j] += num[j-<span class="number">1</span>];</span><br><span class="line">                    num[j-<span class="number">1</span>] = num[j] - num[j-<span class="number">1</span>];</span><br><span class="line">                    num[j] -= num[j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(num[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插排优化希尔排序"><a href="#插排优化希尔排序" class="headerlink" title="插排优化希尔排序"></a>插排优化希尔排序</h2><h3 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li>希尔排序是希尔（Donald Shell）于 1959 年提出的一种排序算法。<strong>希尔排序也是一种插入排序</strong>，它<strong>是简单插入排序经过改进之后的一个更高效的版本</strong>，也称为<strong>缩小增量排序</strong>。</li>
</ul>
<h3 id="希尔排序思想"><a href="#希尔排序思想" class="headerlink" title="希尔排序思想"></a>希尔排序思想</h3><ul>
<li><p>在简单插入排序中存在这样一个问题，说极端点就是如果最后一个无序元素非常小，那么它在插入到前面有序序列时的消耗是很大的，我们自然不希望看到这样的情况频繁发生，所以<strong>希尔排序的思想就是以这一点为切入点，通过增量分组的方式，每次分组排序后都尽量让整个序列均匀，也就是每次分组排序后让整个序列尽可能有序，防止出现某个元素消耗过多的时间去比较，从而优化时间复杂度</strong>。</p>
</li>
<li><p>希尔排序是<strong>把记录按下标的一定增量分组，对每组使用直接插入排序算法排序</strong>；随着增量逐渐减少，每组包含的关键词越来越多，<strong>当增量减至 1 时，整个文件恰被分成一组，算法便终止</strong>。</p>
</li>
<li><p>需要三层循环，<strong>外层循环负责控制分组步长大小，步长大小从序列的长度开始，之后的每次步长都是上次步长的一半，直到步长大小变成0，退出循环</strong>。<strong>中层循环每次从下标为分组步长的元素开始（这个下标对应着所有分组的最前面的无序元素）负责遍历每个分组无序区的元素（步长为1挪到最后就相当于遍历了所有分组的无序元素）</strong>。<strong>内层循环负责对遍历到的无序元素在它们组内（体现在每次比较跨越的步长为外层循环的值，这样可以保证相互比较的值都是同一组）进行插入排序（基于比较往前挪，直到中间某一次没挪，说明归位了）</strong>。</p>
</li>
<li><p>写完代码说一句：不愧是历史上时间复杂度首次突破O(n^2)的算法，这三层循环真是挺巧妙的。</p>
</li>
</ul>
<h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>查前面那个表。</li>
</ul>
<h3 id="希尔排序流程图解"><a href="#希尔排序流程图解" class="headerlink" title="希尔排序流程图解"></a>希尔排序流程图解</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106092745473.png" alt="image-20221106092745473"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106092757251.png" alt="image-20221106092757251"></p>
<h3 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-08 9:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=num.length/<span class="number">2</span>;k&gt;<span class="number">0</span>;k/=<span class="number">2</span>)&#123;<span class="comment">//控制分组步长，从数组长度除2开始，每次迭代都除2，直到小于等于0，说明已经排好序了</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;num.length;++i)&#123;<span class="comment">//为了进行插入排序，我们首先要定位到每一组的第一个无序元素，而每轮的k正好是所有分组的第一个无序元素（因为第一组的有序区元素下标为0，这个下标加上步长k正好是第一个无序元素，而第一组的第一个无序元素又是所有分组中最靠前的，可以保证在它之后的所有元素都是无序区的元素，在它前面的元素都是有序区的元素），之后每次i++的时候就相当于遍历到了别的分组的无序区的头元素，遍历完一轮分组之后，所有分组的无序区的头元素归位，继续i++就是遍历所有分组的新无序区的头元素，直到最后，i可以遍历完所有分组的无序区</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i-k;j&gt;=<span class="number">0</span>;j-=k)&#123;<span class="comment">//把上一层循环选中的元素移动到它所在分组的有序区的正确位置，基于比较移动</span></span><br><span class="line">                    <span class="keyword">if</span>(j!=j+k&amp;&amp;num[j]&gt;num[j+k])&#123;<span class="comment">//原地交换，还是那些问题，数据过大会导致数值溢出并且两边下标相同时会出现问题，总的说就是交换两个元素的时候最少需要两个单位的空间（两个元素已经占用了两个单位的空间）</span></span><br><span class="line">                        num[j] += num[j+k];</span><br><span class="line">                        num[j+k] = num[j] - num[j+k];</span><br><span class="line">                        num[j] -= num[j+k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(num[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="期待已久的堆排序"><a href="#期待已久的堆排序" class="headerlink" title="期待已久的堆排序"></a>期待已久的堆排序</h2><ul>
<li>堆排序这个东西，在上大一的时候就有所耳闻，然而当时写题都用c++自带的快速排序的函数，所以对这种神奇的排序方法也没有深究，这一眨眼上大三了，学校里也开了算法的课程，正好学到了这个堆排序，我听了听确实巧妙，回来之后根据自己的理解进行了实现，下面细说。</li>
</ul>
<h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><ul>
<li><p><strong>同时满足以下两个条件</strong>的数据结构被称为堆：</p>
<ol>
<li>堆是一颗<strong>完全二叉树</strong></li>
<li>堆的<strong>每一个节点的值都大于等于或都小于等于其子节点的值</strong></li>
</ol>
</li>
<li><p>每个节点的值都大于等于其子节点的值的堆被称为<strong>最大堆（或者是大根堆）</strong>，剩下的那种情况被称为<strong>最小堆（或者是小根堆）</strong>。</p>
</li>
</ul>
<h3 id="堆的存储"><a href="#堆的存储" class="headerlink" title="堆的存储"></a>堆的存储</h3><ul>
<li>由于二叉树特殊的访问性质，所以我们一般都<strong>通过数组来存储堆</strong>，可以通过二叉树的性质来对一个节点的父节点或是子节点进行访问，比如说<strong>下标为i的节点的父节点的下标为floor((i-1)&#x2F;2)</strong>,<strong>其子节点的下标为(i*2+1)和(i*2+2)</strong></li>
</ul>
<h3 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h3><h4 id="节点上移（SiftUp）"><a href="#节点上移（SiftUp）" class="headerlink" title="节点上移（SiftUp）"></a>节点上移（SiftUp）</h4><ul>
<li><p>这个操作可以<strong>让某个节点上移直到合适的位置</strong>，由于其父节点只可能有一个，因此只需要进行一次判断并且只有一种上移路径，其中应该格外注意在进行节点上移的时候不要发生数组越界。</p>
</li>
<li><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (index&gt;<span class="number">0</span> &amp;&amp; num[index]&gt;num[(index-<span class="number">1</span>)/<span class="number">2</span>])&#123;<span class="comment">//没越界，并且当前节点位置异常</span></span><br><span class="line">        <span class="comment">//System.out.println(1);</span></span><br><span class="line">   		<span class="comment">//下面三行是交换操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num[index];</span><br><span class="line">        num[index] = num[(index-<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line">        num[(index-<span class="number">1</span>)/<span class="number">2</span>] = temp;</span><br><span class="line">        <span class="comment">//坐标重定向为交换过去的位置</span></span><br><span class="line">        index = (index-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="节点下移（SiftDown）"><a href="#节点下移（SiftDown）" class="headerlink" title="节点下移（SiftDown）"></a>节点下移（SiftDown）</h4><ul>
<li><p>这个操作可以<strong>让某个节点下移直到合适的位置</strong>，其子节点可能有多个，因此需要进行两次判断，由于有两种下移路径，我们应该<strong>选用最合适的路径进行下移</strong>，其中应该格外注意在进行节点下移的时候不要发生数组越界。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((index*<span class="number">2</span>+<span class="number">1</span>)&lt;len &amp;&amp; (index*<span class="number">2</span>+<span class="number">2</span>)&lt;len)&#123;<span class="comment">//有俩孩子的情况</span></span><br><span class="line">        <span class="comment">//System.out.println(1);</span></span><br><span class="line">        <span class="keyword">if</span>(!(num[index]&gt;=num[index*<span class="number">2</span>+<span class="number">1</span>]&amp;&amp;num[index]&gt;=num[index*<span class="number">2</span>+<span class="number">2</span>]))&#123;<span class="comment">//当前节点位置异常，选最合适的一条路径进行下移</span></span><br><span class="line">            <span class="keyword">if</span>(num[index*<span class="number">2</span>+<span class="number">1</span>]&gt;num[index*<span class="number">2</span>+<span class="number">2</span>])&#123;<span class="comment">//第一种情况</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num[index];</span><br><span class="line">                num[index] = num[index*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">                num[index*<span class="number">2</span>+<span class="number">1</span>] = temp;</span><br><span class="line">                index = index*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//第二种情况</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num[index];</span><br><span class="line">                num[index] = num[index*<span class="number">2</span>+<span class="number">2</span>];</span><br><span class="line">                num[index*<span class="number">2</span>+<span class="number">2</span>] = temp;</span><br><span class="line">                index = index*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">//当前节点的位置正常了则不需要做额外操作，直接break，这个地方少了会死循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((index*<span class="number">2</span>+<span class="number">1</span>)&lt;len)&#123;<span class="comment">//只有一个孩子的情况，顶多再下移一次了，既能处理一开始就是这样的情况，又能处理上面的代码执行完毕后剩下是这种的情况，一举两得。</span></span><br><span class="line">        <span class="keyword">if</span>(num[index]&lt;num[index*<span class="number">2</span>+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num[index];</span><br><span class="line">            num[index] = num[index*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">            num[index*<span class="number">2</span>+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="插入元素（Insert）"><a href="#插入元素（Insert）" class="headerlink" title="插入元素（Insert）"></a>插入元素（Insert）</h4><ul>
<li>将<strong>新元素加到堆的最后</strong>，将<strong>堆的规模加1</strong>，然后<strong>使用SiftUp操作将新元素移动到合适的位置</strong>上</li>
<li>代码示例：</li>
</ul>
<h4 id="删除元素（Delete）"><a href="#删除元素（Delete）" class="headerlink" title="删除元素（Delete）"></a>删除元素（Delete）</h4><ul>
<li>将待删除的元素与最后一个元素进行交换，将堆的大小减1（也就是<strong>保证被删除的元素不参与元素上移或者下移的判断</strong>），然后<strong>再用SiftDown操作或者SiftUp操作来调整换上来的那个元素</strong>以维持堆的性质。</li>
<li>代码示例：</li>
</ul>
<h4 id="删除最大值（DeleteMax）"><a href="#删除最大值（DeleteMax）" class="headerlink" title="删除最大值（DeleteMax）"></a>删除最大值（DeleteMax）</h4><ul>
<li><strong>对栈顶元素进行删除元素（Delete）操作</strong>即可。</li>
<li>代码示例：</li>
</ul>
<h4 id="创建堆（MakeHeap）"><a href="#创建堆（MakeHeap）" class="headerlink" title="创建堆（MakeHeap）"></a>创建堆（MakeHeap）</h4><ul>
<li><p>目的是<strong>将一个随机排列的数组变成一个符合堆定义的数组</strong></p>
</li>
<li><p>叶节点只有他本身，没有子树，所以它本身是符合堆的定义的，那么我们就需要<strong>从倒数第一个非叶节点（实际上就是最后一个节点的父节点）开始进行操作</strong>，因为非叶节点有子树，并不能保证它们是符合堆的性质的，因此需要<strong>通过节点下移进行调整</strong>，调整完毕后当前子树符合堆的性质了，再往上走<strong>遇到节点时总能保证它的子树是符合堆定义的，但是顶点的位置不一定正常，因此只需要让顶点进行下移操作即可将其本身也调整为一个堆</strong>，调整完所有非叶节点后，所有子树包括它本身就都符合堆的定义了，这样一个堆就建好了。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shift</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=((len-<span class="number">1</span>)-<span class="number">1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;--i)&#123;<span class="comment">//从最后一个非叶节点开始，倒数第一个非叶子节点实际上就是最后一个节点的父节点</span></span><br><span class="line">        shiftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="堆排序（HeapSort）"><a href="#堆排序（HeapSort）" class="headerlink" title="堆排序（HeapSort）"></a>堆排序（HeapSort）</h4><ul>
<li><p>首先要<strong>保证这个数组符合堆的定义才能进行堆排序</strong>。</p>
</li>
<li><p>每次都<strong>让顶点元素和最后一个元素换位置</strong>，然后将<strong>堆的逻辑长度减1</strong>（也就是<strong>不让换到最后的元素参与下移的运算</strong>），此时除了顶点外别的部分都符合堆的定义，因此需要<strong>对顶点进行下移操作以保证堆的性质</strong>，这个操作完毕后第一轮就结束了，在<strong>堆最后的有序区增加了一个元素</strong>，一共执行这个操作n（数组长度）次，堆排序就做好了。</p>
</li>
<li><p>不难分析出**堆排序的时间复杂度是O(NlogN)**的，换位置的操作复杂度是O(N)，节点下移操作的复杂度是O(logN)，每次换位置的操作后都会有个下移操作，所以整体时间复杂度是O(NlogN)。</p>
</li>
<li><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num.length;++i)&#123;<span class="comment">//做n次</span></span><br><span class="line">        <span class="comment">//换位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num[<span class="number">0</span>];</span><br><span class="line">        num[<span class="number">0</span>] = num[len-<span class="number">1</span>];</span><br><span class="line">        num[len-<span class="number">1</span>] = temp;</span><br><span class="line">        <span class="comment">//堆的逻辑长度--，为的是不让有序区参与下移运算，只让剩下的无序部分参与下移操作</span></span><br><span class="line">        len--;</span><br><span class="line">        <span class="comment">//使用下移操作对堆顶点进行调整</span></span><br><span class="line">        shiftDown(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul>
<li>很明显，在堆上做的节点上移和节点下移操作时间复杂度都是O(logN)的，而每次得到最大值的操作都有节点下移操作，得到所有元素的时间复杂度是O(N)的，所以时间复杂度应该是O(NlogN)的。</li>
</ul>
<h2 id="分而治之归并排序"><a href="#分而治之归并排序" class="headerlink" title="分而治之归并排序"></a>分而治之归并排序</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>这种排序方式主要突出一个分而治之，<strong>将大问题分解成小问题，等小问题解决了之后再合并成为大问题的解</strong>，这种形式的问题就很适合用递归进行解决，每次递归都是一次解决小问题的过程，有些小问题暂时还没法解决怎么办，没事，继续往下递归，到最后层层返回后的答案就是合并后的答案。</li>
</ul>
<h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li>主要思路就是：<strong>每次递归将数组对半分，分别对左右两半的数组进行递归保证左右两边的数组都是有序的之后，再调用双路归并的算法来对两半数组进行合并</strong>，每次递归都执行上述操作，最后得到的答案就是排序后的数组。</li>
</ul>
<h3 id="双路归并算法"><a href="#双路归并算法" class="headerlink" title="双路归并算法"></a>双路归并算法</h3><ul>
<li>该算法是归并排序中合并两个有序集合的操作，具体实现是：<strong>三个指针i，j，k分别表示左集合的头元素，右集合的头元素，结果集合的头元素，每次比较i，j指向的元素，将比较小的那个元素放到结果集合中并移动指针</strong>，以此类推最后得到的就是合并了两个有序集合的有序集合。</li>
</ul>
<h3 id="时间复杂度分析-1"><a href="#时间复杂度分析-1" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul>
<li>二分的时间复杂度是O(logN)的，二路归并的时间复杂度是O(N)的，每次二分之后都会有一个二路归并，所以总体的<strong>时间复杂度是O(NlogN)的</strong>，但是递归所造成的空间消耗是巨大的。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-06 23:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入数据规模：&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        random.setSeed(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            arr[i] = random.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">dateBefore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        arr = sort(arr);</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        System.out.println(<span class="string">&quot;一共用时：&quot;</span>+((<span class="keyword">new</span> <span class="title class_">Date</span>().getTime()-dateBefore.getTime())/<span class="number">60000.0</span>)+<span class="string">&quot;分钟&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length==<span class="number">1</span>)&#123;<span class="comment">//如果只有一个元素，那这个集合本身就是有序的，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> arr.length/<span class="number">2</span>;<span class="comment">//二分</span></span><br><span class="line">        <span class="keyword">return</span> merge(sort(Arrays.copyOfRange(arr,<span class="number">0</span>,mid)),sort(Arrays.copyOfRange(arr,mid,arr.length)));<span class="comment">//保证两边的集合都有序后再合并</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] merge(<span class="type">int</span>[] a,<span class="type">int</span>[] b)&#123;<span class="comment">//二路归并操作</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[a.length+b.length];<span class="comment">//结果数组的长度应该是两个数组的长度之和</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;<span class="comment">//分别是两个数组的头指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;ans.length;++k)&#123;<span class="comment">//对结果数组中的每个元素进行赋值</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;a.length&amp;&amp;j&lt;b.length) &#123;<span class="comment">//两个数组都没到头的时候</span></span><br><span class="line">                ans[k] = a[i] &lt; b[j] ? a[i++] : b[j++];<span class="comment">//赋值为较小的那个并移动指针</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//其中至少有一个数组遍历到头了，就把剩下的元素都塞到后面即可</span></span><br><span class="line">                <span class="keyword">for</span>(;i&lt;a.length;++i)&#123;</span><br><span class="line">                    ans[k++] = a[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(;j&lt;b.length;++j)&#123;</span><br><span class="line">                    ans[k++] = b[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>还<strong>可以用来求逆序对的数量</strong>，在归并的<strong>二路归并阶段</strong>，由于左边的有序数组在原数组中一定是在右边的有序数组的前面的，所以<strong>如果遇到左边的有序数组的当前元素大于右边有序数组的当前元素，那么根据左边数组有序和左边数组在原数组中在右边数组的左边这两个条件，我们可以得知，从左边数组的当前元素开始之后的所有元素都能和右边数组的当前元素组成一个逆序对</strong>，就是在这个地方统计逆序对的数量。并且<strong>由于每次二路归并的时候右半部分都是之前从未出现过的元素，所以保证了这样计算的结果不会重复</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="literal">null</span>||nums.length==<span class="number">0</span>|| nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] r = recursion(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r.length;++i)&#123;</span><br><span class="line">            System.out.print(r[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] recursion(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nums[left]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] leftArr = recursion(nums,left,mid);</span><br><span class="line">        <span class="type">int</span>[] rightArr = recursion(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[leftArr.length+rightArr.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIdx</span> <span class="operator">=</span> <span class="number">0</span>,rightIdx = <span class="number">0</span>,tempIdx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (leftIdx!=leftArr.length&amp;&amp;rightIdx!=rightArr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftArr[leftIdx]&gt;rightArr[rightIdx])&#123;</span><br><span class="line">                ans += leftArr.length-leftIdx;<span class="comment">//统计逆序对的数量</span></span><br><span class="line">                temp[tempIdx++] = rightArr[rightIdx++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp[tempIdx++] = leftArr[leftIdx++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(leftIdx!= leftArr.length)&#123;</span><br><span class="line">            temp[tempIdx++] = leftArr[leftIdx++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rightIdx!=rightArr.length)&#123;</span><br><span class="line">            temp[tempIdx++] = rightArr[rightIdx++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="用得最多快速排序"><a href="#用得最多快速排序" class="headerlink" title="用得最多快速排序"></a>用得最多快速排序</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><ul>
<li>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</li>
<li>效率很高，**平均时间复杂度可以达到O(NlogN)**，但是通常情况下都要比这个快。</li>
</ul>
<h3 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h3><ul>
<li>也是有一个分治的思想在里面，不过每次调整序列的时候是用了效率比较高的方式，其思想是<strong>选中序列中的一个数作为基准数</strong>，我们要调整当前序列为：<strong>所有在基准数左边的数都比基准数要小，所有在基准数右边的数都比基准数要大</strong>。<strong>调整完毕后，再递归地对其左右边的序列继续上面的步骤</strong>，最后递归层层返回后得到的结果就是排序好的序列。</li>
<li>怎么调整序列呢？基本思路是：<strong>设置i，j两个指针分别指向序列的头和尾，选取尾部元素作为基准数，提前记录下来，然后i开始向后扫描，扫描到比基准数小的就过，扫描到比基准数大的就把i当前的值赋值给j位置的值，并让j–，由于j位置的值就是基准数，而基准数被提前记录了，所以在这个操作中没有数据的损失；做完上述步骤之后，换为j向前扫描，扫描到比基准数大的就过，扫描到比基准数小的就把j当前的值赋值给i位置的值，并让i++，由于i位置的值在上一步中已经被记录到之前j所在的位置，所以在这个操作中也没有数据的损失，之后就是一直重复上面的步骤直至i和j汇合，此时的位置就是基准数应该在的位置，将基准数赋值给这个位置，调整完毕</strong>。</li>
<li>为什么上述方式可以保证调整成功呢？是因为最后i和j汇合的地方是基准数的位置，所以在汇合之前，i和j所在的区域都应该是满足调整成功的序列的条件的，所以<strong>无论是谁在扫描序列，在碰上不符合这个区域的条件的元素时，我们就要拜托远在另一个区域的“兄弟”把当前这个不符合条件的数字处理掉，由于处理掉之后产生了空位（至少从逻辑上是这样的，因为当前位置留下的那个数字冗余了），所以当前空位上的指针还要处理一下这个空位，于是它就一直等待它远在另外一个区域的“兄弟”帮它找到一个符合条件的元素来给它处理一下这个空位，而此时另外那个兄弟因为解决了空位问题所以继续扫描，周而复始就能解决所有空位，并能使两边的区域中的元素都符合条件，最后一个空位兄弟俩一起解决，将最开始的那个元素填入，至此调整完毕</strong>。</li>
<li>总之就是萝卜填坑，一个萝卜一个坑，如果想要把一个萝卜填在已经有萝卜的坑中，那就先把那个萝卜拔出来，然后再把新萝卜填进去。</li>
</ul>
<h3 id="时间复杂度分析-2"><a href="#时间复杂度分析-2" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><ul>
<li>最坏情况下每次比较都需要交换位置，所以最坏情况下的时间复杂度是O(N^2)的。</li>
<li>最好情况下和平均情况下的时间复杂度都是O(NlogN)的</li>
<li>正是因为有如此优秀的平均时间复杂度和较小的空间开销，才使得快速排序立于不败之地。</li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-07 12:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入数据规模：&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        random.setSeed(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            arr[i] = random.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">dateBefore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        sort(<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        System.out.println(<span class="string">&quot;一共用时：&quot;</span>+((<span class="keyword">new</span> <span class="title class_">Date</span>().getTime()-dateBefore.getTime())/<span class="number">60000.0</span>)+<span class="string">&quot;分钟&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;<span class="comment">//begin是处理的当前区间的左界，end是处理的当前区间的右界</span></span><br><span class="line">        <span class="comment">//System.out.println(begin+&quot; &quot;+end);</span></span><br><span class="line">        <span class="keyword">if</span>(begin&gt;=end) <span class="keyword">return</span>;<span class="comment">//如果出现只有一个元素或者没有元素的情况在逻辑上就是有序的，直接返回即可</span></span><br><span class="line">        <span class="type">int</span> i=begin,j=end,p=arr[end];<span class="comment">//设置左右哨兵，记录最后一个值为基准数，准备扫描</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">shift</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//为true时i往后扫描，为false时j往前扫描</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;<span class="comment">//没有碰头时说明基准数的位置还没定下来</span></span><br><span class="line">            <span class="keyword">if</span>(shift)&#123;<span class="comment">//i往后扫描</span></span><br><span class="line">                <span class="keyword">if</span>(arr[i]&gt;p)&#123;<span class="comment">//找到了异端，拜托j处理掉它，i在此等待填坑</span></span><br><span class="line">                    arr[j] = arr[i];<span class="comment">//处理异端</span></span><br><span class="line">                    j--;<span class="comment">//j的坑填完了可以继续扫描了</span></span><br><span class="line">                    shift = <span class="literal">false</span>;<span class="comment">//让j扫描</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> i++;<span class="comment">//如果没找到异端就继续扫描</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//j往前扫描</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j]&lt;p)&#123;<span class="comment">//找到了异端，拜托i处理掉它，j在此等待填坑</span></span><br><span class="line">                    arr[i] = arr[j];<span class="comment">//处理异端</span></span><br><span class="line">                    i++;<span class="comment">//i的坑填完了可以继续扫描了</span></span><br><span class="line">                    shift = <span class="literal">true</span>;<span class="comment">//让i扫描</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> j--;<span class="comment">//如果没找到异端就继续扫描</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(i+&quot; &quot;+j);</span></span><br><span class="line">        arr[i] = p;<span class="comment">//将基准数归位</span></span><br><span class="line">        <span class="comment">//System.out.println(p);</span></span><br><span class="line">        sort(begin,i-<span class="number">1</span>);<span class="comment">//处理左半截，开头是begin不是0，因为这次递归处理的是其中一个区间</span></span><br><span class="line">        sort(i+<span class="number">1</span>,end);<span class="comment">//处理右半截，结尾是end不是arr.length-1，因为这次递归处理的是其中一个区间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性复杂度选择数组中的第K个最大-x2F-最小元素"><a href="#线性复杂度选择数组中的第K个最大-x2F-最小元素" class="headerlink" title="线性复杂度选择数组中的第K个最大&#x2F;最小元素"></a>线性复杂度选择数组中的第K个最大&#x2F;最小元素</h3><ul>
<li><p>是快速排序思想的一种应用，用于在线性复杂度内选择给定数组中的第k个最大&#x2F;最小元素。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230107103905808.png" alt="image-20230107103905808"></p>
</li>
<li><p>用快速排序的思想，要找第k个最大的元素，实际上就是找升序排序后的数组的下标为<code>nums.length-k</code>的元素，又因为<strong>快速排序每一轮都会确定这一轮的轴心数在排序完成后的数组中的位置</strong>，所以我们只需要在每一轮快速排序结束的时候，判断一下这一轮轴心数确定下来的位置是不是<code>nums.length-k</code>，如果是的话说明就找到答案了，直接返回即可，如果不是，根据大小关系，继续向左或向右递归。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        recursion(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[right];<span class="comment">//轴心元素为这一段最后一个元素，先记录下来</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftD</span> <span class="operator">=</span> left;<span class="comment">//记录下left的复制，后面递归用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightD</span> <span class="operator">=</span> right;<span class="comment">//记录下right的复制，后面递归用</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//true为left往右走，false为right往左走</span></span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;<span class="comment">//两者相遇，说明两者相遇位置的左右边的元素都符合规则了</span></span><br><span class="line">            <span class="keyword">if</span>(oper)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left]&gt;pivot)&#123;<span class="comment">//如果找到不应该在这一边的元素，就扔给right处理（right在之前肯定留出了位置），空出了当前位置准备放right那边不合理的元素，所以让oper取反，让right行动</span></span><br><span class="line">                    nums[right] = nums[left];</span><br><span class="line">                    oper = !oper;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果元素合理就继续往下巡逻</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[right]&lt;pivot)&#123;<span class="comment">//如果找到不应该在这一边的元素，就扔给left处理（left在之前肯定留出了位置），空出了当前位置准备放left那边不合理的元素，所以让oper取反，让left行动</span></span><br><span class="line">                    nums[left] = nums[right];</span><br><span class="line">                    oper = !oper;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果元素合理就继续往下巡逻</span></span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[left] = pivot;<span class="comment">//相遇的地方是轴心元素的地方，现在轴心左边都小于等于轴心，轴心右边都大于等于轴心</span></span><br><span class="line">        <span class="keyword">if</span>(left == nums.length-k)&#123;<span class="comment">//如果这一轮轴心的位置就是要找的那个位置，答案就找到了，因为每一轮过后都会确定本轮轴心在最后排好序的数组的位置，记录并返回</span></span><br><span class="line">            ans = nums[left];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left&lt;nums.length-k)&#123;<span class="comment">//轴心位置小于要找的位置，就向右再找</span></span><br><span class="line">            recursion(nums,left+<span class="number">1</span>,rightD,k);</span><br><span class="line">        &#125;<span class="keyword">else</span> recursion(nums,leftD,left-<span class="number">1</span>,k);<span class="comment">//轴心位置大于要找的位置，就向左再找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="非递归算法实现快速排序"><a href="#非递归算法实现快速排序" class="headerlink" title="非递归算法实现快速排序"></a>非递归算法实现快速排序</h3><ul>
<li><p>思路就是用一个栈来模拟递归调用栈，主要是把握住如何用栈来模拟递归调用栈，类似的问题也可以用类似的方法解决，我用c语言实现了一下，细节挺多的，一不小心就容易出错：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&#123;</span><span class="comment">//借助一个栈来实现模拟递归的操作 </span></span><br><span class="line">	<span class="type">int</span> left[<span class="number">10005</span>];<span class="comment">//每轮快排的左界 </span></span><br><span class="line">	<span class="type">int</span> right[<span class="number">10005</span>];<span class="comment">//每轮快排的右界 </span></span><br><span class="line">	<span class="type">int</span> size;<span class="comment">//栈的大小 </span></span><br><span class="line">&#125;*Stack;</span><br><span class="line"><span class="type">int</span> leftright[<span class="number">2</span>];<span class="comment">//每次出栈的两个元素存到全局变量中，局部数组变量带不出函数，这样比较方便 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack st,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;<span class="comment">//栈的push操作，把左右界push到栈中表示一轮快排需要处理的数据范围 </span></span><br><span class="line">	st-&gt;left[st-&gt;size] = left;</span><br><span class="line">	st-&gt;right[st-&gt;size] = right;</span><br><span class="line">	st-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">(Stack st)</span>&#123;<span class="comment">//栈的pop操作，pop出这一轮快排需要处理的数据范围 </span></span><br><span class="line">	st-&gt;size--;</span><br><span class="line">	<span class="comment">//pop出的数据存到全局变量中 </span></span><br><span class="line">	leftright[<span class="number">0</span>] = st-&gt;left[st-&gt;size];</span><br><span class="line">	leftright[<span class="number">1</span>] = st-&gt;right[st-&gt;size];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="type">int</span> *num = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,num+i);</span><br><span class="line">	&#125;</span><br><span class="line">	Stack st = (Stack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Stack));</span><br><span class="line">	st-&gt;size = <span class="number">0</span>;<span class="comment">//别忘了申请空间后进行初始化操作，因为c语言不会对申请的空间自动赋初值 </span></span><br><span class="line">	push(st,<span class="number">0</span>,n<span class="number">-1</span>);<span class="comment">//第一轮快排的范围 </span></span><br><span class="line">	<span class="keyword">while</span>(st-&gt;size)&#123;<span class="comment">//用栈模拟递归，每次入栈就相当于调用一次递归函数，每次出栈相当于完成一次递归函数，循环处理直到递归栈为空 </span></span><br><span class="line">		<span class="comment">//printf(&quot;1&quot;);</span></span><br><span class="line">		pop(st);<span class="comment">//出栈，获取本轮快排需要的范围数据 </span></span><br><span class="line">		<span class="type">int</span> left = leftright[<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> right = leftright[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//		printf(&quot;%d %d\n&quot;,left,right);</span></span><br><span class="line"><span class="comment">//		for(int i=0;i&lt;n;++i)&#123;</span></span><br><span class="line"><span class="comment">//			printf(&quot;%d &quot;,num[i]);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		printf(&quot;\n&quot;);</span></span><br><span class="line">		<span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line">		<span class="keyword">if</span>(left&gt;=right) <span class="keyword">continue</span>;<span class="comment">//如果范围不合理则跳过这一轮快排，到下一轮快排 </span></span><br><span class="line">		<span class="comment">//下面就是快排的代码 </span></span><br><span class="line">		<span class="type">int</span> pivot = num[right];</span><br><span class="line">		<span class="type">int</span> op = <span class="number">1</span>;<span class="comment">//这个op一定要在每轮快排的时候初始化一下，不然其初值不确定的话就会出错，因为我这个代码每轮快排规定了左指针先动 </span></span><br><span class="line">		<span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line"><span class="comment">//			printf(&quot;2&quot;);</span></span><br><span class="line">			<span class="keyword">if</span>(op)&#123;</span><br><span class="line">				<span class="keyword">while</span>(left&lt;right&amp;&amp;num[left]&lt;=pivot)&#123;</span><br><span class="line">					left++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(left==right) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					num[right] = num[left];</span><br><span class="line">					op=!op;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">while</span>(left&lt;right&amp;&amp;num[right]&gt;=pivot)&#123;</span><br><span class="line">					right--;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(left==right) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">else</span>&#123;</span><br><span class="line">					num[left] = num[right];</span><br><span class="line">					op=!op;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		num[left] = pivot;</span><br><span class="line">		<span class="comment">//然后向左和向右递归，用栈模拟的话就是把两个递归数据push到栈中 </span></span><br><span class="line">		push(st,leftright[<span class="number">0</span>],left<span class="number">-1</span>);</span><br><span class="line">		push(st,left+<span class="number">1</span>,leftright[<span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,num[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="速度很快的桶排序"><a href="#速度很快的桶排序" class="headerlink" title="速度很快的桶排序"></a>速度很快的桶排序</h2><h3 id="桶排序思路"><a href="#桶排序思路" class="headerlink" title="桶排序思路"></a>桶排序思路</h3><ul>
<li>将待排序元素划分到不同的桶。先扫描一遍序列求出最大值 maxV 和最小值 minV ，设桶的个数为 k ，则把区间 [minV, maxV] 均匀划分成 k 个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。</li>
<li>对每个桶内的元素进行排序。可以选择任意一种排序算法。</li>
<li>将各个桶中的元素合并成一个大的有序序列。</li>
<li>假设数据是均匀分布的，则每个桶的元素平均个数为 n&#x2F;k 。假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为 O(n&#x2F;klog(n&#x2F;k)) 。总的时间复杂度为O(n)+O(k)O(n&#x2F;klog(n&#x2F;k)) &#x3D; O(n+nlog(n&#x2F;k)) &#x3D; O(n+nlogn-nlogk) 。当 k 接近于 n 时，桶排序的时间复杂度就可以金斯认为是 O(n) 的。即桶越多，时间效率就越高，而桶越多，空间就越大。</li>
</ul>
<h3 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="桶数最多计数排序"><a href="#桶数最多计数排序" class="headerlink" title="桶数最多计数排序"></a>桶数最多计数排序</h2><h3 id="计数排序思想"><a href="#计数排序思想" class="headerlink" title="计数排序思想"></a>计数排序思想</h3><ul>
<li><p>是一种<strong>时间复杂度为O(n)的排序算法</strong>，其思路是开一个长度为 maxValue-minValue+1 的数组，然后</p>
<ol>
<li><p><strong>分配</strong>：扫描一遍原始数组，以当前值 - minValue 作为下标，将该下标的计数器增1。</p>
</li>
<li><p><strong>收集</strong>：扫描一遍计数器数组，按顺序把值收集起来。</p>
</li>
</ol>
</li>
<li><p>举个例子， nums&#x3D;[2, 1, 3, 1, 5] , 首先扫描一遍获取最小值和最大值， maxValue&#x3D;5 , minValue&#x3D;1 ，于是开一个长度为5的计数器数组 counter ，</p>
<ol>
<li><p>分配。统计每个元素出现的频率，得到 counter&#x3D;[2, 1, 1, 0, 1] ，例如 counter[0] 表示值 0+minValue&#x3D;1 出现了2次。</p>
</li>
<li><p>收集。 counter[0]&#x3D;2 表示 1 出现了两次，那就向原始数组写入两个1， counter[1]&#x3D;1 表示 2 出现了1次，那就向原始数组写入一个2，依次类推，最终原始数组变为 [1,1,2,3,5] ，排序好了。</p>
</li>
</ol>
</li>
<li><p>计数排序本质上<strong>是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序</strong>。</p>
</li>
</ul>
<h3 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-09 10:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> INF;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> -INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//存储数据并找出数据中的最大值和最小值</span></span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(min&gt;num[i]) min = num[i];</span><br><span class="line">            <span class="keyword">if</span>(max&lt;num[i]) max = num[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[max-min+<span class="number">1</span>];<span class="comment">//把桶子创建出来，创建max-min+1个而不是max个实际上是优化空间，但相应要在下面的步骤中多做一点操作</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//对桶子对应的元素进行计数，计数为几说明存在几个当前桶子对应的元素，不过记得元素减min之后再给对应桶子计数，最后遍历的时候也要将桶子对应的元素加上min，这样才能得到原数据</span></span><br><span class="line">            bucket[num[i]-min]++;<span class="comment">//将元素给个偏移量后放进对应的桶子中，后面输出的时候应该让桶子对应的元素把偏移量加回去</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;max-min+<span class="number">1</span>;++i)&#123;<span class="comment">//遍历桶子</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;bucket[i];++j)&#123;<span class="comment">//根据当前桶子的计数来决定输出当前桶子对应的元素的数量，桶子大于1的计数在原数据中体现为重复的元素</span></span><br><span class="line">                System.out.print((i+min)+<span class="string">&quot; &quot;</span>);<span class="comment">//记得输出的时候把偏移量加回去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数位做桶基数排序"><a href="#数位做桶基数排序" class="headerlink" title="数位做桶基数排序"></a>数位做桶基数排序</h2><h3 id="基数排序介绍"><a href="#基数排序介绍" class="headerlink" title="基数排序介绍"></a>基数排序介绍</h3><ul>
<li>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或 bin sort，顾名思义，<strong>它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</strong>。</li>
<li>基数排序法是属于稳定性的排序，基数排序法的是<strong>效率高的稳定性排序法</strong>。</li>
<li><strong>基数排序(Radix Sort)是桶排序的扩展</strong>。</li>
<li>基数排序是 1887 年赫尔曼·何乐礼发明的。它是这样实现的：<strong>将整数按位数切割成不同的数字，然后按每个位数分别比较</strong>。</li>
</ul>
<h3 id="基数排序基本思想"><a href="#基数排序基本思想" class="headerlink" title="基数排序基本思想"></a>基数排序基本思想</h3><ul>
<li><strong>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零</strong>。然后，<strong>从最低位开始，依次进行一次排序</strong>。这样<strong>从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列</strong>。</li>
<li>实际上的原理就是<strong>每次循环过后使得下一次循环放入同一个桶中的元素从当前数位开始到最后组成的数字有序了，而不同的桶本身就自带顺序属性，在两方有序的加持下，整体的表现就是有序</strong>，比如123和221，经过一次循环之后221排到123前面了；那么在下一次循环中，221和123放到了同一个桶中，由于上一次循环把它们的个位数排序了，所以在这次循环中，它们从十位数开始之后的数位组成的数字是有序的，然后221又排到了123前面；再下一次循环，123和221不在一个桶中了，123又排到了221的前面，更高位数的数以此类推。实际上这么多次循环<strong>是在解决由于放入桶中的条件减少导致的桶内元素无序的情况，每次循环都致力于让最后的桶内部的元素是有序的</strong>。（我在说些什么。。。）</li>
<li>很明显，<strong>外层循环次数由序列中元素的最大数位长度（十进制）决定</strong>，<strong>由于某个数位的大小是0-9，所以桶的数量固定为10</strong>。</li>
<li>需要两层循环，<strong>外层循环控制本次是用哪个数位进行桶排序，内层循环做桶排序</strong>。</li>
</ul>
<h3 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul>
<li>虽然用到了两层循环，但是<strong>外层循环是和最大数位长度（十进制）k有关，内层循环做桶排序和序列长度n有关</strong>，所以<strong>时间复杂度是O(nk)的</strong>。</li>
</ul>
<h3 id="基数排序流程图解"><a href="#基数排序流程图解" class="headerlink" title="基数排序流程图解"></a>基数排序流程图解</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106105500208.png" alt="image-20221106105500208"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106105512310.png" alt="image-20221106105512310"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106105526703.png" alt="image-20221106105526703"></p>
<h3 id="代码示例-6"><a href="#代码示例-6" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-09 10:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INF</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要排序的数字数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入要排序的数字：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDigit</span> <span class="operator">=</span> -INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//存储数据，顺便找到所有数字中最大的数位长度作为桶排序的次数</span></span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> getDigit(num[i]);<span class="comment">//获取对应数字的数位长度</span></span><br><span class="line">            maxDigit = maxDigit&lt;digit?digit:maxDigit;<span class="comment">//找最大的数位长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;LinkedList&lt;Integer&gt;&gt; bucket = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//创建桶子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;<span class="comment">//因为每个数位的大小只能是0-9，而我们要对某个数位进行桶排序，所以只需要十个桶即可。</span></span><br><span class="line">            bucket.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//bucket = bucket.stream().map((v) -&gt; new LinkedList&lt;Integer&gt;()).collect(Collectors.toList());//流式操作初始化容器（好吧这样好像不太行）</span></span><br><span class="line">        <span class="comment">//System.out.println(bucket.size());</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxDigit;++i)&#123;<span class="comment">//对每个数位进行桶排序，从0开始方便后面做相关计算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">divisor</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">10</span>,i);<span class="comment">//用于获取对应的数位，数字除以这个数，然后再mod10就是对应的数位</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;<span class="comment">//遍历数据，根据当前循环到数位往桶子里放</span></span><br><span class="line">                bucket.get((num[j]/divisor)%<span class="number">10</span>).add(num[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//更新num用的下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;++j)&#123;<span class="comment">//遍历桶</span></span><br><span class="line">                <span class="keyword">while</span> (!bucket.get(j).isEmpty())&#123;<span class="comment">//如果桶子里面有元素，取出元素更新num</span></span><br><span class="line">                    num[index++] = bucket.get(j).poll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后的数组为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(num[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDigit</span><span class="params">(<span class="type">int</span> num)</span>&#123;<span class="comment">//获取一个数字的数位长度，就是一个数字十进制下有几位数，比如123的数位长度是3，12的数位长度是2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="埃氏筛"><a href="#埃氏筛" class="headerlink" title="埃氏筛"></a>埃氏筛</h1><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><ul>
<li>埃氏筛是一种能快速找出一个范围内素数的算法，其复杂度是O(n)的，其改良版本是欧式筛。</li>
</ul>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><ul>
<li><strong>一个素数的倍数一定不是素数，我们就利用这一点来利用素数筛掉和它成倍数的数字</strong></li>
</ul>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ul>
<li><strong>用一个prime数组记录筛出来的素数，用vis数组来标记非素数，vis[0]&#x3D;true、vis[1]&#x3D;true</strong></li>
<li>从2开始，由于vis[2]&#x3D;false，所以2是一个素数，将其加入到prime数组中，然后开始标记2的倍数直到边界，然后向后迭代，<strong>遇到vis值是false的就将其放入prime数组中，然后标记其倍数，以此类推</strong>。</li>
</ul>
<h2 id="算法缺陷"><a href="#算法缺陷" class="headerlink" title="算法缺陷"></a>算法缺陷</h2><ul>
<li>有的数字比如6可能会被标记多次(被2和3标记)，这也是欧式筛优化的点。</li>
</ul>
<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] prime = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        vis[<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">        vis[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prime_idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;<span class="number">1000</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                prime[prime_idx++] = i;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=i*<span class="number">2</span>;j&lt;<span class="number">1000</span>;j+=i)&#123;</span><br><span class="line">                    vis[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;0-999中的素数有：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prime_idx-<span class="number">1</span>;++i)&#123;</span><br><span class="line">            System.out.print(prime[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(prime[prime_idx-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><ul>
<li>二分不是单纯指从有序数组中快速找某个数，这只是二分的一个应用。</li>
<li>二分的<strong>本质是两段性，并非单调性</strong>。也就是说<strong>只要一段满足某个性质，另一段不满足这个性质，就可以使用二分</strong>。</li>
</ul>
<h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><ul>
<li>二分法的一个难点在于如何确定移动条件和方式，比如说，在什么条件下我应该左移？怎么左移？对于二分来说不一定就是满足某个条件left就右移，也有可能是满足什么条件后left做什么特殊处理，所以如何确定移动条件和方法这个问题要想清楚</li>
<li>二分法的另一个难点在于如何确定边界条件的写法，这一个难点主要分为两个小点：第一点就是循环退出的条件，第二点就是满足条件后left、right的移动。<del>其实对于这样的问题，只需要<strong>考虑left和right两个元素贴在一起的场景，计算出mid之后，考虑在这种边界场景下，left和right应该如何移动，循环应该什么时候退出</strong>即可。</del>更正一下之前写错的地方，关于<strong>循环条件和满足条件之后left、right的移动实际上是由区间的形式来决定的</strong>：<ul>
<li>其中<strong>循环条件的决定标准就是让每一次循环的区间都是有效的</strong>。比如我们规定区间是左闭右闭的，我们就可以写left&lt;&#x3D;right，因为left&#x3D;&#x3D;right的时候，区间仍然是有效的；但是对于左闭右开区间，我们就不能写那个等于号，因为当left&#x3D;=right的时候，左闭右开区间是无效的、不合理的。</li>
<li>其中<strong>满足条件后left和right的移动方式的决定标准是让已经排除掉的元素不再出现在下一次循环的区间当中，并且让上一个区间中未排除掉的元素全部出现在下一个区间中</strong>。所以对于闭区间，我们缩小范围的时候应该让区间边缘指针指向mid的前一个元素或后一个元素，因为mid在这一轮中已经被排除了，不能出现在下一轮的区间中；对于开区间，我们缩小范围的时候就应该让区间边缘指针指向mid，因为是开区间，所以尽管指向mid，mid也不会被包含在下一个区间当中，如果开区间的指针指向mid前一个或后一个元素的话，上一个区间中没有排除的元素就被无缘无故扔掉了，可能会造成程序错误。</li>
</ul>
</li>
</ul>
<h2 id="二分问题通用思考模型"><a href="#二分问题通用思考模型" class="headerlink" title="二分问题通用思考模型"></a>二分问题通用思考模型</h2><ul>
<li>首先<strong>分析数组的二段性</strong>，也就是我们要<strong>找一个分界点（可能是某个元素或者元素之间的空隙），这个分界点左边的元素都满足某个特性，这个分界点右边的元素满足另一个特性</strong>，比如有序数组就满足二段性，在有序数组中我们可以找到一个元素，这个元素左边的元素都小于它，这个元素右边的元素都大于它。</li>
<li>分析好二段性之后，<strong>二段性实际上就是我们需要移动左右指针的条件</strong>，比如mid满足前一段的特性，那么如果我们想要找分界点，我们就需要让left指针后移。</li>
<li>分析最后一次移动，也就是<strong>分析left和right在分界点周围的元素重合（通常不止一个，可能重合在分界点前面和后面）的时候进行的最后一次移动，这一次移动完之后循环将退出</strong>，我们需要<strong>考虑这次移动完之后left和right谁才是最后的答案</strong>，考虑出来之后返回答案就好。</li>
</ul>
<h2 id="二分找最后一个小于target的元素和第一个大于target的元素"><a href="#二分找最后一个小于target的元素和第一个大于target的元素" class="headerlink" title="二分找最后一个小于target的元素和第一个大于target的元素"></a>二分找最后一个小于target的元素和第一个大于target的元素</h2><ul>
<li><p>这个主要是考虑left&#x3D;&#x3D;right时的那最后一次移动，应该思考此时如果在答案附近的元素进行最后一次移动之后到底是left还是right是最后的答案。</p>
</li>
<li><p>先给个模板代码吧，之后再写思想：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bs</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target,<span class="type">boolean</span> flag)</span>&#123;<span class="comment">//flag是true的时候是找最后一个小于target的元素，flag是false的时候是找第一个大于target的元素，别的情况都可以推断出来</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=target)&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)&#123;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag?right:left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><ul>
<li><p>这个算法是用来快速求幂运算的，也就是求a^b^这样的问题，可以带上取模运算，也就是求a^b^ % mod，如果使用普通的算法来求的话，复杂度是O(N)的，但是如果使用快速幂来进行求解，复杂度可以被优化到O(logN)。</p>
</li>
<li><p>其原理就是将指数拆解成二进制的形式，通过对二进制的每一位的运算来得到最后的结果，设指数为n，那么普通算法需要遍历n次，而快速幂只需要遍历O(logN)次，所以复杂度是O(logN)的。</p>
</li>
<li><p>证明：</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">pow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> mod)</span>&#123;<span class="comment">//求a^b % mod</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//这是最后的结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//这是用来判断指数b某二进制数位的值的变量</span></span><br><span class="line">    <span class="comment">//下面两行将temp调整成和指数b二进制数位长度相同，方便之后从高位到低位获取指数b的二进制数位的值</span></span><br><span class="line">    <span class="keyword">while</span> (temp&lt;=b) temp&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    temp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp!=<span class="number">0</span>)&#123;<span class="comment">//然后就是开始计算，直到temp==0也就是说把指数b的二进制数位的最后一位也用完了</span></span><br><span class="line">        ans = ((ans%mod)*(ans%mod))%mod;<span class="comment">//无论指数b当前二进制数位的值是多少，ans都要平方，注意取模</span></span><br><span class="line">        <span class="keyword">if</span>((temp&amp;b)!=<span class="number">0</span>)&#123;<span class="comment">//如果指数b当前二进制数位的值是1，那么ans就还要乘底数a，注意取模</span></span><br><span class="line">            <span class="comment">//System.out.println(temp);</span></span><br><span class="line">            ans = ((a%mod)*(ans%mod))%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        temp&gt;&gt;=<span class="number">1</span>;<span class="comment">//使用完指数b的最高位，下一轮要使用指数b的低一位，所以temp右移1位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(ans);</span></span><br><span class="line">    <span class="keyword">return</span> ans;<span class="comment">//返回答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><h1 id="如何创建一棵二叉树"><a href="#如何创建一棵二叉树" class="headerlink" title="如何创建一棵二叉树"></a>如何创建一棵二叉树</h1><ul>
<li><p><strong>首先将所有节点按照层序遍历的顺序放入一个线性结构</strong>，然后<strong>再遍历这个线性结构，用访问二叉树子节点的方式(左节点下标为i*2+1，右节点下标为i*2+2)访问当前节点的左右节点并将这些节点建立起联系</strong>。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-10 14:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入树的节点(包括空节点)的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;树为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入树的层序结构（空节点用&#x27;#&#x27;表示，元素之间用空格分割）：&quot;</span>);</span><br><span class="line">        List&lt;TreeNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//用线性结构先把树的节点存储起来，之后再建立节点之间的关系</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//输入节点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.next();<span class="comment">//这个读取String的方法可以被空格阻断</span></span><br><span class="line">            <span class="keyword">if</span>(input.charAt(<span class="number">0</span>)==<span class="string">&#x27;#&#x27;</span>)&#123;<span class="comment">//处理空节点</span></span><br><span class="line">                nodes.add(<span class="literal">null</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//处理非空节点</span></span><br><span class="line">                nodes.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(input)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//建立节点之间的联系</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> nodes.get(i);<span class="comment">//取出当前节点，准备给其左右节点赋值</span></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="literal">null</span>) <span class="keyword">continue</span>;<span class="comment">//如果当前节点是个空节点，就continue，不过从面向对象的角度来说，空节点也应该是一个对象，不过有点麻烦所以就没弄</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//左节点下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i*<span class="number">2</span>+<span class="number">2</span>;<span class="comment">//右节点下标</span></span><br><span class="line">            <span class="keyword">if</span>(left&lt;n)&#123;<span class="comment">//检测左节点下标是否越界，如果越界了不用处理，默认反正就是null</span></span><br><span class="line">                temp.setLeft(nodes.get(left));<span class="comment">//设置左节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right&lt;n)&#123;<span class="comment">//检测右节点下标是否越界，如果越界了不用处理，默认反正就是null</span></span><br><span class="line">                temp.setRight(nodes.get(right));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);<span class="comment">//联系建立完毕后，线性结构中的第一个节点就是树的根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;<span class="comment">//二叉树节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;<span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode left;<span class="comment">//左节点</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode right;<span class="comment">//右节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(TreeNode left)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(TreeNode right)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二叉树遍历算法"><a href="#二叉树遍历算法" class="headerlink" title="二叉树遍历算法"></a>二叉树遍历算法</h1><h2 id="二叉树的纵序遍历"><a href="#二叉树的纵序遍历" class="headerlink" title="二叉树的纵序遍历"></a>二叉树的纵序遍历</h2><h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><ul>
<li><strong>以下均以先遍历左子树再遍历右子树为前提</strong>。</li>
</ul>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>该算法巧妙地利用到了一个二叉树中叶节点的空指针，从而使空间复杂度降到了O(1)，原理是<strong>构建了一颗线索二叉树，使得每次访问到每个子树的最后一个节点后都能找到应该回到哪里继续进行遍历</strong>，这一线索在之前学过的遍历方法中由递归、栈提供，但在Morris遍历中利用叶节点的空指针来提供。</li>
<li>morris遍历是二叉树遍历算法的超强进阶算法，morris遍历可以将非递归遍历中的空间复杂度降为O(1)。从而实现时间复杂度为O(N)，而空间复杂度为O(1)的精妙算法。<strong>morris遍历利用的是树的叶节点左右孩子为空（树的大量空闲指针），实现空间开销的极限缩减</strong>。</li>
</ul>
<h4 id="实现原则"><a href="#实现原则" class="headerlink" title="实现原则"></a>实现原则</h4><ul>
<li>记当前节点为cur：<ol>
<li>如果cur无左孩子，cur向右移动（cur&#x3D;cur.right）</li>
<li>如果cur有左孩子，找到cur左子树上最右的节点，记为mostright：如果mostright的right指针指向空，让其指向cur，cur向左移动（cur&#x3D;cur.left）；如果mostright的right指针指向cur，让其指向空，cur向右移动（cur&#x3D;cur.right）。</li>
</ol>
</li>
</ul>
<h4 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h4><ul>
<li>建立一种机制，对于没有左子树的节点只到达一次，对于有左子树的节点会到达两次。</li>
<li>实际上就是<strong>构建了一棵线索二叉树，让每个子树的最后遍历到的元素的右指针指向这颗子树的顶点，这样遍历完这颗子树后，就可以返回到顶点处（返回后要取消线索，意味着左子树已经遍历完毕）进行下一步的遍历操作了</strong>。</li>
</ul>
<h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-10 14:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Morris</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入树的节点(包括空节点)的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;树为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入树的层序结构（空节点用&#x27;#&#x27;表示，元素之间用空格分割）：&quot;</span>);</span><br><span class="line">        List&lt;TreeNode&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//用线性结构先把树的节点存储起来，之后再建立节点之间的关系</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//输入节点</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> scanner.next();<span class="comment">//这个读取String的方法可以被空格阻断</span></span><br><span class="line">            <span class="keyword">if</span>(input.charAt(<span class="number">0</span>)==<span class="string">&#x27;#&#x27;</span>)&#123;<span class="comment">//处理空节点</span></span><br><span class="line">                nodes.add(<span class="literal">null</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//处理非空节点</span></span><br><span class="line">                nodes.add(<span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(input)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//建立节点之间的联系</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> nodes.get(i);<span class="comment">//取出当前节点，准备给其左右节点赋值</span></span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="literal">null</span>) <span class="keyword">continue</span>;<span class="comment">//如果当前节点是个空节点，就continue，不过从面向对象的角度来说，空节点也应该是一个对象，不过有点麻烦所以就没弄</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//左节点下标</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i*<span class="number">2</span>+<span class="number">2</span>;<span class="comment">//右节点下标</span></span><br><span class="line">            <span class="keyword">if</span>(left&lt;n)&#123;<span class="comment">//检测左节点下标是否越界，如果越界了不用处理，默认反正就是null</span></span><br><span class="line">                temp.setLeft(nodes.get(left));<span class="comment">//设置左节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right&lt;n)&#123;<span class="comment">//检测右节点下标是否越界，如果越界了不用处理，默认反正就是null</span></span><br><span class="line">                temp.setRight(nodes.get(right));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);<span class="comment">//联系建立完毕后，线性结构中的第一个节点就是树的根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pointer</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">if</span>(pointer==<span class="literal">null</span>) System.out.println(<span class="string">&quot;树为空&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;指定树的前序Morris遍历的结果为&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(pointer!=<span class="literal">null</span>)&#123;<span class="comment">//Morris遍历，这里写个前序</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">mostRight</span> <span class="operator">=</span> pointer.left;<span class="comment">//mostRight用来找左子树的最右边的节点，把当前节点的左树赋给mostRight可以在后面顺便检测左树是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(mostRight!=<span class="literal">null</span>)&#123;<span class="comment">//如果左树存在</span></span><br><span class="line">                <span class="keyword">while</span> (mostRight.right != <span class="literal">null</span> &amp;&amp; mostRight.right!=pointer)&#123;<span class="comment">//找左子树最靠右的节点，最靠右的节点的右节点一定是null或者当前节点</span></span><br><span class="line">                    mostRight = mostRight.right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(mostRight.right == <span class="literal">null</span>)&#123;<span class="comment">//如果最右节点的右节点是null，说明这个左子树还没有被遍历过，就做好线索之后向左遍历，这个线索指向当前节点，为的是遍历完左子树回到当前节点并且还是作为左子树已经遍历过的标志</span></span><br><span class="line">                    System.out.print(pointer.val+<span class="string">&quot; &quot;</span>);<span class="comment">//前序遍历，在向左遍历之前输出</span></span><br><span class="line">                    mostRight.right = pointer;<span class="comment">//建立线索</span></span><br><span class="line">                    pointer = pointer.left;<span class="comment">//向左遍历</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果最右节点的右节点是当前节点，说明这个左子树已经被遍历过了，恢复右指针为null并向右遍历即可</span></span><br><span class="line">                    <span class="comment">//这里没有输出语句，是因为这个条件中是左子树已经被遍历过了，由于是前序遍历，所以当前节点应该已经被输出过一遍了，不用再输出一遍了。</span></span><br><span class="line">                    mostRight.right = <span class="literal">null</span>;<span class="comment">//消除线索</span></span><br><span class="line">                    pointer = pointer.right;<span class="comment">//向右遍历</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果左树不存在</span></span><br><span class="line">                System.out.print(pointer.val+<span class="string">&quot; &quot;</span>);<span class="comment">//前序遍历，没有左子树的时候，输出再向右遍历</span></span><br><span class="line">                pointer = pointer.right;<span class="comment">//向右遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;<span class="comment">//二叉树节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;<span class="comment">//节点的值</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode left;<span class="comment">//左节点</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode right;<span class="comment">//右节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(TreeNode left)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(TreeNode right)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码里还有个<strong>创建一棵树</strong>的知识点。</p>
<h2 id="二叉树的层序遍历"><a href="#二叉树的层序遍历" class="headerlink" title="二叉树的层序遍历"></a>二叉树的层序遍历</h2><h3 id="利用队列实现"><a href="#利用队列实现" class="headerlink" title="利用队列实现"></a>利用队列实现</h3><ul>
<li><p>总体思想就是BFS的思想，先初始化队列（往队列里面放第一个值），每次从队列中poll一个元素，然后把和这个元素相邻的下一层元素再放到队列中，一直重复操作直到队列为空，不过其中有几个比较难想的点。</p>
</li>
<li><p>如何获取每一层的元素数量？<strong>每一层的元素数量就是外层循环刚开始时的队列的长度，内层循环根据这个长度来poll元素即可保证poll出来的元素是同一层的</strong>，不过内层for循环中<strong>不要把queue.size()当作循环结束条件</strong>，而要在for循环之前记录队列在循环刚开始时的值，因为在内层循环中队列的长度是不断变化的，不能当作循环结束的条件。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;TreeNode&gt; qu = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; mid;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> list;</span><br><span class="line">        qu.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!qu.isEmpty())&#123;</span><br><span class="line">            mid = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> qu.size();<span class="comment">//本层的节点数量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;++i) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> qu.poll();</span><br><span class="line">                mid.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>)</span><br><span class="line">                    qu.add(temp.left);</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>)</span><br><span class="line">                    qu.add(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h1><h1 id="分支限界算法"><a href="#分支限界算法" class="headerlink" title="分支限界算法"></a>分支限界算法</h1><h2 id="状态空间树（解空间树）"><a href="#状态空间树（解空间树）" class="headerlink" title="状态空间树（解空间树）"></a>状态空间树（解空间树）</h2><ul>
<li>状态空间树就是问题的解空间树，分为<strong>子集树</strong>和<strong>排列树</strong>。</li>
<li>状态空间树<strong>通常是一个虚拟的树，并不需要我们实际将其构建出来，它的存在只是为了让我们能进一步理解解决问题需要计算的规模和问题的可能存在的解等，起到的是辅助的作用</strong>。</li>
<li><strong>对于明显不可能找到答案的分支我们可以选择不予遍历来提高效率，这样就是对状态空间树剪枝，剪枝的难点在于设计剪枝条件</strong>。</li>
</ul>
<h3 id="子集树"><a href="#子集树" class="headerlink" title="子集树"></a>子集树</h3><ul>
<li><p>当所给的问题是<strong>从n个元素组成的集合set中找到满足某一条件的一个子集时，相应的解空间树称为子集树</strong>。要注意，这个<strong>解空间树是一个虚拟的树，并不是需要实际构建出来的</strong>。</p>
</li>
<li><p><strong>0-1背包问题的解空间树实际上就是一个很典型的子集树，因为我们实际上是想要找到所有物品这个集合中的一个子集，使得子集中的物品能全部装到背包中并且价值最大</strong>，所以我们可以使用子集树来描述0-1背包问题的解空间。</p>
</li>
<li><p>对于<strong>0-1背包问题</strong>的子集树，我们通常<strong>将每个节点描述为目前装载的物品，向左遍历可以再装下一个物品，向右遍历不装下一个物品</strong>，以此类推，将所有的物品全部都决定完装或者不装之后，当前的节点也就是叶节点就可能是答案，要尝试更新答案，当将状态空间树的所有节点全部遍历一遍之后，答案也就被找出来了。</p>
</li>
<li><p>子集树示例：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121145007229.png" alt="image-20221121145007229"></p>
</li>
</ul>
<h3 id="排列树"><a href="#排列树" class="headerlink" title="排列树"></a>排列树</h3><ul>
<li><p>当所给的问题是<strong>求n个元素的全排列的时候，相应的解空间树称为排列树</strong>。要注意，这个<strong>解空间树是一个虚拟的树，并不是需要实际构建出来的</strong>。</p>
</li>
<li><p><strong>TSP问题（也就是旅行商问题，求从一个节点开始走过所有其它节点一遍后返回起始节点所需的最短路径）的解空间树实际上就是一个很典型的排列树，因为我们无论如何都要走过所有其它的节点一遍，只是顺序有先后，因此我们需要遍历其所有的顺序，从中找出答案</strong>。</p>
</li>
<li><p>对于<strong>TSP问题</strong>，我们通常<strong>将每个节点描述为目前经过的图上节点，每一层的遍历都是尝试将所有没经过的图上节点加入到经过的图上节点中，所以一个父节点有几个孩子不一定</strong>。最后所有图上节点都经过一遍之后，当前节点就是叶节点就可能是答案，要尝试更新答案，当将状态空间树的所有节点全部遍历一遍之后，答案也就被找出来了。</p>
</li>
<li><p>排列树示例：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121151314120.png" alt="image-20221121151314120"></p>
</li>
</ul>
<h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><ul>
<li>如果说回溯法是使用深度优先搜索的方式遍历一个问题的状态空间树来寻找可能的答案，那么<strong>分支限界法实际上就是使用广度优先搜索的方式遍历一个问题的状态空间树来寻找可能的答案</strong>。</li>
<li><strong>相比于回溯法的用递归解决问题，分支限界法常常具有更好的效率和更小的空间开销，每次都能决定状态空间树一整层节点的特性也让依赖于同层节点状态的剪枝变得相对容易一些</strong>。</li>
<li>在优化方面可以根据具体情况进行<strong>剪枝</strong>；也可以看情况用<strong>优先队列</strong>代替做广度优先搜索用到的队列，让最有可能找出答案的节点尽量早些被遍历到。</li>
<li>对于分支限界算法来说，<strong>如何设计状态空间树的节点是很重要的</strong>，<strong>状态空间树的节点中包含的属性应该可以准确描述当前状态并能为顺利构建下一个状态提供帮助，最好是还带有一些特定数据从而能更方便地实现剪枝操作</strong>。</li>
</ul>
<h2 id="0-1背包问题的分支限界法解决"><a href="#0-1背包问题的分支限界法解决" class="headerlink" title="0-1背包问题的分支限界法解决"></a>0-1背包问题的分支限界法解决</h2><ul>
<li><p><strong>难点在于设计状态空间树的节点、剪枝以及使用优先队列进行优化</strong>。</p>
</li>
<li><p><strong>将所有物品按照性价比进行降序排序，然后从前往后尝试进行选择，向左遍历是选择当前物品，向右遍历时不选择当前物品</strong>。</p>
</li>
<li><p>对于节点的设计，需要一个<strong>index来指示下一个应该尝试选择的物品是第几个（在针对性价比排列过的序列中），这个属性对于顺利构建出下一个节点也有很重要的作用</strong>；需要一个<strong>valueNow来表示当前节点代表的状态装了价值为多少的东西</strong>；需要一个<strong>weightNow来表示当前节点代表的状态装了重量为多少的东西</strong>；还需要一个<strong>upperBound来表示当前节点表示的状态中背包的剩余空间全部利用上（装不下的可以装一部分，总之让剩余空间要全部装满）最多还能装多少价值的东西，这个属性是用来剪枝用的，如果要是valueNow+upperBound小于等于目前更新到的可能的答案，那么就可以剪枝了，因为沿着这条路走下去不可能会遍历到一个节点使得valueNow大于当前更新到的可能的答案，也就是说答案不可能在这条路上得到更新，直接剪掉就好了</strong>。</p>
</li>
<li><p>还可以<strong>用优先队列代替队列进行广度优先搜索，将最有可能得到答案的节点提前遍历，提高提前找到答案的可能性</strong>。</p>
</li>
<li><p>代码示例，没有做剪枝和优先队列优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-20 9:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BranchAndBound01Backpack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入背包的容量：&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">w</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入物品的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">double</span>[] value = <span class="keyword">new</span> <span class="title class_">double</span>[n];<span class="comment">//存物品价值</span></span><br><span class="line">        <span class="type">double</span>[] weight = <span class="keyword">new</span> <span class="title class_">double</span>[n];<span class="comment">//存物品重量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+i+<span class="string">&quot;个物品的价值和重量：&quot;</span>);</span><br><span class="line">            value[i-<span class="number">1</span>] = scanner.nextDouble();</span><br><span class="line">            weight[i-<span class="number">1</span>] = scanner.nextDouble();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//冒泡排序将物品按照性价比排序</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n-i;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(value[j]/weight[j]&lt;value[j+<span class="number">1</span>]/weight[j+<span class="number">1</span>])&#123;<span class="comment">//计算相邻两个物品的性价比，如果顺序不对就交换两个物品的位置（体现在交换两个数组的元素位置上）</span></span><br><span class="line">                    <span class="type">double</span> <span class="variable">temp</span> <span class="operator">=</span> value[j];</span><br><span class="line">                    value[j] = value[j+<span class="number">1</span>];</span><br><span class="line">                    value[j+<span class="number">1</span>] = temp;</span><br><span class="line">                    temp = weight[j];</span><br><span class="line">                    weight[j] = weight[j+<span class="number">1</span>];</span><br><span class="line">                    weight[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//队列</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,getUpperBound(value,weight,<span class="number">0</span>,w)));<span class="comment">//加入初始节点</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;<span class="comment">//广度优先遍历状态空间树</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(temp.index&gt;=n)&#123;<span class="comment">//如果下标越界，说明当前可能是答案，所以对答案尝试更新</span></span><br><span class="line">                <span class="keyword">if</span>(temp.valueNow&gt;ans) ans = temp.valueNow;<span class="comment">//尝试更新答案</span></span><br><span class="line">                <span class="keyword">continue</span>;<span class="comment">//由于下标越界，所以后面不可能有别的节点了，它是叶节点，所以不用扩展它的子节点，直接continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将空间状态树的两个子节点加入队列中</span></span><br><span class="line">            <span class="keyword">if</span>(temp.weightNow+weight[temp.index]&lt;=w)&#123;<span class="comment">//这是要装下一个物品的节点，如果能装下下一个物品就装，如果不能装下的话就不装，体现在程序上就是是否能计算得到下一个有效的状态节点并将其加入到队列中去</span></span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(temp.index+<span class="number">1</span>,temp.valueNow+value[temp.index],temp.weightNow+weight[temp.index],getUpperBound(value,weight,temp.index+<span class="number">1</span>,w-temp.weightNow-weight[temp.index])));</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="title class_">Node</span>(temp.index+<span class="number">1</span>,temp.valueNow,temp.weightNow,getUpperBound(value,weight,temp.index+<span class="number">1</span>,w-temp.weightNow)));<span class="comment">//这是不装下一个物品的节点，由于不装下一个节点，所以除了上界以外的属性都和它的父节点相同。</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;背包所能装下的最大价值为：&quot;</span>+ans);<span class="comment">//输出结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getUpperBound</span><span class="params">(<span class="type">double</span>[] value,<span class="type">double</span>[] weight,<span class="type">int</span> index,<span class="type">double</span> weightRest)</span>&#123;<span class="comment">//index是从哪开始计算，因为要算的是剩下的空间最多还能装多少价值的东西所以已经决定选或不选的元素不参与计算，weightRest是背包剩余的可以装东西的重量</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;value.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(weightRest&gt;=weight[i])&#123;<span class="comment">//如果装的下就装</span></span><br><span class="line">                ans+=value[i];</span><br><span class="line">                weightRest-=weight[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果装不下就按照单位重量的价值计算最多能装的价值是多少</span></span><br><span class="line">                ans+=weightRest*(value[i]/weight[i]);</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//weightRest用光了，直接退出循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> index;<span class="comment">//下一个应该判断第几个要不要装了</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> valueNow;<span class="comment">//装到现在的价值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> weightNow;<span class="comment">//装到现在的重量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> upperBound;<span class="comment">//装到现在的可能的最大价值上界（也就是理论上最多还能装的价值）</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> index,<span class="type">double</span> valueNow,<span class="type">double</span> weightNow,<span class="type">double</span> upperBound)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">            <span class="built_in">this</span>.valueNow = valueNow;</span><br><span class="line">            <span class="built_in">this</span>.weightNow = weightNow;</span><br><span class="line">            <span class="built_in">this</span>.upperBound = upperBound;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="TSP问题的分支限界法解决"><a href="#TSP问题的分支限界法解决" class="headerlink" title="TSP问题的分支限界法解决"></a>TSP问题的分支限界法解决</h2><h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><h2 id="DP之编辑距离"><a href="#DP之编辑距离" class="headerlink" title="DP之编辑距离"></a>DP之编辑距离</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul>
<li>很经典的一个问题，<strong>编辑距离指的是从一个字符串变更为另外一个字符串所需要的最少操作数</strong>，其中可以做三种操作：插入一个字符、删除一个字符、修改一个字符。</li>
</ul>
<h3 id="DP思想"><a href="#DP思想" class="headerlink" title="DP思想"></a>DP思想</h3><ul>
<li><strong>首先将大问题逐步分解为小问题</strong>，以there和here两个字符串为例，大问题是there到here的编辑距离，那么所有小问题就是：t到here、th到here、the到here……</li>
<li>经过上面对于大问题的分解，我们不难发现<strong>所有小问题的状态是需要一个m*n的二维数组来进行表示的</strong>，因此我们需要建立一个二维dp数组，数组元素dp[i][j]代表第一个字符串的前i个字符和第二个字符串的前j个字符的编辑距离，所以最后的dp[m][n]就是答案。</li>
<li>分解完问题之后，我们<strong>再来看看对于每个子问题解是否满足无后效性</strong>，也就是说每个子问题的解是否不影响后序子问题求解，很明显是不影响的。</li>
<li>再<strong>看看子问题是否具有重叠性</strong>。</li>
<li>然后<strong>再确定dp的状态转移方程</strong>，考虑中间某个值<strong>dp[i][j]可以从哪些值转移过来</strong>，以下都是以对第一个字符串做操作为基础，首先可以<strong>从dp[i-1][j]+1转移过来，这个转移对应着我们对第一个字符串删除一个元素</strong>，因为i-1能变到j，i对应的字符没用了；其次可以<strong>从dp[i][j-1]+1转移过来，这个转移对应着我们对第一个字符串增加一个元素使得其和第二个字符串j位置上的字符相同</strong>，因为都能从i变到j-1了，只需要插入一个和j对应的字符相同的字符就能成了；再者<strong>可以从dp[i-1][j-1]+!(a[i]&#x3D;&#x3D;b[j])转移过来，这个转移对应着我们对第一个字符串修改一个元素使得i对应的元素和j对应的元素相同</strong>，因为已经可以从i-1转移到j-1了，所以只需要将剩下的俩元素修改成一样的就行了，如果剩下得俩字符本来就相同的话，那就没必要修改了，值就和dp[i-1][j-1]一样了。综上所述，所有的三个操作对应三个可能的转移方向，确定值的时候只需要取个最小值即可。</li>
<li>确定好状态转移方程后，我们只是确定了中间那部分子问题的求解方式，但是边界子问题的求解方式不一定和中间那部分子问题的求解方式相同，所以我们<strong>要再确定边界子问题的求解方式</strong>。对于边界情况，也就是从一个字符串变成空串，所需要的操作数就是这个字符串的长度，因为只需要把字符串的所有元素都删掉就能达成目标。<strong>对于dp数组来说我们可以额外对每个维度再开出一个空间来，以保证较外层求解时可以使用中间层的求解范式而不至于造成数组越界或者是增加一些繁琐的判断操作</strong>。</li>
<li>确定完边界子问题的求解方式后，我们要<strong>先将边界子问题求出，这一步实际上就是初始化dp数组，然后再使用状态转移方程对其他子问题求解即可</strong>。</li>
</ul>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-15 20:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EditDistance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第一个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入第二个字符串：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[a.length()+<span class="number">1</span>][b.length()+<span class="number">1</span>];<span class="comment">//每个维度大小加一对边界初始化后方便状态转移</span></span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;a.length();++i)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.print(a.indexOf(i)+&quot; &quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=a.length();++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=b.length();++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>) dp[i][j] = Math.max(i,j);<span class="comment">//边界子问题求解</span></span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>,Math.min(dp[i][j-<span class="number">1</span>]+<span class="number">1</span>,dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+(a.charAt(i-<span class="number">1</span>)==b.charAt(j-<span class="number">1</span>)?<span class="number">0</span>:<span class="number">1</span>)));<span class="comment">//状态转移</span></span><br><span class="line"><span class="comment">//                System.out.print(a.indexOf(i-1)+b.indexOf(j-1)+dp[i][j]);</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;答案为：&quot;</span>+dp[a.length()][b.length()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DP之TSP问题"><a href="#DP之TSP问题" class="headerlink" title="DP之TSP问题"></a>DP之TSP问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><ul>
<li>就是旅行商问题，问的是，给你一个图，然后求从一个节点经过剩下所有节点之后回到一开始那个节点所用的最小花费。</li>
</ul>
<h3 id="DP思想-1"><a href="#DP思想-1" class="headerlink" title="DP思想"></a>DP思想</h3><ul>
<li>以下<strong>假设是从节点0开始出发</strong>。</li>
<li>可以<strong>把问题描述为：从节点0开始出发，经过集合中除了节点0的剩余节点，最后再返回到节点0所需要的最小费用</strong>。</li>
<li>然后我们可以定义子问题，每次从集合中的节点中拿出一个来当作子问题的起始节点，这样<strong>子问题就变成了：从取出来的节点开始出发，经过集合中除了节点0和取出来的节点的剩余节点，最后回到节点0所需要的最小费用</strong>。当从集合中把每个元素都取遍，实际上所有子问题也就被遍历过了，找到所有第一轮子问题中结果最小的那个就是答案，不过要确定第一轮子问题的答案，还需要将所有第一轮子问题分解出第二轮子问题，然后确定每一个第一轮子问题分解出的所有第二轮子问题的答案的最小值，那就是对应的第一轮子问题的答案……以此类推，直到无法再分后将答案一层层返回上来，思想像递归，不过在dp中是倒推。</li>
<li>再想想怎么进行状态转移，可以<strong>设置二维dp数组，第一维表示节点，第二位表示当前节点最后到达节点0所通过的子集(都不包括节点0)<strong>，对于子集更长的状态来说，应该从子集长度减一的所有状态中</strong>距离最短的状态</strong>中转移过来，<strong>所以子集更长的状态转移依赖于所有子集长度减一的状态</strong>，所以做状态转移的时候应该是<strong>按轮进行状态转移，子集长度相同的状态在同一轮被确定下来</strong>，这样才能为后面的状态进行确定的时候提供有效的前置状态。</li>
<li>如果是节点0作为起始点的话，最后的结果应该是dp数组中最右上角的那个元素，那个元素代表着节点0通过除了节点0的所有节点之后回到节点0的距离，<strong>这个答案是从所有子集长度减一的有效状态中转移过来的</strong>。</li>
</ul>
<h3 id="dp数组图解"><a href="#dp数组图解" class="headerlink" title="dp数组图解"></a>dp数组图解</h3><ul>
<li><p>dp状态转移方程：其中V’代表不包含它前面节点和起始节点的子集。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221023194550921.png" alt="image-20221023194550921"></p>
</li>
<li><p>dp数组示例：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221024202014918.png" alt="image-20221024202014918"></p>
</li>
</ul>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-22 17:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TSPQuestionDP</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">inf</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;<span class="comment">//正无穷</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入节点数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] g = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];<span class="comment">//邻接矩阵存图</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>)];<span class="comment">//dp数组，第一维为节点，第二维为子集</span></span><br><span class="line">        <span class="comment">//int[][] subSet = new int[n][n];</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化邻接矩阵</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                g[i][j] = inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入边的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+(i+<span class="number">1</span> )+<span class="string">&quot;条边的起点、终点、权值：&quot;</span>);</span><br><span class="line">            g[scanner.nextInt()][scanner.nextInt()] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取子集</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subSet = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//所有子集</span></span><br><span class="line">        HashMap&lt;ArrayList&lt;Integer&gt;,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//子集对应的访问下标</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[n-<span class="number">1</span>];<span class="comment">//用于求子集</span></span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n-<span class="number">1</span>];<span class="comment">//用于求子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//初始化要求子集的集合</span></span><br><span class="line">            temp[i-<span class="number">1</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(temp,<span class="number">0</span>,vis,subSet);<span class="comment">//求子集</span></span><br><span class="line">        subSet.sort((o1,o2) -&gt; &#123;<span class="comment">//按照自定义的排序方式进行排序，返回负数表示当前两者关系是有序（升序）的，无需做调整</span></span><br><span class="line">            <span class="keyword">if</span>(o1.size()==o2.size())&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;o1.size();++i)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(o1.get(i)!=o2.get(i))&#123;</span><br><span class="line">                        <span class="keyword">return</span> o1.get(i)&lt;=o2.get(i)?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.size()&lt;=o2.size()?-<span class="number">1</span>:<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;subSet.size();++i)&#123;<span class="comment">//建立集合和下标的映射</span></span><br><span class="line">            <span class="comment">//System.out.println(subSet.get(i));</span></span><br><span class="line">            map.put(subSet.get(i),i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//初始化dp数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = g[i][<span class="number">0</span>];<span class="comment">//节点i经过空集到节点0，距离就是它们之间的距离</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//节点i经过集合中的单个元素（不能是当前节点）到节点0，距离就是当前节点到集合中的那个节点的距离再加上集合中的那个节点到节点0的距离</span></span><br><span class="line">                    <span class="keyword">if</span>(!subSet.get(j).contains(i) &amp;&amp; g[i][subSet.get(j).get(<span class="number">0</span>)]!=inf &amp;&amp; g[subSet.get(j).get(<span class="number">0</span>)][<span class="number">0</span>]!=inf) dp[i][j] = g[i][subSet.get(j).get(<span class="number">0</span>)] + g[subSet.get(j).get(<span class="number">0</span>)][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = inf;<span class="comment">//如果其中任意两节点无法到达，设置为正无穷，方便之后淘汰经过当前元素的转移方案。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>;m&lt;n;++m)&#123;<span class="comment">//由于更长的子集需要所有之前更短的子集转移出来的结果，所以每轮转移要保证子集长度都相同</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//记录dp的列应该从哪继续转移</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;++j)&#123;<span class="comment">//每一轮的子集数量和组合数有关</span></span><br><span class="line">                begin += C(n-<span class="number">1</span>,j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> begin+C(n-<span class="number">1</span>,m);<span class="comment">//记录dp的列这一轮应该转移到哪里</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">1</span>;--i)&#123;<span class="comment">//dp的行从下往上转移，从上往下也行，但是不转移节点0。</span></span><br><span class="line">                <span class="comment">//System.out.println(begin+&quot; &quot;+end);</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=begin;j&lt;end;++j) &#123;<span class="comment">//dp的列</span></span><br><span class="line">                    <span class="keyword">if</span> (!subSet.get(j).contains(i)) &#123;<span class="comment">//通过的子集中不能包含当前节点</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> inf;<span class="comment">//用于找所有方案中最短的那个</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; subSet.get(j).size(); ++k) &#123;<span class="comment">//依次试遍所有子问题</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">selectedNum</span> <span class="operator">=</span> subSet.get(j).get(k);<span class="comment">//被选中独立出来的元素</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//把一个元素独立出来后，剩下的子集对应的dp列的访问下标</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; subSet.size(); ++l) &#123;<span class="comment">//找独立出元素后的子集对应的dp列的访问下标</span></span><br><span class="line">                                <span class="comment">//先筛一波长度差一并且其中不含独立出来的元素的子集</span></span><br><span class="line">                                <span class="keyword">if</span> (subSet.get(l).size() + <span class="number">1</span> == subSet.get(j).size() &amp;&amp; !subSet.get(l).contains(selectedNum)) &#123;</span><br><span class="line">                                    <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">//是否找到</span></span><br><span class="line">                                    <span class="keyword">for</span>(<span class="type">int</span> o=<span class="number">0</span>;o&lt;subSet.get(j).size();++o)&#123;<span class="comment">//检查初筛出来的子集是否包含刚才独立出元素后的子集的所有剩余元素</span></span><br><span class="line">                                        <span class="keyword">if</span>(subSet.get(j).get(o)==selectedNum) <span class="keyword">continue</span>;<span class="comment">//不看独立出来的元素</span></span><br><span class="line">                                        <span class="keyword">else</span>&#123;</span><br><span class="line">                                            <span class="keyword">if</span>(!subSet.get(l).contains(subSet.get(j).get(o)))&#123;<span class="comment">//如果有一个元素不包含，那当前这个子集就不是刚才独立出元素后变成的子集，要继续找</span></span><br><span class="line">                                                found = <span class="literal">false</span>;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">if</span>(found)&#123;<span class="comment">//找到了就通过之前做的映射拿到其访问下标</span></span><br><span class="line">                                        pos = map.get(subSet.get(l));</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//System.out.println(i+&quot; &quot;+j+&quot; &quot;+selectedNum+&quot; &quot;+pos);</span></span><br><span class="line">                            <span class="keyword">if</span> (min &gt; dp[selectedNum][pos] + g[i][selectedNum])<span class="comment">//尝试更新min的值</span></span><br><span class="line">                                min = dp[selectedNum][pos] + g[i][selectedNum];</span><br><span class="line">                        &#125;</span><br><span class="line">                        dp[i][j] = min;<span class="comment">//进行状态转移，由于初始化的时候不可达设置成了正无穷，所以可以保证不会从非法的地方转移过来</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为得到最终的答案进行状态转移</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;subSet.get((<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>))-<span class="number">1</span>).size();++k)&#123;<span class="comment">//遍历除了节点0的全集的子问题</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">selectedNum</span> <span class="operator">=</span> subSet.get((<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>))-<span class="number">1</span>).get(k);<span class="comment">//独立出一个元素来</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;subSet.size();++l)&#123;<span class="comment">//找独立出元素后的集合下标</span></span><br><span class="line">                <span class="comment">//由于全集的答案是从上一轮的子集中转移过来的，而上一轮的子集比全集只少1，因此如果一个子集不包含从全集中独立出来的那个元素，那么这个子集就是独立出元素后的全集，易证</span></span><br><span class="line">                <span class="keyword">if</span>(subSet.get(l).size()+<span class="number">1</span>==subSet.get((<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>))-<span class="number">1</span>).size()&amp;&amp;!subSet.get(l).contains(selectedNum))&#123;</span><br><span class="line">                    pos = map.get(subSet.get(l));<span class="comment">//拿到下标，不过写注释写到这我发现为啥不直接用l当下标。。。</span></span><br><span class="line">                    <span class="comment">//System.out.println(selectedNum+&quot; &quot;+pos+&quot; &quot;+subSet.get(l));</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(dp[selectedNum][pos]+&quot; &quot;+g[0][selectedNum]);</span></span><br><span class="line">            <span class="comment">//尝试更新min</span></span><br><span class="line">            <span class="keyword">if</span>(min &gt; dp[selectedNum][pos]+g[<span class="number">0</span>][selectedNum]) min = dp[selectedNum][pos]+g[<span class="number">0</span>][selectedNum];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][(<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>))-<span class="number">1</span>] = min;<span class="comment">//状态转移得到最后答案</span></span><br><span class="line">        <span class="comment">//输出dp数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>));++i)&#123;</span><br><span class="line">            System.out.print(subSet.get(i)+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>));++j)&#123;</span><br><span class="line">                System.out.print(dp[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出结论</span></span><br><span class="line">        System.out.println(<span class="string">&quot;从0号节点出发经过所有节点返回的最小距离是：&quot;</span>+dp[<span class="number">0</span>][(<span class="number">1</span>&lt;&lt;(n-<span class="number">1</span>))-<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] num,<span class="type">int</span> a,<span class="type">boolean</span>[] vis,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; subSet)</span>&#123;<span class="comment">//求子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;vis.length;++i)&#123;<span class="comment">//回溯算法求子集</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                dfs(num,i+<span class="number">1</span>,vis,subSet);</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;vis.length;++i)&#123;<span class="comment">//记录当前求得的子集</span></span><br><span class="line">            <span class="keyword">if</span>(vis[i])&#123;</span><br><span class="line">                list.add(num[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        subSet.add(list);<span class="comment">//加入子集的集合</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">C</span><span class="params">(<span class="type">int</span> down,<span class="type">int</span> up)</span>&#123;<span class="comment">//求组合数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;up;++i)&#123;</span><br><span class="line">            ans*=down-i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=up;++i)&#123;</span><br><span class="line">            ans/=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230116110146649.png" alt="image-20230116110146649"></p>
<h2 id="环状DP"><a href="#环状DP" class="headerlink" title="环状DP"></a>环状DP</h2><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><ul>
<li><p>顾名思义就是在树上进行dp，这种情况<strong>一般用一个或多个HashMap来当作dp数组存放状态</strong>，其中key一般是树的节点，value就具体情况具体分析，然后一般是<strong>要对树进行后序遍历</strong>，因为这样在对子树根节点进行状态转移的时候，能保证它的左右节点都已经转移完成，可以直接利用左右节点的状态来进行根节点的状态转移。</p>
</li>
<li><p>无论是对树进行dfs还是dp的时候，树&#x2F;子树的根节点的意义都是至关重要的，因为它在接收左右节点的状态的同时决定着父节点的状态，所以在考虑问题的时候一定要<strong>从树&#x2F;子树的根节点着手</strong>，思考<strong>根节点的意义</strong>、<strong>根节点的所有可能的状态</strong>、<strong>如何利用左右节点来决定根节点</strong>。</p>
</li>
<li><p>LeetCode 337.打家劫舍Ⅲ：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230129095508118.png" alt="image-20230129095508118"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//如果是线性结构嘛，这个地方就是一个二维数组，第二维表示两种选择，但是这是非线性结构，所以只能把第二维拆出来，有几维就创建几个hashmap，每个hashmap表示一种选择。</span></span><br><span class="line">    HashMap&lt;TreeNode,Integer&gt; yes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//选该节点能得到的最大收益</span></span><br><span class="line">    HashMap&lt;TreeNode,Integer&gt; no = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//不选该节点能得到的最大收益</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(yes.get(root),no.get(root));<span class="comment">//最后的结果就是在选和不选当前节点这两种情况中取个最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;<span class="comment">//后序遍历保证子树的根节点进行状态转移的时候它的左右节点的状态均已转移完成</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">noL</span> <span class="operator">=</span> no.getOrDefault(root.left,<span class="number">0</span>);<span class="comment">//以左节点为根的子树，不选它的收益</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">noR</span> <span class="operator">=</span> no.getOrDefault(root.right,<span class="number">0</span>);<span class="comment">//以右节点为根的子树，不选它的收益</span></span><br><span class="line">        yes.put(root,noL+noR+root.val);<span class="comment">//选当前节点的话，收益就是左右节点都不选的情况的收益和+当前节点的收益</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">yesL</span> <span class="operator">=</span> yes.getOrDefault(root.left,<span class="number">0</span>);<span class="comment">//以左节点为根的子树，选它的收益</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">yesR</span> <span class="operator">=</span> yes.getOrDefault(root.right,<span class="number">0</span>);<span class="comment">//以右节点为根的子树，选它的收益</span></span><br><span class="line">        no.put(root,Math.max(yesL,noL)+Math.max(yesR,noR));<span class="comment">//不选当前节点的话，当前节点的收益就是选/不选左右节点四种情况的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>树上dp，用两个hashmap当作dp数组，两个hashmap分别表示选和不选当前节点能得到的最大收益，然后对树进行后序遍历，这样在转移根节点的时候能保证左右节点的结果都转移出来了，进行状态转移的时候，如果选根节点，那么最大收益就是不选左右节点的最大收益和；如果不选根节点，那么最大收益就是选&#x2F;不选左右节点四种情况的收益最大值，最后的结果就是选根节点和不选根节点的收益情况的最大值。</p>
</li>
</ul>
<h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ul>
<li><p>有的题目可能一上来就思考dp比较困难，这个时候我们可以<strong>先考虑怎么用dfs的暴力搜索来解题，找到思路之后再考虑将其优化为记忆化搜索(把中间过程的结果存到哈希表或别的数据结构中，之后用到的时候不用算直接拿)，最后再尝试用下面的五步走来将其优化为dp</strong>。</p>
</li>
<li><p>解决dp问题通常分五步走，走好这五步，dp问题基本能迎刃而解：</p>
<ol>
<li>首先就是要<strong>确定dp数组的元素含义</strong>，然后就是<strong>确定每一个dp数组元素的所有状态</strong>，状态怎么确定呢？<strong>状态一般体现为做了什么操作对dp数组的当前元素产生了影响，每个操作就是这个dp数组元素的一个状态</strong>，在确定好dp数组元素的含义和dp数组元素的状态之后，我们就可以把这个dp数组给定义出来了，一般前面的维度都是用来定位dp数组的元素，最后一个维度可以设计成存放所有当前元素的状态，<strong>通过物理位置和状态号可以准确定位到一个元素在某个状态时的值</strong>，不过也可以分成多个dp数组来表示dp数组元素的所有状态。</li>
<li>然后就是要<strong>确定dp数组各元素之间所有状态的递推公式</strong>，这个递推公式一定要做到面面俱到，也就是说<strong>要考虑到当前元素的所有状态应该怎么从别的状态转移过来</strong>，而不是只转移部分状态，如果只转移部分状态，那么后面的状态可能会转移出错，最后的结果大概率是错的。</li>
<li>然后就是<strong>确定dp数组的边界</strong>，也就是考虑如何初始化dp数组，<strong>本质上是我们要考虑一个元素的状态在从边界及边界之外的状态转移过来的时候应该怎样进行转移</strong>，这个就是要具体情况具体分析，有的问题可以多出一圈虚拟的dp数组元素用来边界转移，也有的问题需要先确定边界的值然后再对后面的状态进行转移。<strong>确定边界值的时候应该考虑dp数组的边界元素转移到其所有状态的值，千万不要只考虑初始化一部分，要把所有边界元素的所有状态都初始化好</strong>。</li>
<li>然后就是<strong>确定遍历顺序</strong>，遍历顺序是由状态之间的依赖关系决定的，<strong>本质上是要求我们在进行一个元素所有状态的转移的时候，它依赖的所有状态都应该是已经转移完毕的</strong>，有的是前面的元素状态依赖后面的，那就从后向前遍历；有的是后面的元素状态依赖前面的，那就从前向后遍历；还有的是非线性的依赖关系，那就具体情况具体分析。</li>
<li>最后就是可以<strong>举个例子，看看自己的推导是否正确</strong>。</li>
</ol>
</li>
</ul>
<h1 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h1><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><ul>
<li>单源无负权最短路径，即一个点到其他点的最短路径，所有的边不允许出现负权值。</li>
</ul>
<h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li><p>每次外层循环确定一个节点到源点的最短距离</p>
</li>
<li><p>每次内层循环通过确定最短路径的点对与其相邻的点到源点的距离进行“松弛”操作以确保下一次外层循环能找到正确的距离源点最短的点。</p>
</li>
<li><p>贪心的思想，每次找最短路径的节点来对别的节点做“松弛”。</p>
</li>
</ul>
<h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><ul>
<li><p>假设节点数量为n，那么首先我们需要一个<strong>n x n的矩阵g来存放图，或者用邻接表、链式前向星存</strong>，然后我们需要一个<strong>长度为n的boolean数组vis来标识节点到源点的最短距离是否已经被确定</strong>，然后<strong>需要一个长度为n的整型数组dis来记录源点到其他点的最短距离</strong>，如果要<strong>对时间复杂度进行优化的话，我们还需要维护一个优先队列（可以用堆实现）q来表示节点到源点的距离</strong>。</p>
</li>
<li><p>初始化g，除了自己到自己的距离为0，其他初始化为inf，然后根据输入的边进行调整；</p>
<p>初始化vis，源点src到自己的最短距离已经确认，所以让src为true，其余为false；</p>
<p>初始化dis，就是src到各点的距离，从g中拿就行。</p>
</li>
<li><p>然后外层循环n-1次，因为有n-1个节点到src的最短路径需要确认，外层循环每循环一次就确定一个节点到src的最短路径。</p>
<p>内层先用一个循环来找到当前与src直接或间接相连的节点到src的最短路径（如果使用优先队列进行优化的话就直接取优先队列的头元素即可，不用循环了就），找到之后对应的那个节点的最短路径就被固定了，因为别的路径都必须经过本轮遍历到的其他路径，而由于没有负权值，别的路径第一段就比最短的路径大了，再加上别的段就更不用说了，因此不存在从别的路径到这轮选中的节点距离更短，所以可以确定本轮选中的节点的最短路径。</p>
<p>确定后更新vis，然后再搞一层循环来更新与本轮选中的节点相邻的节点到src的最短距离，这一操作我们称为通过本轮选中的节点来对src到别的节点的距离进行“松弛”（优先队列的话要对优先队列进行更新操作），这一操作是为了在下一轮的循环中能正确找到距离src最短的节点。最后外层循环完毕，所有节点到src的最短距离也被确定下来了。</p>
</li>
</ul>
<h3 id="代码示例-7"><a href="#代码示例-7" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-28 19:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dijkstra</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">inf</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;<span class="comment">//正无穷</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入节点数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] g = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];<span class="comment">//邻接矩阵存图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化邻接矩阵</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) g[i][j]=<span class="number">0</span>;<span class="comment">//自己到自己的距离为0</span></span><br><span class="line">                <span class="keyword">else</span> g[i][j] = inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入边的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+(i+<span class="number">1</span> )+<span class="string">&quot;条边的起点、终点、权值：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="comment">//这里是无向图的写法，为了方便输入，需要有向图再改</span></span><br><span class="line">            g[begin][end] = value;</span><br><span class="line">            g[end][begin] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入想要看其到别的节点最短路径的节点：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">src</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];<span class="comment">//标识已经确定最小距离的节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) vis[i] = <span class="literal">false</span>;</span><br><span class="line">        vis[src] = <span class="literal">true</span>;<span class="comment">//源节点到自己的距离一直是0，所以是已经确定最小距离的节点</span></span><br><span class="line">        <span class="type">int</span>[] dis = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//源节点到对应节点的最小距离，比如dis[i]就是源节点到节点i的最小距离，动态更新，更新到最后就是答案。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化源节点到对应节点的最小距离为源节点到对应节点的距离，然后之后再动态更新。</span></span><br><span class="line">            dis[i] = g[src][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//还需要找到n-1个节点的最短路径，所以要循环n-1次</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> inf;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//每轮找到的节点下标，该节点应该是本轮中距离src最短的节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;<span class="comment">//找本轮中距离src最短的节点，由于其到src的距离是本轮最短，所以不存在另外一条路径使得被选中的节点和src的距离能更短，因为如果存在这样一条路径，那么一定会从本轮中的其他路径经过，而本轮中的其他路径在不考虑负权值的情况下一定比本轮中的最短路径要长，所以可以放心将本轮最短路径作为选中节点的最短路径。</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[j]&amp;&amp;min&gt;dis[j])&#123;<span class="comment">//只从还没有确定最短路径的节点中找最小值，记录下最小值和节点下标</span></span><br><span class="line">                    min = dis[j];</span><br><span class="line">                    pos = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[pos] = <span class="literal">true</span>;<span class="comment">//标记这一轮选中的节点已经确定了最短路径</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;<span class="comment">//以这一轮选中的节点作为桥梁来更新与其相邻的节点到src的最短距离</span></span><br><span class="line">                <span class="keyword">if</span>(g[pos][j]&lt;inf&amp;&amp;j!=src)&#123;<span class="comment">//找与这一轮选中的节点相邻的节点，不能是src</span></span><br><span class="line">                    <span class="keyword">if</span>(dis[j]&gt;dis[pos]+g[pos][j])&#123;<span class="comment">//如果以这一轮选中的节点为桥梁能使与其相邻的节点到src的距离更短，那就更新，相当于src和那个节点间接建立起了联系，下一轮就可以通过找最小值来固定和src直接或间接有联系的点的最短距离了。</span></span><br><span class="line">                        dis[j] = dis[pos]+g[pos][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;节点&quot;</span>+src+<span class="string">&quot;到各点的最短路径分别为：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            System.out.print(dis[i]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最小生成树算法"><a href="#最小生成树算法" class="headerlink" title="最小生成树算法"></a>最小生成树算法</h1><h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul>
<li>找出一个最短路径使得图中各节点连通，对于有n个节点的图来说，最小生成树需要用n-1条边来构建，该算法在稠密图中的效率较高。</li>
<li>适用于有负权边的情况。</li>
</ul>
<h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li>每次循环选择距离已经被选中的节点组成的集合最短的节点加入集合中，然后将与其连接的路径加入最小生成树中，更新与本轮被选中的节点相邻的节点到已经被选中的节点的集合的距离，以确保下一次循环可以找到正确的需要加入集合的节点，当所有节点都被加入到集合后，最小生成树就建立了。</li>
<li>实际上就是贪心的思想，每次找到集合最短的节点加入集合。</li>
</ul>
<h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><ul>
<li><p>基本上和Dijkstra算法差不多，虽然数据结构和Dijkstra的一样，但是Prim的数据结构的含义和Dijkstra中的数据结构的含义有点出入。</p>
</li>
<li><p>假设节点数量为n，那么首先我们需要一个<strong>n x n的矩阵g来存放图，或者用邻接表、链式前向星存</strong>，然后我们需要一个<strong>长度为n的boolean数组vis来表示已经被最小生成树选中的节点</strong>，然后<strong>需要一个长度为n的整型数组dis来记录已经被选中的节点的集合到其他未被选中的点的最短距离</strong>，如果要<strong>对时间复杂度进行优化的话，我们还需要维护一个优先队列（可以用堆实现）q来表示节点到已经被选中的节点的集合的距离</strong>，还需要一个<strong>变量sum来记录最小生成树的值</strong>。</p>
</li>
<li><p>初始化g，除了自己到自己的距离为0，其他初始化为inf，然后根据输入的边进行调整；</p>
<p>初始化vis，一开始被选中的节点集合中的节点只有源点src，所以让src为true，其余为false；</p>
<p>初始化dis，就是被选中的节点的集合到各点的距离，一开始就是src到各点的距离，从g中拿就行。</p>
</li>
<li><p>然后外层循环n-1次，因为有n-1条边需要被选择，外层循环每循环一次就选择一条边放到最小生成树中，同时也是选中一个节点放入已经被选中的节点的集合中。</p>
<p>内层先用一个循环来找到当前与被选中的节点的集合相连的节点到集合的最短路径（如果使用优先队列进行优化的话就直接取优先队列的头元素即可，不用循环了就），找到之后需要将该点加入集合中，并将该边加入最小生成树中，更新vis和sum，然后再搞一层循环来更新未被选中的节点与新集合的距离，实际上出现变动的只有与这一轮选中的节点相邻的节点，所以更新这一轮选中的节点的相邻节点到新集合的距离就好了，这一步是为了确保下一轮循环中可以正确的选中到集合的最短路径对应的节点。最后外层循环完毕，最小生成树也被确定下来了。</p>
</li>
</ul>
<h3 id="代码示例-8"><a href="#代码示例-8" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-10-29 14:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prim</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">inf</span> <span class="operator">=</span> <span class="number">0x3f3f3f3f</span>;<span class="comment">//正无穷</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入节点数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[][] g = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];<span class="comment">//邻接矩阵存图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化邻接矩阵</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) g[i][j]=<span class="number">0</span>;<span class="comment">//自己到自己的距离为0</span></span><br><span class="line">                <span class="keyword">else</span> g[i][j] = inf;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入边的数量：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+(i+<span class="number">1</span> )+<span class="string">&quot;条边的起点、终点、权值：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="comment">//这里是无向图的写法，为了方便输入，需要有向图再改</span></span><br><span class="line">            g[begin][end] = value;</span><br><span class="line">            g[end][begin] = value;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入起始节点：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">src</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];<span class="comment">//标识已经确定最小距离的节点，同时也是算法工程中被最小生成树选中的节点集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) vis[i] = <span class="literal">false</span>;</span><br><span class="line">        vis[src] = <span class="literal">true</span>;<span class="comment">//源节点到自己的距离一直是0，所以是已经确定最小距离的节点</span></span><br><span class="line">        <span class="type">int</span>[] dis = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//被最小生成树选中的节点集合到与其相邻节点的距离，比如dis[i]就是被最小生成树选中的节点集合到节点i的距离，动态更新。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化源节点（此时最小生成树选中的节点只有源节点）到所有节点的距离为源节点到对应节点的距离，然后之后再动态更新。</span></span><br><span class="line">            dis[i] = g[src][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最小生成树的大小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;<span class="comment">//构建最小生成树一共需要n-1条边，所以要循环n-1遍，每一轮循环选中一条边</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> inf;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//到已经选中的节点集合距离最短的那个节点下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;<span class="comment">//找距离已经选中的节点集合距离最短的节点</span></span><br><span class="line">                <span class="keyword">if</span>(!vis[j]&amp;&amp;min&gt;dis[j])&#123;<span class="comment">//从已经选中的节点集合之外找和已经选中的节点的集合相邻的节点中距离最短的那个节点</span></span><br><span class="line">                    min = dis[j];<span class="comment">//记录最小值</span></span><br><span class="line">                    pos = j;<span class="comment">//记录下标</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[pos] = <span class="literal">true</span>;<span class="comment">//将这轮被选中的节点加入到最小生成树选中节点的集合中</span></span><br><span class="line">            sum+=dis[pos];<span class="comment">//将本轮选中的边加入到最小生成树中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;<span class="comment">//由于本轮选中的节点加入了最小生成树，所以与本轮选中节点相邻的节点与最小生成树选中的节点集合也是相邻的，所以动态更新被最小生成树选中的节点集合到其他节点的距离</span></span><br><span class="line">                <span class="keyword">if</span>(g[pos][j]&lt;dis[j]&amp;&amp;!vis[j])&#123;<span class="comment">//更新与这一轮选中的节点相邻的没被最小生成树选中的节点到被最小生成树选中的节点集合的距离，方便下一轮筛选最小值加入最小生成树</span></span><br><span class="line">                    dis[j] = g[pos][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最小生成树的大小为：&quot;</span>);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><ul>
<li>找出一个最短路径使得图中各节点连通，对于有n个节点的图来说，最小生成树需要用n-1条边来构建，该算法在稀疏图中的效率较高。</li>
<li>适用于有负权边的情况。</li>
</ul>
<h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li><strong>以贪心思想和并查集数据结构为基础</strong>，首先将<strong>所有边按照升序排序</strong>，然后遍历所有边，<strong>每当遍历到一个边就判断这条边是否能作为连接两个端点的最短边</strong>（由于边是升序排列，所以两个端点第一次遇到的可以连接它俩的边就一定是最优的，后面能连接它俩的边都不能选了因为不是最优的。）。<strong>如果能，那就将端点合并到已经被最小生成树选中的节点中，并将该边加入到最小生成树中，并且让选中的边数++；如果不能，就继续遍历，直到选中n-1条边后，最小生成树就形成了，退出循环即可</strong>。</li>
</ul>
<h3 id="算法流程-2"><a href="#算法流程-2" class="headerlink" title="算法流程"></a>算法流程</h3><ul>
<li>上面描述的差不多了。。。。。。</li>
</ul>
<h3 id="代码示例-9"><a href="#代码示例-9" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-03 16:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kruskal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入点数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//并查集数组,f[i]=j说明i的父亲节点是j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化每个节点都是独立的，即他们的father都是自己</span></span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入边数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">e</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        Edge[] edges = <span class="keyword">new</span> <span class="title class_">Edge</span>[e];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;条边的两个节点和权值：&quot;</span>);</span><br><span class="line">            <span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Edge</span>();</span><br><span class="line">            edge.from = scanner.nextInt();</span><br><span class="line">            edge.to = scanner.nextInt();</span><br><span class="line">            edge.value = scanner.nextInt();</span><br><span class="line">            edges[i] = edge;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(edges,(e1,e2) -&gt; e1.value&lt;=e2.value?-<span class="number">1</span>:<span class="number">1</span>);<span class="comment">//按照边从小到大排序，返回负数不换位置，即顺序正确</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最小生成树的大小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;e&amp;&amp;n&gt;<span class="number">1</span>;++i)&#123;<span class="comment">//n可以维护已经选了多少边，当n减到1的时候说明已经选了n-1条边了，最小生成树已经生成，可以走了</span></span><br><span class="line">            <span class="keyword">if</span>(merge(f,edges[i].from,edges[i].to))&#123;<span class="comment">//如果能合并说明可以选这条边作为最小代价连接这条边对应的两个节点</span></span><br><span class="line">                n--;</span><br><span class="line">                sum+=edges[i].value;</span><br><span class="line">                System.out.println(<span class="string">&quot;选择两个点和权值分别为&quot;</span>+edges[i].from+<span class="string">&quot; &quot;</span>+edges[i].to+<span class="string">&quot; &quot;</span>+edges[i].value+<span class="string">&quot;的边&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最小生成树的大小为：&quot;</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Edge</span>&#123;<span class="comment">//边</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> from;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> to;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] f,<span class="type">int</span> v)</span>&#123;<span class="comment">//找一个元素的根节点</span></span><br><span class="line">        <span class="keyword">return</span> f[v]==v?v:(f[v] = find(f,f[v]));<span class="comment">//如果该点独立，直接返回;如果该点不独立,往后找根节点，顺便进行路径压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] f,<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;<span class="comment">//合并操作，其中可以做优化：直接把两者的根节点合并</span></span><br><span class="line">        <span class="keyword">return</span> (u = find(f,u))==(v = find(f,v))?<span class="literal">false</span>:(f[v]=u)==u;<span class="comment">//先找到各自的根，然后比较，如果相同说明已经合并无需再合并，返回false；如果不相同就合并，返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Huffman编码算法"><a href="#Huffman编码算法" class="headerlink" title="Huffman编码算法"></a>Huffman编码算法</h1><h2 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h2><ul>
<li><p><strong>哈夫曼（Huffman）编码算法</strong>是基于二叉树构建编码压缩结构的，它是数据压缩中经典的一种算法。算法根据文本字符出现的频率，重新对字符进行编码。因为为了缩短编码的长度，我们自然<strong>希望频率越高的词，编码越短，这样最终才能最大化压缩存储文本数据的空间</strong>。</p>
</li>
<li><p>假设现在我们要对下面这句歌词“we will we will r u”进行压缩。我们可以想象，如果是使用ASCII码对这句话编码结果则为：119 101 32 119 105 108 108 32 119 101 32 119 105 108 108 32 114 32 117（十进制表示）。我们可以看出需要19个字节，也就是至少需要152位的内存空间去存储这些数据。</p>
</li>
<li><p>很显然直接ASCII码编码是很浪费空间的，Unicode就更不用说了，下面我们先来统计一下这句话中每个字符出现的频率。如下表，按频率高低已排序：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104174352182.png" alt="image-20221104174352182"></p>
</li>
</ul>
<h2 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h2><ul>
<li>让<strong>被编码的字符全部出现在编码树的叶节点上，这样可以做到没有一个字符的编码是另外一个字符编码的前缀，这样可以防止解码的时候出现歧义</strong>。</li>
<li><strong>出现频率越低的字符，在树上的深度就越深，最后对于这个字符的编码就越长，最后总的编码就越短，这其中也有贪心的思想</strong>。</li>
<li>建好哈夫曼树后，<strong>让连接左孩子的边的编码设置为0，让连接右孩子的边的编码设置为1，从根节点开始经过若干边后找到一个字符，那个字符的编码就是经过的所有边的编码的集合</strong>。</li>
</ul>
<h2 id="算法流程-3"><a href="#算法流程-3" class="headerlink" title="算法流程"></a>算法流程</h2><h3 id="初始化优先队列"><a href="#初始化优先队列" class="headerlink" title="初始化优先队列"></a>初始化优先队列</h3><ul>
<li><p>那么我们<strong>按字符出现频率的高低将其放入一个优先队列中，从左到右依次为频率逐渐增加</strong>：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104175410606.png" alt="image-20221104175410606"></p>
</li>
<li><p>下面我们需要将这个队列转换成哈夫曼二叉树，<strong>哈夫曼二叉树是一颗带权重的二叉树，权重是由队列中每个字符出现的次数所决定的</strong>。并且<strong>哈夫曼二叉树始终保证权重越大的字符出现在越高的地方</strong>。</p>
</li>
</ul>
<h3 id="第一步合并"><a href="#第一步合并" class="headerlink" title="第一步合并"></a>第一步合并</h3><ul>
<li><p>首先我们从左到右进行合并，依次构建二叉树。<strong>第一步取前两个字符u和r来构造初始二叉树，第一个字符作为左节点，第二个元素作为右节点，然后两个元素相加作为新空元素，并且两者权重相加作为新元素的权重</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180042562.png" alt="image-20221104180042562"></p>
</li>
<li><p>同理，<strong>由于合并之后优先队列仍有序，所以新元素可以和字符i再合并</strong>，如下：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180101221.png" alt="image-20221104180101221"></p>
</li>
</ul>
<h3 id="重新调整队列"><a href="#重新调整队列" class="headerlink" title="重新调整队列"></a>重新调整队列</h3><ul>
<li><p>上图<strong>新元素权重相加后结果是变大了，需要对权重进行重新排序，也就是调整优先队列</strong>：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180152267.png" alt="image-20221104180152267"></p>
</li>
<li><p>然后再<strong>依次从左到右合并，每合并一次则进行一次队列重新排序调整</strong>。如下：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180234707.png" alt="image-20221104180234707"></p>
</li>
<li><p><strong>经过多步操作之后，优先队列中只剩一个元素，让队列中唯一的元素出队得到以下的哈夫曼二叉树结构，也就是一个带有权重的二叉树</strong>：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180311593.png" alt="image-20221104180311593"></p>
</li>
</ul>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><ul>
<li><p>有了上面带权重的二叉树之后，我们就可以进行编码了。我们<strong>把二叉树分支中左边的支路编码为0，右边分支表示为1</strong>，如下图：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180540694.png" alt="image-20221104180540694"></p>
</li>
<li><p>这样<strong>依次遍历这颗二叉树就可以获取得到所有字符的编码了</strong>。例如：‘ ’的编码为10，‘l’的编码为00，‘u’的编码为11100等等。<strong>经过这个编码设置之后我们可以发现，出现频率越高的字符越会在上层，这样它的编码越短；出现频率越低的字符越会在下层，编码越短。经过这样的设计，最终整个文本存储空间才会最大化的缩减。</strong></p>
</li>
<li><p>最终我们可以得到下面这张编码表：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221104180640922.png" alt="image-20221104180640922"></p>
</li>
</ul>
<h3 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h3><ul>
<li>有了上面的编码表之后，”we will we will r u”这句重新进行编码就可以得到很大的压缩，编码表示为：01 110 10 01 1111 00 00 10 01 110 10 01 1111 00 00 10 11101 10 11100。这样最终我们只需50位内存，比原ASCII码表示节约了2&#x2F;3空间，效果还是很理想的。当然<strong>现实中不是简单这样表示的，还需要考虑很多问题</strong>。</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ul>
<li>我们需要弄明白哈夫曼二叉树概念，<strong>它是带权路径达到最小的二叉树，也叫最优二叉树</strong>。它<strong>不一定是完全二叉树，也不一定是平衡二叉树，它们描述的完全不是一件事情，完全没有概念上的重叠关系</strong>。</li>
</ul>
<h2 id="代码示例-10"><a href="#代码示例-10" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-03 18:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Huffman</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node left;</span><br><span class="line">        <span class="keyword">public</span> Node right;</span><br><span class="line">        <span class="keyword">public</span> Node father;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">char</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//用队列+排序模拟优先队列</span></span><br><span class="line">        ArrayList&lt;Character&gt; charList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//存放所有字符</span></span><br><span class="line">        Node tree;<span class="comment">//Huffman树</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入字符种数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入第&quot;</span>+i+<span class="string">&quot;种字符以及其出现的频数：&quot;</span>);</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            node.c = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            charList.add(node.c);</span><br><span class="line">            node.value = scanner.nextInt();</span><br><span class="line">            queue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(queue,(n1,n2)-&gt;n1.value&lt;=n2.value?-<span class="number">1</span>:<span class="number">1</span>);<span class="comment">//按照频数排序，返回-1说明顺序正好不用调整</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;queue.size();++i) System.out.print(queue.get(i).c);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">while</span> (queue.size()&gt;<span class="number">1</span>)&#123;<span class="comment">//构建哈夫曼树，频率越低的元素越再下层，对应的编码越长，最后生成的总编码就越短，每次构建都会使队列长度减一，当队列长度为1时，唯一的那个元素就是哈夫曼树</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp1</span> <span class="operator">=</span> queue.poll();<span class="comment">//取出队首第一个元素</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp2</span> <span class="operator">=</span> queue.poll();<span class="comment">//取出队首第二个元素</span></span><br><span class="line">            <span class="comment">//System.out.println(temp1.c+&quot; &quot;+temp2.c);</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();<span class="comment">//准备进行元素合并</span></span><br><span class="line">            temp.value = temp1.value+temp2.value;<span class="comment">//合并权值到新的父节点</span></span><br><span class="line">            <span class="comment">//建立三个节点之间的关系</span></span><br><span class="line">            temp.left = temp1;</span><br><span class="line">            temp.right = temp2;</span><br><span class="line">            temp1.father = temp;</span><br><span class="line">            temp2.father = temp;</span><br><span class="line">            queue.push(temp);<span class="comment">//把合并后的节点加入到优先队列前面</span></span><br><span class="line">            Collections.sort(queue,(n1,n2)-&gt;n1.value&lt;=n2.value?-<span class="number">1</span>:<span class="number">1</span>);<span class="comment">//重新排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        tree = queue.poll();<span class="comment">//取出哈夫曼树</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;charList.size();++i)&#123;<span class="comment">//找每个输入的字符对应的哈夫曼编码</span></span><br><span class="line">            ArrayList&lt;Character&gt; code = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            System.out.print(charList.get(i)+<span class="string">&quot;的哈夫曼编码为：&quot;</span>);</span><br><span class="line">            enCode(tree,charList.get(i),code);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">enCode</span><span class="params">(Node tree,<span class="type">char</span> c,ArrayList&lt;Character&gt; now)</span>&#123;<span class="comment">//递归找字符对应的编码，第一个参数是哈夫曼树，第二个参数是字符，第三个参数是当前的编码</span></span><br><span class="line">        <span class="keyword">if</span>(tree==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(tree.value);</span></span><br><span class="line">        <span class="keyword">if</span>(tree.c==c)&#123;<span class="comment">//找到目标了就输出</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> a:now)&#123;</span><br><span class="line">                System.out.print(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯算法遍历左右子树，左0右1</span></span><br><span class="line">        now.add(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        enCode(tree.left,c,now);</span><br><span class="line">        now.remove(now.size()-<span class="number">1</span>);</span><br><span class="line">        now.add(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        enCode(tree.right,c,now);</span><br><span class="line">        now.remove(now.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用霍夫曼编码压缩文件"><a href="#利用霍夫曼编码压缩文件" class="headerlink" title="利用霍夫曼编码压缩文件"></a>利用霍夫曼编码压缩文件</h2><ul>
<li>如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件。</li>
<li><strong>赫夫曼编码是按字节来处理的</strong>，因此**可以处理所有的文件(二进制文件、文本文件等)**。</li>
<li>如果一个文件中的内容，<strong>重复的数据不多，压缩效果也不会很明显</strong>。</li>
</ul>
<h2 id="利用霍夫曼编码解压文件"><a href="#利用霍夫曼编码解压文件" class="headerlink" title="利用霍夫曼编码解压文件"></a>利用霍夫曼编码解压文件</h2><h1 id="表达式算法"><a href="#表达式算法" class="headerlink" title="表达式算法"></a>表达式算法</h1><ul>
<li>这个板块儿<strong>主要是讲前缀、中缀、后缀表达式之间的转换和计算的</strong>。</li>
</ul>
<h2 id="中缀表达式算法"><a href="#中缀表达式算法" class="headerlink" title="中缀表达式算法"></a>中缀表达式算法</h2><h3 id="基本介绍-4"><a href="#基本介绍-4" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li>中缀表达式就是我们平时看到的算式，例如：a+b*c，我们想要实现的就是让计算机计算中缀表达式得到正确的结果。</li>
<li>除了中缀表达式外，还有<strong>运算符在操作数之前的前缀表达式（波兰表达式）和运算符在操作数之后的后缀表达式（逆波兰表达式）</strong>，这两种表达式会在它们的章节细讲。</li>
</ul>
<h3 id="使用栈完成中缀表达式计算的思路"><a href="#使用栈完成中缀表达式计算的思路" class="headerlink" title="使用栈完成中缀表达式计算的思路"></a>使用栈完成中缀表达式计算的思路</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106205752521.png" alt="image-20221106205752521"></p>
<ul>
<li>有一个小难点就是优先级的问题，<strong>当一个优先级小的符号想要入栈的时候要把之前的运算做了之后再入栈</strong>。</li>
</ul>
<h3 id="代码示例-11"><a href="#代码示例-11" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## 逆波兰表达式算法</span><br><span class="line"></span><br><span class="line">### 基本介绍</span><br><span class="line"></span><br><span class="line">- **逆波兰表达式就是后缀表达式**，就是操作符在操作数的后面，至于怎么从中缀表达式转换为后缀表达式下面给出了详细的转换方式。</span><br><span class="line">- 虽然对于人来说计算逆波兰表达式比较困难，但是**对于计算机来说计算逆波兰表达式是非常容易的**，计算机对逆波兰表达式进行计算用到了栈这一数据结构。</span><br><span class="line"></span><br><span class="line">### 算法思想</span><br><span class="line"></span><br><span class="line">- 遍历逆波兰表达式，如果**碰到数字就压入栈中，如果碰到操作符，就从栈顶出栈两个元素，对那两个元素进行对应的运算之后，将运算的结果再压入栈中**。</span><br><span class="line"></span><br><span class="line">### 代码示例</span><br><span class="line"></span><br><span class="line">```java</span><br></pre></td></tr></table></figure>



<h2 id="中缀表达式转换为后缀表达式"><a href="#中缀表达式转换为后缀表达式" class="headerlink" title="中缀表达式转换为后缀表达式"></a>中缀表达式转换为后缀表达式</h2><h3 id="基本介绍-5"><a href="#基本介绍-5" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li>从上面可以看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此<strong>在开发中，我们需要将中缀表达式转成后缀表达式</strong>。</li>
<li>中缀表达式转换为后缀表达式的步骤比较繁琐，也<strong>需要借助栈来实现，不过需要两个栈，其中一个存操作数，另外一个存操作符</strong>。</li>
</ul>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>初始化两个栈：运算符栈 s1 和储存中间结果的栈 s2；</li>
<li>从左至右扫描中缀表达式；</li>
<li>遇到操作数时，将其压 s2；</li>
<li>遇到运算符时，比较其与 s1 栈顶运算符的优先级：<ol>
<li>如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；</li>
<li>否则，若优先级比栈顶运算符的高，也将运算符压入 s1；</li>
<li>否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4.1)与 s1 中新的栈顶运算符相比较；</li>
</ol>
</li>
<li>遇到括号时：<ol>
<li>如果是左括号“(”，则直接压入 s1</li>
<li>如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃</li>
</ol>
</li>
<li>重复步骤 2 至 5，直到表达式的最右边</li>
<li>将 s1 中剩余的运算符依次弹出并压入 s2</li>
<li>依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</li>
</ol>
<ul>
<li>总结：其实就是<strong>根据运算的优先级来将每一部分的操作符放到俩操作数的后面</strong>，比如A*(B+C)+D，优先级最高的是小括号，所以先转换成A*(BC+)+D，然后乘法优先级比较高，把乘号放到俩操作数的后面，即(ABC+*)+D，最后只剩下加法运算了，把加号放到俩操作数后面，即ABC+*D+，这样就得到后缀表达式了，从过程中可以看到，<strong>每次都是选优先级最高的一部分，将其操作符放到它对应的俩操作数的后面</strong>。</li>
</ul>
<h3 id="转换举例"><a href="#转换举例" class="headerlink" title="转换举例"></a>转换举例</h3><ul>
<li><p>将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221106232317323.png" alt="image-20221106232317323"></p>
</li>
<li><p>因此结果为 :”1 2 3 + 4 × + 5 -“</p>
</li>
</ul>
<h3 id="代码示例-12"><a href="#代码示例-12" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><h2 id="KMP算法介绍"><a href="#KMP算法介绍" class="headerlink" title="KMP算法介绍"></a>KMP算法介绍</h2><ul>
<li>KMP 是一个<strong>解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法</strong>。</li>
<li>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法.</li>
<li>KMP 方法算法就<strong>利用之前判断过信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间</strong>。</li>
<li>参考资料：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html">https://www.cnblogs.com/ZuoAndFutureGirl/p/9028287.html</a></li>
</ul>
<h2 id="KMP算法思路分析"><a href="#KMP算法思路分析" class="headerlink" title="KMP算法思路分析"></a>KMP算法思路分析</h2><ul>
<li><p>举例来说，有一个字符串 Str1 &#x3D; “BBC ABCDAB ABCDABCDABDE”，判断，里面是否包含另一个字符串 Str2 &#x3D;“ABCDABD”？</p>
<ol>
<li><p>首先，用 Str1 的第一个字符和 Str2 的第一个字符去比较，不符合，关键词向后移动一位：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094748049.png" alt="image-20221114094748049"></p>
</li>
<li><p>重复第一步，还是不符合，再后移：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094819926.png" alt="image-20221114094819926"></p>
</li>
<li><p>一直重复，直到 Str1 有一个字符与 Str2 的第一个字符符合为止：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094849647.png" alt="image-20221114094849647"></p>
</li>
<li><p>接着比较字符串和搜索词的下一个字符，还是符合：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094908612.png" alt="image-20221114094908612"></p>
</li>
<li><p>遇到 Str1 有一个字符与 Str2 对应的字符不符合：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114094927607.png" alt="image-20221114094927607"></p>
</li>
<li><p>这时候，想到的是继续遍历 Str1 的下一个字符，重复第 1 步，如下图所示。(其实是很不明智的，因为此时 BCD 已经比较过了，没有必要再做重复的工作，一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP 算法的想法是，<strong>设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率</strong>。)</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095220382.png" alt="image-20221114095220382"></p>
</li>
<li><p>怎么做到把刚刚重复的步骤省略掉？可以对 Str2 计算出一张《部分匹配表》，这张表的产生在后面介绍：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095249922.png" alt="image-20221114095249922"></p>
</li>
<li><p>已知空格与 D 不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符 B 对应的”部分匹配值”为 2，因此按照下面的公式算出向后移动的位数：<strong>移动位数 &#x3D; 已匹配的字符数 - 对应的部分匹配值</strong>，因为 6 - 2 等于 4，所以将搜索词向后移动 4 位：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095501622.png" alt="image-20221114095501622"></p>
</li>
<li><p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为 2（”AB”），对应的”部分匹配值”为 0。所以，移动位数 &#x3D; 2 - 0，结果为 2，于是将搜索词向后移 2 位：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095519913.png" alt="image-20221114095519913"></p>
</li>
<li><p>因为空格与 A 不匹配，str1的指针继续后移一位：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114100150053.png" alt="image-20221114100150053"></p>
</li>
<li><p>逐位比较，直到发现 C 与 D 不匹配。于是，移动位数 &#x3D; 6 - 2，继续将搜索词向后移动 4 位：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095539523.png" alt="image-20221114095539523"></p>
</li>
<li><p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 &#x3D; 7 - 0，再将搜索词向后移动 7 位，这里就不再重复了：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114095654873.png" alt="image-20221114095654873"></p>
</li>
</ol>
</li>
</ul>
<h2 id="部分匹配表（next）是如何产生的？"><a href="#部分匹配表（next）是如何产生的？" class="headerlink" title="部分匹配表（next）是如何产生的？"></a>部分匹配表（next）是如何产生的？</h2><ul>
<li><p>先介绍介绍前缀和后缀是什么：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114100319241.png" alt="image-20221114100319241"></p>
</li>
<li><p>实际上<strong>部分匹配值就是从数组头到当前位置这个左闭右开区间（我喜欢这样表示）所表示的字符串的最长公共前后缀，当比较到当前位置产生失配之后，当前位置的指针可以根据当前位置的部分匹配值来进行相应的移动，从而节省开销</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230213100055868.png" alt="image-20230213100055868"></p>
</li>
<li><p>知道怎么得到next值了，那么落实到代码上应该怎么写呢？首先我们考虑前两个元素，明显它们的值都为0（前后缀不能完全重合），但是为了判断后面的一种情况，我们将第一个元素的值规定为-1，然后我们考虑后面的元素，每当遍历到一个元素，我们都看它前面的那个元素，因为它的next值和它本身无关，<strong>如果当前元素前面那个元素和它的next值指向的那个元素相同的话，那么当前元素的next值应该是当前元素前面那个元素的next值加一（为什么？因为当前元素前一个元素的next值的指向还有另一个含义，那就是最长公共前后缀的那个前缀的后面一个元素，如果当前元素的前一个元素和那个元素匹配的话，说明公共前后缀的长度可以扩大1）</strong>；<strong>如果当前元素前面那个元素和它的next值指向的那个元素不相同的话，那么就继续利用next数组进行迭代，每次迭代都是到达当前元素的next指向的位置，直到到达一个地方使得当前元素前一个元素和迭代到的元素相同，那么当前元素的next值就是迭代到的那个元素的next值+1（为什么？还是那个道理，这样做还是为了找到一个和当前元素相同的且正好可以和原最长公共前后缀组成更长的公共前后缀的元素）</strong></p>
</li>
<li><p>其实只要理解了next值的三个含义之后，别的也就顺理成章了：</p>
<ol>
<li>next值的第一个含义不用多说，就是<strong>从开头到当前元素的前一个元素这个模式串子串的最长公共前后缀的长度</strong>。</li>
<li>next值的第二个含义是作为下标的含义，<strong>next值对应的下标是从开头到当前元素的前一个元素这个模式串子串的最长公共前后缀的那个前缀的后一个元素</strong>，如果当前元素和next指向的那个元素相等的话，说明之前求出的前缀和那个元素能结合成一个更长的前缀，也说明之前求出的后缀和当前元素的前一个元素能结合成一个更长的后缀，并且这个更长的后缀和那个更长的前缀相同，那么就说明可以形成更长的公共前后缀，这就是为什么要找和当前元素前一个元素相同的元素，并且每次找到之后都要将其的next值加一之后赋值给当前元素的next值了。</li>
<li>next值的第三个含义也是作为下标的含义，<strong>next值对应的下标是当前元素产生失配之后指针应该回溯到的位置</strong>，这个位置从上面那一条能知道，这个位置是是从开头到当前元素的前一个元素这个模式串子串的最长公共前后缀的那个前缀的后一个元素，将指针回溯到这里是因为如果失配元素前面的子串能和目标串的某个子串匹配，那么模式串这个子串的前缀和目标串的那个子串的后缀可能是有重合的部分的，而<strong>失配元素的next值正好揭示了这个重合部分的大小，所以回溯到那个地方是利用公共前后缀防止重复比较元素</strong>。</li>
</ol>
</li>
<li><p>其实细节还是很多的，<strong>细节1在于next数组的第一个元素应为-1（这个值是为了方便后面对一个特殊情况进行判断），第二个元素的值应为0（如果存在的话）</strong>，这个套定义的话也好理解，主要就是那个-1是为了在后面出现因当前元素前面一个元素和next值指向的元素不同而进行next值迭代的时候判断没有任何元素和当前元素的前一个元素相等的情况；<strong>细节2在于next数组应该比模式串的长度长1个单位</strong>，因为每个元素代表的是从开头到它前一个元素的最长公共前后缀的长度，所以最后一个元素代表的是整个模式串的最长公共前后缀的长度，如果没有最后一位，数据就会缺失；<strong>细节3在于模式串当前元素失配的时候，应该将模式串的指针回溯到失配元素的next值处，此时如果next值是-1，应该进行特殊处理</strong>，因为如果失配元素前面的子串能和目标串的某个子串匹配，那么模式串这个子串的前缀和目标串的那个子串的后缀可能是有重合的部分的，而失配元素的next值正好揭示了这个重合部分的大小，所以要这样进行回溯，是利用了公共前后缀防止重复比较元素，特判-1是因为之前将next数组的第一个元素初始化成了-1以方便处理一种特殊情况，所以这个元素不能用来回溯指针，所以特判一下。</p>
</li>
<li><p>还有个细节没想明白，那就是为什么进行next迭代的时候要跳着迭代而不是顺序迭代？不怕跳过的内容中存在答案吗？</p>
</li>
</ul>
<h2 id="代码示例-13"><a href="#代码示例-13" class="headerlink" title="代码示例"></a>代码示例</h2><ul>
<li><p>力扣上有不少题对于理解KMP算法的原理有很好的作用，这里列出几道，首先就是LeetCode 718. 最长重复子数组，<strong>把下面代码的KMP部分中的i换成0就是普通的KMP了</strong>，这题不过是KMP了多次罢了，不过这个解法不是这个题的最优解：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230212225330655.png" alt="image-20230212225330655"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1==<span class="literal">null</span>||nums2==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums1.length&lt;nums2.length)&#123;<span class="comment">//始终让nums1的长度更长</span></span><br><span class="line">            <span class="type">int</span>[] temp = nums1;</span><br><span class="line">            nums1 = nums2;</span><br><span class="line">            nums2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最后的答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums2.length;++i)&#123;<span class="comment">//第一层循环遍历nums2的开头元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">idx1</span> <span class="operator">=</span> <span class="number">0</span>,idx2 = i;</span><br><span class="line">            <span class="comment">//下面就是拿完整的nums1和以第i个元素为开头的nums2做KMP，过程中尝试更新最后的答案</span></span><br><span class="line">            <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[nums2.length-idx2+<span class="number">1</span>];<span class="comment">//首先就是声明next数组，我习惯next数组的元素表示从开头的元素到当前元素前一个元素这一段的最长公共前后缀的长度，这样在当前元素失配的时候可以通过访问当前元素的next值来回溯指针，所以next数组的长度应该比模式串长1</span></span><br><span class="line">            <span class="comment">//第一个元素应该被初始化为-1（方便之后判断特定情况），第二个元素应该被初始化为0（如果存在的话）</span></span><br><span class="line">            next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//然后就是计算next数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;next.length;++j)&#123;<span class="comment">//由于前两个值是默认，所以直接从第三个值开始</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextPos</span> <span class="operator">=</span> next[j-<span class="number">1</span>];<span class="comment">//先记录下当前元素前一个元素的next值，然后迭代它</span></span><br><span class="line">                <span class="keyword">while</span>(nextPos!=-<span class="number">1</span>&amp;&amp;nums2[idx2+j-<span class="number">1</span>]!=nums2[idx2+nextPos])&#123;<span class="comment">//这个就是一直找和当前元素前面那个元素相等的元素位置，如果找到nextPos为-1，说明没有和当前元素前面那个元素相等的元素</span></span><br><span class="line">                    nextPos = next[nextPos];<span class="comment">//迭代的方式比较特殊，每次迭代都会走向当前nextPost的next值处的元素，因为这个next还表示最长公共前后缀中的前缀的后一个元素，这样找就是为了找到一个和当前元素相同的且正好可以和原最长公共前后缀组成更长的公共前后缀的元素</span></span><br><span class="line">                &#125;</span><br><span class="line">                next[j] = nextPos+<span class="number">1</span>;<span class="comment">//当前元素的next值就是找到的和它相等的那个元素的next值+1或者是没有找到和它相等的元素，此时是-1+1=0也符合条件。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (idx1&lt;nums1.length)&#123;<span class="comment">//KMP算法</span></span><br><span class="line">                <span class="keyword">if</span>(nums1[idx1]==nums2[idx2])&#123;<span class="comment">//如果指针指向的两个元素相同</span></span><br><span class="line">                    <span class="comment">//两个指针一直同时向前走直到两个指针指向的元素不同或者指针越界</span></span><br><span class="line">                    <span class="keyword">while</span> (idx1&lt;nums1.length&amp;&amp;idx2&lt;nums2.length&amp;&amp;nums1[idx1]==nums2[idx2])&#123;</span><br><span class="line">                        idx1++;</span><br><span class="line">                        idx2++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans = Math.max(ans,idx2-i);<span class="comment">//尝试更新答案</span></span><br><span class="line">                    <span class="keyword">if</span>(ans==nums2.length) <span class="keyword">return</span> ans;<span class="comment">//小优化，答案最大就是nums2的长度，所以得到之后可以直接返回</span></span><br><span class="line">                    <span class="keyword">if</span>(next[idx2-i]!=-<span class="number">1</span>) idx2=i+next[idx2-i];<span class="comment">//模式串指针回溯，回溯到当前值的next值处，因为前面的已经被匹配过了，无需重复匹配</span></span><br><span class="line">                    <span class="keyword">else</span> idx2 = i;<span class="comment">//这是个特殊情况，如果当前元素的next值为-1，说明第一位就失配，指针就不用动了</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(idx2!=i)&#123;<span class="comment">//如果指针指向的两个元素不相同并且模式串的指针不在最前面</span></span><br><span class="line">                    <span class="comment">//那么进行指针回溯</span></span><br><span class="line">                    <span class="keyword">if</span>(next[idx2-i]!=-<span class="number">1</span>) idx2=i+next[idx2-i];</span><br><span class="line">                    <span class="keyword">else</span> idx2 = i;<span class="comment">//这是个特殊情况，如果当前元素的next值为-1，说明第一位就失配，指针就不用动了</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果指针指向的两个元素不相同并且模式串的指针在最前面</span></span><br><span class="line">                    idx1++;<span class="comment">//那直接让目标串的指针往后走就行了</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>写个比较标准的，这个是求s2在s1中出现了多少次：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">// 1:无需package</span></span><br><span class="line"><span class="comment">// 2: 类名必须Main, 不可修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//在此输入您的代码...</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> scan.next();<span class="comment">//长的那个串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> scan.next();<span class="comment">//短的那个串</span></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[s2.length()+<span class="number">1</span>];<span class="comment">//next数组，记得长度要大1</span></span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;<span class="comment">//next数组第一个值为-1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;next.length;++i)&#123;<span class="comment">//计算next数组</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">before</span> <span class="operator">=</span> i-<span class="number">1</span>;<span class="comment">//before初始化为当前元素的前一个元素的坐标</span></span><br><span class="line">          <span class="keyword">while</span>(before!=<span class="number">0</span>&amp;&amp;s1.charAt(before)!=s2.charAt(next[before]))&#123;<span class="comment">//利用before的next值向前迭代，直到before对应的元素和before的next值对应的元素相等或者before到了最前面</span></span><br><span class="line">            before = next[before];<span class="comment">//向前迭代</span></span><br><span class="line">          &#125;</span><br><span class="line">          next[i] = next[before]+<span class="number">1</span>;<span class="comment">//当前元素的next值是最后停在的before位置的next值+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s1i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//s1的指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s2i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//s2的指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最后结果</span></span><br><span class="line">        <span class="keyword">while</span>(s1i&lt;s1.length())&#123;<span class="comment">//kmp算法，如果s1的指针走到头了就退出循环完成匹配</span></span><br><span class="line">          <span class="keyword">if</span>(s2i==s2.length())&#123;<span class="comment">//如果此时s2的指针走到头了说明匹配上了一次</span></span><br><span class="line">            ans++;<span class="comment">//结果+1</span></span><br><span class="line">            s2i = next[s2i];<span class="comment">//s2指针指向next值所在的位置，开始尝试下一次匹配，能很好的处理两个目标串嵌套在一起的情况</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(s1.charAt(s1i)==s2.charAt(s2i))&#123;<span class="comment">//如果当前两个元素相等，那就两个指针都往前走一步</span></span><br><span class="line">            s1i++;</span><br><span class="line">            s2i++;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果当前两个元素不相等</span></span><br><span class="line">            <span class="keyword">if</span>(s2i!=<span class="number">0</span>)&#123;<span class="comment">//如果s2当前位置不在最前面</span></span><br><span class="line">              s2i = next[s2i];<span class="comment">//把s2的指针调整到next值的位置，利用next值省掉了部分重复判断</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果s2当前位置在最前面</span></span><br><span class="line">              s1i++;<span class="comment">//s1的指针往后走，因为以s1当前元素开头无论如何也无法和s2匹配</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s2i==s2.length()) ans++;<span class="comment">//统计一下可能被遗漏的情况，即s1和s2的指针都走到了末尾</span></span><br><span class="line">        System.out.println(ans);</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="KMP算法优化之nextval数组"><a href="#KMP算法优化之nextval数组" class="headerlink" title="KMP算法优化之nextval数组"></a>KMP算法优化之nextval数组</h2><ul>
<li>实际上就是对next数组做了进一步的优化，优化之后的数组称为nextval。</li>
<li>具体思路就是如果模式串中当前失配元素的next值指向的元素和当前元素相同，那么即使跳到next值指向的位置，那么那次匹配也一定会失配，然后跳到那个失配元素的next值所在的元素，既然如此，干脆就将next值修改为这次失配后最后能跳到的位置，也就是和当前失配元素不相同的元素位置，这样就能节省很多次多余的比较。</li>
</ul>
<h1 id="弗洛伊德-Floyd-算法"><a href="#弗洛伊德-Floyd-算法" class="headerlink" title="弗洛伊德(Floyd)算法"></a>弗洛伊德(Floyd)算法</h1><h2 id="算法介绍-1"><a href="#算法介绍-1" class="headerlink" title="算法介绍"></a>算法介绍</h2><ul>
<li>和 Dijkstra 算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978 年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名</li>
<li>弗洛伊德算法(Floyd)<strong>计算图中各个顶点之间的最短路径</strong></li>
<li>迪杰斯特拉算法用于计算图中某一个顶点到其他顶点的最短路径。</li>
<li>弗洛伊德算法 VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每一个顶点到其他顶点的最短路径。</li>
<li>也就是说<strong>弗洛伊德算法是多源最短路算法</strong>。</li>
</ul>
<h2 id="算法思路分析"><a href="#算法思路分析" class="headerlink" title="算法思路分析"></a>算法思路分析</h2><ul>
<li>其实比较简单，就是<strong>搞三层循环，其中两层循环遍历任意两个节点，剩下的一层循环遍历除了那俩节点外的节点作为那两个节点之间的中转站尝试将那两个节点之间的距离进行”松弛“</strong>，三层循环过后得到的二维数据的结果就是所有节点到其他节点的最短路径。</li>
</ul>
<h2 id="代码示例-14"><a href="#代码示例-14" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="弗洛伊德-Floyd-判圈算法（龟兔赛跑算法）"><a href="#弗洛伊德-Floyd-判圈算法（龟兔赛跑算法）" class="headerlink" title="弗洛伊德(Floyd)判圈算法（龟兔赛跑算法）"></a>弗洛伊德(Floyd)判圈算法（龟兔赛跑算法）</h1><h2 id="算法介绍-2"><a href="#算法介绍-2" class="headerlink" title="算法介绍"></a>算法介绍</h2><ul>
<li>就是判断一个数据结构比如链表、图中有没有环，用的是快慢指针的方法，<strong>慢指针一次走一步，快指针一次走两步，由于数据结构中存在环，所以快慢指针一定会再次相遇，如果快慢指针相遇说明数据结构中存在环</strong>。</li>
<li>如果想要进一步找到环的入口怎么办，只需要<strong>将慢指针重新放到开头，然后快慢指针都一次走一步，下一次它们相遇的时候就是环的入口的位置</strong>。</li>
</ul>
<h2 id="算法证明"><a href="#算法证明" class="headerlink" title="算法证明"></a>算法证明</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230101103607210.png" alt="image-20230101103607210"></p>
<h2 id="代码示例-15"><a href="#代码示例-15" class="headerlink" title="代码示例"></a>代码示例</h2><ul>
<li><p>Leetcode142 环形链表Ⅱ：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230101111214834.png" alt="image-20230101111214834"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//特判两种情况</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head.next,fast = head.next.next;<span class="comment">//初始化快慢指针，慢指针步长为1，快指针步长为2</span></span><br><span class="line">        <span class="keyword">while</span> (slow!=fast&amp;&amp;slow!=<span class="literal">null</span>&amp;&amp;fast!=<span class="literal">null</span>)&#123;<span class="comment">//快慢指针移动，直至相遇（有环的时候）或走到null（无环的时候）</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="literal">null</span>) <span class="keyword">break</span>;<span class="comment">//这个要判断一下，因为连着两次next，第一次next完可能是个null</span></span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(slow==fast&amp;&amp;slow!=<span class="literal">null</span>)&#123;<span class="comment">//如果不在null处相遇，说明有环</span></span><br><span class="line">            slow = head;<span class="comment">//将慢指针放到头上</span></span><br><span class="line">            <span class="keyword">while</span> (slow!=fast)&#123;<span class="comment">//然后让快慢指针步长都为1继续开始走，直到相遇，相遇的地方就是环的入口</span></span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;<span class="comment">//返回环的入口</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//如果没有相遇，说明没有环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="快慢指针找到链表中点"><a href="#快慢指针找到链表中点" class="headerlink" title="快慢指针找到链表中点"></a>快慢指针找到链表中点</h1><h2 id="算法介绍-3"><a href="#算法介绍-3" class="headerlink" title="算法介绍"></a>算法介绍</h2><ul>
<li>就是通过快慢指针的特性来找到链表的中点，<strong>慢指针步长为1，快指针步长为2，这样在快指针走到尾的时候，慢指针正好处于链表中点的位置</strong>。</li>
<li>可以利用这个特性来实现链表归并排序中的找中点的操作。</li>
</ul>
<h2 id="代码示例-16"><a href="#代码示例-16" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head,fast = head;<span class="comment">//快慢指针</span></span><br><span class="line"><span class="keyword">while</span>(fast!=<span class="literal">null</span>&amp;&amp;fast.next!=<span class="literal">null</span>)&#123;<span class="comment">//经典快慢指针找链表中点的写法，最后如果fast==null说明链表中的元素数量为偶数，此时slow在中间偏右一个元素；最后如果fast!=null也就是fast.next==null说明链表中的元素数量为奇数，此时slow指向正中间的元素。</span></span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">    fast = fast.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="倒转链表"><a href="#倒转链表" class="headerlink" title="倒转链表"></a>倒转链表</h1><h2 id="头插法倒转链表"><a href="#头插法倒转链表" class="headerlink" title="头插法倒转链表"></a>头插法倒转链表</h2><h3 id="代码示例-17"><a href="#代码示例-17" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();<span class="comment">//新链表存逆置后的链表</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="keyword">while</span>(head!=<span class="literal">null</span>)&#123;<span class="comment">//头插法倒转链表</span></span><br><span class="line">    head = head.next;</span><br><span class="line">    p.next = temp.next;</span><br><span class="line">    temp.next = p;</span><br><span class="line">    p = head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="前后指针找链表的倒数第k个元素"><a href="#前后指针找链表的倒数第k个元素" class="headerlink" title="前后指针找链表的倒数第k个元素"></a>前后指针找链表的倒数第k个元素</h1><h2 id="算法介绍-4"><a href="#算法介绍-4" class="headerlink" title="算法介绍"></a>算法介绍</h2><ul>
<li>目的是要找一个链表的倒数第k个元素，然后如果平常做的话，要先遍历一遍链表得到链表长度之后再找倒数第k个元素，但是我们完全可以用前后指针来把遍历链表得到链表长度这一步优化掉。</li>
<li>怎么做呢？我们可以<strong>让一个指针先出发，走k步之后第二个指针再出发，这样两个指针之间就差着k的距离了，当先出发的指针到达链表尾部null的时候，第二个指针指向的元素就是倒数第k个元素</strong>。</li>
</ul>
<h2 id="代码示例-18"><a href="#代码示例-18" class="headerlink" title="代码示例"></a>代码示例</h2><h1 id="Boyer-Moore投票算法"><a href="#Boyer-Moore投票算法" class="headerlink" title="Boyer-Moore投票算法"></a>Boyer-Moore投票算法</h1><h2 id="算法介绍-5"><a href="#算法介绍-5" class="headerlink" title="算法介绍"></a>算法介绍</h2><ul>
<li><p>这算法也叫摩尔投票算法，是从一个无序的投票集合中找出最多的那个票。</p>
</li>
<li><p>具体见下题：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221211114712980.png" alt="image-20221211114712980"></p>
</li>
</ul>
<h2 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h2><ul>
<li>其实就是一个<strong>同类相容，异类相杀</strong>的场景，可以想象这样一个场景，有一个山顶有很多军队想要占领，如果第一个人到达了山顶，由于此时山顶没有军队占领，所以那个人就把自己所在的军队的旗帜插到山顶了以表示现在这个山顶归那个军队所有，然后山顶继续上人，如果下一个人是和自己一个军队的，那么他们就可以相容，山顶还是那个军队的；如果下一个人不是和自己一个军队的，那么目前山顶上的人会出来一个人和那个异类拼杀直至同归于尽，直到山顶上没人了，下一个到达山顶的人可以把自己所在军队的旗帜替换掉之前的旗帜，山顶的归属权发生变化，就这样一致进行下去，最后旗帜在山顶上的军队获得那个山顶的所有权。</li>
<li>我们需要一个<strong>变量winner来标识目前山顶归谁所有</strong>，然后需要一个<strong>变量count来标识目前山顶归属军队在山顶的人数，如果新来了同类就++，如果新来了异类就–，如果count等于0了，说明山顶没人了，那么山顶就会在下一个人到来的时候更换归属者</strong>，最后winner的值就是最后山顶的归属者，也就是票数最多的候选人。</li>
</ul>
<h2 id="算法证明-1"><a href="#算法证明-1" class="headerlink" title="算法证明"></a>算法证明</h2><h2 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h2><ul>
<li>摩尔投票算法有很好的时空复杂度，它只需遍历一次投票集合，所以**时间复杂度是O(n)<strong>的，它只需要额外开两个int型变量，所以</strong>空间复杂度是O(1)**的。</li>
</ul>
<h2 id="代码示例-19"><a href="#代码示例-19" class="headerlink" title="代码示例"></a>代码示例</h2><ul>
<li><p>算法介绍中的那个题的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">winner</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count==<span class="number">0</span>) winner = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==winner) count++;</span><br><span class="line">            <span class="keyword">else</span> count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> winner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="有限状态自动机"><a href="#有限状态自动机" class="headerlink" title="有限状态自动机"></a>有限状态自动机</h1><h1 id="Brian-Kernighan-算法"><a href="#Brian-Kernighan-算法" class="headerlink" title="Brian Kernighan 算法"></a>Brian Kernighan 算法</h1><h2 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h2><ul>
<li>是个位运算的结论，就是<strong>x&amp;(x-1)的结果和让x的最低位的1变成0的结果相同</strong>，如果让x&amp;&#x3D;x-1就相当于把x的最低位的1去掉了，在很多地方有用（比如比特位计数）。</li>
</ul>
<h2 id="代码实例-1"><a href="#代码实例-1" class="headerlink" title="代码实例"></a>代码实例</h2><ul>
<li><p>求汉明距离，可以用这个算法来进行优化：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221228095807579.png" alt="image-20221228095807579"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution26</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> x^y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp!=<span class="number">0</span>)&#123;<span class="comment">//循环次数就是temp中1的个数</span></span><br><span class="line">            temp&amp;=temp-<span class="number">1</span>;<span class="comment">//BK算法，每次都让temp少了最低位的一个1</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="使用位运算做加法"><a href="#使用位运算做加法" class="headerlink" title="使用位运算做加法"></a>使用位运算做加法</h1><h2 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h2><ul>
<li>就是不使用加减乘除四则运算，只利用位运算的特性来做加法运算。</li>
<li>结论就是<strong>两个数的按位异或相当于两个数的不进位加法</strong>，<strong>两个数按位与并向左移动一位得到的结果的二进制上的1仅是两个数相加后的进位</strong>。</li>
<li>从上面的结论中我们<strong>可以通过计算得到两个数的不进位加法值和进位数据</strong>，可以<strong>先计算得到两者的进位数据，然后通过不进位加法得到进位后的数据，通过多次迭代（应对连进好几位的情况）直到没有进位之后再做最后一次不进位加法就能得到加法最终的结果</strong>。</li>
</ul>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (b!=<span class="number">0</span>)&#123;<span class="comment">//直到没有进位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> (a&amp;b)&lt;&lt;<span class="number">1</span>;<span class="comment">//仅得到进位数据，得到的数的二进制表示上的1就是要往那个地方进一位</span></span><br><span class="line">            a = a^b;<span class="comment">//仅为不进位加法</span></span><br><span class="line">            b = temp;<span class="comment">//用于下次进位加法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用位运算做模运算"><a href="#使用位运算做模运算" class="headerlink" title="使用位运算做模运算"></a>使用位运算做模运算</h1><h2 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h2><ul>
<li>也是一个位运算的结论，就是**如果n是2的整数次幂，那么num%n可以被转化为num&amp;(n-1)**，这也是hashmap中寻找存放元素位置时使用的策略，因为这样的位运算比直接使用%进行运算效率要好，hashmap存放元素时，首先根据hashCode()函数求得元素的哈希值，然后通过抖动函数对哈希值进行处理，目的是为了让哈希值尽可能平均一下，减少哈希碰撞，最后就是使用hash&amp;(n-1)来计算元素应该存放的位置，n就是hashmap的链表数组的长度，为了使用这个特性，hashmap的链表数组长度总是2的整数次幂，并且每次扩容都是将链表数组的长度乘2.</li>
</ul>
<h1 id="四平方和定理"><a href="#四平方和定理" class="headerlink" title="四平方和定理"></a>四平方和定理</h1><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><ul>
<li>当一个元素出窗口或者进入窗口后，窗口状态的变化是唯一的，只有满足这个条件的时候，才能尝试使用滑动窗口，如果要是进入窗口或者出窗口后窗口状态的变化不唯一，那么我们大概率没法用简单的代码利用状态的变化来判断窗口应该如何变化。</li>
<li>比如说当数组的元素都为正数时，一个元素出窗口，那么整个窗口的和这个状态一定会变小；一个元素进入窗口，那么整个窗口的和这个状态一定会变大。但是如果要是数组中的元素存在负数，那么一个元素出入窗口时，整个窗口的和这个状态可能变大也可能变小，这就给我们的编码带来了难度。</li>
</ul>
<h1 id="非线性结构转线性结构"><a href="#非线性结构转线性结构" class="headerlink" title="非线性结构转线性结构"></a>非线性结构转线性结构</h1><ul>
<li><p>有些时候我们希望将非线性结构转成线性结构以达成某些目的，最常见的就是二叉树的顺序存储，这个在之前的堆中写过了，这里不再赘述，我想说的是，<strong>有时我们没有必要真的把非线性结构转换成线性结构，而是在逻辑层面上建立起这样的关系，建立关系最常用的工具就是HashMap</strong>，比如<strong>我想用二叉树的节点在顺序结构中的下标，那么我没有必要真的把它放到顺序结构中，而是可以通过HashMap建立起节点和下标的映射，然后通过它的父节点的下标计算出本节点的下标</strong>：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230204105352758.png" alt="image-20230204105352758"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//特殊情况</span></span><br><span class="line">        HashMap&lt;TreeNode,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//里面是节点和顺序存储下节点对应的下标的映射</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; qu = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//队列</span></span><br><span class="line">        qu.add(root);<span class="comment">//root入队</span></span><br><span class="line">        map.put(root,<span class="number">0</span>);<span class="comment">//root的编号是0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最后结果</span></span><br><span class="line">        <span class="keyword">while</span> (!qu.isEmpty())&#123;<span class="comment">//bfs</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> qu.size();<span class="comment">//获取队列的size，下面进行层次遍历要用</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> -<span class="number">1</span>,right = -<span class="number">1</span>;<span class="comment">//分别代表本层最左边那个元素的编号和本层最右边那个元素的编号</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;<span class="comment">//层次遍历</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> qu.poll();<span class="comment">//出队</span></span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)&#123;<span class="comment">//不用考虑null节点，因为每个节点的编号计算不依赖与null节点</span></span><br><span class="line">                    qu.add(node.left);<span class="comment">//入队</span></span><br><span class="line">                    map.put(node.left,map.get(node)*<span class="number">2</span>+<span class="number">1</span>);<span class="comment">//计算出当前节点的左节点在顺序存储中的下标</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    qu.add(node.right);</span><br><span class="line">                    map.put(node.right,map.get(node)*<span class="number">2</span>+<span class="number">2</span>);<span class="comment">//计算出当前节点的右节点在顺序存储中的下标</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) left = map.get(node);<span class="comment">//记录下第一个节点的编号</span></span><br><span class="line">                <span class="keyword">if</span>(i==size-<span class="number">1</span>) right = map.get(node);<span class="comment">//记录下最后一个节点的编号</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans,right-left+<span class="number">1</span>);<span class="comment">//尝试更新答案</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用到了二叉树顺序存储的思想，每个节点在顺序存储下都有自己的编号，一层的宽度就是最后一个元素的编号减去第一个元素的编号再加1。进行层次遍历，每遍历完一层就尝试更新答案，由于<strong>元素的编号只和自己的父节点有关</strong>，所以使用这个思路的话，null节点就不用在层次遍历中考虑了，因为非null节点的编号计算并不依赖于null节点。<br>那么怎么把二叉树表示成一个顺序结构呢，我们可以<strong>只在逻辑上把二叉树表示成一个顺序结构，也就是使用HashMap，记录二叉树节点和顺序结构中二叉树节点的下标的映射，之后我们就能通过这个hashmap来得到某个节点在顺序结构中的编号了</strong>。</p>
</li>
</ul>
<h1 id="上下车问题"><a href="#上下车问题" class="headerlink" title="上下车问题"></a>上下车问题</h1><h2 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h2><ul>
<li>这个问题就是，<strong>给出所有乘客的上车时间和下车时间，求同一时刻车上最多的乘客人数</strong>。</li>
</ul>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ul>
<li><strong>不用在意是谁上下车，只需要注意什么时候上下车即可</strong>。</li>
<li>可以<strong>遍历所有时间，遍历到上车时间，车上的人就++；遍历到下车时间，车上的人就–，每次车上的人++的时候都要尝试更新车上人数最大值max</strong>。</li>
<li>具体实现方式可以<strong>分别对上车时间的集合和下车时间的集合进行排序</strong>，然后<strong>使用双指针+二路归并算法的思路来从逻辑上遍历上车时间集合和下车时间集合组合成的有序集合</strong>，遍历到上车时间就让车上的人数++并尝试更新车上人数的最大值max，遍历到下车时间就让车上的人数–。</li>
<li>通过这个问题可以在以后见到和时间相关的问题的时候留个心眼，可以尝试按照时间轴进行遍历，说不定会有新的思路。</li>
</ul>
<h2 id="具体问题"><a href="#具体问题" class="headerlink" title="具体问题"></a>具体问题</h2><ul>
<li><p>LeetCode 253. 会议室Ⅱ：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230130101107904.png" alt="image-20230130101107904"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMeetingRooms</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] begin = <span class="keyword">new</span> <span class="title class_">int</span>[intervals.length];<span class="comment">//会议开始时间的集合</span></span><br><span class="line">        <span class="type">int</span>[] end = <span class="keyword">new</span> <span class="title class_">int</span>[intervals.length];<span class="comment">//会议结束时间的集合</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最后答案</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;intervals.length;++i)&#123;<span class="comment">//给begin和end赋值</span></span><br><span class="line">            begin[i] = intervals[i][<span class="number">0</span>];</span><br><span class="line">            end[i] = intervals[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(begin);<span class="comment">//给begin排序</span></span><br><span class="line">        Arrays.sort(end);<span class="comment">//给end排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">beginI</span> <span class="operator">=</span> <span class="number">0</span>,endI = <span class="number">0</span>;<span class="comment">//双指针分别指向begin和end的开头</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用来统计某一时刻正在使用的会议室的数量</span></span><br><span class="line">        <span class="keyword">while</span> (beginI&lt;intervals.length&amp;&amp;endI&lt;intervals.length)&#123;<span class="comment">//二路归并算法的思想，逻辑上是将begin和end组合成了一个有序集合然后遍历</span></span><br><span class="line">            <span class="keyword">if</span>(begin[beginI]&lt;end[endI])&#123;<span class="comment">//如果遍历到会议开始时间，那就开个会议室</span></span><br><span class="line">                temp++;<span class="comment">//正在开会的会议室数量++</span></span><br><span class="line">                beginI++;<span class="comment">//begin往后走</span></span><br><span class="line">                <span class="keyword">if</span>(temp&gt;ans) ans = temp;<span class="comment">//尝试更新答案</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//遍历到会议结束时间，关一个会议室，不用纠结元素相同的问题，稍微想想就知道这一点对最后的结果无影响</span></span><br><span class="line">                temp--;<span class="comment">//正在开会的会议室数量--</span></span><br><span class="line">                endI++;<span class="comment">//end往后走</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//temp += intervals.length-beginI;//最后处理一下剩余的会议开始时间，不处理也行，因为总会有会议的结束时间比所有会议的开始时间都要晚</span></span><br><span class="line">        <span class="comment">//if(temp&gt;ans) ans = temp;</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h1><ul>
<li><p>最简单的方法就是使用一个栈来模拟括号的匹配，不再赘述。</p>
</li>
<li><p>实际上还可以把栈优化掉，将括号的匹配进一步抽象，可以<strong>定义两个变量分别表示左右括号的数量，然后遍历括号序列，每当遍历到左括号，记录左括号数量的变量就++；每当遍历到右括号，如果左括号数量不为空，那么左括号的数量就–，如果左括号数量为空，那么右括号数量就++，如果最后两个变量都是0，那么括号匹配，否则，两个变量加起来就是失配的括号数量</strong>。这样做不仅可以优化空间，还可以处理中间夹杂着其他字符的情况，用这种方式处理，中间夹杂着的其他字符不影响括号的匹配。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><ul>
<li>如果要想使用正则表达式匹配一些在正则表达式中有特定含义的字符（比如：\、*、.等），要使用反斜杠‘\’来对这些字符进行转义，不过要注意，<strong>反斜杠本身也是一个在正则表达式中有特定含义的字符，所以它本身也需要一个反斜杠来进行转义</strong>。</li>
</ul>
<h2 id="匹配-‘-‘-字符"><a href="#匹配-‘-‘-字符" class="headerlink" title="匹配 ‘ . ‘ 字符"></a>匹配 ‘ . ‘ 字符</h2><ul>
<li>今天用到Java String中的split方法来着，我的本意是以’ . ‘字符为分割符来对字符串进行分割，所以我就传了个”.”参数，但是分割的结果不尽人意，后来我才意识到，<strong>split方法要求传入的是一个正则表达式，而’ . ‘字符在正则表达式中是个特殊字符，所以我们应该使用反斜杠’&#39;来对它进行转义，但是反斜杠在正则表达式中也是一个特殊字符，所以反斜杠本身也需要被转义，所以如果要想匹配’.’字符，正则表达式应该写为：”\\.”</strong></li>
</ul>
<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h2 id="简单拓扑排序"><a href="#简单拓扑排序" class="headerlink" title="简单拓扑排序"></a>简单拓扑排序</h2><h3 id="算法介绍-6"><a href="#算法介绍-6" class="headerlink" title="算法介绍"></a>算法介绍</h3><ul>
<li><p>拓扑排序就是<strong>用来计算一些具有先决条件的事情的执行顺序的算法</strong>，最经典的例子就是大学里修课程，每门课程可能有先决条件，也就是说可能你必须要修掉这门课程的先决条件的课程，你才能修这门课程：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230110092904231.png" alt="image-20230110092904231"></p>
</li>
<li><p>我们可以<strong>根据这些事件的关系，来画出一个有向无环图来表示他们之间的执行顺序</strong>，这个有向无环图被称为<strong>AOV网</strong>，如果在AOV网中a指向b，那么说明b的先决条件就是a，也就是说，在最后得到的序列中，a必须在b的前面：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230110093122193.png" alt="image-20230110093122193"></p>
</li>
<li><p>而简单拓扑排序只是<strong>要求我们最后将一种执行事件的顺序计算出来</strong>，没有一些额外的要求，比较复杂一点的拓扑排序可能会有额外的一些要求，比如求选修某课程所需的最短事件等，包括还有一些AOV网中的边带有权值，关于这些比较复杂的情况，写在后面，这里就只讨论最简单的拓扑排序。</p>
</li>
<li><p>从上面的描述中我们很容易得知，<strong>只有有向无环图（DAG）才会有拓扑排序，非DAG图没有拓扑排序的概念</strong>，因为如果得到的AOV网有环，很明显在那个环里的事件都不会得到执行。</p>
</li>
<li><p>再来看看对拓扑排序比较准确的描述：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230110093800562.png" alt="image-20230110093800562"></p>
</li>
</ul>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><ul>
<li><p>对于AOV网我们只需要：</p>
<ol>
<li>找到所有无入度的顶点，任选其中一点写入排序队列。</li>
<li>在AOV网中删除刚才写入排序队列的顶点，并将它的边也一同删除。</li>
<li>重复1、2步操作直到AOV网为空。</li>
</ol>
<p>然后我们就得到了一个排序队列，这个排序队列实际上就是AOV网对应的一种拓扑排序的结果。</p>
<p>整个流程和bfs很像，可以用bfs实现，当节点入度为0时才能加入队列中参与bfs，每次都将poll出来的元素指向的那些元素的入度减1来表示从AOV网中将poll出来的元素移除。</p>
</li>
<li><p>还可以用栈+dfs倒推（之后理解理解再来补）</p>
</li>
</ul>
<h3 id="代码示例-20"><a href="#代码示例-20" class="headerlink" title="代码示例"></a>代码示例</h3><ul>
<li><p>LeetCode 207. 课程表：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230110105510020.png" alt="image-20230110105510020"></p>
<p>可以用拓扑排序的思路+bfs实现，只有当一个节点的入度为0的时候才能被放到队列中进行bfs，每次都让poll出来的元素指向的那些元素的入度–，因为相当于从AOV网中删除了poll出来的元素，如果一个节点到最后了入度也没能减为0，说明它在一个环中，也就说明对应的AOV网无法完成拓扑排序，即无法完成所有课程的学习。</p>
<p>按理说拓扑排序最后需要得到一个序列，但是这个题中可以做个优化，不统计序列，只统计序列中元素的数量，因为最后只需要判断是否可以完成拓扑序列，也就是只需要判断序列中元素的数量是否等于给出的元素数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//维护每个节点指向的那些节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;++i)&#123;</span><br><span class="line">            temp.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];<span class="comment">//统计各节点的入度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;++i)&#123;<span class="comment">//初始化各节点的关系和入度</span></span><br><span class="line">            temp.get(prerequisites[i][<span class="number">0</span>]).add(prerequisites[i][<span class="number">1</span>]);</span><br><span class="line">            indegree[prerequisites[i][<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; qu = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//bfs用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//统计可以被加入队列中进行bfs的节点数，如果到最后sum的数量和numCourse不相同，说明到最后有些节点也无法被加入到队列中，说明他们到最后入度也没有归零，说明他们是在一个环中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;indegree.length;++i)&#123;<span class="comment">//给qu初始化</span></span><br><span class="line">            <span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)&#123;<span class="comment">//入度为0才能被加入队列进行bfs</span></span><br><span class="line">                qu.offer(i);</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!qu.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> qu.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;++i) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> qu.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> a : temp.get(head)) &#123;</span><br><span class="line">                    indegree[a]--;<span class="comment">//相当于把head移除，所以head指向的元素入度都--</span></span><br><span class="line">                    <span class="keyword">if</span> (indegree[a]==<span class="number">0</span>) &#123;<span class="comment">//只有当入度为0的时候才能被加入队列进行bfs</span></span><br><span class="line">                        qu.offer(a);</span><br><span class="line">                        sum++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum==numCourses;<span class="comment">//如果sum==numCourse说明无环，所有的节点的入度最后都能归零</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h1><h2 id="算法介绍-7"><a href="#算法介绍-7" class="headerlink" title="算法介绍"></a>算法介绍</h2><ul>
<li>Manacher 算法是在线性时间内求解最长回文子串的算法。</li>
</ul>
<h1 id="字符串hash"><a href="#字符串hash" class="headerlink" title="字符串hash"></a>字符串hash</h1><h2 id="算法介绍-8"><a href="#算法介绍-8" class="headerlink" title="算法介绍"></a>算法介绍</h2><ul>
<li>一个用来<strong>快速判断两个字符串或者两个字符串的子串是否相等</strong>的算法，缺点在于答案不会完全正确，发生哈希碰撞的时候答案就可能不正确，但是大部分情况下答案是对的；优点在于速度快，思想简单。</li>
</ul>
<h2 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h2><ul>
<li>思想就是<strong>设计一个hash函数，可以快速求出一个字符串及其子串的hash值</strong>，如果想要减少碰撞的概率，可以设计多个hash函数，对比两个字符串的时候需要所有hash函数求出来的值都相等才判定为相等（布隆过滤器的原理好像和这个类似）。</li>
</ul>
<h2 id="hash函数的设计"><a href="#hash函数的设计" class="headerlink" title="hash函数的设计"></a>hash函数的设计</h2><ul>
<li>首先我们<strong>规定f(i)的值是i这一位上字符的ascii码</strong>；然后<strong>规定hash[i]是前i位(包括当前位)字符的hash值</strong>（记录下求hash的中间过程后面<strong>方便求子串的hash</strong>）；<strong>p和mod均是我们自己选取的参数</strong>，一般<strong>p我们选个质数</strong>，29或者131就不错，mod选的大一点，803081491就挺不错，<strong>mod选得大一点，越大碰撞的几率越低</strong>。</li>
<li>那么<strong>hash[i] &#x3D; ( hash[i-1] * p + f(i) ) % mod</strong>，递推到最后一位，最后一位就是整个字符串的hash值</li>
</ul>
<h2 id="求子串的hash值"><a href="#求子串的hash值" class="headerlink" title="求子串的hash值"></a>求子串的hash值</h2><ul>
<li><p>刚才我们记录下来了求整个字符串hash的完整过程，我们通过这些过程数据就可以快速求出所有子串的hash</p>
</li>
<li><p>先给出一个有五个字符的字符串的hash过程（省略了取模的过程方便理解）：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230515221312912.png" alt="image-20230515221312912"></p>
</li>
<li><p>如果我们想求第三个和第四个字符组成的子串的hash值，那么我们根据hash函数，可以得到的公式为s3*p+s4，这个式子可以通过hash[4]-hash[2]*$p^2$来得到，通过数学归纳法我们可以得到求解子串hash的公式：<strong>求[i,j]子串有((hash[j]-hash[i-1]*$p^{j-i+1}$)%mod+mod)%mod</strong>后面的+mod%mod操作是为了防止里面的减法出现负数的情况</p>
</li>
<li><p><strong>如果需要多次反复求子串的hash，那么可以预处理p的n次方来加速后面的运算</strong></p>
</li>
</ul>
<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><h1 id="数字魔方阵的求法"><a href="#数字魔方阵的求法" class="headerlink" title="数字魔方阵的求法"></a>数字魔方阵的求法</h1><h2 id="奇数阶魔方阵（阶数为奇数）"><a href="#奇数阶魔方阵（阶数为奇数）" class="headerlink" title="奇数阶魔方阵（阶数为奇数）"></a>奇数阶魔方阵（阶数为奇数）</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20231017170357172.png" alt="image-20231017170357172"></p>
<ul>
<li><p>C语言代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="type">int</span> ans[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">			ans[i][j] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> row=<span class="number">0</span>,line=n/<span class="number">2</span>;<span class="comment">//从第一行的中间位置开始填数 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*n;++i)&#123;<span class="comment">//要填的数是从1-n*n </span></span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">1</span>)&#123;<span class="comment">//把1填到第一行的中间位置 </span></span><br><span class="line">			ans[row][line] = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//每次填完数让row-1，让line+1，注意处理越界的情况，越界之后从另一头开始 </span></span><br><span class="line">			row = row<span class="number">-1</span>&lt;<span class="number">0</span>?n<span class="number">-1</span>:row<span class="number">-1</span>;</span><br><span class="line">			line = (line+<span class="number">1</span>)%n;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(ans[row][line]==<span class="number">0</span>)&#123;<span class="comment">//如果当前位置为空则填数然后row和line变到下一个位置 </span></span><br><span class="line">				ans[row][line] = i;</span><br><span class="line">				row = row<span class="number">-1</span>&lt;<span class="number">0</span>?n<span class="number">-1</span>:row<span class="number">-1</span>;</span><br><span class="line">				line = (line+<span class="number">1</span>)%n;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;<span class="comment">//如果当前位置不为空则将当前数字填到上一个数字的下面</span></span><br><span class="line">				<span class="comment">//把位置定位到上一个元素的下面的位置 </span></span><br><span class="line">				row = (row+<span class="number">1</span>)%n;</span><br><span class="line">				line = line<span class="number">-1</span>&lt;<span class="number">0</span>?n<span class="number">-1</span>:line<span class="number">-1</span>;</span><br><span class="line">				row = (row+<span class="number">1</span>)%n;</span><br><span class="line">				<span class="comment">//填数然后变坐标 </span></span><br><span class="line">				ans[row][line] = i;</span><br><span class="line">				row = row<span class="number">-1</span>&lt;<span class="number">0</span>?n<span class="number">-1</span>:row<span class="number">-1</span>;</span><br><span class="line">				line = (line+<span class="number">1</span>)%n;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>,ans[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="双偶数阶魔方阵（阶数为偶数且能被4整除）"><a href="#双偶数阶魔方阵（阶数为偶数且能被4整除）" class="headerlink" title="双偶数阶魔方阵（阶数为偶数且能被4整除）"></a>双偶数阶魔方阵（阶数为偶数且能被4整除）</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20231017170513879.png" alt="image-20231017170513879"></p>
<h1 id="两个升序链表取交集"><a href="#两个升序链表取交集" class="headerlink" title="两个升序链表取交集"></a>两个升序链表取交集</h1><ul>
<li><p>c语言实现，思路都在注释里了，不过我这个写的没有把结果去重。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  	<span class="type">int</span> data;</span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span></span><br><span class="line">  &#125;*List,*ListNode;</span><br><span class="line">  <span class="type">void</span> <span class="title function_">getUnion</span><span class="params">(List list1,List list2)</span>&#123;<span class="comment">//求两个链表的交集 </span></span><br><span class="line">  	ListNode tail = list1;<span class="comment">//将结果存到list1中，tail用来存结果</span></span><br><span class="line">  	<span class="comment">//初始化两个链表的工作指针 </span></span><br><span class="line">  	ListNode temp1 = list1-&gt;next;</span><br><span class="line">  	ListNode temp2 = list2-&gt;next;</span><br><span class="line">  	<span class="keyword">while</span>(temp1&amp;&amp;temp2)&#123;<span class="comment">//两个工作指针任意一个指向了NULL就退出，因为后面不可能有答案了 </span></span><br><span class="line">  		<span class="keyword">if</span>(temp1-&gt;data&lt;temp2-&gt;data)temp1 = temp1-&gt;next;<span class="comment">//如果list1的当前元素小于list2的当前元素，说明list1当前的元素不可能是答案，list1往后走 </span></span><br><span class="line">  		<span class="keyword">else</span> <span class="keyword">if</span>(temp1-&gt;data==temp2-&gt;data)&#123;<span class="comment">//如果 list1和list2当前元素相等，那么就把当前元素的值给tail结点，然后tail、list1、list2都往后走 </span></span><br><span class="line">  			tail = tail-&gt;next;</span><br><span class="line">  			tail-&gt;data = temp2-&gt;data;</span><br><span class="line">  			temp1=temp1-&gt;next;</span><br><span class="line">  			temp2=temp2-&gt;next;</span><br><span class="line">  		&#125;<span class="keyword">else</span>&#123;<span class="comment">//如果list1的当前元素大于list2的当前元素，说明list2的当前元素不可能是答案，所以list2往后走 </span></span><br><span class="line">  			temp2=temp2-&gt;next;</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	tail-&gt;next = <span class="literal">NULL</span>;<span class="comment">//最后把tail的next设置为NULL，这样输出时就输出的是全部答案。 </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  	<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">  	List heada = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">  	heada-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  	ListNode taila = heada,temp = heada;</span><br><span class="line">  	List headb = (List)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">  	headb-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  	ListNode tailb = headb;</span><br><span class="line">  	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">  		<span class="keyword">if</span>(num==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">  		temp = (ListNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">  		temp-&gt;data = num;</span><br><span class="line">  		temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  		taila-&gt;next = temp;</span><br><span class="line">  		taila = temp;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">  		<span class="keyword">if</span>(num==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">  		temp = (ListNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">  		temp-&gt;data = num;</span><br><span class="line">  		temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  		tailb-&gt;next = temp;</span><br><span class="line">  		tailb = temp;</span><br><span class="line">  	&#125;</span><br><span class="line">  	getUnion(heada,headb);</span><br><span class="line">  	temp = heada-&gt;next;</span><br><span class="line">  	<span class="keyword">while</span>(temp)&#123;</span><br><span class="line">  		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,temp-&gt;data);</span><br><span class="line">  		temp = temp-&gt;next;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"># 给定后序遍历序列恢复完全二叉树</span><br><span class="line"></span><br><span class="line">- 对于非完全二叉树来说，只有一个后序遍历序列是无法确定一个二叉树的结构的，因为对于给定数量的结点来说，它们可形成的二叉树的结构是多种多样的，而完全二叉树不同，对于给定数量的结点，它们的完全二叉树的结构是唯一的，此时如果再给出其后序遍历序列，那么我们就可以通过这个遍历序列递归地重建这颗完全二叉树。</span><br><span class="line"></span><br><span class="line">- 具体做法就是我们可以假想存在这样一棵完全二叉树，只不过它的所有结点都是空的，然后后序/前序（从前向后扫后序序列就后序遍历，从后向前扫后序序列就前序遍历）遍历这棵树，每遍历到一个结点时就把后序遍历序列中的一个数赋值给它，然后后序遍历序列中的指针移动到下一个应该遍历到的结点的值位置处，直到所有值都被赋值完毕。</span><br><span class="line"></span><br><span class="line">- 代码示例：</span><br><span class="line"></span><br><span class="line">  ```c</span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">  <span class="type">int</span> numPos = <span class="number">0</span>;<span class="comment">//从后序遍历序列的数组中取数的下标 </span></span><br><span class="line">  <span class="type">void</span> <span class="title function_">layer</span><span class="params">(<span class="type">int</span> *ans,<span class="type">int</span> size,<span class="type">int</span> now,<span class="type">int</span> *arr)</span>&#123;<span class="comment">//后序遍历的顺序是左右根，那么我们可以按照根右左的顺序递归地重建这棵树，对于普通的二叉树这样是行不通的，因为你无法判断当前元素的下一个元素和当前元素之间的位置关系，但是对于完全二叉树是可以的，因为对于给定数量的结点来说，它们构成的完全二叉树的形状是唯一的 </span></span><br><span class="line">  	<span class="keyword">if</span>(now&gt;=size) <span class="keyword">return</span>;<span class="comment">//递归退出条件</span></span><br><span class="line">  	<span class="comment">//按照根右左的顺序递归建树 </span></span><br><span class="line">  	ans[now] = arr[numPos--];</span><br><span class="line">  	layer(ans,size,now*<span class="number">2</span>+<span class="number">2</span>,arr);<span class="comment">//先右 </span></span><br><span class="line">  	layer(ans,size,now*<span class="number">2</span>+<span class="number">1</span>,arr);<span class="comment">//再左 </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  	<span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">  	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);<span class="comment">//输入结点数量 </span></span><br><span class="line">  	<span class="type">int</span> *arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*len);<span class="comment">//动态申请数组</span></span><br><span class="line">  	<span class="type">int</span> *ans = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*len); </span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i) ans[i] = <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;arr[i]);<span class="comment">//输入完全二叉树的后序序列 </span></span><br><span class="line">  	numPos = len<span class="number">-1</span>;</span><br><span class="line">  	layer(ans,len,<span class="number">0</span>,arr);<span class="comment">//利用后序遍历序列建立完全二叉树</span></span><br><span class="line">  	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">  		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">  	&#125; </span><br><span class="line">  	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><ul>
<li>就是从一组数据中找出给定的数据。</li>
</ul>
<h2 id="线性查找算法"><a href="#线性查找算法" class="headerlink" title="线性查找算法"></a>线性查找算法</h2><h3 id="基本介绍-6"><a href="#基本介绍-6" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li>就是遍历一遍数据，找到了对应元素就记下来，没啥好介绍的。</li>
</ul>
<h3 id="算法思想-7"><a href="#算法思想-7" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li>就是遍历一遍数据，找到了对应元素就记下来，没啥思想。</li>
</ul>
<h3 id="代码示例-21"><a href="#代码示例-21" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-11 15:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinearSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入集合中的数据个数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入集合中的数据，数据之间用空格分隔：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要查找的数据：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]==target)&#123;</span><br><span class="line">                System.out.println(target+<span class="string">&quot;第一次在集合中出现位置的下标是：&quot;</span>+i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(target+<span class="string">&quot;在集合中不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二分-折半-查找算法"><a href="#二分-折半-查找算法" class="headerlink" title="二分(折半)查找算法"></a>二分(折半)查找算法</h2><h3 id="基本介绍-7"><a href="#基本介绍-7" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li>使用<strong>二分查找的前提是数据有序</strong>，然后<strong>每次找数据中间的数，然后根据那个数和要找的数之间的关系来决定继续向左还是向右进行查找</strong>。</li>
</ul>
<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107090928743.png" alt="image-20221107090928743"></p>
<h3 id="对于中间值下标计算的优化"><a href="#对于中间值下标计算的优化" class="headerlink" title="对于中间值下标计算的优化"></a>对于中间值下标计算的优化</h3><ul>
<li>上面计算中间值的下标mid用的是(left+right)&#x2F;2这个表达式，然而这个表达式实际上不够安全，<strong>如果left和right是两个非常大的数，那么left+right这一操作可能造成数值溢出</strong>。</li>
<li>鉴于上面的问题，我们可以<strong>将计算中间值下标mid用到的表达式换成left+(right-left)&#x2F;2</strong>，这样由于之前的两个大数的加法转换成了两个大数的减法，所以杜绝了正常数据下数值溢出的问题。</li>
</ul>
<h3 id="代码示例-22"><a href="#代码示例-22" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-11 15:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入集合中的数据个数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入集合中的数据，数据有序并且数据之间用空格分隔：&quot;</span>);<span class="comment">//二分查找的数组必须有序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要查找的数据：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//左边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n-<span class="number">1</span>;<span class="comment">//右边界</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;<span class="comment">//这里的等号是必要的，因为按照下面的写法，当两个下标重合的时候，重合处的元素还没有被判断过</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)/<span class="number">2</span>;<span class="comment">//这样写是为了在数据很大的情况下不至于造成算数溢出</span></span><br><span class="line">            <span class="keyword">if</span>(target==num[mid])&#123;<span class="comment">//找到了</span></span><br><span class="line">                System.out.println(target+<span class="string">&quot;在集合中出现位置对应的下标是：&quot;</span>+mid);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;num[mid])&#123;<span class="comment">//target比num[mid]小说明target在前半段</span></span><br><span class="line">                right = mid-<span class="number">1</span>;<span class="comment">//向前折半，注意这里由于是mid-1，所以下一轮的right是还没有被查过的，此时如果下一轮left和right重合了，还要再走一轮查重合的那个元素，所以在循环中的那个等号是必要的</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;num[mid])&#123;<span class="comment">//target比num[mid]大说明target在后半段</span></span><br><span class="line">                left = mid+<span class="number">1</span>;<span class="comment">//向后折半，注意这里由于是mid+1，所以下一轮的left是还没有被查过的，此时如果下一轮left和right重合了，还要再走一轮查重合的那个元素，所以在循环中的那个等号是必要的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(target+<span class="string">&quot;在集合中不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插值查找算法"><a href="#插值查找算法" class="headerlink" title="插值查找算法"></a>插值查找算法</h2><h3 id="基本介绍-8"><a href="#基本介绍-8" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li><p><strong>如果要查找的元素位于数据的头部或者尾部左右，使用二分查找的话效率会比较低</strong>，因为每次不管数据在什么部分，对于数据的分割总是二分，这样我们就思考，<strong>如果有一种查找方式可以在每次分割数据的时候根据要找的数据的值来自适应地向最有可能存在目标数据的区间去寻找就好了</strong>，这就是插值查找算法的基本思路。</p>
</li>
<li><p>插值查找算法类似于二分查找，不同的是<strong>插值查找每次从自适应 mid 处开始查找</strong>。</p>
</li>
</ul>
<h3 id="算法思想-8"><a href="#算法思想-8" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li><p>其思想就是<strong>利用一个插值参数代替二分查找计算中间值表达式的1&#x2F;2</strong>，而这个插值参数是自适应的，也就是说这个插值参数揭示了要找的元素最有可能出现在哪一部分，我的数学不是很好，看着应该是利用了比例。</p>
</li>
<li><p>将折半查找中的求 mid 索引的公式进行修改 , low 表示左边索引 left，high 表示右边索引 right，key 就是我们想要找的数据：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107092311759.png" alt="image-20221107092311759"></p>
</li>
<li><p>**int mid &#x3D; low + (high - low) * (key - arr[low]) &#x2F; (arr[high] - arr[low])**这就是插值索引mid的计算方法。</p>
</li>
</ul>
<h3 id="插值查找算法举例"><a href="#插值查找算法举例" class="headerlink" title="插值查找算法举例"></a>插值查找算法举例</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107092649559.png" alt="image-20221107092649559"></p>
<h3 id="插值查找注意事项"><a href="#插值查找注意事项" class="headerlink" title="插值查找注意事项"></a>插值查找注意事项</h3><ul>
<li>对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快。</li>
<li>关键字分布不均匀的情况下，该方法不一定比折半查找要好。</li>
</ul>
<h3 id="代码示例-23"><a href="#代码示例-23" class="headerlink" title="代码示例"></a>代码示例</h3><ul>
<li><p>和二分查找差不多，只是索引mid的计算方法变了而已：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-11 15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterpolationSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入集合中的数据个数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请依次输入集合中的数据，数据有序并且数据之间用空格分隔：&quot;</span>);<span class="comment">//插值查找的数组必须有序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            num[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要查找的数据：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//左边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n-<span class="number">1</span>;<span class="comment">//右边界</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;<span class="comment">//这里的等号是必要的，因为按照下面的写法，当两个下标重合的时候，重合处的元素还没有被判断过</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left+(right-left)*((target-num[left])/(num[right]-num[left]));<span class="comment">//插值看上去好像是表示某个比例，同理，这样写不至于算术溢出</span></span><br><span class="line">            <span class="keyword">if</span>(target==num[mid])&#123;<span class="comment">//找到了</span></span><br><span class="line">                System.out.println(target+<span class="string">&quot;在集合中出现位置对应的下标是：&quot;</span>+mid);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;num[mid])&#123;<span class="comment">//target比num[mid]小说明target在前段</span></span><br><span class="line">                right = mid-<span class="number">1</span>;<span class="comment">//向前折，注意这里由于是mid-1，所以下一轮的right是还没有被查过的，此时如果下一轮left和right重合了，还要再走一轮查重合的那个元素，所以在循环中的那个等号是必要的</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;num[mid])&#123;<span class="comment">//target比num[mid]大说明target在后段</span></span><br><span class="line">                left = mid+<span class="number">1</span>;<span class="comment">//向后折，注意这里由于是mid+1，所以下一轮的left是还没有被查过的，此时如果下一轮left和right重合了，还要再走一轮查重合的那个元素，所以在循环中的那个等号是必要的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(target+<span class="string">&quot;在集合中不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="斐波那契-黄金分割-查找算法"><a href="#斐波那契-黄金分割-查找算法" class="headerlink" title="斐波那契(黄金分割)查找算法"></a>斐波那契(黄金分割)查找算法</h2><h3 id="基本介绍-9"><a href="#基本介绍-9" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li>黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是 0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不到的效果。</li>
<li>斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值0.618</li>
<li>也就是说<strong>找目标值的时候用到的所以是利用斐波那契数列两个相邻数的比例计算出来的</strong>。（怎么感觉这种查找这么玄学。。。）</li>
</ul>
<h3 id="算法思想-9"><a href="#算法思想-9" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li><p>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid 不再是中间或插值得到，而是位于黄金分割点附近，即 <strong>mid&#x3D;low+F(k-1)-1（F 代表斐波那契数列）</strong>，如下图所示：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107093420069.png" alt="image-20221107093420069"></p>
</li>
<li><p>对F(k-1)-1的理解：</p>
<ol>
<li>由斐波那契数列 F[k]&#x3D;F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）&#x3D;（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：<strong>只要顺序表的长度为 F[k]-1，则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段，即如上图所示。从而中间位置为 mid&#x3D;low+F(k-1)-1</strong>。</li>
<li>类似的，每一子段也可以用相同的方式分割</li>
<li>但顺序表长度 n 不一定刚好等于 F[k]-1，所以<strong>需要将原来的顺序表长度 n 增加至 F[k]-1</strong>。这里的<strong>k 值只要能使得 F[k]-1 恰好大于或等于 n 即可</strong>，由以下代码得到,顺序表长度增加后，<strong>新增的位置（从 n+1 到 F[k]-1 位置），都赋为 n 位置的值即可</strong>。</li>
</ol>
</li>
<li></li>
</ul>
<h3 id="代码示例-24"><a href="#代码示例-24" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"># 数论相关</span><br><span class="line"></span><br><span class="line">## 求组合数并取模（例题：CF1999F）</span><br><span class="line"></span><br><span class="line">- 这个算法中涉及到很多数论相关的知识，包括取模意义下的除法（因为求组合数涉及到了除法）等内容，我只是从网上找了个板子，等我学习之后再来详细写一下相关内容，我先把板子放在下面：</span><br><span class="line"></span><br><span class="line">  ```cpp</span><br><span class="line">  typedef <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">  const LL maxn=<span class="number">200005</span>, mod=<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">  LL Jc[maxn];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">calJc</span><span class="params">()</span>	<span class="comment">//求maxn以内的数的阶乘，这个要在main函数中运行一次</span></span><br><span class="line">  &#123;</span><br><span class="line">      Jc[<span class="number">0</span>] = Jc[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">LL</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; maxn; i++)</span><br><span class="line">          Jc[i] = Jc[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  //拓展欧几里得算法求逆元</span></span><br><span class="line"><span class="comment">  void exgcd(LL a, LL b, LL &amp;x, LL &amp;y)	//拓展欧几里得算法</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">      if(!b) x = 1, y = 0;</span></span><br><span class="line"><span class="comment">      else</span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">          exgcd(b, a % b, y, x);</span></span><br><span class="line"><span class="comment">          y -= x * (a / b);</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  LL niYuan(LL a, LL b)	//求a对b取模的逆元</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">      LL x, y;</span></span><br><span class="line"><span class="comment">      exgcd(a, b, x, y);</span></span><br><span class="line"><span class="comment">      return (x + b) % b;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//费马小定理求逆元</span></span><br><span class="line">  LL <span class="title function_">pow</span><span class="params">(LL a, LL n, LL p)</span>	<span class="comment">//快速幂 a^n % p</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">LL</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>(n)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ans = ans * a % p;</span><br><span class="line">          a = a * a % p;</span><br><span class="line">          n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  LL <span class="title function_">niYuan</span><span class="params">(LL a, LL b)</span>	<span class="comment">//费马小定理求逆元</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">return</span> pow(a, b - <span class="number">2</span>, b);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  LL <span class="title function_">C</span><span class="params">(LL a, LL b)</span>	<span class="comment">//计算C(a, b)，a是下面那个数，b是上面那个数</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span>(a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> Jc[a] * niYuan(Jc[b], mod) % mod</span><br><span class="line">          * niYuan(Jc[a - b], mod) % mod;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>顺便给一下我写的CF1999F那题的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//const int mod = 1e9+7;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> LL maxn=<span class="number">200005</span>, mod=<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">LL Jc[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calJc</span><span class="params">()</span>	<span class="comment">//求maxn以内的数的阶乘</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Jc[<span class="number">0</span>] = Jc[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">2</span>; i &lt; maxn; i++)</span><br><span class="line">        Jc[i] = Jc[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//拓展欧几里得算法求逆元</span></span><br><span class="line"><span class="comment">void exgcd(LL a, LL b, LL &amp;x, LL &amp;y)	//拓展欧几里得算法</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if(!b) x = 1, y = 0;</span></span><br><span class="line"><span class="comment">    else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        exgcd(b, a % b, y, x);</span></span><br><span class="line"><span class="comment">        y -= x * (a / b);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">LL niYuan(LL a, LL b)	//求a对b取模的逆元</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    LL x, y;</span></span><br><span class="line"><span class="comment">    exgcd(a, b, x, y);</span></span><br><span class="line"><span class="comment">    return (x + b) % b;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//费马小定理求逆元</span></span><br><span class="line"><span class="function">LL <span class="title">pow</span><span class="params">(LL a, LL n, LL p)</span>	<span class="comment">//快速幂 a^n % p</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) ans = ans * a % p;</span><br><span class="line">        a = a * a % p;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">niYuan</span><span class="params">(LL a, LL b)</span>	<span class="comment">//费马小定理求逆元</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(a, b - <span class="number">2</span>, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL b, LL a)</span>	<span class="comment">//计算C(a, b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &lt; b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Jc[a] * <span class="built_in">niYuan</span>(Jc[b], mod) % mod</span><br><span class="line">        * <span class="built_in">niYuan</span>(Jc[a - b], mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//long long C(int up,int down)&#123;</span></span><br><span class="line"><span class="comment">//	if(up==down) return 1;</span></span><br><span class="line"><span class="comment">//	if(up==0) return 1;</span></span><br><span class="line"><span class="comment">//	long long ans = 0;</span></span><br><span class="line"><span class="comment">//	long long tempUp,tempDown;</span></span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=up;++i)&#123;</span></span><br><span class="line"><span class="comment">//		if(i==1)&#123;</span></span><br><span class="line"><span class="comment">//			tempUp = down;</span></span><br><span class="line"><span class="comment">//			tempDown = i;</span></span><br><span class="line"><span class="comment">//		&#125;else&#123;</span></span><br><span class="line"><span class="comment">//			tempUp=((tempUp%mod)*((down-i+1)%mod))%mod;</span></span><br><span class="line"><span class="comment">//			tempDown=((tempDown%mod)*(i%mod))%mod;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	ans = tempUp/tempDown;</span></span><br><span class="line"><span class="comment">//	return ans%mod;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">calJc</span>();</span><br><span class="line">	<span class="type">int</span> t,n,k;</span><br><span class="line">	<span class="type">int</span> nums[<span class="number">200005</span>];</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t;++i)&#123;</span><br><span class="line">		cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">		ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">			cin&gt;&gt;nums[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(nums,nums+n);</span><br><span class="line">		<span class="type">int</span> temp = k/<span class="number">2</span>;</span><br><span class="line">		<span class="type">int</span> half = k/<span class="number">2</span>; </span><br><span class="line">		<span class="keyword">while</span>(temp!=n-half)&#123;</span><br><span class="line">			<span class="keyword">if</span>(nums[temp]==<span class="number">1</span>)&#123;</span><br><span class="line">				ans=((ans%mod)+((<span class="built_in">C</span>(half,temp)*<span class="built_in">C</span>(half,n-temp<span class="number">-1</span>))%mod))%mod;</span><br><span class="line">			&#125;</span><br><span class="line">			temp++;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="数据结构-树"><a href="#数据结构-树" class="headerlink" title="数据结构-树"></a>数据结构-树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="为什么需要树这种数据结构"><a href="#为什么需要树这种数据结构" class="headerlink" title="为什么需要树这种数据结构"></a>为什么需要树这种数据结构</h3><ul>
<li><p><strong>数组存储方式</strong>的分析：</p>
<ul>
<li><p><strong>优点</strong>：通过下标方式访问元素，速度快。对于有序数组，还可使用<strong>二分查找提高检索速度</strong>。</p>
</li>
<li><p><strong>缺点</strong>：如果要检索具体某个值，或者<strong>插入值(按一定顺序)会整体移动，效率较低</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107201028421.png" alt="image-20221107201028421"></p>
</li>
</ul>
</li>
<li><p><strong>链式存储方式</strong>的分析：</p>
<ul>
<li><p><strong>优点</strong>：在一定程度上对数组存储方式有优化(比如：<strong>插入</strong>一个数值节点，只需要将插入节点，链接到链表中即可，<strong>删除效率也很好</strong>)。</p>
</li>
<li><p><strong>缺点</strong>：<strong>在进行检索时，效率仍然较低</strong>，比如(检索某个值，需要从头节点开始遍历)</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107201236741.png" alt="image-20221107201236741"></p>
</li>
</ul>
</li>
<li><p><strong>树存储方式</strong>的分析</p>
<ul>
<li><p>能提高数据存储，读取的效率, 比如<strong>利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221107201333513.png" alt="image-20221107201333513"></p>
</li>
</ul>
</li>
</ul>
<h3 id="树示意图"><a href="#树示意图" class="headerlink" title="树示意图"></a>树示意图</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111195315513.png" alt="image-20221111195315513"></p>
<h3 id="树的常用术语"><a href="#树的常用术语" class="headerlink" title="树的常用术语"></a>树的常用术语</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111195347117.png" alt="image-20221111195347117"></p>
<ul>
<li>节点：就是树的节点</li>
<li>根节点：就是最顶上那个节点</li>
<li>父节点：指向这个节点的节点是这个节点的父节点</li>
<li>子节点：被指向的节点是指向它的那个节点的子节点</li>
<li>叶子节点：没有子节点的节点</li>
<li>节点的权：就是节点的值</li>
<li>路径：一个节点的路径就是从根节点找到该节点的路线</li>
<li>层：横着看是一层，从根节点途经相同步数能到达的节点在同一层中</li>
<li>子树：在二叉树中一个节点只有两个子树，分别是左子树和右子树，左右子树都是由是左右节点直接或间接的子节点来构成的</li>
<li>树的高度：就是树的最大层数</li>
<li>森林：多棵子树构成森林</li>
</ul>
<h3 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h3><ul>
<li><p>树有很多种，<strong>每个节点最多只能有两个子节点</strong>的一种形式称为二叉树。</p>
</li>
<li><p>二叉树的子节点分为左节点和右节点</p>
</li>
<li><p>示意图：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201052749.png" alt="image-20221111201052749"></p>
</li>
<li><p>如果该二叉树的<strong>所有叶子节点都在最后一层，并且结点总数&#x3D; 2^n -1 , n 为层数</strong>，则我们称为<strong>满二叉树</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201131764.png" alt="image-20221111201131764"></p>
</li>
<li><p>如果该二叉树的<strong>所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续</strong>，我们称为<strong>完全二叉树</strong>。更通俗一点的解释就是：<strong>去掉最后一层是满二叉树，倒数第一层的节点全部紧靠在左边</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201217766.png" alt="image-20221111201217766"></p>
</li>
</ul>
<h3 id="二叉树遍历的说明"><a href="#二叉树遍历的说明" class="headerlink" title="二叉树遍历的说明"></a>二叉树遍历的说明</h3><ul>
<li>我们可以使用<strong>层序、前序、中序和后序</strong>等对二叉树进行遍历。</li>
<li>前序遍历：先输出父节点，再遍历左子树和右子树</li>
<li>中序遍历：先遍历左子树，再输出父节点，再遍历右子树</li>
<li>后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点</li>
<li>小结: 看输出父节点的顺序，就能确定是前序，中序还是后序</li>
</ul>
<h3 id="二叉树遍历步骤"><a href="#二叉树遍历步骤" class="headerlink" title="二叉树遍历步骤"></a>二叉树遍历步骤</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201731060.png" alt="image-20221111201731060"></p>
<h3 id="二叉树查找指定节点"><a href="#二叉树查找指定节点" class="headerlink" title="二叉树查找指定节点"></a>二叉树查找指定节点</h3><ul>
<li><p>思路分析图解：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201900016.png" alt="image-20221111201900016"></p>
</li>
</ul>
<h3 id="二叉树删除节点"><a href="#二叉树删除节点" class="headerlink" title="二叉树删除节点"></a>二叉树删除节点</h3><ul>
<li><p>思路分析图解：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221111201942720.png" alt="image-20221111201942720"></p>
</li>
<li><p>注意这里的删除思路是针对普通二叉树来说的，后面的排序二叉树、平衡二叉树等的删除思路和普通二叉树不同，后面会详细介绍。</p>
</li>
</ul>
<h2 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a>顺序存储二叉树</h2><ul>
<li>堆这个数据结构会用到顺序存储二叉树</li>
</ul>
<h3 id="顺序存储二叉树的概念"><a href="#顺序存储二叉树的概念" class="headerlink" title="顺序存储二叉树的概念"></a>顺序存储二叉树的概念</h3><ul>
<li><p>基本说明：从数据存储来看，数组存储方式和树的存储方式可以相互转换，即<strong>数组可以转换成树，树也可以转换成数组</strong>，看下面的示意图：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221112112821494.png" alt="image-20221112112821494"></p>
</li>
<li><p>要求：在遍历数组 arr 时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历。</p>
</li>
<li><p>顺序存储二叉树的特点：</p>
<ol>
<li>顺序二叉树通常<strong>只考虑完全二叉树</strong></li>
<li>第 n 个元素的<strong>左子节点为 2 * n + 1</strong></li>
<li>第 n 个元素的<strong>右子节点为 2 * n + 2</strong></li>
<li>第 n 个元素的<strong>父节点为 (n-1) &#x2F; 2</strong></li>
<li>n : 表示二叉树中的第几个元素(按 0 开始编号如图所示)</li>
</ol>
</li>
</ul>
<h3 id="顺序存储二叉树的遍历"><a href="#顺序存储二叉树的遍历" class="headerlink" title="顺序存储二叉树的遍历"></a>顺序存储二叉树的遍历</h3><ul>
<li><p>其实思路和非顺序存储二叉树的遍历相同，也是递归，只不过就是访问左子节点和访问右子节点的方式变了一下，之前是通过指针访问，现在是通过下标访问。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Konjacer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2022-11-12 11:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderTreeTraverse</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入树的节点数量（包括空节点）：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span>[] tree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        System.out.println(<span class="string">&quot;请按层序输入树的节点权值，空节点用-1代替：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            tree[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历的结果为：&quot;</span>);</span><br><span class="line">        before(tree,<span class="number">0</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历的结果为：&quot;</span>);</span><br><span class="line">        mid(tree,<span class="number">0</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历的结果为：&quot;</span>);</span><br><span class="line">        after(tree,<span class="number">0</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(<span class="type">int</span>[] tree,<span class="type">int</span> now)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now&gt;=tree.length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tree[now]!=-<span class="number">1</span>)<span class="comment">//如果不是空节点就输出</span></span><br><span class="line">            System.out.print(tree[now]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        before(tree,now*<span class="number">2</span>+<span class="number">1</span>);<span class="comment">//向左遍历</span></span><br><span class="line">        before(tree,now*<span class="number">2</span>+<span class="number">2</span>);<span class="comment">//向右遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mid</span><span class="params">(<span class="type">int</span>[] tree,<span class="type">int</span> now)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now&gt;=tree.length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid(tree,now*<span class="number">2</span>+<span class="number">1</span>);<span class="comment">//向左遍历</span></span><br><span class="line">        <span class="keyword">if</span>(tree[now]!=-<span class="number">1</span>)<span class="comment">//如果不是空节点就输出</span></span><br><span class="line">            System.out.print(tree[now]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        mid(tree,now*<span class="number">2</span>+<span class="number">2</span>);<span class="comment">//向右遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(<span class="type">int</span>[] tree,<span class="type">int</span> now)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(now&gt;=tree.length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        after(tree,now*<span class="number">2</span>+<span class="number">1</span>);<span class="comment">//向左遍历</span></span><br><span class="line">        after(tree,now*<span class="number">2</span>+<span class="number">2</span>);<span class="comment">//向右遍历</span></span><br><span class="line">        <span class="keyword">if</span>(tree[now]!=-<span class="number">1</span>)<span class="comment">//如果不是空节点就输出</span></span><br><span class="line">            System.out.print(tree[now]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h2><ul>
<li>在普通的非顺序存储的二叉树中，所有的没有两个子节点的节点会有空闲的指针没有被利用，<strong>线索二叉树做的实际上就是利用二叉树中空闲的指针再表示一些信息，从而使得在之后的操作中受益</strong>。比如树的Morris遍历，实际上就是利用了左子树最右节点的空闲指针从而使得遍历起来更加方便。</li>
</ul>
<h3 id="线索二叉树基本介绍"><a href="#线索二叉树基本介绍" class="headerlink" title="线索二叉树基本介绍"></a>线索二叉树基本介绍</h3><ul>
<li>n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)&#x3D;n+1】 个空指针域。<strong>利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”）</strong></li>
<li>这种<strong>加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)<strong>。根据线索性质的不同，线索二叉树可分为</strong>前序</strong>线索二叉树、<strong>中序</strong>线索二叉树和<strong>后序</strong>线索二叉树三种</li>
<li>一个结点的前一个结点，称为<strong>前驱结点</strong></li>
<li>一个结点的后一个结点，称为<strong>后继结点</strong></li>
</ul>
<h3 id="将二叉树线索化的流程"><a href="#将二叉树线索化的流程" class="headerlink" title="将二叉树线索化的流程"></a>将二叉树线索化的流程</h3><ul>
<li><p>将二叉树线索化实际上就是<strong>将特定遍历顺序中对应节点的前驱和后继记录到对应节点的空闲指针上去</strong>。所以根据遍历顺序的不同，线索二叉树可以分为前序、中序、后序线索二叉树三种，这些都是对于线索二叉树这个抽象的实现，实际上你也可以用别的方式实现不同的线索二叉树。</p>
</li>
<li><p>需要两个节点指针，其中一个<strong>node用来指向遍历到的节点</strong>，另外一个<strong>pre用来指向遍历到的节点的前一个遍历到的节点</strong>。<strong>设置当前节点的前驱节点需要让node对应节点（当前节点）的左指针指向pre对应的节点；设置当前节点的后继节点需要继续遍历到下一个节点（此时node指向了下一个遍历的节点，pre指向了当前节点）让pre对应节点（当前节点）的右指针指向node对应的节点</strong>。</p>
</li>
<li><p>中序线索二叉树示例：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221112122030580.png" alt="image-20221112122030580"></p>
<p>说明：当线索化二叉树后，Node 节点的 属性 left 和 right ，有如下情况:</p>
<ol>
<li>left 指向的是左子树，也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点。</li>
<li>right 指向的是右子树，也可能是指向后继节点，比如 ① 节点 right 指向的是右子树，而⑩ 节点的 right 指向的是后继节点。</li>
</ol>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  ```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 遍历线索化二叉树</span><br><span class="line"></span><br><span class="line">- 因为**线索化后，各个结点指向有变化，因此原来的遍历方式不能使用**，这时需要使用新的方式遍历线索化二叉树，各个节点**可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率**。 遍历的次序应当和线索化所用的遍历次序保持一致。</span><br><span class="line"></span><br><span class="line">- 代码示例：</span><br><span class="line"></span><br><span class="line">  ```java</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="二叉排序-查找-树"><a href="#二叉排序-查找-树" class="headerlink" title="二叉排序(查找)树"></a>二叉排序(查找)树</h2><h3 id="先看一个需求"><a href="#先看一个需求" class="headerlink" title="先看一个需求"></a>先看一个需求</h3><ul>
<li>给你一个数列 (7, 3, 10, 12, 5, 1, 9)，要求能够高效的完成对数据的查询和添加</li>
</ul>
<h3 id="解决方案分析"><a href="#解决方案分析" class="headerlink" title="解决方案分析"></a>解决方案分析</h3><ul>
<li>使用数组：<ul>
<li>数组未排序：优点：接在数组尾添加，速度快。 缺点：查找速度慢。</li>
<li>数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。</li>
</ul>
</li>
<li>使用链式存储-链表：不管链表是否有序，查找速度都慢；添加数据速度比数组快，不需要数据整体移动。</li>
<li>使用二叉排序树：既可以保证较快的查找速度，也可以保证较高的插入效率。</li>
</ul>
<h3 id="二叉排序树介绍"><a href="#二叉排序树介绍" class="headerlink" title="二叉排序树介绍"></a>二叉排序树介绍</h3><ul>
<li><p><strong>二叉排序树：BST (Binary Sort(Search) Tree)</strong>, 对于二叉排序树的任何一个非叶子节点，<strong>要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大</strong>。从更宏观的角度来看，<strong>任何一个非叶子节点的左子树的所有值都比该节点小，右子树的所有值都比该节点大</strong>。</p>
</li>
<li><p>特别说明：<strong>如果有相同的值，可以将和父节点相同的节点放在左子节点或右子节点都可以</strong>。</p>
</li>
<li><p>针对前面的数据(7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113092545691.png" alt="image-20221113092545691"></p>
</li>
</ul>
<h3 id="二叉排序树的创建和插入节点"><a href="#二叉排序树的创建和插入节点" class="headerlink" title="二叉排序树的创建和插入节点"></a>二叉排序树的创建和插入节点</h3><ul>
<li><p>二叉排序树创建的时候，<strong>对于每个要插入的节点，都要先和根节点比较，比根节点小的话就往左走，比根节点大的话就往右走，然后继续和左子节点或者右子节点比较，重复上述操作直到找到空位置进行插入</strong>。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  ```</span><br><span class="line"></span><br><span class="line">### 二叉排序树查找节点</span><br><span class="line"></span><br><span class="line">- **从根节点开始，如果要查找的节点比当前节点要小，就向左找；如果要查找的节点比当前节点要大，就向右找，重复上述操作直到找到或者没找到**。没啥好说的</span><br><span class="line"></span><br><span class="line">- 代码示例：</span><br><span class="line"></span><br><span class="line">  ```java</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="二叉排序树删除节点"><a href="#二叉排序树删除节点" class="headerlink" title="二叉排序树删除节点"></a>二叉排序树删除节点</h3><ul>
<li><p>二叉排序树的删除情况比较复杂，有下面三种情况需要考虑（以上面的数据为例）：</p>
<ol>
<li>删除叶子节点 (比如：2, 5, 9, 12)</li>
<li>删除只有一颗子树的节点 (比如：1)</li>
<li>删除有两颗子树的节点. (比如：7, 3，10 )</li>
</ol>
</li>
<li><p><strong>删除叶子节点的时候，只需要将其父节点对应的指针置空即可</strong>，没什么好说的；</p>
</li>
<li><p><strong>删除只有一颗子树的节点的时候，将其父节点的对应指针指向该节点的子节点即可</strong>，也就是要保证该节点的子树不会随着该节点的删除而丢失；</p>
</li>
<li><p><strong>删除有两棵子树的节点的时候</strong>，这种情况比较复杂但也比较巧妙，我们<strong>需要找到该节点的左子树的最大的节点或者右子树最小的节点，将找到的符合条件的节点的值赋值给该节点，然后对找到的那个符合条件的那个节点执行删除操作。由于找到的那个节点是左&#x2F;右子树的最值，根据二叉排序树的特性，它一定是叶节点，所以根据叶节点的删除方式对其删除即可</strong>。感慨一句，真是挺巧妙的，把删除非叶节点转换成了删除叶节点同时还保证了二叉排序树的结构。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="平衡二叉树-AVL树"><a href="#平衡二叉树-AVL树" class="headerlink" title="平衡二叉树(AVL树)"></a>平衡二叉树(AVL树)</h2><ul>
<li><strong>平衡二叉树本身就是一种特殊的二叉排序树，它身上有二叉排序树的所有特性</strong>。</li>
</ul>
<h3 id="通过一个案例来认识二叉排序树可能存在的问题"><a href="#通过一个案例来认识二叉排序树可能存在的问题" class="headerlink" title="通过一个案例来认识二叉排序树可能存在的问题"></a>通过一个案例来认识二叉排序树可能存在的问题</h3><ul>
<li>给你一个数列{1,2,3,4,5,6}，要求创建一颗二叉排序树(BST), 并分析问题所在。</li>
<li>如果让1作为根节点的话，后面所有的元素依次递增，也就是说后面的每一个元素都会是前一个元素的右子节点，这样的一颗<strong>二叉排序树实际上就退化成链表了，查询速度明显降低</strong>，数据一旦大起来，这样的性能折损显然是我们不能接受的。</li>
<li>就算不是上面这种非常极端的情况，平常也会出现<strong>二叉排序树的其中某些路径的深度很深的情况，那么查询这个路径上的节点的时候效率就会较低</strong>。</li>
<li>鉴于上面这种情况的存在，我们需要使用平衡二叉树来解决这种问题。</li>
</ul>
<h3 id="基本介绍-10"><a href="#基本介绍-10" class="headerlink" title="基本介绍"></a>基本介绍</h3><ul>
<li><p>平衡二叉树也叫<strong>平衡二叉搜索树（Self-balancing binary search tree）</strong>又被称为 AVL 树， 可以<strong>保证查询效率较高</strong>。</p>
</li>
<li><p>平衡二叉树具有以下特点：<strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树</strong>。平衡二叉树的常用实现方法有<strong>红黑树、AVL、替罪羊树、Treap、伸展树等</strong>。</p>
</li>
<li><p>平衡二叉树举例：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113103456817.png" alt="image-20221113103456817"></p>
<p>最右边的二叉树不是平衡二叉树，因为根节点的左右子树的高度差为2（一个是2一个是0），大于1，不符合平衡二叉树的定义。</p>
</li>
</ul>
<h3 id="平衡二叉树左旋转"><a href="#平衡二叉树左旋转" class="headerlink" title="平衡二叉树左旋转"></a>平衡二叉树左旋转</h3><ul>
<li><p>如果要是<strong>树的最右路径（一直往右走）长度过长的话，我们就需要对整棵树进行左旋转来尝试将最右路径的长度变短</strong>。</p>
</li>
<li><p>由于在创建和维护平衡二叉树的时候，每次插入一个新的节点都会触发判断平衡二叉树是否需要进行旋转，所以<strong>最多会出现高度差为2的不平衡</strong>，所以只需要针对这种情况设计旋转的过程即可。</p>
</li>
<li><p>左旋转通过<strong>将最右路径的高度分一个单位给最左路径来将最右路径的高度降低</strong>，这种方式通常通过将根节点分到左边，将根节点的右子节点提升为根节点来实现。</p>
</li>
<li><p>具体步骤就是：<strong>创建一个新节点，值等于根节点的右节点的值，新节点的左指针指向根节点，右指针指向根节点的右节点的右节点，然后让根节点的右节点指向根节点的右节点的左节点</strong>。</p>
</li>
<li><p>上面的操作实际上就是<strong>让新节点替代了根节点的右节点变成了整个树的根节点，根节点的右节点由于失去引用被回收了，从整体上看就相当于最右路径向左转了一下</strong>，由于二叉排序树的性质，根节点的右节点的左子树的所有值肯定是比根节点的右节点的值要小的，那么根节点的右节点提升为根节点的话，根节点的右节点的左子树肯定要放到提升为根节点的那个节点的左边，同时由于二叉排序树的性质，根节点的右节点的左子树的所有值肯定比原来的根节点的值要大，原来的根节点降低为新根节点的左节点，同时空闲出来了右指针，所以可以把原根节点的右节点的左子树放到平衡后的原根节点的右指针上。</p>
</li>
<li><p>思路分析图解：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113111118855.png" alt="image-20221113111118855"></p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="平衡二叉树右旋转"><a href="#平衡二叉树右旋转" class="headerlink" title="平衡二叉树右旋转"></a>平衡二叉树右旋转</h3><ul>
<li><p>如果要是<strong>树的最左路径（一直往左走）长度过长的话，我们就需要对整棵树进行右旋转来尝试将最左路径的长度变短</strong>。</p>
</li>
<li><p>由于在创建和维护平衡二叉树的时候，每次插入一个新的节点都会触发判断平衡二叉树是否需要进行旋转，所以<strong>最多会出现高度差为2的不平衡</strong>，所以只需要针对这种情况设计旋转的过程即可。</p>
</li>
<li><p>右旋转通过<strong>将最左路径的高度分一个单位给最右路径来将最左路径的高度降低</strong>，这种方式通常通过将根节点分到右边，将根节点的左子节点提升为根节点来实现。</p>
</li>
<li><p>具体步骤就是：<strong>创建一个新节点，值等于根节点的左节点的值，新节点的右指针指向根节点，左指针指向根节点的左节点的左节点，然后让根节点的左节点指向根节点的左节点的右节点</strong>。</p>
</li>
<li><p>上面的操作实际上就是<strong>让新节点替代了根节点的左节点变成了整个树的根节点，根节点的左节点由于失去引用被回收了，从整体上看就相当于最左路径向右转了一下</strong>，由于二叉排序树的性质，根节点的左节点的右子树的所有值肯定是比根节点的左节点的值要大的，那么根节点的左节点提升为根节点的话，根节点的左节点的右子树肯定要放到提升为根节点的那个节点的右边，同时由于二叉排序树的性质，根节点的左节点的右子树的所有值肯定比原来的根节点的值要小，原来的根节点降低为新根节点的右节点，同时空闲出来了左指针，所以可以把原根节点的左节点的右子树放到平衡后的原根节点的左指针上。</p>
</li>
<li><p>思路分析图解：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113111357063.png" alt="image-20221113111357063"></p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="平衡二叉树双旋转"><a href="#平衡二叉树双旋转" class="headerlink" title="平衡二叉树双旋转"></a>平衡二叉树双旋转</h3><ul>
<li><p>如果要是<strong>树的非最左最右路径过长的话，单用一次或右旋转或左旋转无法将树调整为平衡二叉树</strong>，这种时候就需要使用双旋转，核心思路就是<strong>先把长出来的部分转移到最左或者最右路径上，这一步通常需要一个旋转操作来实现，然后再进行左旋转或者右旋转</strong>。</p>
</li>
<li><p><strong>当根节点左子树的高度大于右子树且高度差大于1的时候，理应发生右旋转</strong>，但是<strong>如果根节点的左子树的右子树的高度大于根节点的左子树的左子树，一次右旋转无法将其调整为平衡二叉树</strong>，这时我们就需要<strong>先对根节点的左子树做一次左旋转，将高出来的高度旋转到最左路径上，然后就可以通过右旋转进行调整了</strong>。</p>
</li>
<li><p><strong>当根节点右子树的高度大于左子树且高度差大于1的时候，理应发生左旋转</strong>，但是<strong>如果根节点的右子树的左子树的高度大于根节点的右子树的右子树，一次左旋转无法将其调整为平衡二叉树</strong>，这时我们就需要<strong>先对根节点的右子树做一次右旋转，将高出来的高度旋转到最右路径上，然后就可以通过左旋转进行调整了</strong>。</p>
</li>
<li><p>思路分析图解：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113113223559.png" alt="image-20221113113223559"></p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="数据结构-多路查找树"><a href="#数据结构-多路查找树" class="headerlink" title="数据结构-多路查找树"></a>数据结构-多路查找树</h1><h2 id="多叉树与B树"><a href="#多叉树与B树" class="headerlink" title="多叉树与B树"></a>多叉树与B树</h2><h3 id="二叉树的问题分析"><a href="#二叉树的问题分析" class="headerlink" title="二叉树的问题分析"></a>二叉树的问题分析</h3><ul>
<li><p>二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113114141432.png" alt="image-20221113114141432"></p>
</li>
<li><p>二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如 1 亿)， 就存在如下问题：</p>
<ol>
<li>在构建二叉树时，需要多次进行 i&#x2F;o 操作(海量数据存在数据库或文件中)，<strong>节点海量，构建二叉树时，对速度有影响</strong>。</li>
<li><strong>节点海量，也会造成二叉树的高度很大，会降低操作速度</strong>。</li>
</ol>
</li>
</ul>
<h3 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h3><ul>
<li><p>在二叉树中，每个节点有数据项，最多有两个子节点。<strong>如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）</strong>。</p>
</li>
<li><p>后面我们讲解的 2-3 树，2-3-4 树就是多叉树，<strong>多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化</strong>。</p>
</li>
<li><p>多叉树示例（下面的2-3树就是一棵多叉树）：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113114500386.png" alt="image-20221113114500386"></p>
</li>
</ul>
<h3 id="B树的基本介绍"><a href="#B树的基本介绍" class="headerlink" title="B树的基本介绍"></a>B树的基本介绍</h3><ul>
<li><p>B树<strong>通过重新组织节点，降低树的高度，并且通过减少I&#x2F;O读写次数来提升效率</strong>。</p>
</li>
<li><p>B树示例：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221113114712207.png" alt="image-20221113114712207"></p>
</li>
<li><p>如图<strong>B树通过重新组织节点，降低了树的高度</strong>。</p>
</li>
<li><p><strong>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页（页的大小通常为4k），这样每个节点只需要一次I&#x2F;O就可以完全载入</strong>。</p>
</li>
<li><p>将树的度 M 设置为 1024，在 600 亿个元素中最多只需要 4 次 I&#x2F;O 操作就可以读取到想要的元素, <strong>B 树(B+)广泛应用于文件存储系统以及数据库系统中</strong>。</p>
</li>
<li><p>B树是个相对抽象的概念，2-3树、2-3-4树都是B树的一种实现。</p>
</li>
</ul>
<h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><h3 id="2-3树是最简单的B树结构"><a href="#2-3树是最简单的B树结构" class="headerlink" title="2-3树是最简单的B树结构"></a>2-3树是最简单的B树结构</h3><ul>
<li>2-3树具有如下特点：<ol>
<li>2-3 树的<strong>所有叶子节点都在同一层.(只要是 B 树都满足这个条件)</strong></li>
<li><strong>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点</strong>.</li>
<li><strong>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</strong>.</li>
<li>2-3 树是<strong>由二节点和三节点构成</strong>的树。</li>
</ol>
</li>
</ul>
<h3 id="2-3树应用案例"><a href="#2-3树应用案例" class="headerlink" title="2-3树应用案例"></a>2-3树应用案例</h3><ul>
<li><p>将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成 2-3 树，并保证数据插入的大小顺序：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114090342074.png" alt="image-20221114090342074"></p>
</li>
</ul>
<h3 id="2-3树节点插入规则"><a href="#2-3树节点插入规则" class="headerlink" title="2-3树节点插入规则"></a>2-3树节点插入规则</h3><ol>
<li>2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件)</li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.</li>
<li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</li>
<li>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，<strong>先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面 3 个条件</strong>。</li>
<li><strong>对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则，除此之外，三节点内部的两个元素也应该是有序的</strong>。</li>
</ol>
<h3 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h3><ul>
<li><p>除了 23 树，还有 234 树等，概念和 23 树类似，也是一种 B 树。 如图:</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114092600003.png" alt="image-20221114092600003"></p>
</li>
</ul>
<h2 id="B树、B-树和B-树"><a href="#B树、B-树和B-树" class="headerlink" title="B树、B+树和B*树"></a>B树、B+树和B*树</h2><h3 id="B树的介绍"><a href="#B树的介绍" class="headerlink" title="B树的介绍"></a>B树的介绍</h3><ul>
<li><p><strong>B-tree 树即 B 树，B 即 Balanced，平衡的意思</strong>。有人把 B-tree 翻译成 B-树，容易让人产生误解。会以为 B-树是一种树，而 B 树又是另一种树。实际上，<strong>B-tree 就是指的 B 树</strong>。</p>
</li>
<li><p>前面已经介绍了 2-3 树和 2-3-4 树，他们就是 B 树(英语：B-tree 也写成 B-树)，这里我们再做一个说明，我们在学习 Mysql 时，经常听到说某种类型的索引是基于 B 树或者 B+树的，如图:</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114092747019.png" alt="image-20221114092747019"></p>
</li>
<li><p>对B树的说明：</p>
<ol>
<li><strong>B树的阶：节点的最多子节点个数</strong>。比如 2-3 树的阶是 3，2-3-4 树的阶是 4</li>
<li>B-树的搜索，<strong>从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</strong>。</li>
<li>关键字集合分布在整颗树中, 即<strong>叶子节点和非叶子节点都存放数据</strong>。</li>
<li><strong>搜索有可能在非叶子结点结束</strong></li>
<li>其<strong>搜索性能等价于在关键字全集内做一次二分查找</strong></li>
</ol>
</li>
</ul>
<h3 id="B-树的介绍"><a href="#B-树的介绍" class="headerlink" title="B+树的介绍"></a>B+树的介绍</h3><ul>
<li><p>B+树是B树的变体，也是一种多路搜索树：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114093141034.png" alt="image-20221114093141034"></p>
</li>
<li><p>对B+树的说明：</p>
<ol>
<li>B+树的搜索与 B 树也基本相同，区别是<strong>B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</strong>。</li>
<li><strong>所有关键字都出现在叶子结点的链表中</strong>（即<strong>数据只能在叶子节点</strong>【也叫<strong>稠密索引</strong>】），且<strong>链表中的关键字(数据)恰好是有序的</strong>。</li>
<li><strong>不可能在非叶子结点命中</strong></li>
<li><strong>非叶子结点相当于是叶子结点的索引（稀疏索引）</strong>，<strong>叶子结点相当于是存储（关键字）数据的数据层</strong></li>
<li>更<strong>适合文件索引系统</strong></li>
<li>B 树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然.</li>
</ol>
</li>
</ul>
<h3 id="B-树的介绍-1"><a href="#B-树的介绍-1" class="headerlink" title="B*树的介绍"></a>B*树的介绍</h3><ul>
<li><p>B*树是 B+树的变体，<strong>在B+树的非根和非叶子结点再增加指向兄弟的指针</strong>：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221114093538855.png" alt="image-20221114093538855"></p>
</li>
<li><p>对B*树的说明：</p>
<ol>
<li>B*树定义了<strong>非叶子结点关键字个数至少为(2&#x2F;3)*M</strong>，即<strong>块的最低使用率为 2&#x2F;3</strong>，而<strong>B+树的块的最低使用率为的1&#x2F;2</strong>。</li>
<li>从第 1 个特点我们可以看出，<strong>B*树分配新结点的概率比B+树要低，空间使用率更高</strong>。</li>
</ol>
</li>
</ul>
<h1 id="数据结构-并查集"><a href="#数据结构-并查集" class="headerlink" title="数据结构-并查集"></a>数据结构-并查集</h1><h2 id="基本介绍-11"><a href="#基本介绍-11" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul>
<li>并查集作为一种简洁而优雅的树形数据结构，主要用于解决一些<strong>元素分组</strong>的问题，它<strong>管理着一系列不相交的集合</strong>，并支持两种操作：<ol>
<li><strong>合并（Union）</strong>：把两个不相交的集合合并为一个集合。</li>
<li><strong>查询（Find）</strong>：查询两个元素是否在同一个集合中。</li>
</ol>
</li>
</ul>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>在最基础的应用中，抽象后的点集都是按顺序的数字，此时我们只<strong>需要一个一维数组f来表示元素之间的关系</strong>，如果<strong>f[i]&#x3D;j说明i的父节点是j</strong>，那么它们肯定有相同的根节点，也就是说明i和j是属于同一组的，在这个一维数组中，<strong>两者拥有相同根节点的元素都是属于同一组的</strong>。</p>
</li>
<li><p>对于一维数组f的初始化，应该<strong>把每个元素的值初始化成它的下标，表示刚开始的时候所有元素彼此独立</strong>，互相之间没有从属关系，所以<strong>如果后面出现一个元素的值为它的下标，说明它是独立的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n];<span class="comment">//并查集数组,f[i]=j说明i的父亲节点是j</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;<span class="comment">//初始化每个节点都是独立的，即他们的father都是自己</span></span><br><span class="line">    f[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>首先来看<strong>查询（Find）操作</strong>，这个操作的最终目的是查询两个元素是否在同一个集合中，那么我们不妨<strong>把这个操作的粒度降低，让每次Find操作都查询一个元素的根节点，这样可以在后续编码时带来更高的灵活性</strong>，判定两个元素是否同一组就是判断两个元素的根节点是否相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] f,<span class="type">int</span> v)</span>&#123;<span class="comment">//找一个元素的根节点</span></span><br><span class="line">        <span class="keyword">return</span> f[v]==v?v:(f[v] = find(f,f[v]));<span class="comment">//如果该点独立，直接返回;如果该点不独立,往后找根节点，顺便进行路径压缩</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们<strong>通过递归去找元素对应的根节点</strong>，实际上<strong>在递归的过程中做了一个路径压缩的优化</strong>，路径压缩就是说<strong>把递归过程中经过的所有节点的父节点都变成它们的根节点，这样做可以使后面再次查找这条递归链上元素根节点的时间复杂度降低，由于递归过程中经过的节点拥有相同的根节点，所以保证了该操作的正确性</strong>。</p>
</li>
<li><p>再来看<strong>合并（Union）操作</strong>，这个操作的目的是<strong>如果两个元素本来不是同一组的，那么就将两个元素合并到同一组中</strong>，反映到数据结构上就是让一个元素变成另外一个元素的父亲。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] f,<span class="type">int</span> u,<span class="type">int</span> v)</span>&#123;<span class="comment">//合并操作，其中可以做优化：直接把两者的根节点合并</span></span><br><span class="line">        <span class="keyword">return</span> (u = find(f,u))==(v = find(f,v))?<span class="literal">false</span>:(f[v]=u)==u;<span class="comment">//先找到各自的根，然后比较，如果相同说明已经合并无需再合并，返回false；如果不相同就合并，返回true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>本来是让其中一个元素的根节点合并到另外一个元素上面的，但是上面的代码中也做了一个优化，那就是<strong>直接把两者的根节点合并，可以缩短递归链的长度，优化时间复杂度</strong>。</p>
</li>
</ul>
<h2 id="带权并查集"><a href="#带权并查集" class="headerlink" title="带权并查集"></a>带权并查集</h2><ul>
<li><p>如果我们把并查集的元素都拿出来，然后用有向边从子元素连接到父元素来表示他们之间的父子关系，那么我们得到一个有向图，在上面的并查集中，有向边是没有权值的，它仅表示一种关系。但是<strong>在带权并查集中，元素和元素之间的有向边是有权值的，所以带权并查集除了有一个维护元素的父元素的数组之外，还有一个维护元素和父元素之间的有向边的权值的数组，具体这个权值的定义需要结合具体情况进行定义</strong>。</p>
</li>
<li><p>带权并查集的其中一个<strong>难点在于如何在进行路径压缩的时候正确维护权值数组</strong>，因为进行路径压缩的时候，节点之间的关系会进行改变，所以大部分情况下我们需要根据具体情况来判断如何正确维护权值数组才能使得权值数组是有效的。</p>
</li>
<li><p>如果我们想将一个非线性结构的元素放到并查集中怎么办？可以<strong>维护一个map来做元素和并查集数组下标的映射</strong>。</p>
</li>
<li><p>在思考如何正确维护权值数组的时候，可以<strong>将并查集当成一个有向图，用纸笔进行推导，这样比较容易得出结论</strong>。</p>
</li>
<li><p>代码示例，下面这个题维护权值数组的方式可以看官方题解，是有推导的：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230127104534916.png" alt="image-20230127104534916"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="type">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">equationSize</span> <span class="operator">=</span> equations.size();</span><br><span class="line">        <span class="comment">//并查集的大小开两倍的equationSize是因为在最极端的情况下，equation中所有元素都不同，所以这里考虑的是上界</span></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">unionFind</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(<span class="number">2</span>*equationSize);</span><br><span class="line">        <span class="comment">//由于并查集的底层是用数组实现的，所以需要这个map用于映射不同的元素在并查集中的数组中的位置</span></span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//在并查集数组中的位置从0开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;equationSize;++i)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> equations.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> equations.get(i).get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//将其中以前没有加入并查集的元素加入并查集，体现在把元素映射到并查集数组的下标上</span></span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(s1))&#123;</span><br><span class="line">                map.put(s1,id++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(s2))&#123;</span><br><span class="line">                map.put(s2,id++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//两个元素在一组中，我们需要用并查集维护他们的关系和权值，这个权值就是子元素/父元素的值</span></span><br><span class="line">            unionFind.union(map.get(s1),map.get(s2),values[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">queriesSize</span> <span class="operator">=</span> queries.size();</span><br><span class="line">        <span class="type">double</span>[] ans = <span class="keyword">new</span> <span class="title class_">double</span>[queriesSize];<span class="comment">//答案数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;queriesSize;++i)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> queries.get(i).get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//获取两个元素在并查集中的位置</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">id1</span> <span class="operator">=</span> map.get(s1);</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">id2</span> <span class="operator">=</span> map.get(s2);</span><br><span class="line">            <span class="keyword">if</span>(id1==<span class="literal">null</span>||id2==<span class="literal">null</span>)&#123;<span class="comment">//如果两个元素中任何一个元素在并查集中不存在，那么答案都是无法计算的，返回-1.0d</span></span><br><span class="line">                ans[i] = -<span class="number">1.0d</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果两个元素都在并查集中存在，那么我们可以直接从并查集中获取答案</span></span><br><span class="line">                ans[i] = unionFind.getAns(id1,id2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;<span class="comment">//带权并查集</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] parent;<span class="comment">//维护父子关系</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">double</span>[] weight;<span class="comment">//维护当前元素指向其父节点的权值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="built_in">this</span>.weight = <span class="keyword">new</span> <span class="title class_">double</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) &#123;<span class="comment">//初始化父子关系数组，每个元素的父亲先设置成是自己，针对这题，权值的意思是子元素除以父元素所以权值都先初始化为1</span></span><br><span class="line">                parent[i] = i;</span><br><span class="line">                weight[i] = <span class="number">1.0d</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">double</span> value)</span>&#123;<span class="comment">//并查集的合并操作</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);<span class="comment">//找x的根节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);<span class="comment">//找y的根节点</span></span><br><span class="line">            <span class="keyword">if</span>(rootX!=rootY)&#123;<span class="comment">//如果x和y的根节点不相同，说明我们可以进行合并操作，如果相同说明他们已经合并过了，不用再合并了</span></span><br><span class="line">                parent[rootX] = rootY;<span class="comment">//将x的根节点的父亲设置为y的根节点</span></span><br><span class="line">                weight[rootX] = weight[y]*value/weight[x];<span class="comment">//维护并查集的权值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;<span class="comment">//并查集的查操作</span></span><br><span class="line">            <span class="keyword">if</span>(x != parent[x])&#123;<span class="comment">//如果当前元素的父亲不是自己，那么就要找当前元素的根节点顺便进行路径压缩</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">origin</span> <span class="operator">=</span> parent[x];<span class="comment">//先记录下当前元素的父节点，因为之后的路径压缩会改变当前元素的父节点</span></span><br><span class="line">                parent[x] = find(parent[x]);<span class="comment">//路径压缩</span></span><br><span class="line">                weight[x] *= weight[origin];<span class="comment">//维护被压缩的路径上的权值，从下面压缩上去的权值是路径中的权值之积</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAns</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;<span class="comment">//得到x/y的答案</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);<span class="comment">//找到x的根节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);<span class="comment">//找到y的根节点</span></span><br><span class="line">            <span class="keyword">if</span>(rootX == rootY)&#123;<span class="comment">//如果x和y的根节点相同，说明可以通过下面这个式子得到答案</span></span><br><span class="line">                <span class="keyword">return</span> weight[x]/weight[y];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果x和y的根节点不相同，那么说明我们无法通过给的条件得到答案，返回-1.0d</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1.0d</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="数据结构-稀疏数组（Sparsearray）"><a href="#数据结构-稀疏数组（Sparsearray）" class="headerlink" title="数据结构-稀疏数组（Sparsearray）"></a>数据结构-稀疏数组（Sparsearray）</h1><h2 id="需求场景示例"><a href="#需求场景示例" class="headerlink" title="需求场景示例"></a>需求场景示例</h2><ul>
<li><p>编写一个五子棋程序，有存盘退出的功能和续上盘的功能。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031201730800.png" alt="image-20221031201730800"></p>
</li>
<li><p>问题分析：要想实现这些功能，就需要对棋局进行持久化，而大部分情况下棋局对应的二维数组都是比较稀疏的，因此有很多没有意义的数据，这些没有意义的数据如果做持久化，就会对空间产生额外的消耗，因此为了应对这种情况，我们<strong>可以使用稀疏数组来对数组进行存储，在特定情况下使用可以减少空间的开销</strong>。</p>
</li>
</ul>
<h2 id="基本介绍-12"><a href="#基本介绍-12" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul>
<li><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
</li>
<li><p>稀疏数组的处理方法是:</p>
<ol>
<li>在稀疏数组的<strong>第一个元素中存放原数组的行数、列数、元素数</strong>。</li>
<li>在稀疏数组<strong>除了第一个元素后面的每一个空间中记录原数组的一个元素所在的行数、列数和值</strong>。</li>
</ol>
</li>
<li><p>稀疏数组举例说明：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031202328310.png" alt="image-20221031202328310"></p>
</li>
</ul>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><ul>
<li><p>使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)</p>
</li>
<li><p>把稀疏数组存盘，并且可以重新恢复原来的二维数组。</p>
</li>
<li><p>整体思路分析：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031202449600.png" alt="image-20221031202449600"></p>
</li>
<li><p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.sparsearray;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建一个原始的二维数组 11 * 11</span></span><br><span class="line">		<span class="comment">// 0: 表示没有棋子， 1 表示 黑子 2 表蓝子</span></span><br><span class="line">		<span class="type">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">		chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">		chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">		chessArr1[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">		<span class="comment">// 输出原始的二维数组</span></span><br><span class="line">		System.out.println(<span class="string">&quot;原始的二维数组~~&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr1) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line">				System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将二维数组 转 稀疏数组的思</span></span><br><span class="line">		<span class="comment">// 1. 先遍历二维数组 得到非 0 数据的个数</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">					sum++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2. 创建对应的稀疏数组</span></span><br><span class="line">		<span class="type">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">		<span class="comment">// 给稀疏数组赋值</span></span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">		<span class="comment">// 遍历二维数组，将非 0 的值存放到 sparseArr 中</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//count 用于记录是第几个非 0 数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">					count++;</span><br><span class="line">					sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">					sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">					sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 输出稀疏数组的形式</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">&quot;得到稀疏数组为~~~~&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">			System.out.printf(<span class="string">&quot;%d\t%d\t%d\t\n&quot;</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="comment">//将稀疏数组 --》 恢复成 原始的二维数组</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2 = int[11][11]</span></span><br><span class="line"><span class="comment">		   2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line">		<span class="type">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">		<span class="comment">//2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">			chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">&quot;恢复后的二维数组&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr2) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line">				System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="数据结构-单调队列（Monotone-Queue）"><a href="#数据结构-单调队列（Monotone-Queue）" class="headerlink" title="数据结构-单调队列（Monotone Queue）"></a>数据结构-单调队列（Monotone Queue）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p>通过一道题来引出这个数据结构：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221222203612061.png" alt="image-20221222203612061"></p>
</li>
<li><p>上面这个题呢，在解决的过程中我们就非常可以体会到单调队列的原理、适用场景以及实现单调队列的底层逻辑，所以很适合用来入门单调队列。</p>
</li>
<li><p>单调队列通常和滑动窗口结合来解决一些最值问题。</p>
</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>顾名思义，单调队列，队列不是关键，单调才是关键，<strong>单调意味着队列中的数字排列是非上升或非下降的</strong>，除了这个特性之外，别的和普通的队列别无二致。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul>
<li>单调队列<strong>一般都是用双端队列实现</strong>（下面以不递增的单调队列为例，不递减的反过来就行），每次向单调队列中push元素的时候都要从后面开始依次让小于该元素的元素出队，直到队尾元素大于等于该元素，此时才能将该元素push进去，这样做的目的是为了维持队列的单调性。</li>
<li>别的操作就和普通的双端队列一样了。</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>那么我们知道了单调队列的定义和实现之后，我们应该如何去应用它呢，这时我们回看上面的那个题，题目要求三个操作的均摊复杂度是O(1)，那么我们可以考虑维护一个单调队列，<strong>每次向普通队列中添加元素，就对应着也给单调队列添加相同的元素</strong>，<strong>单调队列通过相应的操作来调整自身以满足“单调”的条件</strong>，在<strong>查找最大值的时候实际上只要把单调队列的队首元素返回即可，因为它是单调的</strong>，如果我们规定它的规则是不递增，那么队首元素就是普通队列中的最大值。在<strong>做元素出队操作的时候，除了要让普通队列的元素出队之外还应该判断一下单调队列是否满足元素出队的条件</strong>，如果出队的元素正好是单调队列的队首元素，这说明普通队列的这个元素出队后，最大值不一定还是这个值了，这个时候单调队列队首的元素就应该出队，防止错误的最值影响到普通队列后面的元素。</li>
<li>为什么像上面那样做可以解决问题呢，因为<strong>每当普通队列push元素的时候，这个元素很有可能对某个长度的队列的最大值有影响，而且这个影响一直持续到第一个大于等于它的那个地方</strong>，比如6，1，2，3这个队列，如果我要向其中push一个4，这个4虽然对当前的最大值没有影响，但是它会对6pop之后的队列的最大值产生影响，这个影响是一直延续到第一个大于等于4的值也就是6那里的，在6之前，队列的最大值不受4的影响，但是在6没了之后的队列最大值就会受4的影响，所以单调队列插入4的时候会将3，2，1从后面pop掉，目的就是为了让4这个部分队列的最大值影响到它该影响到的地方，这样6pop掉后，单调队列的6肯定也pop掉了，此时求最大值，我们只需要将队列中的新首部4返回即可，如果要pop1，那千万别把单调队列中的4pop掉，因为4还会对pop掉1之后的队列产生影响，但是注意这个影响的也不是后面全部的队列，如果要是普通队列pop到了4，那么单调队列就应该将4pop掉，防止4影响到再后面的队列。</li>
</ul>
<h2 id="代码示例-25"><a href="#代码示例-25" class="headerlink" title="代码示例"></a>代码示例</h2><ul>
<li><p>就是上面那个题的代码，可以用来理解单调队列的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; qu = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//普通队列</span></span><br><span class="line">    Deque&lt;Integer&gt; monotoneQu = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//单调队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxQueue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max_value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(qu.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> monotoneQu.getFirst();<span class="comment">//求最大值可以直接返回单调队列的头</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        qu.addLast(value);</span><br><span class="line">        <span class="keyword">while</span> (!monotoneQu.isEmpty()&amp;&amp;monotoneQu.getLast()&lt;value)&#123;<span class="comment">//向单调队列中添加元素的时候要让队列尾部不满足单调条件的元素从尾部出队直到将目标元素入队后队列是单调的或者队列为空，然后再将目标元素入队</span></span><br><span class="line">            monotoneQu.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        monotoneQu.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(qu.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>((<span class="type">int</span>)qu.getFirst()==(<span class="type">int</span>)monotoneQu.getFirst())&#123;<span class="comment">//如果要是普通队列中要pop的元素和单调队列的头相同，说明这个元素的影响力已经到尽头了，它无权影响后面的队列了，所以要随着普通队列一起pop掉；但是如果要是普通队列要pop的元素和单调队列的头不同，说明单调队列的头元素的影响力还能再存在一段时间，这种情况下就不用pop单调队列。</span></span><br><span class="line">            monotoneQu.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> qu.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.max_value();</span></span><br><span class="line"><span class="comment"> * obj.push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>还有另外一个结合了滑动窗口的题，把那个的代码也放这儿吧：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221222214301014.png" alt="image-20221222214301014"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="literal">null</span>||nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>,right=k-<span class="number">1</span>;<span class="comment">//滑动窗口的左右指针</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length-k+<span class="number">1</span>];<span class="comment">//答案数组</span></span><br><span class="line">        Deque&lt;Integer&gt; monotone = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//单调队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=left;i&lt;=right;++i)&#123;<span class="comment">//先把第一个窗口预处理掉</span></span><br><span class="line">            <span class="comment">//还是单调队列添加元素的流程</span></span><br><span class="line">            <span class="keyword">while</span> (!monotone.isEmpty()&amp;&amp;monotone.getLast()&lt;nums[i]) monotone.removeLast();</span><br><span class="line">            monotone.addLast(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//答案数组的索引</span></span><br><span class="line">        <span class="comment">//处理第一个答案值</span></span><br><span class="line">        <span class="keyword">if</span>(nums[left]==monotone.getFirst()) ans[idx++] = monotone.removeFirst();</span><br><span class="line">        <span class="keyword">else</span> ans[idx++] = monotone.getFirst();</span><br><span class="line">        <span class="keyword">while</span> (right+<span class="number">1</span>&lt;nums.length)&#123;<span class="comment">//滑动窗口</span></span><br><span class="line">            right++;<span class="comment">//窗口右端点右滑</span></span><br><span class="line">            <span class="comment">//还是单调队列添加元素的流程</span></span><br><span class="line">            <span class="keyword">while</span> (!monotone.isEmpty()&amp;&amp;monotone.getLast()&lt;nums[right]) monotone.removeLast();</span><br><span class="line">            monotone.addLast(nums[right]);</span><br><span class="line">            left++;<span class="comment">//窗口左端点右滑</span></span><br><span class="line">            <span class="comment">//窗口更新，更新答案数组</span></span><br><span class="line">            <span class="keyword">if</span>(nums[left]==monotone.getFirst()) ans[idx++] = monotone.removeFirst();</span><br><span class="line">            <span class="keyword">else</span> ans[idx++] = monotone.getFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="数据结构-单调栈（Monotone-Stack）"><a href="#数据结构-单调栈（Monotone-Stack）" class="headerlink" title="数据结构-单调栈（Monotone Stack）"></a>数据结构-单调栈（Monotone Stack）</h1><ul>
<li><p>用c语言写了个单调栈，也是用了一个辅助栈来实现，两个栈协调工作来实现这个数据结构，思路和单调队列差不多。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 10005</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> num[N];<span class="comment">//存原始数据的栈 </span></span><br><span class="line">	<span class="type">int</span> mono[N];<span class="comment">//单调栈，栈头是目前的最大值 </span></span><br><span class="line">	<span class="type">int</span> nump; </span><br><span class="line">	<span class="type">int</span> monop;</span><br><span class="line">&#125;Stack;<span class="comment">//单调栈 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack *st,<span class="type">int</span> num)</span>&#123;<span class="comment">//单调栈的push </span></span><br><span class="line">	st-&gt;num[(st-&gt;nump)++] = num;<span class="comment">//先把数据放到原始栈中 </span></span><br><span class="line">	<span class="keyword">if</span>(st-&gt;monop==<span class="number">0</span>||num&gt;=st-&gt;mono[(st-&gt;monop)<span class="number">-1</span>]) st-&gt;mono[(st-&gt;monop)++] = num;<span class="comment">//如果当前数据大于单调栈的栈头，那么也把这个数字放到单调栈中 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *st)</span>&#123;<span class="comment">//单调栈的pop </span></span><br><span class="line">	<span class="keyword">if</span>(st-&gt;nump==<span class="number">0</span>)&#123;<span class="comment">//栈为空的特殊情况 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;empty\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(st-&gt;num[st-&gt;nump<span class="number">-1</span>]==st-&gt;mono[st-&gt;monop<span class="number">-1</span>])&#123;<span class="comment">//如果当前原始栈和单调栈的栈头数据相同，那么就把两个栈都pop一下 </span></span><br><span class="line">		(st-&gt;monop)--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> k = st-&gt;num[--(st-&gt;nump)];</span><br><span class="line">	<span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getTop</span><span class="params">(Stack *st)</span>&#123;<span class="comment">//获取原始栈栈顶元素 </span></span><br><span class="line">	<span class="keyword">if</span>(st-&gt;nump==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;empty\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> st-&gt;num[st-&gt;nump<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getMax</span><span class="params">(Stack *st)</span>&#123;<span class="comment">//获取单调栈栈顶元素也就是目前栈中元素的最大值 </span></span><br><span class="line">	<span class="keyword">if</span>(st-&gt;nump==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;empty\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> st-&gt;mono[st-&gt;monop<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(Stack *st)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;st-&gt;nump;++i)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,st-&gt;num[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;st-&gt;monop;++i)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,st-&gt;mono[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Stack st = &#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">0</span>&#125;,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> op = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;1.push 2.pop 3.getTop 4.getMax 5.output 6.quit\n&quot;</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">		<span class="keyword">switch</span>(op)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;enter push number:\n&quot;</span>);</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;op);</span><br><span class="line">				push(&amp;st,op); </span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,pop(&amp;st));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,getTop(&amp;st));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">4</span>:&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,getMax(&amp;st));</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">5</span>:&#123;</span><br><span class="line">				output(&amp;st);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">6</span>:&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">default</span>:&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="数据结构-优先队列（Priority-Queue）"><a href="#数据结构-优先队列（Priority-Queue）" class="headerlink" title="数据结构-优先队列（Priority Queue）"></a>数据结构-优先队列（Priority Queue）</h1><ul>
<li><p>用c语言写了个小根堆，可以作为优先队列的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PriorQu</span>&#123;</span><span class="comment">//优先队列 </span></span><br><span class="line">	<span class="type">int</span> * arr;<span class="comment">//顺序存储的小根堆 </span></span><br><span class="line">	<span class="type">int</span> size;<span class="comment">//堆中元素个数 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PriorQu</span> *<span class="title">pq</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(pq,<span class="type">int</span>)</span>;<span class="comment">//向堆中增加元素 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">siftDown</span><span class="params">(pq,<span class="type">int</span>)</span>;<span class="comment">//元素下沉操作 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftUp</span><span class="params">(pq,<span class="type">int</span>)</span>;<span class="comment">//元素上浮操作 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">del</span><span class="params">(pq)</span>;<span class="comment">//删除堆顶元素 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(pq qu,<span class="type">int</span> num)</span>&#123;<span class="comment">//向堆中增加元素 </span></span><br><span class="line">	<span class="type">int</span> now = qu-&gt;size;<span class="comment">//获取现在堆中元素数量 </span></span><br><span class="line">	qu-&gt;arr[qu-&gt;size++] = num;<span class="comment">//向堆尾加入一个元素 </span></span><br><span class="line">	<span class="keyword">while</span>(now!=<span class="number">0</span>&amp;&amp;qu-&gt;arr[(now<span class="number">-1</span>)/<span class="number">2</span>]&gt;num)&#123;<span class="comment">//然后将新加入的元素上浮至顶或至无法上浮 </span></span><br><span class="line">		siftUp(qu,now);<span class="comment">//上浮 </span></span><br><span class="line">		now = (now<span class="number">-1</span>)/<span class="number">2</span>;<span class="comment">//得到新元素上浮后的下标，方便下次上浮 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">del</span><span class="params">(pq qu)</span>&#123;<span class="comment">//删除堆顶元素</span></span><br><span class="line">	<span class="comment">//将堆顶元素和堆底元素交换位置 </span></span><br><span class="line">	<span class="type">int</span> temp = qu-&gt;arr[<span class="number">0</span>]; </span><br><span class="line">	qu-&gt;arr[<span class="number">0</span>] = qu-&gt;arr[qu-&gt;size<span class="number">-1</span>];</span><br><span class="line">	qu-&gt;arr[qu-&gt;size<span class="number">-1</span>] = temp;</span><br><span class="line">	<span class="comment">//记录下堆顶元素，最后返回这个值 </span></span><br><span class="line">	<span class="type">int</span> ans = temp;</span><br><span class="line">	<span class="comment">//准备让当前的堆顶元素，也就是之前的堆底元素下沉 </span></span><br><span class="line">	temp = qu-&gt;arr[<span class="number">0</span>];<span class="comment">//记录当前的堆顶元素 </span></span><br><span class="line">	qu-&gt;size--;<span class="comment">//别忘了将堆的大小-1，这样就逻辑删除了当前堆尾的元素 </span></span><br><span class="line">	<span class="type">int</span> now = <span class="number">0</span>;<span class="comment">//记录当前堆顶元素的下标，方便下沉操作 </span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;<span class="comment">//一直下沉到无法下沉 </span></span><br><span class="line">		<span class="keyword">if</span>(now*<span class="number">2</span>+<span class="number">1</span>&gt;=qu-&gt;size) <span class="keyword">break</span>;<span class="comment">//左右都为空时无法下沉，这里的判断条件是用到了完全二叉树的性质 </span></span><br><span class="line">		<span class="keyword">if</span>(temp&lt;=qu-&gt;arr[now*<span class="number">2</span>+<span class="number">1</span>]&amp;&amp;now*<span class="number">2</span>+<span class="number">2</span>&gt;=qu-&gt;size) <span class="keyword">break</span>;<span class="comment">//右边为空，左边非空但大于等于当前值时也无法下沉 </span></span><br><span class="line">		<span class="keyword">if</span>(temp&gt;qu-&gt;arr[now*<span class="number">2</span>+<span class="number">1</span>]&amp;&amp;now*<span class="number">2</span>+<span class="number">2</span>&gt;=qu-&gt;size)&#123;<span class="comment">//右边为空，左边非空且小于当前值时，可以下沉一次，下沉后必定无法再次下沉 </span></span><br><span class="line">			now = siftDown(qu,now);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(temp&lt;=qu-&gt;arr[now*<span class="number">2</span>+<span class="number">1</span>]&amp;&amp;temp&lt;=qu-&gt;arr[now*<span class="number">2</span>+<span class="number">2</span>]) <span class="keyword">break</span>;<span class="comment">//左右非空，但都大于等于当前元素时无法下沉 </span></span><br><span class="line">		now = siftDown(qu,now);<span class="comment">//左右非空，且至少有一个元素小于当前元素时，下沉 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;<span class="comment">//返回被删除的元素 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">siftDown</span><span class="params">(pq qu,<span class="type">int</span> pos)</span>&#123;<span class="comment">//下沉操作 </span></span><br><span class="line">	<span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(pos*<span class="number">2</span>+<span class="number">2</span>&gt;=qu-&gt;size)&#123;<span class="comment">//右边越界，往左沉 </span></span><br><span class="line">		temp = qu-&gt;arr[pos];</span><br><span class="line">		qu-&gt;arr[pos] = qu-&gt;arr[pos*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">		qu-&gt;arr[pos*<span class="number">2</span>+<span class="number">1</span>] = temp;</span><br><span class="line">		<span class="keyword">return</span> pos*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//左右都不越界时，下沉到值比较小的一边 </span></span><br><span class="line">	<span class="keyword">if</span>(qu-&gt;arr[pos*<span class="number">2</span>+<span class="number">1</span>]&gt;qu-&gt;arr[pos*<span class="number">2</span>+<span class="number">2</span>])&#123;</span><br><span class="line">		temp = qu-&gt;arr[pos];</span><br><span class="line">		qu-&gt;arr[pos] = qu-&gt;arr[pos*<span class="number">2</span>+<span class="number">2</span>];</span><br><span class="line">		qu-&gt;arr[pos*<span class="number">2</span>+<span class="number">2</span>] = temp;</span><br><span class="line">		<span class="keyword">return</span> pos*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		temp = qu-&gt;arr[pos];</span><br><span class="line">		qu-&gt;arr[pos] = qu-&gt;arr[pos*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">		qu-&gt;arr[pos*<span class="number">2</span>+<span class="number">1</span>] = temp;</span><br><span class="line">		<span class="keyword">return</span> pos*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">siftUp</span><span class="params">(pq qu,<span class="type">int</span> pos)</span>&#123;<span class="comment">//上浮操作</span></span><br><span class="line">	<span class="comment">//交换当前元素和其父亲的位置 </span></span><br><span class="line">	<span class="type">int</span> temp = qu-&gt;arr[pos];</span><br><span class="line">	qu-&gt;arr[pos] = qu-&gt;arr[(pos<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">	qu-&gt;arr[(pos<span class="number">-1</span>)/<span class="number">2</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span> len,temp;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;len);<span class="comment">//堆的大小 </span></span><br><span class="line">	pq qu = (pq)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> PriorQu));</span><br><span class="line">	qu-&gt;arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*len);</span><br><span class="line">	qu-&gt;size = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;++i)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;temp);<span class="comment">//每输入一个元素就将其加入到堆中并调整 </span></span><br><span class="line">		add(qu,temp);</span><br><span class="line"><span class="comment">//		for(int i=0;i&lt;qu-&gt;size;++i)&#123;</span></span><br><span class="line"><span class="comment">//			printf(&quot;%d &quot;,qu-&gt;arr[i]);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		printf(&quot;\n&quot;);</span></span><br><span class="line">		<span class="comment">//printf(&quot;%d &quot;,qu-&gt;size);	</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;<span class="comment">//最后结果 </span></span><br><span class="line">	<span class="keyword">while</span>(qu-&gt;size!=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//		for(int i=0;i&lt;qu-&gt;size;++i)&#123;</span></span><br><span class="line"><span class="comment">//			printf(&quot;%d &quot;,qu-&gt;arr[i]);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		printf(&quot;\n&quot;);</span></span><br><span class="line">		temp = <span class="number">0</span>;</span><br><span class="line">		temp+=del(qu);</span><br><span class="line"><span class="comment">//		for(int i=0;i&lt;qu-&gt;size;++i)&#123;</span></span><br><span class="line"><span class="comment">//			printf(&quot;%d &quot;,qu-&gt;arr[i]);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		printf(&quot;\n&quot;);</span></span><br><span class="line">		temp+=del(qu);</span><br><span class="line"><span class="comment">//		for(int i=0;i&lt;qu-&gt;size;++i)&#123;</span></span><br><span class="line"><span class="comment">//			printf(&quot;%d &quot;,qu-&gt;arr[i]);</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		printf(&quot;\n&quot;);</span></span><br><span class="line">		ans+=temp;</span><br><span class="line">		add(qu,temp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="数据结构-前缀树（Trie）"><a href="#数据结构-前缀树（Trie）" class="headerlink" title="数据结构-前缀树（Trie）"></a>数据结构-前缀树（Trie）</h1><h2 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h2><ul>
<li>是一种搜索引擎（比如baidu、google）、数据检索引擎（比如elasticsearch等）经常使用的数据结构，可以大大优化检索数据的效率。</li>
<li>如果说要实现一个数据结构，能将word存放到其中，并且要能查找指定的word是否在那个数据结构中存在，并且还能查找指定的prefix也就是前缀是否在那个数据结构中存在，我们首先可以想到用数组来存放这些word，可是这样做有很多的问题，首先就是添加word的时候，由于数组在分配空间后长度是不可变的，所以在超出数组空间的情况下添加word是O(N)复杂度的，N是数组中的元素数量，这也是添加操作的最坏时间复杂度，平时就是O(1)；在检索word的时候，我们需要不断对比数组中的元素和word，这样如果有相同前缀的字符串，那么重复遍历前缀所造成的时间损耗是没必要的，检索prefix也是同理。</li>
<li>针对上面这些问题，我们可以将word存放在Trie中，其原理就是<strong>将所有的word的单个字符按照树形结构存储，前一个字符是后一个字符的父节点</strong>，这样我们就<strong>可以重复利用那些有着相同前缀的word的前缀所占的存储空间，而且在检索的时候也能优化掉判断重复前缀的时间</strong>。从这里也能看出来这个数据结构为啥叫前缀树，就是因为充分利用字符串的前缀在空间和时间上都做了优化，提升了数据检索的效率。</li>
</ul>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><ul>
<li>要想实现Trie，<strong>首先就要定义它的节点类</strong>，节点类中应该包含：<ol>
<li><strong>该节点的值</strong>，可以用char类型来定义。</li>
<li><strong>该节点是否为某个word的结束节点</strong>，用这个属性来判断某个word是否在Trie中存在，可以用boolean类型来定义。</li>
<li><strong>该节点的子节点，可以用HashMap来定义</strong>，优化检索效率。</li>
<li>……</li>
</ol>
</li>
<li>定义完节点类，我们就可以<strong>定义Trie类</strong>了，Trie类包括：<ol>
<li>该<strong>Trie的根节点，根节点不存储数据</strong>，只是作为检索的root。</li>
<li><strong>插入word</strong>的方法，插入就是从root开始沿着已经有的字符节点往下找，没有的字符节点就new，有的就跳过，<strong>最后一个节点的isEnd属性要置为true</strong>。</li>
<li><strong>查找word</strong>的方法，就是从root开始沿着对应的字符往下找，<strong>直到找到最后一个字符，并且这个字符节点的isEnd应该为true</strong>，这点很重要，如果找到了最后一个节点，但是isEnd属性不为true，说明这个word不存在Trie中。</li>
<li><strong>查找prefix</strong>的方法，<strong>从root开始找，直到找到最后一个字符，不用判断isEnd的值</strong>，因为只是要找个前缀。</li>
<li>……</li>
</ol>
</li>
</ul>
<h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><ul>
<li><p>LeetCode 208. 实现Trie(前缀树)：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20230112103631899.png" alt="image-20230112103631899"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">char</span> val;<span class="comment">//前缀树节点的值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> isEnd;<span class="comment">//该节点是否是存储的某个单词的结尾，用这个属性来判断前缀树中是否存在某单词</span></span><br><span class="line">        <span class="keyword">public</span> HashMap&lt;Character,Node&gt; children;<span class="comment">//该节点的孩子节点，用hashmap提高检索效率。可以懒加载这个属性</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">char</span> val,<span class="type">boolean</span> isEnd)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.isEnd = isEnd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">Node</span>((<span class="type">char</span>)<span class="number">0</span>,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.children!=<span class="literal">null</span> &amp;&amp; node.children.containsKey(word.charAt(i)))&#123;<span class="comment">//如果children存在并且其中存在目标字符</span></span><br><span class="line">                node = node.children.get(word.charAt(i));<span class="comment">//node直接到下一个节点</span></span><br><span class="line">                <span class="keyword">if</span>(i==word.length()-<span class="number">1</span>)&#123;<span class="comment">//如果当前是word的最后一个元素</span></span><br><span class="line">                    node.isEnd = <span class="literal">true</span>;<span class="comment">//那么让node的isEnd为true表示将该word存放进了trie中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果children为null或者其中不存在目标字符</span></span><br><span class="line">                <span class="keyword">if</span>(node.children==<span class="literal">null</span>) node.children = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//如果children为空就new，这是懒加载的做法</span></span><br><span class="line">                <span class="comment">//向当前节点的子节点添加新的字符，顺便判断这个字符是不是word的最后一个字符，如果是就把isEnd置为true以表示将该word存放进了trie</span></span><br><span class="line">                node.children.put(word.charAt(i),<span class="keyword">new</span> <span class="title class_">Node</span>(word.charAt(i),i==word.length()-<span class="number">1</span>?<span class="literal">true</span>:<span class="literal">false</span>));</span><br><span class="line">                <span class="comment">//node到下一个节点</span></span><br><span class="line">                node = node.children.get(word.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.children!=<span class="literal">null</span> &amp;&amp; node.children.containsKey(word.charAt(i)))&#123;<span class="comment">//如果children存在并且其中存在目标字符</span></span><br><span class="line">                node = node.children.get(word.charAt(i));<span class="comment">//node向下走</span></span><br><span class="line">                <span class="keyword">if</span>(i==word.length()-<span class="number">1</span>)&#123;<span class="comment">//如果当前字符是最后一个字符，直接返回node.isEnd表示是否存在该word</span></span><br><span class="line">                    <span class="keyword">return</span> node.isEnd;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果children为null或者其中不存在目标字符</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//找不到返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//为了过编译</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;prefix.length();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.children!=<span class="literal">null</span> &amp;&amp; node.children.containsKey(prefix.charAt(i)))&#123;<span class="comment">//如果children存在并且其中存在目标字符</span></span><br><span class="line">                node = node.children.get(prefix.charAt(i));<span class="comment">//node向下走</span></span><br><span class="line">                <span class="keyword">if</span>(i==prefix.length()-<span class="number">1</span>)&#123;<span class="comment">//如果当前字符是最后一个字符，直接返回true表示存在该prefix</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果children为null或者其中不存在目标字符</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//找不到返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//查找的过程没有返回说明不存在prefix</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>todo</p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://Konjacor.github.io">Konjacer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://konjacor.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">https://konjacor.github.io/2022/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Konjacor.github.io" target="_blank">孤舟</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="/img/background.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/05/Redis%E5%85%A5%E9%97%A8/"><img class="prev-cover" src="/img/background.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis入门</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/14/Linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"><img class="next-cover" src="/img/background.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux常用操作</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/07/05/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E5%AD%A6%E5%A4%A7%E7%BA%B2/" title="C语言与数据结构教学大纲"><img class="cover" src="/img/background.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-05</div><div class="title">C语言与数据结构教学大纲</div></div></a></div><div><a href="/2022/05/08/%E4%BB%8E%E7%BB%8F%E5%85%B8%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9C%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E6%80%9D%E6%83%B3/" title="从经典动态规划问题看动态规划的思想"><img class="cover" src="/img/background.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-08</div><div class="title">从经典动态规划问题看动态规划的思想</div></div></a></div><div><a href="/2022/09/13/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E5%BF%83%E5%BE%97/" title="算法刷题心得"><img class="cover" src="/img/background.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-13</div><div class="title">算法刷题心得</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/xiaozhai.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Konjacer</div><div class="author-info__description">仰望星空，脚踏实地，寻觅纯粹，奔向自由</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">87</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Konjacor" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1175590069@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/Konjacor" target="_blank" title="Gitee"><i class="fa-solid fa-g"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93%E5%92%8C%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.</span> <span class="toc-text">常用排序算法的总结和对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%BC%A0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E5%9B%BE"><span class="toc-number">1.1.1.</span> <span class="toc-text">一张排序算法的比较图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A"><span class="toc-number">1.1.2.</span> <span class="toc-text">相关术语解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E4%BA%BA%E5%85%A5%E5%9D%91%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">新人入坑冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.2.3.</span> <span class="toc-text">冒泡过程图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.4.</span> <span class="toc-text">对于冒泡排序的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.5.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E6%8C%91%E5%90%8E%E6%8D%A2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">先挑后换选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3"><span class="toc-number">1.3.2.</span> <span class="toc-text">选择排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.3.4.</span> <span class="toc-text">选择排序过程图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.3.5.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E5%8F%96%E5%90%8E%E6%8F%92%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text">先取后插插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3"><span class="toc-number">1.4.2.</span> <span class="toc-text">插入排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-2"><span class="toc-number">1.4.3.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.4.4.</span> <span class="toc-text">插入排序过程图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">1.4.5.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E6%8E%92%E4%BC%98%E5%8C%96%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text">插排优化希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">1.5.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3"><span class="toc-number">1.5.2.</span> <span class="toc-text">希尔排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-3"><span class="toc-number">1.5.3.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.5.4.</span> <span class="toc-text">希尔排序流程图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">1.5.5.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%9F%E5%BE%85%E5%B7%B2%E4%B9%85%E7%9A%84%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.</span> <span class="toc-text">期待已久的堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86"><span class="toc-number">1.6.1.</span> <span class="toc-text">什么是堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">堆的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.6.3.</span> <span class="toc-text">堆的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E4%B8%8A%E7%A7%BB%EF%BC%88SiftUp%EF%BC%89"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">节点上移（SiftUp）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E4%B8%8B%E7%A7%BB%EF%BC%88SiftDown%EF%BC%89"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">节点下移（SiftDown）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%EF%BC%88Insert%EF%BC%89"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">插入元素（Insert）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%88Delete%EF%BC%89"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">删除元素（Delete）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%88DeleteMax%EF%BC%89"><span class="toc-number">1.6.3.5.</span> <span class="toc-text">删除最大值（DeleteMax）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A0%86%EF%BC%88MakeHeap%EF%BC%89"><span class="toc-number">1.6.3.6.</span> <span class="toc-text">创建堆（MakeHeap）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88HeapSort%EF%BC%89"><span class="toc-number">1.6.3.7.</span> <span class="toc-text">堆排序（HeapSort）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.6.4.</span> <span class="toc-text">时间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.7.</span> <span class="toc-text">分而治之归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF"><span class="toc-number">1.7.2.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E8%B7%AF%E5%BD%92%E5%B9%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.3.</span> <span class="toc-text">双路归并算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">1.7.4.</span> <span class="toc-text">时间复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.5.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E5%BE%97%E6%9C%80%E5%A4%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.</span> <span class="toc-text">用得最多快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">1.8.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF-1"><span class="toc-number">1.8.2.</span> <span class="toc-text">基本思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">1.8.3.</span> <span class="toc-text">时间复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.8.4.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%80%89%E6%8B%A9%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7-x2F-%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0"><span class="toc-number">1.8.5.</span> <span class="toc-text">线性复杂度选择数组中的第K个最大&#x2F;最小元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.6.</span> <span class="toc-text">非递归算法实现快速排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9F%E5%BA%A6%E5%BE%88%E5%BF%AB%E7%9A%84%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.</span> <span class="toc-text">速度很快的桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F%E6%80%9D%E8%B7%AF"><span class="toc-number">1.9.1.</span> <span class="toc-text">桶排序思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">1.9.2.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%B6%E6%95%B0%E6%9C%80%E5%A4%9A%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.10.</span> <span class="toc-text">桶数最多计数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3"><span class="toc-number">1.10.1.</span> <span class="toc-text">计数排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">1.10.2.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E4%BD%8D%E5%81%9A%E6%A1%B6%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.11.</span> <span class="toc-text">数位做桶基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.11.1.</span> <span class="toc-text">基数排序介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">1.11.2.</span> <span class="toc-text">基数排序基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-4"><span class="toc-number">1.11.3.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.11.4.</span> <span class="toc-text">基数排序流程图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-6"><span class="toc-number">1.11.5.</span> <span class="toc-text">代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%83%E6%B0%8F%E7%AD%9B"><span class="toc-number">2.</span> <span class="toc-text">埃氏筛</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.1.</span> <span class="toc-text">算法介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">2.2.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">算法流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%BC%BA%E9%99%B7"><span class="toc-number">2.4.</span> <span class="toc-text">算法缺陷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.5.</span> <span class="toc-text">代码实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86"><span class="toc-number">3.</span> <span class="toc-text">二分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%BE%E7%82%B9"><span class="toc-number">3.1.</span> <span class="toc-text">难点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E9%97%AE%E9%A2%98%E9%80%9A%E7%94%A8%E6%80%9D%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">二分问题通用思考模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%89%BE%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%B0%8F%E4%BA%8Etarget%E7%9A%84%E5%85%83%E7%B4%A0%E5%92%8C%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%A4%A7%E4%BA%8Etarget%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">3.3.</span> <span class="toc-text">二分找最后一个小于target的元素和第一个大于target的元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">4.</span> <span class="toc-text">快速幂</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RSA"><span class="toc-number">5.</span> <span class="toc-text">RSA</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">如何创建一棵二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">二叉树遍历算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BA%B5%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">7.1.</span> <span class="toc-text">二叉树的纵序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Morris%E9%81%8D%E5%8E%86"><span class="toc-number">7.1.1.</span> <span class="toc-text">Morris遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%88%99"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">实现原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E8%B4%A8"><span class="toc-number">7.1.1.3.</span> <span class="toc-text">实质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">7.1.1.4.</span> <span class="toc-text">代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">7.2.</span> <span class="toc-text">二叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.2.1.</span> <span class="toc-text">利用队列实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text">回溯算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E7%AE%97%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">分支限界算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%A0%91%EF%BC%88%E8%A7%A3%E7%A9%BA%E9%97%B4%E6%A0%91%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">状态空间树（解空间树）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E6%A0%91"><span class="toc-number">9.1.1.</span> <span class="toc-text">子集树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E6%A0%91"><span class="toc-number">9.1.2.</span> <span class="toc-text">排列树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-number">9.2.</span> <span class="toc-text">算法简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95%E8%A7%A3%E5%86%B3"><span class="toc-number">9.3.</span> <span class="toc-text">0-1背包问题的分支限界法解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TSP%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%B3%95%E8%A7%A3%E5%86%B3"><span class="toc-number">9.4.</span> <span class="toc-text">TSP问题的分支限界法解决</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">动态规划算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DP%E4%B9%8B%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">10.1.</span> <span class="toc-text">DP之编辑距离</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">10.1.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DP%E6%80%9D%E6%83%B3"><span class="toc-number">10.1.2.</span> <span class="toc-text">DP思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">10.1.3.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DP%E4%B9%8BTSP%E9%97%AE%E9%A2%98"><span class="toc-number">10.2.</span> <span class="toc-text">DP之TSP问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">10.2.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DP%E6%80%9D%E6%83%B3-1"><span class="toc-number">10.2.2.</span> <span class="toc-text">DP思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dp%E6%95%B0%E7%BB%84%E5%9B%BE%E8%A7%A3"><span class="toc-number">10.2.3.</span> <span class="toc-text">dp数组图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">10.2.4.</span> <span class="toc-text">代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4DP"><span class="toc-number">10.3.</span> <span class="toc-text">区间DP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E7%8A%B6DP"><span class="toc-number">10.4.</span> <span class="toc-text">环状DP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2DP"><span class="toc-number">10.5.</span> <span class="toc-text">树形DP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E6%80%BB%E7%BB%93"><span class="toc-number">10.6.</span> <span class="toc-text">小总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">最短路径算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">11.1.</span> <span class="toc-text">Dijkstra算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">11.1.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-1"><span class="toc-number">11.1.2.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="toc-number">11.1.3.</span> <span class="toc-text">算法过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-7"><span class="toc-number">11.1.4.</span> <span class="toc-text">代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%AE%97%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">最小生成树算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="toc-number">12.1.</span> <span class="toc-text">Prim算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0"><span class="toc-number">12.1.1.</span> <span class="toc-text">算法描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-2"><span class="toc-number">12.1.2.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-1"><span class="toc-number">12.1.3.</span> <span class="toc-text">算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-8"><span class="toc-number">12.1.4.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">Kruskal算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">12.2.1.</span> <span class="toc-text">算法描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-3"><span class="toc-number">12.2.2.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-2"><span class="toc-number">12.2.3.</span> <span class="toc-text">算法流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-9"><span class="toc-number">12.2.4.</span> <span class="toc-text">代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Huffman%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">Huffman编码算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">13.1.</span> <span class="toc-text">算法描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-4"><span class="toc-number">13.2.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B-3"><span class="toc-number">13.3.</span> <span class="toc-text">算法流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">13.3.1.</span> <span class="toc-text">初始化优先队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%90%88%E5%B9%B6"><span class="toc-number">13.3.2.</span> <span class="toc-text">第一步合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E8%B0%83%E6%95%B4%E9%98%9F%E5%88%97"><span class="toc-number">13.3.3.</span> <span class="toc-text">重新调整队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">13.3.4.</span> <span class="toc-text">哈夫曼编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81"><span class="toc-number">13.3.5.</span> <span class="toc-text">字符串编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">13.3.6.</span> <span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-10"><span class="toc-number">13.4.</span> <span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6"><span class="toc-number">13.5.</span> <span class="toc-text">利用霍夫曼编码压缩文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6"><span class="toc-number">13.6.</span> <span class="toc-text">利用霍夫曼编码解压文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%97%E6%B3%95"><span class="toc-number">14.</span> <span class="toc-text">表达式算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%97%E6%B3%95"><span class="toc-number">14.1.</span> <span class="toc-text">中缀表达式算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">14.1.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%8C%E6%88%90%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">14.1.2.</span> <span class="toc-text">使用栈完成中缀表达式计算的思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-11"><span class="toc-number">14.1.3.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">14.2.</span> <span class="toc-text">中缀表达式转换为后缀表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">14.2.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">14.2.2.</span> <span class="toc-text">算法步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E4%B8%BE%E4%BE%8B"><span class="toc-number">14.2.3.</span> <span class="toc-text">转换举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-12"><span class="toc-number">14.2.4.</span> <span class="toc-text">代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="toc-number">15.</span> <span class="toc-text">KMP算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">15.1.</span> <span class="toc-text">KMP算法介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">15.2.</span> <span class="toc-text">KMP算法思路分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E5%8C%B9%E9%85%8D%E8%A1%A8%EF%BC%88next%EF%BC%89%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84%EF%BC%9F"><span class="toc-number">15.3.</span> <span class="toc-text">部分匹配表（next）是如何产生的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-13"><span class="toc-number">15.4.</span> <span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E4%B9%8Bnextval%E6%95%B0%E7%BB%84"><span class="toc-number">15.5.</span> <span class="toc-text">KMP算法优化之nextval数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7-Floyd-%E7%AE%97%E6%B3%95"><span class="toc-number">16.</span> <span class="toc-text">弗洛伊德(Floyd)算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">16.1.</span> <span class="toc-text">算法介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">16.2.</span> <span class="toc-text">算法思路分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-14"><span class="toc-number">16.3.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7-Floyd-%E5%88%A4%E5%9C%88%E7%AE%97%E6%B3%95%EF%BC%88%E9%BE%9F%E5%85%94%E8%B5%9B%E8%B7%91%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">17.</span> <span class="toc-text">弗洛伊德(Floyd)判圈算法（龟兔赛跑算法）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">17.1.</span> <span class="toc-text">算法介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AF%81%E6%98%8E"><span class="toc-number">17.2.</span> <span class="toc-text">算法证明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-15"><span class="toc-number">17.3.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%89%BE%E5%88%B0%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%82%B9"><span class="toc-number">18.</span> <span class="toc-text">快慢指针找到链表中点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">18.1.</span> <span class="toc-text">算法介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-16"><span class="toc-number">18.2.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%80%92%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">19.</span> <span class="toc-text">倒转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B4%E6%8F%92%E6%B3%95%E5%80%92%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="toc-number">19.1.</span> <span class="toc-text">头插法倒转链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-17"><span class="toc-number">19.1.1.</span> <span class="toc-text">代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88%E6%89%BE%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">20.</span> <span class="toc-text">前后指针找链表的倒数第k个元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">20.1.</span> <span class="toc-text">算法介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-18"><span class="toc-number">20.2.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Boyer-Moore%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95"><span class="toc-number">21.</span> <span class="toc-text">Boyer-Moore投票算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D-5"><span class="toc-number">21.1.</span> <span class="toc-text">算法介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-5"><span class="toc-number">21.2.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AF%81%E6%98%8E-1"><span class="toc-number">21.3.</span> <span class="toc-text">算法证明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87"><span class="toc-number">21.4.</span> <span class="toc-text">算法效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-19"><span class="toc-number">21.5.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">22.</span> <span class="toc-text">有限状态自动机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Brian-Kernighan-%E7%AE%97%E6%B3%95"><span class="toc-number">23.</span> <span class="toc-text">Brian Kernighan 算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-3"><span class="toc-number">23.1.</span> <span class="toc-text">算法描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">23.2.</span> <span class="toc-text">代码实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="toc-number">24.</span> <span class="toc-text">使用位运算做加法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-4"><span class="toc-number">24.1.</span> <span class="toc-text">算法描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">24.2.</span> <span class="toc-text">算法实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E5%81%9A%E6%A8%A1%E8%BF%90%E7%AE%97"><span class="toc-number">25.</span> <span class="toc-text">使用位运算做模运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%8F%8F%E8%BF%B0-5"><span class="toc-number">25.1.</span> <span class="toc-text">算法描述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E5%B9%B3%E6%96%B9%E5%92%8C%E5%AE%9A%E7%90%86"><span class="toc-number">26.</span> <span class="toc-text">四平方和定理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">27.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%E8%BD%AC%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">28.</span> <span class="toc-text">非线性结构转线性结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E8%BD%A6%E9%97%AE%E9%A2%98"><span class="toc-number">29.</span> <span class="toc-text">上下车问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-3"><span class="toc-number">29.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">29.2.</span> <span class="toc-text">解决思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E9%97%AE%E9%A2%98"><span class="toc-number">29.3.</span> <span class="toc-text">具体问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="toc-number">30.</span> <span class="toc-text">括号匹配</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">31.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D-%E2%80%98-%E2%80%98-%E5%AD%97%E7%AC%A6"><span class="toc-number">31.1.</span> <span class="toc-text">匹配 ‘ . ‘ 字符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">32.</span> <span class="toc-text">拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">32.1.</span> <span class="toc-text">简单拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D-6"><span class="toc-number">32.1.1.</span> <span class="toc-text">算法介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">32.1.2.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-20"><span class="toc-number">32.1.3.</span> <span class="toc-text">代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Manacher%E7%AE%97%E6%B3%95"><span class="toc-number">33.</span> <span class="toc-text">Manacher算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D-7"><span class="toc-number">33.1.</span> <span class="toc-text">算法介绍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2hash"><span class="toc-number">34.</span> <span class="toc-text">字符串hash</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D-8"><span class="toc-number">34.1.</span> <span class="toc-text">算法介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-6"><span class="toc-number">34.2.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">34.3.</span> <span class="toc-text">hash函数的设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%82%E5%AD%90%E4%B8%B2%E7%9A%84hash%E5%80%BC"><span class="toc-number">34.4.</span> <span class="toc-text">求子串的hash值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">35.</span> <span class="toc-text">贪心算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">36.</span> <span class="toc-text">前缀和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%AE%E5%88%86"><span class="toc-number">37.</span> <span class="toc-text">差分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E9%AD%94%E6%96%B9%E9%98%B5%E7%9A%84%E6%B1%82%E6%B3%95"><span class="toc-number">38.</span> <span class="toc-text">数字魔方阵的求法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%87%E6%95%B0%E9%98%B6%E9%AD%94%E6%96%B9%E9%98%B5%EF%BC%88%E9%98%B6%E6%95%B0%E4%B8%BA%E5%A5%87%E6%95%B0%EF%BC%89"><span class="toc-number">38.1.</span> <span class="toc-text">奇数阶魔方阵（阶数为奇数）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%81%B6%E6%95%B0%E9%98%B6%E9%AD%94%E6%96%B9%E9%98%B5%EF%BC%88%E9%98%B6%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E4%B8%94%E8%83%BD%E8%A2%AB4%E6%95%B4%E9%99%A4%EF%BC%89"><span class="toc-number">38.2.</span> <span class="toc-text">双偶数阶魔方阵（阶数为偶数且能被4整除）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8F%96%E4%BA%A4%E9%9B%86"><span class="toc-number">39.</span> <span class="toc-text">两个升序链表取交集</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">40.</span> <span class="toc-text">查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">40.1.</span> <span class="toc-text">线性查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-6"><span class="toc-number">40.1.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-7"><span class="toc-number">40.1.2.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-21"><span class="toc-number">40.1.3.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86-%E6%8A%98%E5%8D%8A-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">40.2.</span> <span class="toc-text">二分(折半)查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-7"><span class="toc-number">40.2.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="toc-number">40.2.2.</span> <span class="toc-text">算法思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E4%B8%AD%E9%97%B4%E5%80%BC%E4%B8%8B%E6%A0%87%E8%AE%A1%E7%AE%97%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">40.2.3.</span> <span class="toc-text">对于中间值下标计算的优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-22"><span class="toc-number">40.2.4.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">40.3.</span> <span class="toc-text">插值查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-8"><span class="toc-number">40.3.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-8"><span class="toc-number">40.3.2.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B8%BE%E4%BE%8B"><span class="toc-number">40.3.3.</span> <span class="toc-text">插值查找算法举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">40.3.4.</span> <span class="toc-text">插值查找注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-23"><span class="toc-number">40.3.5.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91-%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">40.4.</span> <span class="toc-text">斐波那契(黄金分割)查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-9"><span class="toc-number">40.4.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-9"><span class="toc-number">40.4.2.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-24"><span class="toc-number">40.4.3.</span> <span class="toc-text">代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91"><span class="toc-number">41.</span> <span class="toc-text">数据结构-树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">41.1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%A0%91%E8%BF%99%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">41.1.1.</span> <span class="toc-text">为什么需要树这种数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-number">41.1.2.</span> <span class="toc-text">树示意图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%B8%B8%E7%94%A8%E6%9C%AF%E8%AF%AD"><span class="toc-number">41.1.3.</span> <span class="toc-text">树的常用术语</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">41.1.4.</span> <span class="toc-text">二叉树的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">41.1.5.</span> <span class="toc-text">二叉树遍历的说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E6%AD%A5%E9%AA%A4"><span class="toc-number">41.1.6.</span> <span class="toc-text">二叉树遍历步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E8%8A%82%E7%82%B9"><span class="toc-number">41.1.7.</span> <span class="toc-text">二叉树查找指定节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">41.1.8.</span> <span class="toc-text">二叉树删除节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">41.2.</span> <span class="toc-text">顺序存储二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">41.2.1.</span> <span class="toc-text">顺序存储二叉树的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">41.2.2.</span> <span class="toc-text">顺序存储二叉树的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">41.3.</span> <span class="toc-text">线索化二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">41.3.1.</span> <span class="toc-text">线索二叉树基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%BF%E7%B4%A2%E5%8C%96%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">41.3.2.</span> <span class="toc-text">将二叉树线索化的流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F-%E6%9F%A5%E6%89%BE-%E6%A0%91"><span class="toc-number">41.4.</span> <span class="toc-text">二叉排序(查找)树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E7%9C%8B%E4%B8%80%E4%B8%AA%E9%9C%80%E6%B1%82"><span class="toc-number">41.4.1.</span> <span class="toc-text">先看一个需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%88%86%E6%9E%90"><span class="toc-number">41.4.2.</span> <span class="toc-text">解决方案分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">41.4.3.</span> <span class="toc-text">二叉排序树介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="toc-number">41.4.4.</span> <span class="toc-text">二叉排序树的创建和插入节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="toc-number">41.4.5.</span> <span class="toc-text">二叉排序树删除节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-AVL%E6%A0%91"><span class="toc-number">41.5.</span> <span class="toc-text">平衡二叉树(AVL树)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E6%9D%A5%E8%AE%A4%E8%AF%86%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">41.5.1.</span> <span class="toc-text">通过一个案例来认识二叉排序树可能存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-10"><span class="toc-number">41.5.2.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A6%E6%97%8B%E8%BD%AC"><span class="toc-number">41.5.3.</span> <span class="toc-text">平衡二叉树左旋转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E6%97%8B%E8%BD%AC"><span class="toc-number">41.5.4.</span> <span class="toc-text">平衡二叉树右旋转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8C%E6%97%8B%E8%BD%AC"><span class="toc-number">41.5.5.</span> <span class="toc-text">平衡二叉树双旋转</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">42.</span> <span class="toc-text">数据结构-多路查找树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%8F%89%E6%A0%91%E4%B8%8EB%E6%A0%91"><span class="toc-number">42.1.</span> <span class="toc-text">多叉树与B树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">42.1.1.</span> <span class="toc-text">二叉树的问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%8F%89%E6%A0%91"><span class="toc-number">42.1.2.</span> <span class="toc-text">多叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">42.1.3.</span> <span class="toc-text">B树的基本介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E6%A0%91"><span class="toc-number">42.2.</span> <span class="toc-text">2-3树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E6%A0%91%E6%98%AF%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84B%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">42.2.1.</span> <span class="toc-text">2-3树是最简单的B树结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E6%A0%91%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">42.2.2.</span> <span class="toc-text">2-3树应用案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E6%A0%91%E8%8A%82%E7%82%B9%E6%8F%92%E5%85%A5%E8%A7%84%E5%88%99"><span class="toc-number">42.2.3.</span> <span class="toc-text">2-3树节点插入规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E8%AF%B4%E6%98%8E"><span class="toc-number">42.2.4.</span> <span class="toc-text">其它说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B%E6%A0%91%E3%80%81B-%E6%A0%91%E5%92%8CB-%E6%A0%91"><span class="toc-number">42.3.</span> <span class="toc-text">B树、B+树和B*树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E6%A0%91%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">42.3.1.</span> <span class="toc-text">B树的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">42.3.2.</span> <span class="toc-text">B+树的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E7%9A%84%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">42.3.3.</span> <span class="toc-text">B*树的介绍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">43.</span> <span class="toc-text">数据结构-并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-11"><span class="toc-number">43.1.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">43.2.</span> <span class="toc-text">实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">43.2.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">43.2.2.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">43.3.</span> <span class="toc-text">带权并查集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%EF%BC%88Sparsearray%EF%BC%89"><span class="toc-number">44.</span> <span class="toc-text">数据结构-稀疏数组（Sparsearray）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B"><span class="toc-number">44.1.</span> <span class="toc-text">需求场景示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-12"><span class="toc-number">44.2.</span> <span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">44.3.</span> <span class="toc-text">应用实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%88Monotone-Queue%EF%BC%89"><span class="toc-number">45.</span> <span class="toc-text">数据结构-单调队列（Monotone Queue）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">45.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">45.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">45.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">45.4.</span> <span class="toc-text">应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-25"><span class="toc-number">45.5.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E8%B0%83%E6%A0%88%EF%BC%88Monotone-Stack%EF%BC%89"><span class="toc-number">46.</span> <span class="toc-text">数据结构-单调栈（Monotone Stack）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%88Priority-Queue%EF%BC%89"><span class="toc-number">47.</span> <span class="toc-text">数据结构-优先队列（Priority Queue）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%89%8D%E7%BC%80%E6%A0%91%EF%BC%88Trie%EF%BC%89"><span class="toc-number">48.</span> <span class="toc-text">数据结构-前缀树（Trie）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="toc-number">48.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">48.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8-1"><span class="toc-number">48.3.</span> <span class="toc-text">应用</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/18/IT%E8%BF%90%E7%BB%B4%E5%89%8D%E6%B2%BF/" title="IT运维前沿"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IT运维前沿"/></a><div class="content"><a class="title" href="/2024/09/18/IT%E8%BF%90%E7%BB%B4%E5%89%8D%E6%B2%BF/" title="IT运维前沿">IT运维前沿</a><time datetime="2024-09-18T02:04:08.000Z" title="发表于 2024-09-18 10:04:08">2024-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/05/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E5%AD%A6%E5%A4%A7%E7%BA%B2/" title="C语言与数据结构教学大纲"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言与数据结构教学大纲"/></a><div class="content"><a class="title" href="/2024/07/05/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E5%AD%A6%E5%A4%A7%E7%BA%B2/" title="C语言与数据结构教学大纲">C语言与数据结构教学大纲</a><time datetime="2024-07-05T10:19:21.000Z" title="发表于 2024-07-05 18:19:21">2024-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/14/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E9%A1%B9%E7%9B%AE-%E5%90%88%E4%BD%9C%E5%8A%9E%E5%AD%A6%E8%AF%84%E4%BC%B0%E5%B9%B3%E5%8F%B0/" title="实验室项目-合作办学评估平台"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实验室项目-合作办学评估平台"/></a><div class="content"><a class="title" href="/2024/06/14/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E9%A1%B9%E7%9B%AE-%E5%90%88%E4%BD%9C%E5%8A%9E%E5%AD%A6%E8%AF%84%E4%BC%B0%E5%B9%B3%E5%8F%B0/" title="实验室项目-合作办学评估平台">实验室项目-合作办学评估平台</a><time datetime="2024-06-14T02:15:32.000Z" title="发表于 2024-06-14 10:15:32">2024-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/23/%E8%88%B8%E6%96%8B%E5%BF%83%E6%B3%95/" title="舸斋心法"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="舸斋心法"/></a><div class="content"><a class="title" href="/2024/04/23/%E8%88%B8%E6%96%8B%E5%BF%83%E6%B3%95/" title="舸斋心法">舸斋心法</a><time datetime="2024-04-23T15:20:13.000Z" title="发表于 2024-04-23 23:20:13">2024-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/15/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" title="离散数学"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="离散数学"/></a><div class="content"><a class="title" href="/2024/03/15/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" title="离散数学">离散数学</a><time datetime="2024-03-15T09:54:51.000Z" title="发表于 2024-03-15 17:54:51">2024-03-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/background.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By Konjacer</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
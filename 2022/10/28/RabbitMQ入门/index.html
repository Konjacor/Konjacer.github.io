<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>RabbitMQ入门 | 孤舟</title><meta name="keywords" content="消息队列,RabbitMQ"><meta name="author" content="Konjacer,1175590069@qq.com"><meta name="copyright" content="Konjacer"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MQ的相关概念什么是MQ MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。  为什么要用MQ流量削(消)峰 举个例子">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ入门">
<meta property="og:url" content="https://konjacor.github.io/2022/10/28/RabbitMQ%E5%85%A5%E9%97%A8/index.html">
<meta property="og:site_name" content="孤舟">
<meta property="og:description" content="MQ的相关概念什么是MQ MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。  为什么要用MQ流量削(消)峰 举个例子">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://konjacor.github.io/img/background.jpeg">
<meta property="article:published_time" content="2022-10-28T01:29:59.000Z">
<meta property="article:modified_time" content="2022-12-20T12:11:43.199Z">
<meta property="article:author" content="Konjacer">
<meta property="article:tag" content="消息队列">
<meta property="article:tag" content="RabbitMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://konjacor.github.io/img/background.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://konjacor.github.io/2022/10/28/RabbitMQ%E5%85%A5%E9%97%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RabbitMQ入门',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-20 20:11:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="孤舟" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/xiaozhai.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">87</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/background.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">孤舟</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">RabbitMQ入门</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-28T01:29:59.000Z" title="发表于 2022-10-28 09:29:59">2022-10-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-20T12:11:43.199Z" title="更新于 2022-12-20 20:11:43">2022-12-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RabbitMQ入门"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><meta name="referrer" content="no-referrer"/>

<h1 id="MQ的相关概念"><a href="#MQ的相关概念" class="headerlink" title="MQ的相关概念"></a>MQ的相关概念</h1><h2 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h2><ul>
<li>MQ(message queue)，从字面意思上看，<strong>本质是个队列，FIFO 先入先出</strong>，只不过队列中存放的内容是message 而已，还<strong>是一种跨进程的通信机制，用于上下游传递消息</strong>。在互联网架构中，MQ 是一种非常常见的<strong>上下游“逻辑解耦+物理解耦”的消息通信服务</strong>。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。</li>
</ul>
<h2 id="为什么要用MQ"><a href="#为什么要用MQ" class="headerlink" title="为什么要用MQ"></a>为什么要用MQ</h2><h3 id="流量削-消-峰"><a href="#流量削-消-峰" class="headerlink" title="流量削(消)峰"></a>流量削(消)峰</h3><ul>
<li>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。<strong>使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好</strong>。</li>
</ul>
<h3 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h3><ul>
<li><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，<strong>如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常</strong>。当<strong>转变成基于消息队列的方式后，系统间调用的问题会减少很多</strong>，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统<strong>要处理的内容被缓存在消息队列中</strong>，用户的下单操作可以正常完成。当物流<strong>系统恢复后，继续处理订单信息</strong>即可，下单用户感受不到物流系统的故障，<strong>提升系统的可用性</strong>。</p>
</li>
<li><p>引入消息队列后系统的结构：<img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221028095447013.png" alt="image-20221028095447013"></p>
</li>
</ul>
<h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><ul>
<li><p><strong>有些服务间调用是异步的</strong>，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，<strong>使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务</strong>。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样 B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p>
</li>
<li><p>加入消息队列后的异步消息处理：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221028100044425.png" alt="image-20221028100044425"></p>
</li>
</ul>
<h2 id="MQ的分类"><a href="#MQ的分类" class="headerlink" title="MQ的分类"></a>MQ的分类</h2><h3 id="ActiveMQ"><a href="#ActiveMQ" class="headerlink" title="ActiveMQ"></a>ActiveMQ</h3><ul>
<li><strong>优点</strong>：单机吞吐量万级，时效性 ms 级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据。</li>
<li><strong>缺点</strong>：官方社区现在对 ActiveMQ 5.x <strong>维护越来越少，高吞吐量场景较少使用</strong>。</li>
</ul>
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><ul>
<li>大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开 Kafka，这款<strong>为大数据而生的消息中间件</strong>，以其<strong>百万级</strong> <strong>TPS</strong> 的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被 LinkedIn，Uber, Twitter, Netflix 等大公司所采纳。</li>
<li><strong>优点</strong>: 性能卓越，单机写入 TPS 约在百万条&#x2F;秒，最大的优点，就是<strong>吞吐量高</strong>。时效性 ms 级可用性非常高，<strong>kafka 是分布式的</strong>，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用,消费者采用 Pull 方式获取消息, 消息有序, 通过控制能够保证所有消息被消费且仅被消费一次;<strong>有优秀的第三方Kafka Web 管理界面 Kafka-Manager</strong>；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能较为简单，主要支持简单的 MQ 功能，<strong>在大数据领域的实时计算以及日志采集被大规模使用</strong>。</li>
<li><strong>缺点</strong>：Kafka 单机超过 64 个队列&#x2F;分区，Load（负载）会发生明显的飙高现象，<strong>队列越多，load 越高，发送消息响应时间变长</strong>，<strong>使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试</strong>；<strong>支持消息顺序，但是一台代理宕机后，就会产生消息乱序</strong>，<strong>社区更新较慢</strong>；</li>
</ul>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><ul>
<li>RocketMQ 出自阿里巴巴的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发等场景。‘</li>
<li><strong>优点</strong>：<strong>单机吞吐量十万级</strong>,可用性非常高，分布式架构,<strong>消息可以做到</strong> <strong>0</strong> <strong>丢失</strong>,MQ 功能较为完善，还是<strong>分布式的，扩展性好</strong>,<strong>支持</strong> <strong>10</strong> <strong>亿级别的消息堆积</strong>，不会因为堆积导致性能下降,源码是 java 我们可以自己阅读源码，定制自己公司的 MQ。</li>
<li><strong>缺点</strong>：<strong>支持的客户端语言不多</strong>，目前是 java 及 c++，其中 c++不成熟；社区活跃度一般,没有在 MQ核心中去实现 JMS 等接口,有些系统要迁移需要修改大量代码。</li>
</ul>
<h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><ul>
<li>2007 年发布，是一个<strong>在 AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统</strong>，是<strong>当前最主流的消息中间件之一</strong>。</li>
<li><strong>优点</strong>：由于 erlang 语言的<strong>高并发特性</strong>，性能较好；<strong>吞吐量到万级</strong>，MQ 功能比较完备,健壮、稳定、易用、跨平台、<strong>支持多种语言</strong> 如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持 AJAX 文档齐全；<strong>开源提供的管理界面非常棒</strong>，用起来很好用,<strong>社区活跃度高</strong>；<strong>更新频率相当高</strong>。</li>
<li><strong>缺点</strong>：商业版需要收费,学习成本较高。</li>
</ul>
<h2 id="MQ的选择"><a href="#MQ的选择" class="headerlink" title="MQ的选择"></a>MQ的选择</h2><h3 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h3><ul>
<li>Kafka 主要特点是<strong>基于 Pull 的模式来处理消息消费，追求高吞吐量</strong>，一开始的目的就是用于日志收集和传输，<strong>适合产生大量数据的互联网服务的数据收集业务</strong>。<strong>大型公司建议可以选用</strong>，如果<strong>有日志采集功能，肯定是首选 kafka</strong>了。</li>
</ul>
<h3 id="RocketMQ-1"><a href="#RocketMQ-1" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><ul>
<li>天生<strong>为金融互联网领域而生</strong>，对于<strong>可靠性要求很高的场景</strong>，尤其是<strong>电商里面的订单扣款，以及业务削峰</strong>，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择 RocketMQ。</li>
</ul>
<h3 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><ul>
<li>结合 <strong>erlang 语言本身的并发优势</strong>，性能好<strong>时效性微秒级</strong>，<strong>社区活跃度也比较高</strong>，<strong>管理界面用起来十分方便</strong>，如果你的<strong>数据量没有那么大</strong>，中小型公司优先选择功能比较完备的 RabbitMQ。</li>
</ul>
<h1 id="RabbitMQ-2"><a href="#RabbitMQ-2" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="RabbitMQ的概念"><a href="#RabbitMQ的概念" class="headerlink" title="RabbitMQ的概念"></a>RabbitMQ的概念</h2><ul>
<li>RabbitMQ 是一个消息中间件：它<strong>接受并转发消息</strong>。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑<strong>RabbitMQ 是一个快递站，一个快递员帮你传递快件。RabbitMQ 与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据</strong>。</li>
</ul>
<h2 id="四大核心概念"><a href="#四大核心概念" class="headerlink" title="四大核心概念"></a>四大核心概念</h2><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><ul>
<li>产生数据发送消息的程序是生产者。</li>
</ul>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><ul>
<li>交换机是 RabbitMQ 非常重要的一个部件，一方面<strong>它接收来自生产者的消息，另一方面它将消息推送到队列中</strong>。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得由交换机类型决定。</li>
</ul>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul>
<li>队列是 RabbitMQ 内部使用的一种数据结构，<strong>尽管消息流经 RabbitMQ 和应用程序，但它们只能存储在队列中</strong>。队列仅受主机的内存和磁盘限制的约束，<strong>本质上是一个大的消息缓冲区</strong>。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式。</li>
</ul>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><ul>
<li>消费与接收具有相似的含义。<strong>消费者大多时候是一个等待接收消息的程序</strong>。请注意<strong>生产者，消费者和消息中间件很多时候并不在同一机器上</strong>。同一个应用程序既可以是生产者又是可以是消费者。</li>
</ul>
<h2 id="RabbitMQ核心部分"><a href="#RabbitMQ核心部分" class="headerlink" title="RabbitMQ核心部分"></a>RabbitMQ核心部分</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029093156586.png" alt="image-20221029093156586"></p>
<ol>
<li>“Hello World”：消息队列的简单使用</li>
<li>Work queues：工作队列</li>
<li>Publish&#x2F;Subscribe：消息的发布订阅</li>
<li>Routing：不同的路由方式</li>
<li>Topics：主题路由</li>
<li>Publisher Confirms：消息的发布确认</li>
</ol>
<h2 id="相关名词介绍"><a href="#相关名词介绍" class="headerlink" title="相关名词介绍"></a>相关名词介绍</h2><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029093829448.png" alt="image-20221029093829448"></p>
<ul>
<li><strong>Broker（代理）</strong>：<strong>接收和分发消息的应用</strong>，RabbitMQ Server 就是 Message Broker。</li>
<li><strong>Virtual host</strong>：出于多租户和安全因素设计的，把 AMQP（协议）的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。<strong>当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个 vhost，每个用户在自己的 vhost 创建 exchange／queue 等</strong>。</li>
<li><strong>Connection</strong>：<strong>publisher／consumer 和 broker 之间的 TCP 连接</strong>。</li>
<li><strong>Channel</strong>：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection 的开销将是巨大的，效率也较低。<strong>Channel 是在 connection 内部建立的逻辑连接</strong>，如果应用程序支持多线程，通常每个 thread 创建单独的 channel 进行通讯，AMQP method 包含了 channel id 帮助客户端和 message broker 识别 channel，所以 channel 之间是完全隔离的。<strong>Channel 作为轻量级的Connection极大减少了操作系统建立TCP connection的开销</strong>。</li>
<li><strong>Exchange</strong>：message 到达 broker 的第一站，<strong>根据分发规则，匹配查询表中的 routing key，分发消息到 queue 中去</strong>。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)</li>
<li><strong>Queue</strong>：<strong>消息最终被送到这里等待 consumer 取走</strong>。</li>
<li><strong>Binding</strong>：<strong>exchange 和 queue 之间的虚拟连接</strong>，binding 中可以包含 routing key，Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a></li>
</ul>
<h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><ul>
<li><p>下载到&#x2F;usr&#x2F;local&#x2F;software 目录下(如果没有 software 需要自己创建)</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029100246651.png" alt="image-20221029100246651"></p>
</li>
</ul>
<h3 id="安装文件-分别按照以下顺序安装"><a href="#安装文件-分别按照以下顺序安装" class="headerlink" title="安装文件(分别按照以下顺序安装)"></a>安装文件(分别按照以下顺序安装)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh erlang-21.3-1.el7.x86_64.rpm</span><br><span class="line">yum install socat -y</span><br><span class="line">rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>

<h3 id="常用命令（按照以下顺序执行）"><a href="#常用命令（按照以下顺序执行）" class="headerlink" title="常用命令（按照以下顺序执行）"></a>常用命令（按照以下顺序执行）</h3><ul>
<li><p>添加开机启动RabbitMQ服务：<strong>chkconfig rabbitmq-server on</strong></p>
</li>
<li><p>启动服务：**&#x2F;sbin&#x2F;service rabbitmq-server start**</p>
</li>
<li><p>查看服务状态：**&#x2F;sbin&#x2F;service rabbitmq-server status**</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029100508454.png" alt="image-20221029100508454"></p>
</li>
<li><p>停止服务（选择执行）：**&#x2F;sbin&#x2F;service rabbitmq-server stop**</p>
</li>
<li><p>开启web管理插件：<strong>rabbitmq-plugins enable rabbitmq_management</strong></p>
</li>
<li><p>用默认账号密码(guest)访问地址<a target="_blank" rel="noopener" href="http://47.115.185.244:15672/%E5%87%BA%E7%8E%B0%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%EF%BC%9A">http://47.115.185.244:15672/出现权限问题：</a></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029100645974.png" alt="image-20221029100645974"></p>
</li>
</ul>
<h3 id="添加一个新的用户"><a href="#添加一个新的用户" class="headerlink" title="添加一个新的用户"></a>添加一个新的用户</h3><ul>
<li><p>创建帐号：<strong>rabbitmqctl add_user admin 123</strong></p>
</li>
<li><p>设置用户角色：<strong>rabbitmqctl set_user_tags admin administrator</strong></p>
</li>
<li><p>设置用户权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_permissions [-p &lt;vhostpath&gt;] &lt;user&gt; &lt;conf&gt; &lt;write&gt; &lt;read&gt;</span><br><span class="line">rabbitmqctl set_permissions -p &quot;/&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">用户 user_admin 具有/vhost1 这个 virtual host 中所有资源的配置、写、读权限当前用户和角色</span><br><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="再次利用admin用户登录"><a href="#再次利用admin用户登录" class="headerlink" title="再次利用admin用户登录"></a>再次利用admin用户登录</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221029100915001.png" alt="image-20221029100915001"></p>
<h3 id="重置命令"><a href="#重置命令" class="headerlink" title="重置命令"></a>重置命令</h3><ul>
<li>关闭应用的命令为：<strong>rabbitmqctl stop_app</strong></li>
<li>清除的命令为：<strong>rabbitmqctl reset</strong></li>
<li>重新启动命令为：<strong>rabbitmqctl start_app</strong></li>
</ul>
<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><ul>
<li><p>在这一部分中，我们将用 Java 编写两个程序。发送单个消息的生产者和接收消息并打印出来的消费者。我们将介绍 Java API 中的一些细节。</p>
</li>
<li><p>在下图中，“P”是我们的生产者，“C”是我们的消费者。中间的框是一个队列-RabbitMQ代表使用者保留的消息缓冲区。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221030093742819.png" alt="image-20221030093742819"></p>
</li>
</ul>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定 jdk 编译版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> 				<span class="tag">&lt;<span class="name">source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"> 				<span class="tag">&lt;<span class="name">target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--rabbitmq 依赖客户端--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--操作文件流的一个依赖--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="comment">//创建一个连接工厂</span></span><br><span class="line"> 		<span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"> 		factory.setHost(<span class="string">&quot;182.92.234.71&quot;</span>);</span><br><span class="line"> 		factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"> 		factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">	 	<span class="comment">//channel 实现了自动 close 接口 自动关闭 不需要显示关闭</span></span><br><span class="line"> 		<span class="keyword">try</span>(<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel()) &#123;<span class="comment">//从factory中获得connection，再从connection中获得channel</span></span><br><span class="line"> 			<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 			 * 生成一个队列</span></span><br><span class="line"><span class="comment"> 			 * 1.队列名称</span></span><br><span class="line"><span class="comment"> 			 * 2.队列里面的消息是否持久化 默认消息存储在内存中</span></span><br><span class="line"><span class="comment"> 			 * 3.该队列是否只供一个消费者进行消费 是否进行共享 true 可以多个消费者消费</span></span><br><span class="line"><span class="comment"> 			 * 4.是否自动删除 最后一个消费者端开连接以后 该队列是否自动删除 true 自动删除</span></span><br><span class="line"><span class="comment"> 			 * 5.其他参数</span></span><br><span class="line"><span class="comment"> 			 */</span></span><br><span class="line"> 			channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);<span class="comment">//声明队列</span></span><br><span class="line"> 			String message=<span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"> 			<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 			 * 发送一个消息</span></span><br><span class="line"><span class="comment"> 			 * 1.发送到那个交换机</span></span><br><span class="line"><span class="comment"> 			 * 2.路由的 key 是哪个</span></span><br><span class="line"><span class="comment"> 			 * 3.其他的参数信息</span></span><br><span class="line"><span class="comment"> 			 * 4.发送消息的消息体</span></span><br><span class="line"><span class="comment"> 			 */</span></span><br><span class="line"> 			channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());<span class="comment">//由于没有设置交换机，所以消息发布到队列中</span></span><br><span class="line">			System.out.println(<span class="string">&quot;消息发送完毕&quot;</span>);</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		<span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"> 		factory.setHost(<span class="string">&quot;182.92.234.71&quot;</span>);</span><br><span class="line"> 		factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"> 		factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"> 		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"> 		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"> 		System.out.println(<span class="string">&quot;等待接收消息....&quot;</span>);</span><br><span class="line"> 		<span class="comment">//推送的消息如何进行消费的接口回调</span></span><br><span class="line"> 		DeliverCallback deliverCallback=(consumerTag,delivery)-&gt;&#123;</span><br><span class="line"> 			String message= <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line"> 			System.out.println(message);</span><br><span class="line"> 		&#125;;</span><br><span class="line"> 		<span class="comment">//取消消费的一个回调接口 如在消费的时候队列被删除掉了</span></span><br><span class="line"> 		CancelCallback cancelCallback=(consumerTag)-&gt;&#123;</span><br><span class="line"> 			System.out.println(<span class="string">&quot;消息消费被中断&quot;</span>);</span><br><span class="line"> 		&#125;;</span><br><span class="line"> 		<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 		 * 消费者消费消息</span></span><br><span class="line"><span class="comment"> 		 * 1.消费哪个队列</span></span><br><span class="line"><span class="comment"> 		 * 2.消费成功之后是否要自动应答 true 代表自动应答 false 手动应答</span></span><br><span class="line"><span class="comment"> 		 * 3.消费者未成功消费的回调</span></span><br><span class="line"><span class="comment"> 		 */</span></span><br><span class="line"> 		channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);<span class="comment">//从队列中消费消息</span></span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Work-Queues"><a href="#Work-Queues" class="headerlink" title="Work Queues"></a>Work Queues</h1><ul>
<li><p>工作队列(又称任务队列)的主要思想是<strong>避免立即执行资源密集型任务</strong>，而不得不等待它完成。</p>
<p>相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进</p>
<p>程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。</p>
</li>
</ul>
<h2 id="轮询分发消息"><a href="#轮询分发消息" class="headerlink" title="轮询分发消息"></a>轮询分发消息</h2><ul>
<li><p>在这个案例中我们会启动两个工作线程，一个消息发送线程，我们来看看他们两个工作线程</p>
<p>是如何工作的。</p>
</li>
</ul>
<h3 id="抽取工具类"><a href="#抽取工具类" class="headerlink" title="抽取工具类"></a>抽取工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqUtils</span> &#123;</span><br><span class="line"> 	<span class="comment">//得到一个连接的 channel</span></span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"> 		<span class="comment">//创建一个连接工厂</span></span><br><span class="line"> 		<span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line"> 		factory.setHost(<span class="string">&quot;182.92.234.71&quot;</span>);</span><br><span class="line"> 		factory.setUsername(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line"> 		factory.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"> 		<span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line"> 		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"> 		<span class="keyword">return</span> channel;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动两个工作线程"><a href="#启动两个工作线程" class="headerlink" title="启动两个工作线程"></a>启动两个工作线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker01</span> &#123;<span class="comment">//改个文本再开第二个线程比较有辨识度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">		DeliverCallback deliverCallback=(consumerTag,delivery)-&gt;&#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">			System.out.println(<span class="string">&quot;接收到消息:&quot;</span>+receivedMessage);</span><br><span class="line">		&#125;;</span><br><span class="line">		CancelCallback cancelCallback=(consumerTag)-&gt;&#123;</span><br><span class="line">			System.out.println(consumerTag+<span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line">		&#125;;</span><br><span class="line">		System.out.println(<span class="string">&quot;C2 消费者启动等待消费......&quot;</span>);</span><br><span class="line">		channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,cancelCallback);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221030230515903.png" alt="image-20221030230515903"></p>
<h3 id="启动一个发送线程"><a href="#启动一个发送线程" class="headerlink" title="启动一个发送线程"></a>启动一个发送线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task01</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		<span class="keyword">try</span>(Channel channel=RabbitMqUtils.getChannel();) &#123;</span><br><span class="line"> 			channel.queueDeclare(QUEUE_NAME,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"> 			<span class="comment">//从控制台当中接受信息</span></span><br><span class="line"> 			<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"> 			<span class="keyword">while</span> (scanner.hasNext())&#123;</span><br><span class="line"> 				<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> scanner.next();</span><br><span class="line"> 				channel.basicPublish(<span class="string">&quot;&quot;</span>,QUEUE_NAME,<span class="literal">null</span>,message.getBytes());</span><br><span class="line"> 				System.out.println(<span class="string">&quot;发送消息完成:&quot;</span>+message);</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><ul>
<li><p>通过程序执行发现生产者总共发送 4 个消息，消费者 1 和消费者 2 分别分得两个消息，并且是按照有序的一个接收一次消息。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221030230922398.png" alt="image-20221030230922398"></p>
</li>
</ul>
<h2 id="消息应答"><a href="#消息应答" class="headerlink" title="消息应答"></a>消息应答</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。<strong>默认情况下RabbitMQ一旦向消费者传递了一条消息，便立即将该消息标记为删除。在这种情况下，突然有个消费者挂掉了，我们将丢失正在处理的消息，以及后续发送给该消费者的消息</strong>，因为它无法接收到。</li>
<li>为了保证消息在发送过程中不丢失，rabbitmq引入<strong>消息应答机制</strong>，消息应答就是：<strong>消费者在接收到消息并且处理该消息之后，告诉 rabbitmq 它已经处理了，rabbitmq 可以把该消息删除了。</strong></li>
</ul>
<h3 id="自动应答"><a href="#自动应答" class="headerlink" title="自动应答"></a>自动应答</h3><ul>
<li><strong>消息发送后立即被认为已经传送成功</strong>，这种模式需要在<strong>高吞吐量和数据传输安全性方面做权衡</strong>,因为这种模式如果消息在接收到之前，消费者那边出现连接或者 channel 关闭，那么消息就丢失了,当然另一方面<strong>这种模式消费者那边可以传递过载的消息（因为传过去就马上确认，就可以马上传下一个了），没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压</strong>，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以<strong>这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用</strong>。</li>
</ul>
<h3 id="手动消息应答的方法"><a href="#手动消息应答的方法" class="headerlink" title="手动消息应答的方法"></a>手动消息应答的方法</h3><ul>
<li>**Channel.basicAck(args)**：用于肯定确认，RabbitMQ 已知道该消息并且成功的处理消息，可以将其丢弃了。</li>
<li>**Channel.basicNack()**：用于否定确认。</li>
<li>**Channel.basicReject()**：用于否定确认，与 Channel.basicNack 相比少一个参数，不处理该消息了直接拒绝，可以将其丢弃了</li>
</ul>
<h3 id="手动应答方法参数Multiple的解释"><a href="#手动应答方法参数Multiple的解释" class="headerlink" title="手动应答方法参数Multiple的解释"></a>手动应答方法参数Multiple的解释</h3><ul>
<li><p>手动应答的好处是<strong>可以批量应答并且减少网络拥堵</strong></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031090701521.png" alt="image-20221031090701521"></p>
</li>
<li><p>multiple的true和false代表不同的意思：</p>
<ul>
<li><p>true代表<strong>批量应答channel上未应答的消息</strong>。比如说 channel 上有传送 tag 的消息 5,6,7,8 当前 tag 是 8 那么此时5-8 的这些还未应答的消息都会被确认收到消息应答</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031091013530.png" alt="image-20221031091013530"></p>
</li>
<li><p>false同上面相比，只会应答tag&#x3D;8的消息，5，6，7这三个消息依然不会被确认收到消息应答</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031091025972.png" alt="image-20221031091025972"></p>
</li>
</ul>
</li>
</ul>
<h3 id="消息自动重新入队"><a href="#消息自动重新入队" class="headerlink" title="消息自动重新入队"></a>消息自动重新入队</h3><ul>
<li><p>如果消费者由于某些原因失去连接（其通道已关闭，连接已关闭或TCP连接丢失），导致<strong>消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将对其重新排队</strong>。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031091402285.png" alt="image-20221031091402285"></p>
</li>
</ul>
<h3 id="消息手动应答代码"><a href="#消息手动应答代码" class="headerlink" title="消息手动应答代码"></a>消息手动应答代码</h3><ul>
<li><p>默认消息采用的是自动应答，所以我们要想实现消息消费过程中不丢失，需要把自动应答改为手动应答，消费者在上面代码的基础上增加下面画红色部分代码。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031091631480.png" alt="image-20221031091631480"></p>
</li>
<li><p>消息生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task02</span> &#123;</span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TASK_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line">    </span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		<span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line"> 			channel.queueDeclare(TASK_QUEUE_NAME, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line"> 			<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"> 			System.out.println(<span class="string">&quot;请输入信息&quot;</span>);</span><br><span class="line"> 			<span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line"> 				<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"> 				channel.basicPublish(<span class="string">&quot;&quot;</span>, TASK_QUEUE_NAME, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"> 				System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line"> 			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者01：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work03</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACK_QUEUE_NAME=<span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"> 		System.out.println(<span class="string">&quot;C1 等待接收消息处理时间较短&quot;</span>);</span><br><span class="line">		<span class="comment">//消息消费的时候如何处理消息</span></span><br><span class="line"> 		DeliverCallback deliverCallback=(consumerTag,delivery)-&gt;&#123;</span><br><span class="line"> 			String message= <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line"> 			SleepUtils.sleep(<span class="number">1</span>);</span><br><span class="line"> 			System.out.println(<span class="string">&quot;接收到消息:&quot;</span>+message);</span><br><span class="line"> 			<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 			 * 1.消息标记 tag</span></span><br><span class="line"><span class="comment"> 			 * 2.是否批量应答未应答消息</span></span><br><span class="line"><span class="comment"> 			 */</span></span><br><span class="line"> 			channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line">		 &#125;;</span><br><span class="line"> 		<span class="comment">//采用手动应答</span></span><br><span class="line"> 		<span class="type">boolean</span> autoAck=<span class="literal">false</span>;</span><br><span class="line"> 		channel.basicConsume(ACK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag)-&gt;&#123;</span><br><span class="line"> 			System.out.println(consumerTag+<span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line"> 		&#125;);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者02：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Work04</span> &#123;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACK_QUEUE_NAME=<span class="string">&quot;ack_queue&quot;</span>;</span><br><span class="line"> 	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> 		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line"> 		System.out.println(<span class="string">&quot;C2 等待接收消息处理时间较长&quot;</span>);</span><br><span class="line"> 		<span class="comment">//消息消费的时候如何处理消息</span></span><br><span class="line"> 		DeliverCallback deliverCallback=(consumerTag,delivery)-&gt;&#123;</span><br><span class="line"> 			String message= <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line"> 			SleepUtils.sleep(<span class="number">30</span>);</span><br><span class="line"> 			System.out.println(<span class="string">&quot;接收到消息:&quot;</span>+message);</span><br><span class="line"> 			<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 			 * 1.消息标记 tag</span></span><br><span class="line"><span class="comment"> 			 * 2.是否批量应答未应答消息</span></span><br><span class="line"><span class="comment"> 			 */</span></span><br><span class="line"> 			channel.basicAck(delivery.getEnvelope().getDeliveryTag(),<span class="literal">false</span>);</span><br><span class="line"> 		&#125;;</span><br><span class="line"> 		<span class="comment">//采用手动应答</span></span><br><span class="line"> 		<span class="type">boolean</span> autoAck=<span class="literal">false</span>;</span><br><span class="line"> 		channel.basicConsume(ACK_QUEUE_NAME,autoAck,deliverCallback,(consumerTag)-&gt;&#123;</span><br><span class="line"> 			System.out.println(consumerTag+<span class="string">&quot;消费者取消消费接口回调逻辑&quot;</span>);</span><br><span class="line"> 		&#125;);</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="手动应答效果演示"><a href="#手动应答效果演示" class="headerlink" title="手动应答效果演示"></a>手动应答效果演示</h3><ul>
<li><p>正常情况下消息发送方发送两个消息，C1和C2分别接收到消息并进行处理：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031092726539.png" alt="image-20221031092726539"></p>
</li>
<li><p>在发送者发送消息 dd，发出消息之后把 C2 消费者停掉，按理说该 C2 来处理该消息，但是由于它处理时间较长，在还未处理完，也就是说 C2 还没有执行 ack 代码的时候，C2 被停掉了，此时会看到消息被 C1 接收到了，说明消息 dd 被重新入队，然后分配给能处理消息的 C1 处理了。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031092917687.png" alt="image-20221031092917687"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031092931800.png" alt="image-20221031092931800"></p>
</li>
</ul>
<h2 id="RabbitMQ持久化"><a href="#RabbitMQ持久化" class="headerlink" title="RabbitMQ持久化"></a>RabbitMQ持久化</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>刚刚我们已经看到了如何处理任务不丢失的情况，但是如何保障当 RabbitMQ 服务停掉以后消息生产者发送过来的消息不丢失。默认情况下 RabbitMQ 退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：<strong>我们需要将队列和消息都标记为持久化</strong>。</li>
</ul>
<h3 id="队列如何实现持久化"><a href="#队列如何实现持久化" class="headerlink" title="队列如何实现持久化"></a>队列如何实现持久化</h3><ul>
<li><p>之前我们创建的队列都是非持久化的，rabbitmq 如果重启的话，该队列就会被删除掉，如果要队列实现持久化 需要<strong>在声明队列的时候把durable参数设置为true</strong></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031093551216.png" alt="image-20221031093551216"></p>
</li>
<li><p>但是需要注意的就是<strong>如果之前声明的队列不是持久化的，需要把原先的队列先删除，或者重新创建一个持久化的队列，不然就会出现错误</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031093753906.png" alt="image-20221031093753906"></p>
</li>
<li><p>以下为控制台中持久化与非持久化队列的UI显示区：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031093845725.png" alt="image-20221031093845725"></p>
</li>
<li><p>将队列设置为持久化后，即使重启rabbitmq队列也依然存在。</p>
</li>
</ul>
<h3 id="消息实现持久化"><a href="#消息实现持久化" class="headerlink" title="消息实现持久化"></a>消息实现持久化</h3><ul>
<li><p>要想让消息实现持久化需要<strong>在消息生产者修改代码，添加MessageProperties.PERSISTENT_TEXT_PLAIN这个属性</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031094022385.png" alt="image-20221031094022385"></p>
</li>
<li><p>将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉 RabbitMQ 将消息保存到磁盘，但是这里<strong>依然存在当消息刚准备存储在磁盘的时候 但是还没有存储完，消息还在缓存的一个间隔点，此时并没有真正写入磁盘。持久性保证并不强</strong>，但是对于我们的简单任务队列而言，这已经绰绰有余了。如果需要更强有力的持久化策略，参考后边课件发布确认章节。</p>
</li>
</ul>
<h3 id="不公平分发"><a href="#不公平分发" class="headerlink" title="不公平分发"></a>不公平分发</h3><ul>
<li><p>在最开始的时候我们学习到 RabbitMQ 分发消息采用的轮询分发，但是在某种场景下这种策略并不是很好，<strong>比方说有两个消费者在处理任务，其中有个消费者 1 处理任务的速度非常快，而另外一个消费者2处理速度却很慢，这个时候我们还是采用轮询分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好</strong>，但是RabbitMQ 并不知道这种情况它依然很公平的进行分发。</p>
</li>
<li><p>为了避免这种情况，我们可以<strong>设置参数channel.basicQos(1);</strong></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031094452126.png" alt="image-20221031094452126"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031094517497.png" alt="image-20221031094517497"></p>
</li>
<li><p>意思就是<strong>如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我</strong>，我目前只能处理一个任务，然后 rabbitmq 就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的 worker 或者改变其他存储任务的策略。</p>
</li>
</ul>
<h3 id="预取值"><a href="#预取值" class="headerlink" title="预取值"></a>预取值</h3><ul>
<li><p>本身消息的发送就是异步发送的，所以在任何时候，channel 上肯定不止只有一个消息另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开发人员能<strong>限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题</strong>。这个时候就可以<strong>通过使用basic.qos 方法设置“预取计数”值</strong>来完成的。<strong>该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，RabbitMQ 将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认</strong>，例如，假设在通道上有未确认的消息 5、6、7，8，并且通道的预取计数设置为 4，此时 RabbitMQ 将不在该通道上再传递任何消息，除非至少有一个未应答的消息被 ack。比方说 tag&#x3D;6 这个消息刚刚被确认 ACK，RabbitMQ 将会感知这个情况到并再发送一条消息。消息应答和 QoS 预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。<strong>虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的RAM消耗</strong>(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同 100 到 300 范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。<strong>预取值为 1 是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中。对于大多数应用来说，稍微高一点的值将是最佳的</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221031095001072.png" alt="image-20221031095001072"></p>
</li>
</ul>
<h1 id="发布确认"><a href="#发布确认" class="headerlink" title="发布确认"></a>发布确认</h1><h2 id="发布确认原理"><a href="#发布确认原理" class="headerlink" title="发布确认原理"></a>发布确认原理</h2><ul>
<li>生产者将信道设置成 confirm 模式，<strong>一旦信道进入 confirm 模式，所有在该信道上面发布的消息都将会被指派一个唯一的 ID(从 1 开始)，一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者(包含消息的唯一 ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出</strong>，broker 回传给生产者的确认消息中 <strong>delivery-tag 域包含了确认消息的序列号</strong>，此外broker 也可以<strong>设置basic.ack 的 multiple 域，表示到这个序列号之前的所有消息都已经得到了处理</strong>。</li>
<li>confirm 模式最大的好处在于<strong>他是异步的</strong>，一旦发布一条消息，<strong>生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息</strong>，如果<strong>RabbitMQ 因为自身内部错误导致消息丢失，就会发送一条 nack 消息，生产者应用程序同样可以在回调方法中处理该 nack 消息</strong>。</li>
</ul>
<h2 id="发布确认的策略"><a href="#发布确认的策略" class="headerlink" title="发布确认的策略"></a>发布确认的策略</h2><h3 id="开启发布确认的方法"><a href="#开启发布确认的方法" class="headerlink" title="开启发布确认的方法"></a>开启发布确认的方法</h3><ul>
<li><p>发布确认默认是没有开启的，如果<strong>要开启需要调用方法 confirmSelect</strong>，每当你要想使用发布确认，都需要在 channel 上调用该方法：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105092853970.png" alt="image-20221105092853970"></p>
</li>
</ul>
<h3 id="单个确认发布"><a href="#单个确认发布" class="headerlink" title="单个确认发布"></a>单个确认发布</h3><ul>
<li><p>这是一种简单的确认方式，它是一种<strong>同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布</strong>,<strong>waitForConfirmsOrDie(long)这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常</strong>。</p>
</li>
<li><p>这种确认方式有一个最大的缺点就是:<strong>发布速度特别的慢</strong>，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量。当然对于某些应用程序来说这可能已经足够了。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageIndividually</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">		channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">		<span class="comment">//开启发布确认</span></span><br><span class="line">		channel.confirmSelect();</span><br><span class="line">		<span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">			channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">			<span class="comment">//服务端返回 false 或超时时间内未返回，生产者可以消息重发</span></span><br><span class="line">			<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> channel.waitForConfirms();</span><br><span class="line">			<span class="keyword">if</span>(flag)&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;消息发送成功&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个单独确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="批量确认发布"><a href="#批量确认发布" class="headerlink" title="批量确认发布"></a>批量确认发布</h3><ul>
<li><p>上面那种方式非常慢，与单个等待确认消息相比，<strong>先发布一批消息然后一起确认可以极大地提高吞吐量</strong>，当然这种方式的<strong>缺点就是:当发生故障导致发布出现问题时，不知道是哪个消息出现问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息</strong>。当然<strong>这种方案仍然是同步的，也一样阻塞消息的发布</strong>。</p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">		channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">		<span class="comment">//开启发布确认</span></span><br><span class="line">		channel.confirmSelect();</span><br><span class="line">		<span class="comment">//批量确认消息大小</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">batchSize</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">		<span class="comment">//未确认消息个数</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">outstandingMessageCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">			channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">			outstandingMessageCount++;</span><br><span class="line">			<span class="keyword">if</span> (outstandingMessageCount == batchSize) &#123;</span><br><span class="line">				channel.waitForConfirms();</span><br><span class="line">				outstandingMessageCount = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//为了确保还有剩余没有确认消息 再次确认</span></span><br><span class="line">		<span class="keyword">if</span> (outstandingMessageCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			channel.waitForConfirms();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个批量确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="异步确认发布"><a href="#异步确认发布" class="headerlink" title="异步确认发布"></a>异步确认发布</h3><ul>
<li><p>异步确认虽然编程逻辑比上两个要复杂，但是<strong>性价比最高，无论是可靠性还是效率都没得说</strong>，他是<strong>利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功</strong>，下面就让我们来详细讲解异步确认是怎么实现的。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105094400729.png" alt="image-20221105094400729"></p>
</li>
<li><p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">publishMessageAsync</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">	<span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">		channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">		<span class="comment">//开启发布确认</span></span><br><span class="line">		channel.confirmSelect();</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 线程安全有序的一个哈希表，适用于高并发的情况</span></span><br><span class="line"><span class="comment">		 * 1.轻松的将序号与消息进行关联</span></span><br><span class="line"><span class="comment">		 * 2.轻松批量删除条目 只要给到序列号</span></span><br><span class="line"><span class="comment">		 * 3.支持并发访问</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		ConcurrentSkipListMap&lt;Long, String&gt; outstandingConfirms = <span class="keyword">new</span> <span class="title class_">ConcurrentSkipListMap</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 确认收到消息的一个回调</span></span><br><span class="line"><span class="comment">		 * 1.消息序列号</span></span><br><span class="line"><span class="comment">		 * 2.true 可以确认小于等于当前序列号的消息</span></span><br><span class="line"><span class="comment">		 * 	 false 确认当前序列号消息</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">ConfirmCallback</span> <span class="variable">ackCallback</span> <span class="operator">=</span> (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">				<span class="comment">//返回的是小于等于当前序列号的未确认消息 是一个 map</span></span><br><span class="line">				ConcurrentNavigableMap&lt;Long, String&gt; confirmed = outstandingConfirms.headMap(sequenceNumber, <span class="literal">true</span>);</span><br><span class="line">				<span class="comment">//清除该部分未确认消息</span></span><br><span class="line">				confirmed.clear();</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="comment">//只清除当前序列号的消息</span></span><br><span class="line">				outstandingConfirms.remove(sequenceNumber);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">ConfirmCallback</span> <span class="variable">nackCallback</span> <span class="operator">=</span> (sequenceNumber, multiple) -&gt; &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> outstandingConfirms.get(sequenceNumber);</span><br><span class="line">			System.out.println(<span class="string">&quot;发布的消息&quot;</span>+message+<span class="string">&quot;未被确认，序列号&quot;</span>+sequenceNumber);</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 添加一个异步确认的监听器</span></span><br><span class="line"><span class="comment">		 * 1.确认收到消息的回调</span></span><br><span class="line"><span class="comment">		 * 2.未收到消息的回调</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		channel.addConfirmListener(ackCallback, <span class="literal">null</span>);</span><br><span class="line">		<span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MESSAGE_COUNT; i++) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;消息&quot;</span> + i;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * channel.getNextPublishSeqNo() 获取下一个消息的序列号</span></span><br><span class="line"><span class="comment">			 * 通过序列号与消息体进行一个关联</span></span><br><span class="line"><span class="comment">			 * 全部都是未确认的消息体</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			outstandingConfirms.put(channel.getNextPublishSeqNo(), message);</span><br><span class="line">			channel.basicPublish(<span class="string">&quot;&quot;</span>, queueName, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;发布&quot;</span> + MESSAGE_COUNT + <span class="string">&quot;个异步确认消息,耗时&quot;</span> + (end - begin) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="如何处理异步未确认消息"><a href="#如何处理异步未确认消息" class="headerlink" title="如何处理异步未确认消息"></a>如何处理异步未确认消息</h3><ul>
<li>最好的解决的解决方案就是<strong>把未确认的消息放到一个基于内存的能被发布线程访问的队列</strong>，比如说用 ConcurrentLinkedQueue 这个队列在 confirm callbacks 与发布线程之间进行消息的传递。</li>
</ul>
<h3 id="以上3种发布确认速度对比"><a href="#以上3种发布确认速度对比" class="headerlink" title="以上3种发布确认速度对比"></a>以上3种发布确认速度对比</h3><ul>
<li><p><strong>单独发布消息</strong>：同步等待确认，简单，但吞吐量非常有限。</p>
</li>
<li><p><strong>批量发布消息</strong>：批量同步等待确认，简单，合理的吞吐量，一旦出现问题但很难推断出是那条消息出现了问题。</p>
</li>
<li><p><strong>异步处理</strong>：最佳性能和资源使用，在出现错误的情况下可以很好地控制，但是实现起来稍微难些。</p>
</li>
<li><p>三种方式的确认速度对比：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221105095710510.png" alt="image-20221105095710510"></p>
</li>
</ul>
<h1 id="交换机-1"><a href="#交换机-1" class="headerlink" title="交换机"></a>交换机</h1><ul>
<li>在上一节中，我们创建了一个工作队列。我们<strong>假设的是工作队列背后，每个任务都恰好交付给一个消费者(工作进程)<strong>。在这一部分中，我们将做一些完全不同的事情-我们</strong>将消息传达给多个消费者。这种模式称为 ”发布&#x2F;订阅”</strong>。</li>
<li>为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成:第一个程序将发出日志消息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者</li>
</ul>
<h2 id="Exchange简介"><a href="#Exchange简介" class="headerlink" title="Exchange简介"></a>Exchange简介</h2><h3 id="Exchanges概念"><a href="#Exchanges概念" class="headerlink" title="Exchanges概念"></a>Exchanges概念</h3><ul>
<li><p>RabbitMQ 消息传递模型的核心思想是: <strong>生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中</strong>。</p>
</li>
<li><p>相反，<strong>生产者只能将消息发送到交换机(exchange)，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列</strong>。<strong>交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们到许多队列中还是说应该丢弃它们。这就的由交换机的类型来决定</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116093140914.png" alt="image-20221116093140914"></p>
</li>
</ul>
<h3 id="Exchanges的类型"><a href="#Exchanges的类型" class="headerlink" title="Exchanges的类型"></a>Exchanges的类型</h3><ul>
<li>目前总共有以下类型：**直接(direct), 主题(topic) ,标题(headers) , 扇出(fanout)**。</li>
</ul>
<h3 id="无名exchange"><a href="#无名exchange" class="headerlink" title="无名exchange"></a>无名exchange</h3><ul>
<li><p>在前面部分我们对 exchange 一无所知，但仍然能够将消息发送到队列。之前能实现的原因是因为我们使用的是默认交换，我们通过空字符串(“”)进行标识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="literal">null</span>,message.getBytes());</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个参数是交换机的名称。<strong>空字符串表示默认或无名称交换机：消息能路由发送到队列中其实是由 routingKey(bindingkey)绑定 key 指定的</strong>，如果它存在的话.</p>
</li>
</ul>
<h2 id="临时队列"><a href="#临时队列" class="headerlink" title="临时队列"></a>临时队列</h2><ul>
<li><p>之前的部分我们使用的是具有特定名称的队列(还记得 hello 和 ack_queue 吗？)。<strong>队列的名称我们来说至关重要-我们需要指定我们的消费者去消费哪个队列的消息</strong>。</p>
</li>
<li><p>每当我们连接到 Rabbit 时，我们都需要一个全新的空队列，为此我们<strong>可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了</strong>。其次<strong>一旦我们断开了消费者的连接，临时队列将被自动删除</strong>。</p>
</li>
<li><p>创建临时队列的方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建出来之后长这样儿：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116093814696.png" alt="image-20221116093814696"></p>
</li>
</ul>
<h2 id="绑定（bindings）"><a href="#绑定（bindings）" class="headerlink" title="绑定（bindings）"></a>绑定（bindings）</h2><ul>
<li><p>什么是 bingding 呢，<strong>binding 其实是 exchange 和 queue 之间的桥梁，它告诉我们 exchange 和那个队列进行了绑定关系</strong>。比如说下面这张图告诉我们的就是 X 与 Q1 和 Q2 进行了绑定：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116093917802.png" alt="image-20221116093917802"></p>
</li>
</ul>
<h2 id="Fanout-Exchange-扇出交换机"><a href="#Fanout-Exchange-扇出交换机" class="headerlink" title="Fanout Exchange(扇出交换机)"></a>Fanout Exchange(扇出交换机)</h2><h3 id="Fanout介绍"><a href="#Fanout介绍" class="headerlink" title="Fanout介绍"></a>Fanout介绍</h3><ul>
<li><p>Fanout这种类型非常简单。正如从名称中猜到的那样，<strong>它是将接收到的所有消息广播到它知道的所有队列中</strong>。系统中某些exchange的默认类型：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116094214448.png" alt="image-20221116094214448"></p>
</li>
</ul>
<h3 id="Fanout实战"><a href="#Fanout实战" class="headerlink" title="Fanout实战"></a>Fanout实战</h3><ul>
<li><p>准备实现以下结构：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116094408254.png" alt="image-20221116094408254"></p>
</li>
<li><p>Logs和临时队列的绑定关系如下图：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116094434664.png" alt="image-20221116094434664"></p>
</li>
<li><p>ReceiveLogs01 将接收到的消息打印在控制台：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs01</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">		channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 生成一个临时的队列 队列的名称是随机的</span></span><br><span class="line"><span class="comment">		 * 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">		<span class="comment">//把该临时队列绑定我们的 exchange 其中 routingkey(也称之为 binding key)为空字符串</span></span><br><span class="line">		channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;等待接收消息,把接收到的消息打印在屏幕.....&quot;</span>);</span><br><span class="line">		<span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;控制台打印接收到的消息&quot;</span>+message);</span><br><span class="line">		&#125;;</span><br><span class="line">		channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ReceiveLogs02 将接收到的消息存储在磁盘：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogs02</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">		channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 生成一个临时的队列 队列的名称是随机的</span></span><br><span class="line"><span class="comment">		 * 当消费者断开和该队列的连接时 队列自动删除</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> channel.queueDeclare().getQueue();</span><br><span class="line">		<span class="comment">//把该临时队列绑定我们的 exchange其中 routingkey(也称之为 binding key)为空字符串</span></span><br><span class="line">		channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;等待接收消息,把接收到的消息写到文件.....&quot;</span>);</span><br><span class="line">		<span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\work\\rabbitmq_info.txt&quot;</span>);</span><br><span class="line">			FileUtils.writeStringToFile(file,message,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;数据写入文件成功&quot;</span>);</span><br><span class="line">		&#125;;</span><br><span class="line">		channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123; &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>EmitLog 发送消息给两个消费者接收：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLog</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;logs&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel()) &#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 声明一个 exchange</span></span><br><span class="line"><span class="comment">			 * 1.exchange 的名称</span></span><br><span class="line"><span class="comment">			 * 2.exchange 的类型</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;fanout&quot;</span>);</span><br><span class="line">			<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">			System.out.println(<span class="string">&quot;请输入信息&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">				channel.basicPublish(EXCHANGE_NAME, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">				System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Direct-Exchange-直接交换机"><a href="#Direct-Exchange-直接交换机" class="headerlink" title="Direct Exchange(直接交换机)"></a>Direct Exchange(直接交换机)</h2><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><ul>
<li>在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能-比方说<strong>我们只让某个消费者订阅发布的部分消息</strong>。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。</li>
<li>我们再次来回顾一下什么是 bindings，<strong>绑定是交换机和队列之间的桥梁关系</strong>。也可以这么理解：<strong>队列只对它绑定的交换机的消息感兴趣</strong>。</li>
<li>绑定用参数：routingKey 来表示也可称该参数为 binding key，<strong>创建绑定我们用代码:channel.queueBind(queueName, EXCHANGE_NAME, “routingKey”);<strong>，</strong>绑定之后的意义由其交换类型决定，交换类型由交换机决定</strong>。</li>
</ul>
<h3 id="Direct-Exchange介绍"><a href="#Direct-Exchange介绍" class="headerlink" title="Direct Exchange介绍"></a>Direct Exchange介绍</h3><ul>
<li><p>上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希望将日志消息写入磁盘的程序仅接收严重错误(errros)，而不存储哪些警告(warning)或信息(info)日志消息避免浪费磁盘空间。<strong>Fanout 这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的广播</strong>，在这里我们将<strong>使用 direct 这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的routingKey 队列中去</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116095810639.png" alt="image-20221116095810639"></p>
</li>
<li><p>在上面这张图中，我们可以看到 X 绑定了两个队列，绑定类型是 direct。队列 Q1 绑定键为 orange，队列 Q2 绑定键有两个:一个绑定键为 black，另一个绑定键为 green。</p>
</li>
<li><p>在这种绑定情况下，生产者发布消息到 exchange 上，绑定键为 orange 的消息会被发布到队列Q1。绑定键为 blackgreen 和的消息会被发布到队列 Q2，其他消息类型的消息将被丢弃。</p>
</li>
</ul>
<h3 id="多重绑定"><a href="#多重绑定" class="headerlink" title="多重绑定"></a>多重绑定</h3><ul>
<li><p><strong>同一个routingKey可以和多个队列进行绑定</strong>：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116100026526.png" alt="image-20221116100026526"></p>
</li>
<li><p>当然如果 exchange 的绑定类型是 direct，但是它绑定的多个队列的 key 如果都相同，在这种情况下虽然绑定类型是 direct 但是它表现的就和 fanout 有点类似了，就跟广播差不多，如上图所示。</p>
</li>
</ul>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><ul>
<li><p>准备实现以下结构，通过不同的routingKey给日志区分级别并由不同的消费者进行处理（或没有消费者处理，直接丢弃）。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116100257537.png" alt="image-20221116100257537"></p>
</li>
<li><p>交换机的绑定关系如下：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116100330363.png" alt="image-20221116100330363"></p>
</li>
<li><p>消费者1接收错误日志并将其存储到磁盘中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect01</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">		channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">		<span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;disk&quot;</span>;</span><br><span class="line">		channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">		channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">		<span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			message=<span class="string">&quot;接收绑定键:&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="string">&quot;,消息:&quot;</span>+message;</span><br><span class="line">			<span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\work\\rabbitmq_info.txt&quot;</span>);</span><br><span class="line">			FileUtils.writeStringToFile(file,message,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;错误日志已经接收&quot;</span>);</span><br><span class="line">		&#125;;</span><br><span class="line">		channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者2接收info和warning级别的日志并输出到终端上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsDirect02</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">		channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">		<span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;console&quot;</span>;</span><br><span class="line">		channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">		channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;info&quot;</span>);</span><br><span class="line">		channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;warning&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">		<span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot; 接 收 绑 定 键 :&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="string">&quot;, 消息:&quot;</span>+message);</span><br><span class="line">		&#125;;</span><br><span class="line">		channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生产者发送消息到直接交换机中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLogDirect</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;direct_logs&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel()) &#123;</span><br><span class="line">			channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);</span><br><span class="line">			<span class="comment">//创建多个 bindingKey</span></span><br><span class="line">			Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">			bindingKeyMap.put(<span class="string">&quot;info&quot;</span>,<span class="string">&quot;普通 info 信息&quot;</span>);</span><br><span class="line">			bindingKeyMap.put(<span class="string">&quot;warning&quot;</span>,<span class="string">&quot;警告 warning 信息&quot;</span>);</span><br><span class="line">			bindingKeyMap.put(<span class="string">&quot;error&quot;</span>,<span class="string">&quot;错误 error 信息&quot;</span>);</span><br><span class="line">			<span class="comment">//debug 没有消费这接收这个消息 所有就丢失了</span></span><br><span class="line">			bindingKeyMap.put(<span class="string">&quot;debug&quot;</span>,<span class="string">&quot;调试 debug 信息&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry: bindingKeyMap.entrySet())&#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">bindingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line">				<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">				channel.basicPublish(EXCHANGE_NAME,bindingKey, <span class="literal">null</span>,message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">				System.out.println(<span class="string">&quot;生产者发出消息:&quot;</span> + message);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Topic-Exchange-主题交换机"><a href="#Topic-Exchange-主题交换机" class="headerlink" title="Topic Exchange(主题交换机)"></a>Topic Exchange(主题交换机)</h2><h3 id="之前类型的交换机存在的问题"><a href="#之前类型的交换机存在的问题" class="headerlink" title="之前类型的交换机存在的问题"></a>之前类型的交换机存在的问题</h3><ul>
<li>在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的 fanout 交换机，而是使用了 direct 交换机，从而有能实现有选择性地接收日志。</li>
<li>尽管使用 direct 交换机改进了我们的系统，但是它仍然存在局限性-比方说我们想接收的日志类型有info.base 和 info.advantage，某个队列只想 info.base 的消息，那这个时候 direct 就办不到了。这个时候就只能使用 topic 类型。</li>
</ul>
<h3 id="Topic-Exchange的要求"><a href="#Topic-Exchange的要求" class="headerlink" title="Topic Exchange的要求"></a>Topic Exchange的要求</h3><ul>
<li>发送到类型是 topic 交换机的消息的 routing_key 不能随意写，必须满足一定的要求，它<strong>必须是一个单词列表，以点号分隔开</strong>。这些单词可以是任意单词，比如说：”stock.usd.nyse”, “nyse.vmw”,”quick.orange.rabbit”.这种类型的。当然<strong>这个单词列表最多不能超过 255 个字节</strong>。</li>
<li>在这个规则列表中，其中有两个替换符是大家需要注意的：<ol>
<li>***(星号)可以代替一个单词**</li>
<li><strong>#(井号)可以替代零个或多个单词</strong></li>
</ol>
</li>
<li>之后<strong>主题交换机就通过结合了单词列表和替换符的routingKey进行路由</strong>。</li>
</ul>
<h3 id="Topic-Exchange匹配案例"><a href="#Topic-Exchange匹配案例" class="headerlink" title="Topic Exchange匹配案例"></a>Topic Exchange匹配案例</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116103116297.png" alt="image-20221116103116297"></p>
<ul>
<li>上图的绑定关系如下：<ul>
<li>Q1–&gt;绑定的是中间带 orange 带 3 个单词的字符串(*.orange.*)</li>
<li>Q2–&gt;绑定的是最后一个单词是 rabbit 的 3 个单词(*.*.rabbit)和第一个单词是 lazy 的多个单词(lazy.#)</li>
</ul>
</li>
<li>上图是一个队列绑定关系图，我们来看看他们之间数据接收情况是怎么样的：<ul>
<li>quick.orange.rabbit 被队列 Q1Q2 接收到</li>
<li>lazy.orange.elephant 被队列 Q1Q2 接收到</li>
<li>quick.orange.fox 被队列 Q1 接收到</li>
<li>lazy.brown.fox 被队列 Q2 接收到</li>
<li>lazy.pink.rabbit 虽然满足两个绑定但只被队列 Q2 接收一次</li>
<li>quick.brown.fox 不匹配任何绑定不会被任何队列接收到会被丢弃</li>
<li>quick.orange.male.rabbit 是四个单词不匹配任何绑定会被丢弃</li>
<li>lazy.orange.male.rabbit 是四个单词但匹配 Q2</li>
</ul>
</li>
<li>当队列绑定关系是下列这种情况时需要引起注意：<ul>
<li><strong>当一个队列绑定键是#,那么这个队列将接收所有数据，就有点像 fanout 了</strong></li>
<li><strong>如果队列绑定键当中没有#和*出现，那么该队列绑定类型就是 direct 了</strong></li>
</ul>
</li>
</ul>
<h3 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h3><ul>
<li><p>交换机的绑定关系如下：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221116103417491.png" alt="image-20221116103417491"></p>
</li>
<li><p>生产者发送消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmitLogTopic</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel()) &#123;</span><br><span class="line">			channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * Q1--&gt;绑定的是中间带 orange带3个单词的字符串(*.orange.*)</span></span><br><span class="line"><span class="comment">			 * Q2--&gt;绑定的是最后一个单词是 rabbit的 3个单词(*.*.rabbit)和第一个单词是 lazy的多个单词(lazy.#)</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			Map&lt;String, String&gt; bindingKeyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">			bindingKeyMap.put(<span class="string">&quot;quick.orange.rabbit&quot;</span>,<span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">			bindingKeyMap.put(<span class="string">&quot;lazy.orange.elephant&quot;</span>,<span class="string">&quot;被队列 Q1Q2 接收到&quot;</span>);</span><br><span class="line">			bindingKeyMap.put(<span class="string">&quot;quick.orange.fox&quot;</span>,<span class="string">&quot;被队列 Q1 接收到&quot;</span>);</span><br><span class="line">			bindingKeyMap.put(<span class="string">&quot;lazy.brown.fox&quot;</span>,<span class="string">&quot;被队列 Q2 接收到&quot;</span>);</span><br><span class="line">			bindingKeyMap.put(<span class="string">&quot;lazy.pink.rabbit&quot;</span>,<span class="string">&quot;虽然满足两个绑定但只被队列 Q2 接收一次&quot;</span>);</span><br><span class="line">			bindingKeyMap.put(<span class="string">&quot;quick.brown.fox&quot;</span>,<span class="string">&quot;不匹配任何绑定不会被任何队列接收到会被丢弃&quot;</span>);</span><br><span class="line">			bindingKeyMap.put(<span class="string">&quot;quick.orange.male.rabbit&quot;</span>,<span class="string">&quot;是四个单词不匹配任何绑定会被丢弃&quot;</span>);</span><br><span class="line">			bindingKeyMap.put(<span class="string">&quot;lazy.orange.male.rabbit&quot;</span>,<span class="string">&quot;是四个单词但匹配 Q2&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span> (Map.Entry&lt;String, String&gt; bindingKeyEntry: bindingKeyMap.entrySet())&#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">bindingKey</span> <span class="operator">=</span> bindingKeyEntry.getKey();</span><br><span class="line">				<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> bindingKeyEntry.getValue();</span><br><span class="line">				channel.basicPublish(EXCHANGE_NAME,bindingKey, <span class="literal">null</span>,</span><br><span class="line">				message.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">				System.out.println(<span class="string">&quot;生产者发出消息&quot;</span> + message);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic01</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">		channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">		<span class="comment">//声明 Q1队列与绑定关系</span></span><br><span class="line">		String queueName=<span class="string">&quot;Q1&quot;</span>;</span><br><span class="line">		channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">		channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.orange.*&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">		<span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot; 接 收 队 列 :&quot;</span>+queueName+<span class="string">&quot; 绑 定键:&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="string">&quot;,消息:&quot;</span>+message);</span><br><span class="line">		&#125;;</span><br><span class="line">		channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiveLogsTopic02</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;topic_logs&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">		channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">&quot;topic&quot;</span>);</span><br><span class="line">		<span class="comment">//声明 Q2队列与绑定关系</span></span><br><span class="line">		String queueName=<span class="string">&quot;Q2&quot;</span>;</span><br><span class="line">		channel.queueDeclare(queueName, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">		channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;*.*.rabbit&quot;</span>);</span><br><span class="line">		channel.queueBind(queueName, EXCHANGE_NAME, <span class="string">&quot;lazy.#&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">		<span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot; 接 收 队 列 :&quot;</span>+queueName+<span class="string">&quot; 绑 定键:&quot;</span>+delivery.getEnvelope().getRoutingKey()+<span class="string">&quot;,消息:&quot;</span>+message);</span><br><span class="line">		&#125;;</span><br><span class="line">		channel.basicConsume(queueName, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">		&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Header-Exchange-标题-x2F-首部交换机"><a href="#Header-Exchange-标题-x2F-首部交换机" class="headerlink" title="Header Exchange(标题&#x2F;首部交换机)"></a>Header Exchange(标题&#x2F;首部交换机)</h2><ul>
<li><strong>首部交换机是忽略<code>routing_key</code>的一种路由方式</strong>。路由器和交换机<strong>路由的规则是通过<code>Headers</code>信息来交换的</strong>，这个有点像<code>HTTP</code>的<code>Headers</code>。<strong>将一个交换机声明成首部交换机，绑定一个队列的时候，定义一个<code>Hash</code>的数据结构，消息发送的时候，会携带一组hash数据结构的信息，当<code>Hash</code>的内容匹配上的时候，消息就会被写入队列</strong>。</li>
<li>绑定交换机和队列的时候，Hash结构中要求携带一个键<strong>“x-match”</strong>，这个键的<code>Value</code>可以是<code>any</code>或者<code>all</code>，这代表消息携带的<code>Hash</code>是需要<strong>全部匹配</strong>(all)，还是<strong>仅匹配一个键</strong>(any)就可以了。**相比直连交换机，首部交换机的优势是匹配的规则不被限定为字符串(string)**。</li>
</ul>
<h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><h2 id="死信的概念"><a href="#死信的概念" class="headerlink" title="死信的概念"></a>死信的概念</h2><ul>
<li>先从概念解释上搞清楚这个定义，<strong>死信，顾名思义就是无法被消费的消息，字面意思可以这样理解</strong>，一般来说，producer 将消息投递到 broker 或者直接到 queue 里了，consumer 从 queue 取出消息进行消费，但<strong>某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列</strong>。</li>
<li>应用场景:<strong>为了保证订单业务的消息数据不丢失，需要使用到 RabbitMQ 的死信队列机制，当消息消费发生异常时，将消息投入死信队列中</strong>.还有比如说: <strong>用户在商城下单成功并点击去支付后在指定时间未支付时自动失效</strong>。</li>
</ul>
<h2 id="死信的来源"><a href="#死信的来源" class="headerlink" title="死信的来源"></a>死信的来源</h2><ol>
<li><strong>消息 TTL 过期</strong></li>
<li><strong>队列达到最大长度</strong>(队列满了，无法再添加数据到 mq 中)</li>
<li><strong>消息被拒绝(basic.reject 或 basic.nack)并且 requeue&#x3D;false</strong>.</li>
</ol>
<h2 id="死信实战"><a href="#死信实战" class="headerlink" title="死信实战"></a>死信实战</h2><h3 id="代码架构图"><a href="#代码架构图" class="headerlink" title="代码架构图"></a>代码架构图</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117110145349.png" alt="image-20221117110145349"></p>
<p>需要手动给队列配置它的死信队列。</p>
<h3 id="消息TTL过期造成的死信"><a href="#消息TTL过期造成的死信" class="headerlink" title="消息TTL过期造成的死信"></a>消息TTL过期造成的死信</h3><ul>
<li><p>主要是<strong>发送消息的时候给消息设置TTL时间，然后发送到队列中，将对应的消费者关闭以模拟消费者无法消费队列中的消息的场景，然后TTL到期后，相关消息就会被送到和当前队列绑定的死信队列中，被死信队列的消费者消费掉</strong>。</p>
</li>
<li><p>生产者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">			channel.exchangeDeclare(NORMAL_EXCHANGE,BuiltinExchangeType.DIRECT);</span><br><span class="line">			<span class="comment">//设置消息的 TTL时间</span></span><br><span class="line">			AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">			<span class="title class_">AMQP</span>.BasicProperties().builder().expiration(<span class="string">&quot;10000&quot;</span>).build();</span><br><span class="line">			<span class="comment">//该信息是用作演示队列个数限制</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">11</span> ; i++) &#123;</span><br><span class="line">				String message=<span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">				channel.basicPublish(NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>, properties,message.getBytes());</span><br><span class="line">				System.out.println(<span class="string">&quot;生产者发送消息:&quot;</span>+message);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者C1代码（启动之后关闭该消费者，模拟其接收不到消息的情况）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line">	<span class="comment">//普通交换机名称</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">	<span class="comment">//死信交换机名称</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">		<span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">		channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">		channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">		<span class="comment">//声明死信队列</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">		channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">		<span class="comment">//死信队列绑定死信交换机与 routingkey</span></span><br><span class="line">		channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">		<span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">		Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//正常队列设置死信交换机 参数 key是固定值</span></span><br><span class="line">		params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">		<span class="comment">//正常队列设置死信 routing-key参数 key是固定值</span></span><br><span class="line">		params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">normalQueue</span> <span class="operator">=</span> <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">		channel.queueDeclare(normalQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">		channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">		<span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span>+message);</span><br><span class="line">		&#125;;</span><br><span class="line">		channel.basicConsume(normalQueue, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117110757546.png" alt="image-20221117110757546"></p>
</li>
<li><p>消费者C2代码（以上步骤完成后，启动C2消费者，它消费死信队列里面的信息）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer02</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">		channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">		<span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">		channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">		channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;等待接收死信队列消息.....&quot;</span>);</span><br><span class="line">		<span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;Consumer02 接收死信队列的消息&quot;</span> + message);</span><br><span class="line">		&#125;;</span><br><span class="line">		channel.basicConsume(deadQueue, <span class="literal">true</span>, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117111130151.png" alt="image-20221117111130151"></p>
</li>
</ul>
<h3 id="队列达到最大长度造成死信"><a href="#队列达到最大长度造成死信" class="headerlink" title="队列达到最大长度造成死信"></a>队列达到最大长度造成死信</h3><ul>
<li><p>也是<strong>通过关闭消费者来模拟消费者无法消费队列中的消息，然后队列中的消息越来越多，最后达到队列所能存储消息的上限，多余的消息就会被送到死信队列中</strong>。</p>
</li>
<li><p>上面消息生产者的代码去掉设置消息的TTL这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel()) &#123;</span><br><span class="line">			channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">             <span class="comment">//该信息是用作演示队列个数限制</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">11</span> ; i++) &#123;</span><br><span class="line">				String message=<span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">				channel.basicPublish(NORMAL_EXCHANGE,<span class="string">&quot;zhangsan&quot;</span>,<span class="literal">null</span>, message.getBytes());</span><br><span class="line">				System.out.println(<span class="string">&quot;生产者发送消息:&quot;</span>+message);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C1 消费者修改以下代码(启动之后关闭该消费者 模拟其接收不到消息)：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117112737502.png" alt="image-20221117112737502"></p>
<p>需要手动删除之前的队列以更新队列的配置。</p>
</li>
<li><p>C2 消费者代码不变(启动 C2 消费者)：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117112840830.png" alt="image-20221117112840830"></p>
</li>
</ul>
<h3 id="消息被拒造成的死信"><a href="#消息被拒造成的死信" class="headerlink" title="消息被拒造成的死信"></a>消息被拒造成的死信</h3><ul>
<li><p>通过<strong>手动让消费者拒绝消息来模拟消息在消费的时候被拒绝的情景，被拒绝的消息会进入死信队列中</strong>。</p>
</li>
<li><p>消息生产者代码同上生产者一致</p>
</li>
<li><p>C1 消费者代码(手动拒绝消息 模拟其拒绝消息)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer01</span> &#123;</span><br><span class="line">	<span class="comment">//普通交换机名称</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NORMAL_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;normal_exchange&quot;</span>;</span><br><span class="line">	<span class="comment">//死信交换机名称</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;dead_exchange&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitUtils.getChannel();</span><br><span class="line">		<span class="comment">//声明死信和普通交换机 类型为 direct</span></span><br><span class="line">		channel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">		channel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);</span><br><span class="line">		<span class="comment">//声明死信队列</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">deadQueue</span> <span class="operator">=</span> <span class="string">&quot;dead-queue&quot;</span>;</span><br><span class="line">		channel.queueDeclare(deadQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">		<span class="comment">//死信队列绑定死信交换机与 routingkey</span></span><br><span class="line">		channel.queueBind(deadQueue, DEAD_EXCHANGE, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">		<span class="comment">//正常队列绑定死信队列信息</span></span><br><span class="line">		Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//正常队列设置死信交换机 参数 key是固定值</span></span><br><span class="line">		params.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DEAD_EXCHANGE);</span><br><span class="line">		<span class="comment">//正常队列设置死信 routing-key参数 key是固定值</span></span><br><span class="line">		params.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">normalQueue</span> <span class="operator">=</span> <span class="string">&quot;normal-queue&quot;</span>;</span><br><span class="line">		channel.queueDeclare(normalQueue, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">		channel.queueBind(normalQueue, NORMAL_EXCHANGE, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;等待接收消息.....&quot;</span>);</span><br><span class="line">		<span class="type">DeliverCallback</span> <span class="variable">deliverCallback</span> <span class="operator">=</span> (consumerTag, delivery) -&gt; &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span>(message.equals(<span class="string">&quot;info5&quot;</span>))&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span> + message + <span class="string">&quot;并拒绝签收该消息&quot;</span>);</span><br><span class="line">				<span class="comment">//requeue设置为 false代表拒绝重新入队 该队列如果配置了死信交换机将发送到死信队列中</span></span><br><span class="line">				channel.basicReject(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;Consumer01 接收到消息&quot;</span>+message);</span><br><span class="line">				channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">autoAck</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">		channel.basicConsume(normalQueue, autoAck, deliverCallback, consumerTag -&gt; &#123;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117113216967.png" alt="image-20221117113216967"></p>
</li>
<li><p>C2消费者代码不变。启动消费者1然后再启动消费者2：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221117113300286.png" alt="image-20221117113300286"></p>
</li>
</ul>
<h1 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h1><h2 id="延迟队列概念"><a href="#延迟队列概念" class="headerlink" title="延迟队列概念"></a>延迟队列概念</h2><ul>
<li>延时队列,队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的元素的队列。</li>
</ul>
<h2 id="延迟队列使用场景"><a href="#延迟队列使用场景" class="headerlink" title="延迟队列使用场景"></a>延迟队列使用场景</h2><ol>
<li>订单在十分钟之内未支付则自动取消</li>
<li>新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒。</li>
<li>用户注册成功后，如果三天内没有登陆则进行短信提醒。</li>
<li>用户发起退款，如果三天内没有得到处理则通知相关运营人员。</li>
<li>预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议</li>
</ol>
<ul>
<li><p>这些场景都有一个特点，<strong>需要在某个事件发生之后或者之前的指定时间点完成某一项任务</strong>，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果数据量比较少，确实可以这样做，比如：对于“如果账单一周内未支付则进行自动结算”这样的需求，如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：“订单十分钟内未支付则关闭“，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118093518414.png" alt="image-20221118093518414"></p>
</li>
</ul>
<h2 id="RabbitMQ中的TTL"><a href="#RabbitMQ中的TTL" class="headerlink" title="RabbitMQ中的TTL"></a>RabbitMQ中的TTL</h2><ul>
<li>TTL 是什么呢？<strong>TTL就是Time To Live生存时间</strong>，TTL 是 RabbitMQ 中一个消息或者队列的属性，<strong>表明一条消息或者该队列中的所有消息的最大存活时间，单位是毫秒</strong>。换句话说，<strong>如果一条消息设置了 TTL 属性或者进入了设置 TTL 属性的队列，那么这条消息如果在 TTL 设置的时间内没有被消费，则会成为”死信”<strong>。如果</strong>同时配置了队列的 TTL 和消息的TTL，那么较小的那个值将会被使用</strong>，有两种方式设置 TTL。</li>
</ul>
<h3 id="队列设置TTL"><a href="#队列设置TTL" class="headerlink" title="队列设置TTL"></a>队列设置TTL</h3><ul>
<li><p>第一种是在创建队列的时候设置队列的“x-message-ttl”属性：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118093824706.png" alt="image-20221118093824706"></p>
</li>
</ul>
<h3 id="消息设置TTL"><a href="#消息设置TTL" class="headerlink" title="消息设置TTL"></a>消息设置TTL</h3><ul>
<li><p>另一种方式便是针对每条消息设置 TTL：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118093848655.png" alt="image-20221118093848655"></p>
</li>
</ul>
<h3 id="两种设置TTL方式的区别"><a href="#两种设置TTL方式的区别" class="headerlink" title="两种设置TTL方式的区别"></a>两种设置TTL方式的区别</h3><ul>
<li><strong>如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)<strong>，而</strong>如果设置消息的TTL，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的（也就是说如果设置了消息的TTL，只有该消息将要被消费者消费的时候会检查一遍TTL，别的时间不检查TTL），如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间（因为消息始终没有将被消费者消费，所以它们的TTL一直得不到检查）</strong>；另外，还需要注意的一点是，<strong>如果不设置 TTL，表示消息永远不会过期，如果将 TTL 设置为 0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃</strong>。</li>
<li>前一小节我们介绍了死信队列，刚刚又介绍了 TTL，至此利用 RabbitMQ 实现延时队列的两大要素已经集齐，接下来只需要将它们进行融合，再加入一点点调味料，延时队列就可以新鲜出炉了。想想看，延时队列，不就是想要消息延迟多久被处理吗，<strong>TTL 则刚好能让消息在延迟多久之后成为死信，另一方面，成为死信的消息都会被投递到死信队列里，这样只需要消费者一直消费死信队列里的消息就完事了，因为里面的消息都是希望被立即处理的消息</strong>。</li>
</ul>
<h2 id="整合SpringBoot"><a href="#整合SpringBoot" class="headerlink" title="整合SpringBoot"></a>整合SpringBoot</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118095817073.png" alt="image-20221118095817073"></p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--RabbitMQ依赖--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--RabbitMQ测试依赖--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.amqp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-rabbit-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">182.92.234.71</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure>

<h3 id="添加Swagger配置类"><a href="#添加Swagger配置类" class="headerlink" title="添加Swagger配置类"></a>添加Swagger配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.Contact;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Docket <span class="title function_">webApiConfig</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">			.groupName(<span class="string">&quot;webApi&quot;</span>)</span><br><span class="line">			.apiInfo(webApiInfo())</span><br><span class="line">			.select()</span><br><span class="line">			.build();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">private</span> ApiInfo <span class="title function_">webApiInfo</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">				.title(<span class="string">&quot;rabbitmq 接口文档&quot;</span>)</span><br><span class="line">				.description(<span class="string">&quot;本文档描述了 rabbitmq 微服务接口定义&quot;</span>)</span><br><span class="line">				.version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">				.contact(<span class="keyword">new</span> <span class="title class_">Contact</span>(<span class="string">&quot;enjoy6288&quot;</span>, <span class="string">&quot;http://atguigu.com&quot;</span>,<span class="string">&quot;1551388580@qq.com&quot;</span>))</span><br><span class="line">				.build();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="通过设置队列的TTL实现延迟队列"><a href="#通过设置队列的TTL实现延迟队列" class="headerlink" title="通过设置队列的TTL实现延迟队列"></a>通过设置队列的TTL实现延迟队列</h2><h3 id="代码架构图-1"><a href="#代码架构图-1" class="headerlink" title="代码架构图"></a>代码架构图</h3><ul>
<li><p>创建两个队列 QA 和 QB，两者队列 TTL 分别设置为 10S 和 40S，然后在创建一个交换机 X 和死信交换机 Y，它们的类型都是 direct，创建一个死信队列 QD，它们的绑定关系如下：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118100311986.png" alt="image-20221118100311986"></p>
</li>
</ul>
<h3 id="配置文件类代码"><a href="#配置文件类代码" class="headerlink" title="配置文件类代码"></a>配置文件类代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TtlQueueConfig</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">X_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;X&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_A</span> <span class="operator">=</span> <span class="string">&quot;QA&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_B</span> <span class="operator">=</span> <span class="string">&quot;QB&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEAD_LETTER_QUEUE</span> <span class="operator">=</span> <span class="string">&quot;QD&quot;</span>;</span><br><span class="line">	<span class="comment">//声明 xExchange</span></span><br><span class="line">	<span class="meta">@Bean(&quot;xExchange&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> DirectExchange <span class="title function_">xExchange</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(X_EXCHANGE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明 xExchange</span></span><br><span class="line">	<span class="meta">@Bean(&quot;yExchange&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> DirectExchange <span class="title function_">yExchange</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明队列 A ttl 为 10s 并绑定到对应的死信交换机</span></span><br><span class="line">	<span class="meta">@Bean(&quot;queueA&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Queue <span class="title function_">queueA</span><span class="params">()</span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">		<span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">		args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">		<span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">		args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">		<span class="comment">//声明队列的 TTL</span></span><br><span class="line">		args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">		<span class="keyword">return</span> QueueBuilder.durable(QUEUE_A).withArguments(args).build();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明队列 A 绑定 X 交换机</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Binding <span class="title function_">queueaBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueA&quot;)</span> Queue queueA,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BindingBuilder.bind(queueA).to(xExchange).with(<span class="string">&quot;XA&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明队列 B ttl为 40s并绑定到对应的死信交换机</span></span><br><span class="line">	<span class="meta">@Bean(&quot;queueB&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">		<span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">		args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">		<span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">		args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">		<span class="comment">//声明队列的 TTL</span></span><br><span class="line">		args.put(<span class="string">&quot;x-message-ttl&quot;</span>, <span class="number">40000</span>);</span><br><span class="line">		<span class="keyword">return</span> QueueBuilder.durable(QUEUE_B).withArguments(args).build();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明队列 B 绑定 X 交换机</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Binding <span class="title function_">queuebBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueB&quot;)</span> Queue queue1B,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BindingBuilder.bind(queue1B).to(xExchange).with(<span class="string">&quot;XB&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明死信队列 QD</span></span><br><span class="line">	<span class="meta">@Bean(&quot;queueD&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Queue <span class="title function_">queueD</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DEAD_LETTER_QUEUE);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明死信队列 QD 绑定关系</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Binding <span class="title function_">deadLetterBindingQAD</span><span class="params">(<span class="meta">@Qualifier(&quot;queueD&quot;)</span> Queue queueD,<span class="meta">@Qualifier(&quot;yExchange&quot;)</span> DirectExchange yExchange)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BindingBuilder.bind(queueD).to(yExchange).with(<span class="string">&quot;YD&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息生产者代码"><a href="#消息生产者代码" class="headerlink" title="消息生产者代码"></a>消息生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;ttl&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SendMsgController</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">	<span class="meta">@GetMapping(&quot;sendMsg/&#123;message&#125;&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line">		log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条信息给两个 TTL 队列:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), message);</span><br><span class="line">		rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XA&quot;</span>, <span class="string">&quot;消息来自 ttl 为 10S 的队列: &quot;</span>+message);</span><br><span class="line">		rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XB&quot;</span>, <span class="string">&quot;消息来自 ttl 为 40S 的队列: &quot;</span>+message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息消费者代码"><a href="#消息消费者代码" class="headerlink" title="消息消费者代码"></a>消息消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLetterQueueConsumer</span> &#123;</span><br><span class="line">	<span class="meta">@RabbitListener(queues = &quot;QD&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveD</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">		log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到死信队列信息&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li><p>发起一个请求 <a target="_blank" rel="noopener" href="http://localhost:8080/ttl/sendMsg/%E5%98%BB%E5%98%BB%E5%98%BB%EF%BC%9A">http://localhost:8080/ttl/sendMsg/嘻嘻嘻：</a></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118101038315.png" alt="image-20221118101038315"></p>
</li>
<li><p>第一条消息在 10S 后变成了死信消息，然后被消费者消费掉，第二条消息在 40S 之后变成了死信消息，然后被消费掉，这样一个延时队列就打造完成了。</p>
</li>
<li><p>不过，如果这样使用的话，岂不是每增加一个新的时间需求，就要新增一个队列，这里只有 10S 和 40S两个时间选项，如果需要一个小时后处理，那么就需要增加 TTL 为一个小时的队列，如果是预定会议室然后提前通知这样的场景，岂不是要增加无数个队列才能满足需求？</p>
</li>
<li><p>问题在于<strong>无法很方便地添加处理新的延时长度的解决方案</strong>。</p>
</li>
</ul>
<h2 id="通过设置消息的TTL实现延迟队列"><a href="#通过设置消息的TTL实现延迟队列" class="headerlink" title="通过设置消息的TTL实现延迟队列"></a>通过设置消息的TTL实现延迟队列</h2><h3 id="代码架构图-2"><a href="#代码架构图-2" class="headerlink" title="代码架构图"></a>代码架构图</h3><ul>
<li><p>在这里新增了一个队列QC，绑定关系如下，该队列不设置TTL时间：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118101405136.png" alt="image-20221118101405136"></p>
</li>
</ul>
<h3 id="配置文件类代码-1"><a href="#配置文件类代码-1" class="headerlink" title="配置文件类代码"></a>配置文件类代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MsgTtlQueueConfig</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">Y_DEAD_LETTER_EXCHANGE</span> <span class="operator">=</span> <span class="string">&quot;Y&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_C</span> <span class="operator">=</span> <span class="string">&quot;QC&quot;</span>;</span><br><span class="line">	<span class="comment">//声明队列 C 死信交换机</span></span><br><span class="line">	<span class="meta">@Bean(&quot;queueC&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Queue <span class="title function_">queueB</span><span class="params">()</span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">		<span class="comment">//声明当前队列绑定的死信交换机</span></span><br><span class="line">		args.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, Y_DEAD_LETTER_EXCHANGE);</span><br><span class="line">		<span class="comment">//声明当前队列的死信路由 key</span></span><br><span class="line">		args.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;YD&quot;</span>);</span><br><span class="line">		<span class="comment">//没有声明 TTL属性</span></span><br><span class="line">		<span class="keyword">return</span> QueueBuilder.durable(QUEUE_C).withArguments(args).build();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明队列 B 绑定 X 交换机</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Binding <span class="title function_">queuecBindingX</span><span class="params">(<span class="meta">@Qualifier(&quot;queueC&quot;)</span> Queue queueC,<span class="meta">@Qualifier(&quot;xExchange&quot;)</span> DirectExchange xExchange)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BindingBuilder.bind(queueC).to(xExchange).with(<span class="string">&quot;XC&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息生产者代码-1"><a href="#消息生产者代码-1" class="headerlink" title="消息生产者代码"></a>消息生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;sendExpirationMsg/&#123;message&#125;/&#123;ttlTime&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message,<span class="meta">@PathVariable</span> String ttlTime)</span> &#123;</span><br><span class="line">	rabbitTemplate.convertAndSend(<span class="string">&quot;X&quot;</span>, <span class="string">&quot;XC&quot;</span>, message, correlationData -&gt;&#123;</span><br><span class="line">		correlationData.getMessageProperties().setExpiration(ttlTime);</span><br><span class="line">		<span class="keyword">return</span> correlationData;</span><br><span class="line">	&#125;);</span><br><span class="line">	log.info(<span class="string">&quot;当前时间：&#123;&#125;,发送一条时长&#123;&#125;毫秒 TTL 信息给队列 C:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(),ttlTime, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><ul>
<li><p>发起请求<br><a target="_blank" rel="noopener" href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendExpirationMsg/你好</a> 1&#x2F;20000<br><a target="_blank" rel="noopener" href="http://localhost:8080/ttl/sendExpirationMsg/%E4%BD%A0%E5%A5%BD">http://localhost:8080/ttl/sendExpirationMsg/你好</a> 2&#x2F;2000</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118101718111.png" alt="image-20221118101718111"></p>
</li>
<li><p>看起来似乎没什么问题，但是在最开始的时候，就介绍过<strong>如果使用在消息属性上设置 TTL 的方式，消息可能并不会按时“死亡“，因为 RabbitMQ 只会检查第一个消息是否过期</strong>，如果过期则丢到死信队列，如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。</p>
</li>
<li><p>问题在于<strong>无法保证检查各消息TTL的并行性，也就是无法保证各消息按时死亡</strong>。</p>
</li>
</ul>
<h2 id="Rabbitmq插件实现延迟队列解决上述问题"><a href="#Rabbitmq插件实现延迟队列解决上述问题" class="headerlink" title="Rabbitmq插件实现延迟队列解决上述问题"></a>Rabbitmq插件实现延迟队列解决上述问题</h2><ul>
<li>上文中两种实现方式提到的问题，确实是我们需要去解决的，<strong>如果不能实现在消息粒度上的 TTL，并使其在设置的 TTL 时间及时死亡，就无法设计成一个通用的延时队列</strong>。那如何解决呢，接下来我们就去解决该问题。</li>
</ul>
<h3 id="安装延时队列插件"><a href="#安装延时队列插件" class="headerlink" title="安装延时队列插件"></a>安装延时队列插件</h3><ul>
<li><p>在官网上下载 <a target="_blank" rel="noopener" href="https://www.rabbitmq.com/community-plugins.html%EF%BC%8C%E4%B8%8B%E8%BD%BD">https://www.rabbitmq.com/community-plugins.html，下载</a><br><strong>rabbitmq_delayed_message_exchange</strong>插件，然后解压放置到 RabbitMQ 的plugins目录。</p>
</li>
<li><p>进入 RabbitMQ 的安装目录下的 <strong>plgins 目录</strong>，<strong>执行下面命令让该插件生效</strong>，然后<strong>重启RabbitMQ</strong>：<strong>rabbitmq-plugins enable rabbitmq_delayed_message_exchange</strong></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118103039084.png" alt="image-20221118103039084"></p>
</li>
<li><p>在RabbitMQ的图形化界面中查看插件的安装情况：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118103116179.png" alt="image-20221118103116179"></p>
</li>
</ul>
<h3 id="代码架构图-3"><a href="#代码架构图-3" class="headerlink" title="代码架构图"></a>代码架构图</h3><ul>
<li><p>在这里新增了一个队列 delayed.queue,一个自定义交换机 delayed.exchange，绑定关系如下：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118103144304.png" alt="image-20221118103144304"></p>
</li>
<li><p>确实比之前的方案简洁了不少。</p>
</li>
</ul>
<h3 id="配置文件类代码-2"><a href="#配置文件类代码-2" class="headerlink" title="配置文件类代码"></a>配置文件类代码</h3><ul>
<li><p>主要是<strong>通过设置交换机的类型为我们新安装的那个插件的类型来让交换机实现延时投递消息的功能</strong>。</p>
</li>
<li><p>在我们自定义的交换机中，这是一种新的交换类型，<strong>该类型消息支持延迟投递机制 消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayedQueueConfig</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(DELAYED_QUEUE_NAME);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//自定义交换机 我们在这里定义的是一个延迟交换机</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> CustomExchange <span class="title function_">delayedExchange</span><span class="params">()</span> &#123;</span><br><span class="line">		Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="comment">//自定义交换机的类型</span></span><br><span class="line">		args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(DELAYED_EXCHANGE_NAME, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>,args);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Binding <span class="title function_">bindingDelayedQueue</span><span class="params">(<span class="meta">@Qualifier(&quot;delayedQueue&quot;)</span> Queue queue,<span class="meta">@Qualifier(&quot;delayedExchange&quot;)</span> CustomExchange delayedExchange)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> BindingBuilder.bind(queue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="消息生产者代码-2"><a href="#消息生产者代码-2" class="headerlink" title="消息生产者代码"></a>消息生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.exchange&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_ROUTING_KEY</span> <span class="operator">=</span> <span class="string">&quot;delayed.routingkey&quot;</span>;</span><br><span class="line"><span class="meta">@GetMapping(&quot;sendDelayMsg/&#123;message&#125;/&#123;delayTime&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsg</span><span class="params">(<span class="meta">@PathVariable</span> String message,<span class="meta">@PathVariable</span> Integer delayTime)</span> &#123;</span><br><span class="line">	rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY, message,correlationData -&gt;&#123;</span><br><span class="line">    correlationData.getMessageProperties().setDelay(delayTime);</span><br><span class="line">	<span class="keyword">return</span> correlationData;</span><br><span class="line">	&#125;);</span><br><span class="line">	log.info(<span class="string">&quot; 当 前 时 间 ： &#123;&#125;, 发 送 一 条 延 迟 &#123;&#125; 毫 秒 的 信 息 给 队 列 delayed.queue:&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(),delayTime, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息消费者代码-1"><a href="#消息消费者代码-1" class="headerlink" title="消息消费者代码"></a>消息消费者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELAYED_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;delayed.queue&quot;</span>;</span><br><span class="line"><span class="meta">@RabbitListener(queues = DELAYED_QUEUE_NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveDelayedQueue</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">	log.info(<span class="string">&quot;当前时间：&#123;&#125;,收到延时队列的消息：&#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>().toString(), msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><ul>
<li><p>发起请求：</p>
<p><a target="_blank" rel="noopener" href="http://localhost:8080/ttl/sendDelayMsg/come">http://localhost:8080/ttl/sendDelayMsg/come</a> on baby1&#x2F;20000<br><a target="_blank" rel="noopener" href="http://localhost:8080/ttl/sendDelayMsg/come">http://localhost:8080/ttl/sendDelayMsg/come</a> on baby2&#x2F;2000</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221118105503523.png" alt="image-20221118105503523"></p>
</li>
<li><p>第二个消息被先消费掉了，符合预期</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>延时队列在需要延时处理的场景下非常有用，<strong>使用 RabbitMQ 来实现延时队列可以很好的利用RabbitMQ 的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃</strong>。另外，<strong>通过 RabbitMQ 集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失</strong>。</li>
<li>当然，延时队列还有很多其它选择，比如利用<strong>Java 的 DelayQueue，利用 Redis 的 zset，利用 Quartz 或者利用 kafka 的时间轮</strong>，这些方式各有特点,看需要适用的场景</li>
</ul>
<h1 id="发布确认高级"><a href="#发布确认高级" class="headerlink" title="发布确认高级"></a>发布确认高级</h1><ul>
<li><p>在生产环境中<strong>由于一些不明原因，导致 rabbitmq 重启，在RabbitMQ 重启期间生产者消息投递失败，导致消息丢失，需要手动处理和恢复</strong>。于是，我们开始思考，<strong>如何才能进行 RabbitMQ 的消息可靠投递呢</strong>？特别是在这样比较极端的情况，RabbitMQ 集群不可用的时候，无法投递的消息该如何处理呢：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">应 用 [xxx] 在 [08-1516:36:04] 发 生 [ 错 误 日 志 异 常 ] ， alertId=[xxx] 。 </span><br><span class="line">由[org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:620] 触 发 。</span><br><span class="line">应用 xxx 可能原因如下</span><br><span class="line">服 务 名 为 ：</span><br><span class="line">异 常 为 ： org.springframework.amqp.rabbit.listener.BlockingQueueConsumer:start:620,</span><br><span class="line">产 生 原 因 如 下 :1.org.springframework.amqp.rabbit.listener.QueuesNotAvailableException:</span><br><span class="line">Cannot prepare queue for listener. Either the queue doesn&#x27;t exist or the broker will not</span><br><span class="line">allow us to use it.||Consumer received fatal=false exception on startup:</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="发布确认的SpringBoot版本"><a href="#发布确认的SpringBoot版本" class="headerlink" title="发布确认的SpringBoot版本"></a>发布确认的SpringBoot版本</h2><ul>
<li>针对上面的问题我们通常<strong>采用消息的发布确认模式，并且设置缓存，可以尽可能保证消息的可靠传递</strong>。</li>
</ul>
<h3 id="确认机制方案"><a href="#确认机制方案" class="headerlink" title="确认机制方案"></a>确认机制方案</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121165323942.png" alt="image-20221121165323942"></p>
<h3 id="代码架构图-4"><a href="#代码架构图-4" class="headerlink" title="代码架构图"></a>代码架构图</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121165344609.png" alt="image-20221121165344609"></p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul>
<li><p>在配置文件当中需要添加<strong>spring.rabbitmq.publisher-confirm-type&#x3D;correlated</strong></p>
<p>后面的值可以换不同的，有不同的效果：</p>
<p><strong>none</strong>：禁用发布确认模式，是默认值</p>
<p><strong>correlated</strong>：发布消息成功到交换机后会出发回调方法</p>
<p><strong>simple</strong>：经测试有两种效果，其一效果和correlated值一样会触发回调方法，其二在发布消息成功后使用 rabbitTemplate 调用 waitForConfirms 或 waitForConfirmsOrDie 方法<br>等待 broker 节点返回发送结果，根据返回结果来判定下一步的逻辑，要注意的点是<br>waitForConfirmsOrDie 方法如果返回 false 则会关闭 channel，则接下来无法发送消息到 broker。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">182.92.234.71</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>=<span class="string">123</span></span><br><span class="line"><span class="attr">spring.rabbitmq.publisher-confirm-type</span>=<span class="string">correlated</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="添加配置类"><a href="#添加配置类" class="headerlink" title="添加配置类"></a>添加配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line">	<span class="comment">//声明业务 Exchange</span></span><br><span class="line">	<span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(CONFIRM_EXCHANGE_NAME);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明确认队列</span></span><br><span class="line">	<span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明确认队列绑定关系</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Binding <span class="title function_">queueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息生产者-1"><a href="#消息生产者-1" class="headerlink" title="消息生产者"></a>消息生产者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/confirm&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> MyCallBack myCallBack;</span><br><span class="line">	<span class="comment">//依赖注入 rabbitTemplate 之后再设置它的回调对象</span></span><br><span class="line">	<span class="meta">@PostConstruct</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">		rabbitTemplate.setConfirmCallback(myCallBack);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@GetMapping(&quot;sendMessage/&#123;message&#125;&quot;)</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@PathVariable</span> String message)</span>&#123;</span><br><span class="line">		<span class="comment">//指定消息 id为 1</span></span><br><span class="line">		CorrelationData correlationData1=<span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">		String routingKey=<span class="string">&quot;key1&quot;</span>;</span><br><span class="line">		rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME,routingKey,message+routingKey,correlationData1);</span><br><span class="line">		CorrelationData correlationData2=<span class="keyword">new</span> <span class="title class_">CorrelationData</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">		routingKey=<span class="string">&quot;key2&quot;</span>;</span><br><span class="line">		rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME,routingKey,message+routingKey,correlationData2);</span><br><span class="line">		log.info(<span class="string">&quot;发送消息内容:&#123;&#125;&quot;</span>,message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回调接口"><a href="#回调接口" class="headerlink" title="回调接口"></a>回调接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 交换机不管是否收到消息的一个回调方法</span></span><br><span class="line"><span class="comment">	 * CorrelationData 消息相关数据</span></span><br><span class="line"><span class="comment">	 * ack 交换机是否收到消息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">		String id=correlationData!=<span class="literal">null</span>?correlationData.getId():<span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(ack)&#123;</span><br><span class="line">			log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>,id);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>,id,cause);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="消息消费者-1"><a href="#消息消费者-1" class="headerlink" title="消息消费者"></a>消息消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConsumer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line">	<span class="meta">@RabbitListener(queues =CONFIRM_QUEUE_NAME)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">		String msg=<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">		log.info(<span class="string">&quot;接受到队列 confirm.queue 消息:&#123;&#125;&quot;</span>,msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121185348719.png" alt="image-20221121185348719"></p>
<ul>
<li>可以看到，发送了两条消息，第一条消息的 RoutingKey 为 “key1”，第二条消息的 RoutingKey 为”key2”，两条消息都成功被交换机接收，也收到了交换机的确认回调，但消费者只收到了一条消息，因为第二条消息的 RoutingKey 与队列的 BindingKey 不一致，也没有其它队列能接收这个消息，所有第二条消息被直接丢弃了。</li>
</ul>
<h2 id="回退消息"><a href="#回退消息" class="headerlink" title="回退消息"></a>回退消息</h2><h3 id="Mandatory参数"><a href="#Mandatory参数" class="headerlink" title="Mandatory参数"></a>Mandatory参数</h3><ul>
<li>在仅开启了生产者确认机制的情况下，交换机接收到消息后，会直接给消息生产者发送确认消息，如果发现该消息不可路由，那么消息会被直接丢弃，此时生产者是不知道消息被丢弃这个事件的。那么如何让无法被路由的消息帮我想办法处理一下？最起码通知我一声，我好自己处理啊。通过设置 mandatory 参数可以在当消息传递过程中不可达目的地时将消息返回给生产者。</li>
</ul>
<h3 id="消息生产者代码-3"><a href="#消息生产者代码-3" class="headerlink" title="消息生产者代码"></a>消息生产者代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageProducer</span> <span class="keyword">implements</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback ,</span><br><span class="line">RabbitTemplate.ReturnCallback &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">	<span class="comment">//rabbitTemplate 注入之后就设置该值</span></span><br><span class="line">	<span class="meta">@PostConstruct</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">		rabbitTemplate.setConfirmCallback(<span class="built_in">this</span>);</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * true：交换机无法将消息进行路由时，会将该消息返回给生产者</span></span><br><span class="line"><span class="comment">		 * false：如果发现消息无法进行路由，则直接丢弃</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		rabbitTemplate.setMandatory(<span class="literal">true</span>);</span><br><span class="line">		<span class="comment">//设置回退消息交给谁处理</span></span><br><span class="line">		rabbitTemplate.setReturnCallback(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@GetMapping(&quot;sendMessage&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">(String message)</span>&#123;</span><br><span class="line">	<span class="comment">//让消息绑定一个 id值</span></span><br><span class="line">	<span class="type">CorrelationData</span> <span class="variable">correlationData1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">	rabbitTemplate.convertAndSend(<span class="string">&quot;confirm.exchange&quot;</span>,<span class="string">&quot;key1&quot;</span>,message+<span class="string">&quot;key1&quot;</span>,correlationData1);</span><br><span class="line">	log.info(<span class="string">&quot;发送消息 id 为:&#123;&#125;内容为&#123;&#125;&quot;</span>,correlationData1.getId(),message+<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">	<span class="type">CorrelationData</span> <span class="variable">correlationData2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>(UUID.randomUUID().toString());</span><br><span class="line">	rabbitTemplate.convertAndSend(<span class="string">&quot;confirm.exchange&quot;</span>,<span class="string">&quot;key2&quot;</span>,message+<span class="string">&quot;key2&quot;</span>,correlationData2);</span><br><span class="line">	log.info(<span class="string">&quot;发送消息 id 为:&#123;&#125;内容为&#123;&#125;&quot;</span>,correlationData2.getId(),message+<span class="string">&quot;key2&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> correlationData != <span class="literal">null</span> ? correlationData.getId() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span> (ack) &#123;</span><br><span class="line">			log.info(<span class="string">&quot;交换机收到消息确认成功, id:&#123;&#125;&quot;</span>, id);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			log.error(<span class="string">&quot;消息 id:&#123;&#125;未成功投递到交换机,原因是:&#123;&#125;&quot;</span>, id, cause);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class="line">		log.info(<span class="string">&quot;消息:&#123;&#125;被服务器退回，退回原因:&#123;&#125;, 交换机是:&#123;&#125;, 路由 key:&#123;&#125;&quot;</span>,</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()),replyText, exchange, routingKey);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回调接口-1"><a href="#回调接口-1" class="headerlink" title="回调接口"></a>回调接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallBack</span> <span class="keyword">implements</span></span><br><span class="line"><span class="title class_">RabbitTemplate</span>.ConfirmCallback,RabbitTemplate.ReturnCallback &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 交换机不管是否收到消息的一个回调方法</span></span><br><span class="line"><span class="comment">	 * CorrelationData 消息相关数据</span></span><br><span class="line"><span class="comment"> 	 * ack 交换机是否收到消息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">		String id=correlationData!=<span class="literal">null</span>?correlationData.getId():<span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">if</span>(ack)&#123;</span><br><span class="line">			log.info(<span class="string">&quot;交换机已经收到 id 为:&#123;&#125;的消息&quot;</span>,id);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			log.info(<span class="string">&quot;交换机还未收到 id 为:&#123;&#125;消息,由于原因:&#123;&#125;&quot;</span>,id,cause);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//当消息无法路由的时候的回调方法</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class="line">		log.error(<span class="string">&quot; 消 息 &#123;&#125;, 被 交 换 机 &#123;&#125; 退 回 ， 退 回 原 因 :&#123;&#125;, 路 由 key:&#123;&#125;&quot;</span>,<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()),exchange,replyText,routingKey);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121192233476.png" alt="image-20221121192233476"></p>
<h2 id="备份交换机"><a href="#备份交换机" class="headerlink" title="备份交换机"></a>备份交换机</h2><ul>
<li><strong>有了 mandatory 参数和回退消息，我们获得了对无法投递消息的感知能力，有机会在生产者的消息无法被投递时发现并处理</strong>。但有时候，我们并不知道该如何处理这些无法路由的消息，最多打个日志，然后触发报警，再来手动处理。而通过日志来处理这些无法路由的消息是很不优雅的做法，特别是当生产者所在的服务有多台机器的时候，手动复制日志会更加麻烦而且容易出错。而且设置 mandatory 参数会增加生产者的复杂性，需要添加处理这些被退回的消息的逻辑。如果既不想丢失消息，又不想增加生产者的复杂性，该怎么做呢？前面在设置死信队列的文章中，我们提到，可以为队列设置死信交换机来存储那些处理失败的消息，可是这些不可路由消息根本没有机会进入到队列，因此无法使用死信队列来保存消息。在 RabbitMQ 中，有一种备份交换机的机制存在，可以很好的应对这个问题。什么是备份交换机呢？<strong>备份交换机可以理解为 RabbitMQ 中交换机的“备胎”，当我们为某一个交换机声明一个对应的备份交换机时，就是为它创建一个备胎，当交换机接收到一条不可路由消息时，将会把这条消息转发到备份交换机中，由备份交换机来进行转发和处理</strong>，通常备份交换机的类型为 Fanout ，这样就能把所有消息都投递到与其绑定的队列中，然后我们在备份交换机下绑定一个队列，这样所有那些原交换机无法被路由的消息，就会都进入这个队列了。当然，我们<strong>还可以建立一个报警队列，用独立的消费者来进行监测和报警</strong>。</li>
</ul>
<h3 id="代码架构图-5"><a href="#代码架构图-5" class="headerlink" title="代码架构图"></a>代码架构图</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121192654594.png" alt="image-20221121192654594"></p>
<h3 id="修改配置类"><a href="#修改配置类" class="headerlink" title="修改配置类"></a>修改配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfirmConfig</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.exchange&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONFIRM_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;confirm.queue&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;backup.exchange&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BACKUP_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;backup.queue&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WARNING_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;warning.queue&quot;</span>;</span><br><span class="line">	<span class="comment">//声明确认队列</span></span><br><span class="line">	<span class="meta">@Bean(&quot;confirmQueue&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Queue <span class="title function_">confirmQueue</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明确认队列绑定关系</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Binding <span class="title function_">queueBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;confirmQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;confirmExchange&quot;)</span> DirectExchange exchange)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明备份 Exchange</span></span><br><span class="line">	<span class="meta">@Bean(&quot;backupExchange&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> FanoutExchange <span class="title function_">backupExchange</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(BACKUP_EXCHANGE_NAME);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明确认 Exchange 交换机的备份交换机</span></span><br><span class="line">	<span class="meta">@Bean(&quot;confirmExchange&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> DirectExchange <span class="title function_">confirmExchange</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">ExchangeBuilder</span> <span class="variable">exchangeBuilder</span> <span class="operator">=</span> </span><br><span class="line">           ExchangeBuilder.directExchange(CONFIRM_EXCHANGE_NAME).durable(<span class="literal">true</span>)</span><br><span class="line">			<span class="comment">//设置该交换机的备份交换机</span></span><br><span class="line">			.withArgument(<span class="string">&quot;alternate-exchange&quot;</span>, BACKUP_EXCHANGE_NAME);</span><br><span class="line">		<span class="keyword">return</span> (DirectExchange)exchangeBuilder.build();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明警告队列</span></span><br><span class="line">	<span class="meta">@Bean(&quot;warningQueue&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Queue <span class="title function_">warningQueue</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> QueueBuilder.durable(WARNING_QUEUE_NAME).build();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明报警队列绑定关系</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Binding <span class="title function_">warningBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;warningQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明备份队列</span></span><br><span class="line">	<span class="meta">@Bean(&quot;backQueue&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> Queue <span class="title function_">backQueue</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> QueueBuilder.durable(BACKUP_QUEUE_NAME).build();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//声明备份队列绑定关系</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="keyword">public</span> Binding <span class="title function_">backupBinding</span><span class="params">(<span class="meta">@Qualifier(&quot;backQueue&quot;)</span> Queue queue, <span class="meta">@Qualifier(&quot;backupExchange&quot;)</span> FanoutExchange backupExchange)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BindingBuilder.bind(queue).to(backupExchange);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="报警消费者"><a href="#报警消费者" class="headerlink" title="报警消费者"></a>报警消费者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WarningConsumer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">WARNING_QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;warning.queue&quot;</span>;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = WARNING_QUEUE_NAME)</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveWarningMsg</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(message.getBody());</span><br><span class="line">		log.error(<span class="string">&quot;报警发现不可路由消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试注意事项"><a href="#测试注意事项" class="headerlink" title="测试注意事项"></a>测试注意事项</h3><ul>
<li><p><strong>重新启动项目的时候需要把原来的 confirm.exchange 删除因为我们修改了其绑定属性</strong>，不然报以下错:</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121193524288.png" alt="image-20221121193524288"></p>
</li>
</ul>
<h3 id="结果分析-2"><a href="#结果分析-2" class="headerlink" title="结果分析"></a>结果分析</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221121193542021.png" alt="image-20221121193542021"></p>
<ul>
<li>mandatory 参数与备份交换机可以一起使用的时候，如果两者同时开启，消息究竟何去何从？谁优先级高，经过上面结果显示答案是<strong>备份交换机优先级高</strong>。</li>
</ul>
<h1 id="RabbitMQ其他知识点"><a href="#RabbitMQ其他知识点" class="headerlink" title="RabbitMQ其他知识点"></a>RabbitMQ其他知识点</h1><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><ul>
<li><strong>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用</strong>。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额发现多扣钱了，流水记录也变成了两条。在以前的单应用系统中，我们只需要把数据操作放入事务中即可，发生错误立即回滚，但是再响应客户端的时候也有可能出现网络中断或者异常等等。</li>
</ul>
<h3 id="消息重复消费"><a href="#消息重复消费" class="headerlink" title="消息重复消费"></a>消息重复消费</h3><ul>
<li>消费者在消费 MQ 中的消息时，MQ 已把消息发送给消费者，消费者在给 MQ 返回 ack 时网络中断，故 <strong>MQ 未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消息</strong>。</li>
</ul>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><ul>
<li>MQ 消费者的幂等性的解决<strong>一般使用全局 ID 或者写个唯一标识比如时间戳 或者 UUID 或者订单消费者消费 MQ 中的消息也可利用 MQ 的该 id 来判断，或者可按自己的规则生成一个全局唯一 id，每次消费消息时用该 id 先判断该消息是否已消费过</strong>。</li>
</ul>
<h3 id="消费端的幂等性保障"><a href="#消费端的幂等性保障" class="headerlink" title="消费端的幂等性保障"></a>消费端的幂等性保障</h3><ul>
<li>在海量订单生成的业务高峰期，<strong>生产端有可能就会重复发生了消息，这时候消费端就要实现幂等性，这就意味着我们的消息永远不会被消费多次，即使我们收到了一样的消息</strong>。业界主流的幂等性有两种操作:a.<strong>唯一 ID+指纹码机制,利用数据库主键去重</strong>, b.<strong>利用 redis 的原子性去实现</strong></li>
</ul>
<h3 id="唯一ID-指纹码机制"><a href="#唯一ID-指纹码机制" class="headerlink" title="唯一ID+指纹码机制"></a>唯一ID+指纹码机制</h3><ul>
<li><strong>指纹码:我们的一些规则或者时间戳加别的服务给到的唯一信息码,它并不一定是我们系统生成的，基本都是由我们的业务规则拼接而来，但是一定要保证唯一性</strong>，然后就<strong>利用查询语句进行判断这个 id 是否存在数据库中</strong>,<strong>优势就是实现简单就一个拼接，然后查询判断是否重复</strong>；<strong>劣势就是在高并发时，如果是单个数据库就会有写入性能瓶颈当然也可以采用分库分表提升性能</strong>，但也不是我们最推荐的方式。</li>
</ul>
<h3 id="Redis原子性"><a href="#Redis原子性" class="headerlink" title="Redis原子性"></a>Redis原子性</h3><ul>
<li><strong>利用redis执行setnx命令，天然具有幂等性</strong>，从而实现不重复消费。</li>
</ul>
<h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>在我们系统中有一个<strong>订单催付的场景</strong>，我们的客户在天猫下的订单,淘宝会及时将订单推送给我们，如果在用户设定的时间内未付款那么就会给用户推送一条短信提醒，很简单的一个功能对吧，但是，tmall 商家对我们来说，肯定是要分大客户和小客户的对吧，比如像苹果，小米这样大商家一年起码能给我们创造很大的利润，所以理应当然，他们的订单必须得到优先处理，而曾经我们的后端系统是使用 redis 来存放的定时轮询，大家都知道 redis 只能用 List 做一个简简单单的消息队列，并不能实现一个优先级的场景，所以<strong>订单量大了后采用 RabbitMQ 进行改造和优化,如果发现是大客户的订单就给一个相对比较高的优先级，否则就给默认优先级</strong>。</li>
</ul>
<h3 id="如何添加优先级"><a href="#如何添加优先级" class="headerlink" title="如何添加优先级"></a>如何添加优先级</h3><ul>
<li><p>可以<strong>在控制台页面给队列添加最大优先级属性</strong>，从而使队列变成优先级队列：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122121113089.png" alt="image-20221122121113089"></p>
</li>
<li><p>也可以在<strong>声明队列的代码中添加最大优先级属性</strong>从而让队列变成优先级队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;hello&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br></pre></td></tr></table></figure>

<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122121153693.png" alt="image-20221122121153693"></p>
</li>
<li><p><strong>在生成消息的代码中添加优先级</strong>表示当前消息的优先级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项：要让队列实现优先级需要做的事情有如下事情：<strong>队列需要设置为优先级队列，消息需要设置消息的优先级，消费者需要等待消息已经发送到队列中才去消费</strong>，因为这样才有机会对消息进行排序</p>
</li>
</ul>
<h3 id="实战-2"><a href="#实战-2" class="headerlink" title="实战"></a>实战</h3><ul>
<li><p>消息生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">try</span> (<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();) &#123;</span><br><span class="line">			<span class="comment">//给消息赋予一个 priority属性来表示当前消息的优先级</span></span><br><span class="line">			AMQP.<span class="type">BasicProperties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AMQP</span>.BasicProperties().builder().priority(<span class="number">5</span>).build();</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;<span class="number">11</span>; i++) &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;info&quot;</span>+i;</span><br><span class="line">				<span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">					channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, properties, message.getBytes());</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="literal">null</span>, message.getBytes());</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;发送消息完成:&quot;</span> + message);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消息消费者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUEUE_NAME=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> RabbitMqUtils.getChannel();</span><br><span class="line">        <span class="comment">//设置队列的最大优先级 最大可以设置到 255 官网推荐 1-10 如果设置太高比较吃内存和 CPU</span></span><br><span class="line">		Map&lt;String, Object&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">		params.put(<span class="string">&quot;x-max-priority&quot;</span>, <span class="number">10</span>);</span><br><span class="line">		channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, params);</span><br><span class="line">		System.out.println(<span class="string">&quot;消费者启动等待消费......&quot;</span>);</span><br><span class="line">		DeliverCallback deliverCallback=(consumerTag, delivery)-&gt;&#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">receivedMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(delivery.getBody());</span><br><span class="line">			System.out.println(<span class="string">&quot;接收到消息:&quot;</span>+receivedMessage);</span><br><span class="line">		&#125;;</span><br><span class="line">		channel.basicConsume(QUEUE_NAME,<span class="literal">true</span>,deliverCallback,(consumerTag)-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;消费者无法消费消息时调用，如队列被删除&quot;</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>RabbitMQ 从 3.6.0 版本开始引入了惰性队列的概念。<strong>惰性队列会尽可能的将消息存入磁盘中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储</strong>。当消费者<strong>由于各种各样的原因(比如消费者下线、宕机亦或者是由于维护而关闭等)而致使长时间内不能消费消息造成堆积时，惰性队列就很有必要了</strong>。</li>
<li><strong>默认情况（不使用惰性队列）下，当生产者将消息发送到 RabbitMQ 的时候，队列中的消息会尽可能的存储在内存之中，这样可以更加快速的将消息发送给消费者</strong>。即使是<strong>持久化的消息，在被写入磁盘的同时也会在内存中驻留一份备份。当 RabbitMQ 需要释放内存的时候，会将内存中的消息换页至磁盘中，这个操作会耗费较长的时间，也会阻塞队列的操作，进而无法接收新的消息</strong>。虽然 RabbitMQ 的开发者们一直在升级相关的算法，但是效果始终不太理想，尤其是在消息量特别大的时候。</li>
</ul>
<h3 id="队列的两种模式"><a href="#队列的两种模式" class="headerlink" title="队列的两种模式"></a>队列的两种模式</h3><ul>
<li><p><strong>队列具备两种模式：default 和 lazy</strong>。默认的为 default 模式，在 3.6.0 之前的版本无需做任何变更。<strong>lazy模式即为惰性队列的模式，可以通过调用 channel.queueDeclare 方法的时候在参数中设置，也可以通过Policy 的方式设置，如果一个队列同时使用这两种方式设置的话，那么 Policy 的方式具备更高的优先级</strong>。如果<strong>要通过声明的方式改变已有队列的模式的话，那么只能先删除队列，然后再重新声明一个新的</strong>。</p>
</li>
<li><p>在队列声明的时候<strong>可以通过“x-queue-mode”参数来设置队列的模式，取值为“default”和“lazy”</strong>。下面示例中演示了一个惰性队列的声明细节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">args.put(<span class="string">&quot;x-queue-mode&quot;</span>, <span class="string">&quot;lazy&quot;</span>);</span><br><span class="line">channel.queueDeclare(<span class="string">&quot;myqueue&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, args);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="内存开销对比"><a href="#内存开销对比" class="headerlink" title="内存开销对比"></a>内存开销对比</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122122542824.png" alt="image-20221122122542824"></p>
<ul>
<li>在发送 1 百万条消息，每条消息大概占 1KB 的情况下，普通队列占用内存是 1.2GB，而惰性队列仅仅占用 1.5MB，毕竟大部分数据全存到磁盘中了。</li>
</ul>
<h1 id="RabbitMQ集群"><a href="#RabbitMQ集群" class="headerlink" title="RabbitMQ集群"></a>RabbitMQ集群</h1><h2 id="clustering-使用集群"><a href="#clustering-使用集群" class="headerlink" title="clustering(使用集群)"></a>clustering(使用集群)</h2><h3 id="使用集群的原因"><a href="#使用集群的原因" class="headerlink" title="使用集群的原因"></a>使用集群的原因</h3><ul>
<li>最开始我们介绍了如何安装及运行 RabbitMQ 服务，不过这些是单机版的，无法满足目前真实应用的要求。如果 RabbitMQ 服务器遇到内存崩溃、机器掉电或者主板故障等情况，该怎么办？单台 RabbitMQ服务器可以满足每秒 1000 条消息的吞吐量，那么如果应用需要RabbitMQ 服务满足每秒 10 万条消息的吞吐量呢？<strong>购买昂贵的服务器来增强单机RabbitMQ 务的性能显得捉襟见肘，搭建一个 RabbitMQ 集群才是解决实际问题的关键</strong>。</li>
</ul>
<h3 id="搭建步骤（三台机器）"><a href="#搭建步骤（三台机器）" class="headerlink" title="搭建步骤（三台机器）"></a>搭建步骤（三台机器）</h3><ol>
<li><p>使用命令<strong>vim &#x2F;etc&#x2F;hostname</strong>修改3台机器的主机名称，最好使用比较规范的命名方式，方便识别，这里将3台机器分别命名为node1、node2、node3。</p>
</li>
<li><p>使用命令<strong>vim &#x2F;etc&#x2F;hosts</strong>配置各个节点的hosts文件，让各个节点都能互相识别对方，<strong>把所有机器对应的ip和其对应机器的机器名组成的映射写到所有机器的hosts文件中</strong>：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122163145480.png" alt="image-20221122163145480"></p>
</li>
<li><p>在node1上执行远程操作命令：</p>
<p><strong>scp &#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie root@node2:&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie</strong></p>
<p><strong>scp &#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie root@node3:&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;.erlang.cookie</strong></p>
<p>以确保各个节点的cookie文件使用的是同一个值</p>
</li>
<li><p>启动RabbitMQ 服务,顺带启动 Erlang 虚拟机和 RbbitMQ 应用服务(在三台节点上分别执行以下命令)：<strong>rabbitmq-server -detached</strong></p>
</li>
<li><p>在节点2执行：</p>
<p><strong>rabbitmqctl stop_app</strong>（rabbitmqctl stop 会将Erlang 虚拟机和RabbitMQ服务一起关闭，rabbitmqctl stop_app 只关闭 RabbitMQ 服务）</p>
<p><strong>rabbitmqctl reset</strong></p>
<p><strong>rabbitmqctl join_cluster rabbit@node1</strong></p>
<p><strong>rabbitmqctl start_app</strong>（只启动应用服务）</p>
</li>
<li><p>在节点3执行：</p>
<p><strong>rabbitmqctl stop_app</strong><br><strong>rabbitmqctl reset</strong><br><strong>rabbitmqctl join_cluster rabbit@node2</strong><br><strong>rabbitmqctl start_app</strong></p>
</li>
<li><p>查询集群状态：<strong>rabbitmqctl cluster_status</strong></p>
</li>
<li><p>需要重新设置集群的用户：</p>
<p>创建帐号：<strong>rabbitmqctl add_user admin 123</strong></p>
<p>设置用户角色：<strong>rabbitmqctl set_user_tags admin administrator</strong></p>
<p>设置用户权限：<strong>rabbitmqctl set_permissions -p “&#x2F;“ admin “.*“ “.*“ “.*“</strong></p>
</li>
<li><p>解除集群节点（node2和node3机器分别执行）：</p>
<p><strong>rabbitmqctl stop_app</strong><br><strong>rabbitmqctl reset</strong><br><strong>rabbitmqctl start_app</strong><br><strong>rabbitmqctl cluster_status</strong></p>
<p>在node1机器上执行：</p>
<p><strong>rabbitmqctl forget_cluster_node rabbit@node2</strong></p>
</li>
<li><p>总结一下就是：<strong>创建集群的时候需要重启从机并设置其归属主机；解除集群的时候需要重启从机以让从机忘掉主机，再在主机上执行对应的命令以让主机忘记从机</strong>。（集群中应该没有不对等的主从关系，这里使用主机从机只是为了表述归属关系）</p>
</li>
</ol>
<h2 id="镜像队列-Mirror-Queue"><a href="#镜像队列-Mirror-Queue" class="headerlink" title="镜像队列(Mirror Queue)"></a>镜像队列(Mirror Queue)</h2><h3 id="使用镜像队列的原因"><a href="#使用镜像队列的原因" class="headerlink" title="使用镜像队列的原因"></a>使用镜像队列的原因</h3><ul>
<li><strong>如果 RabbitMQ 集群中只有一个 Broker 节点，那么该节点的失效将导致整体服务的临时性不可用，并且也可能会导致消息的丢失</strong>。可以将所有消息都设置为持久化，并且对应队列的 durable 属性也设置为 true，但是这样仍然无法避免由于缓存导致的问题：因为<strong>消息在发送之后和被写入磁盘井执行刷盘动作之间存在一个短暂却会产生问题的时间窗</strong>。通过 publisher-confirm 机制能够确保客户端知道哪些消息己经存入磁盘，尽管如此，<strong>一般不希望遇到因单点故障导致的服务不可用</strong>。</li>
<li>引入镜像队列(Mirror Queue)的机制，<strong>可以将队列镜像到集群中的其他 Broker 节点之上，如果集群中的一个节点失效了，队列能自动地切换到镜像中的另一个节点上以保证服务的可用性</strong>。</li>
</ul>
<h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol>
<li><p>启动三台集群节点</p>
</li>
<li><p>随便找一个节点添加policy，这个数字参数是配置在集群中队列镜像的个数：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122165327443.png" alt="image-20221122165327443"></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122165539951.png" alt="image-20221122165539951"></p>
</li>
<li><p>在 node1 上创建一个队列发送一条消息，在node3中存在该队列的镜像队列：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122165658467.png" alt="image-20221122165658467"></p>
</li>
<li><p>停掉node1之后发现使用的队列变成了node3里的那个镜像队列，而node2中出现了另外一个镜像队列，说明无论何时，只要机器数量足够，那么一个队列总会有一个镜像队列：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122170014398.png" alt="image-20221122170014398"></p>
</li>
<li><p>就算整个集群只剩下一台机器了 依然能消费队列里面的消息，说明队列里面的消息被镜像队列传递到相应机器里面了</p>
</li>
</ol>
<h2 id="Haproxy-Keepalive实现高可用负载均衡"><a href="#Haproxy-Keepalive实现高可用负载均衡" class="headerlink" title="Haproxy+Keepalive实现高可用负载均衡"></a>Haproxy+Keepalive实现高可用负载均衡</h2><ul>
<li>用nginx好像也可以，都是用来做反向代理服务器的。</li>
</ul>
<h3 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h3><p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122170143227.png" alt="image-20221122170143227"></p>
<h3 id="Haproxy实现负载均衡"><a href="#Haproxy实现负载均衡" class="headerlink" title="Haproxy实现负载均衡"></a>Haproxy实现负载均衡</h3><ul>
<li><strong>HAProxy 提供高可用性、负载均衡及基于 TCP-HTTP 应用的代理</strong>，支持虚拟主机，它是免费、快速并且可靠的一种解决方案，包括 Twitter,Reddit,StackOverflow,GitHub 在内的多家知名互联网公司在使用。<strong>HAProxy 实现了一种事件驱动、单一进程模型，此模型支持非常大的井发连接数</strong>。</li>
<li>扩展 nginx,lvs,haproxy 之间的区别: <a target="_blank" rel="noopener" href="http://www.ha97.com/5646.html">http://www.ha97.com/5646.html</a></li>
</ul>
<h3 id="搭建步骤-1"><a href="#搭建步骤-1" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol>
<li><p>下载 haproxy(在 node1 和 node2)：<strong>yum -y install haproxy</strong></p>
</li>
<li><p>修改 node1 和 node2 的 haproxy.cfg：<strong>vim &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg</strong></p>
<p>需要修改红色部分的IP为当前机器的IP：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122170545602.png" alt="image-20221122170545602"></p>
</li>
<li><p>在两台机器上启动haproxy：</p>
<p><strong>haproxy -f &#x2F;etc&#x2F;haproxy&#x2F;haproxy.cfg</strong></p>
<p><strong>ps -ef | grep haproxy</strong></p>
</li>
<li><p>访问地址：<strong><a target="_blank" rel="noopener" href="http://10.211.55.71:8888/stats">http://10.211.55.71:8888/stats</a></strong></p>
</li>
</ol>
<h2 id="Keepalived实现双机-主备-热备-热备份"><a href="#Keepalived实现双机-主备-热备-热备份" class="headerlink" title="Keepalived实现双机(主备)热备(热备份)"></a>Keepalived实现双机(主备)热备(热备份)</h2><ul>
<li>试想如果前面配置的 HAProxy 主机突然宕机或者网卡失效，那么虽然 RbbitMQ 集群没有任何故障但是对于外界的客户端来说所有的连接都会被断开结果将是灾难性的，<strong>确保负载均衡服务的可靠性同样显得十分重要</strong>，这里就要引入<strong>Keepalived，它能够通过自身健康检查、资源接管功能做高可用(双机热备)，实现故障转移</strong>。</li>
</ul>
<h3 id="搭建步骤-2"><a href="#搭建步骤-2" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol>
<li>下载keepalived：<strong>yum -y install keepalived</strong></li>
<li>修改节点node1的配置文件：<strong>vim &#x2F;etc&#x2F;keepalived&#x2F;keepalived.conf</strong>，把资料里面的keepalived.conf修改之后替换</li>
<li>节点node2配置文件，需要修改global_defs的router_id，如nodeB；其次要修改 vrrp_instance_VI 中 state 为”BACKUP”；最后要将 priority 设置为小于 100 的值。</li>
<li>添加haproxy_chk.sh(为了<strong>防止 HAProxy 服务挂掉之后 Keepalived 还在正常工作而没有切换到 Backup 上，所以这里需要编写一个脚本来检测 HAProxy 务的状态,当 HAProxy 服务挂掉之后该脚本会自动重启HAProxy 的服务，如果不成功则关闭 Keepalived 服务，这样便可以切换到 Backup 继续工作</strong>)：<strong>vim &#x2F;etc&#x2F;keepalived&#x2F;haproxy_chk.sh(可以直接上传文件)<strong>，修改权限</strong>chmod 777 &#x2F;etc&#x2F;keepalived&#x2F;haproxy_chk.sh</strong></li>
<li>启动keepalive命令（node1和node2启动）：<strong>systemctl start keepalived</strong></li>
<li>观察 Keepalived 的日志：<strong>tail -f &#x2F;var&#x2F;log&#x2F;messages -n 200</strong></li>
<li>观察最新添加的vip：<strong>ip add show</strong></li>
<li>node1 模拟 keepalived 关闭状态：<strong>systemctl stop keepalived</strong></li>
<li>使用 vip 地址来访问 rabbitmq 集群</li>
</ol>
<h2 id="Federation-Exchange（联邦交换机）"><a href="#Federation-Exchange（联邦交换机）" class="headerlink" title="Federation Exchange（联邦交换机）"></a>Federation Exchange（联邦交换机）</h2><h3 id="使用它的原因"><a href="#使用它的原因" class="headerlink" title="使用它的原因"></a>使用它的原因</h3><ul>
<li><p><strong>(broker 北京)，(broker 深圳)彼此之间相距甚远，网络延迟是一个不得不面对的问题</strong>。有一个在北京的业务(Client 北京) 需要连接(broker 北京)，向其中的交换器 exchangeA 发送消息，此时的网络延迟很小，(Client 北京)可以迅速将消息发送至 exchangeA 中，就算在开启了 publisher-confirm 机制或者事务机制的情况下，也可以迅速收到确认信息。此时又有个在深圳的业务(Client 深圳)需要向 exchangeA 发送消息，那么**(Client 深圳) (broker 北京)之间有很大的网络延迟，(Client 深圳) 将发送消息至 exchangeA 会经历一定的延迟，尤其是在开启了 publisher-confirm 机制或者事务机制的情况下，(Client 深圳) 会等待很长的延迟时间来接收(broker 北京)的确认信息，进而必然造成这条发送线程的性能降低，甚至造成一定程度上的阻塞**。</p>
</li>
<li><p>将业务(Client 深圳)部署到北京的机房可以解决这个问题，但是如果(Client 深圳)调用的另些服务都部署在深圳，那么又会引发新的时延问题，总不见得将所有业务全部部署在一个机房，那么容灾又何以实现？这里<strong>使用 Federation 插件就可以很好地解决这个问题</strong>。</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122181644954.png" alt="image-20221122181644954"></p>
</li>
</ul>
<h3 id="搭建步骤-3"><a href="#搭建步骤-3" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol>
<li><p>需要保证每台节点单独运行</p>
</li>
<li><p>在每台机器上开启federation相关插件：</p>
<p><strong>rabbitmq-plugins enable rabbitmq_federation</strong></p>
<p><strong>rabbitmq-plugins enable rabbitmq_federation_management</strong></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122202128016.png" alt="image-20221122202128016"></p>
</li>
<li><p>原理图（先运行consumer在node2创建fed_exchange）：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122202308766.png" alt="image-20221122202308766"></p>
</li>
<li><p>在downstream（node2）配置upstream（node1）：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122202343393.png" alt="image-20221122202343393"></p>
</li>
<li><p>添加policy：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122202405537.png" alt="image-20221122202405537"></p>
</li>
<li><p>成功的前提是联邦交换机的state是running：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122202450382.png" alt="image-20221122202450382"></p>
</li>
</ol>
<h2 id="Federation-Queue（联邦队列）"><a href="#Federation-Queue（联邦队列）" class="headerlink" title="Federation Queue（联邦队列）"></a>Federation Queue（联邦队列）</h2><h3 id="使用它的原因-1"><a href="#使用它的原因-1" class="headerlink" title="使用它的原因"></a>使用它的原因</h3><ul>
<li><strong>联邦队列可以在多个 Broker 节点(或者集群)之间为单个队列提供均衡负载的功能</strong>。<strong>一个联邦队列可以连接一个或者多个上游队列(upstream queue)，并从这些上游队列中获取消息以满足本地消费者消费消息的需求</strong>。</li>
</ul>
<h3 id="搭建步骤-4"><a href="#搭建步骤-4" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol>
<li><p>原理图：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122201858251.png" alt="image-20221122201858251"></p>
</li>
<li><p>添加upstream（同上）</p>
</li>
<li><p>添加policy：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122201931786.png" alt="image-20221122201931786"></p>
</li>
</ol>
<h2 id="Shovel"><a href="#Shovel" class="headerlink" title="Shovel"></a>Shovel</h2><h3 id="使用它的原因-2"><a href="#使用它的原因-2" class="headerlink" title="使用它的原因"></a>使用它的原因</h3><ul>
<li>Federation 具备的数据转发功能类似，<strong>Shovel 能够可靠、持续地从一个 Broker 中的队列(作为源端，即source)拉取数据并转发至另一个 Broker 中的交换器(作为目的端，即 destination)。作为源端的队列和作为目的端的交换器可以同时位于同一个 Broker，也可以位于不同的 Broker 上</strong>。Shovel 可以翻译为”铲子”，是一种比较形象的比喻，这个”铲子”可以将消息从一方”铲子”另一方。<strong>Shovel的行为就像优秀的客户端应用程序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理</strong>。</li>
</ul>
<h3 id="搭建步骤-5"><a href="#搭建步骤-5" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><ol>
<li><p>开启插件（需要的机器都开启）：</p>
<p><strong>rabbitmq-plugins enable rabbitmq_shovel</strong></p>
<p><strong>rabbitmq-plugins enable rabbitmq_shovel_management</strong></p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122201615713.png" alt="image-20221122201615713"></p>
</li>
<li><p>原理图（在源头发送的消息直接会进入到目的地队列）：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122201702271.png" alt="image-20221122201702271"></p>
</li>
<li><p>添加shovel源和目的地：</p>
<p><img src="https://konjacer-blog-img-repo.oss-cn-qingdao.aliyuncs.com/img/image-20221122201727815.png" alt="image-20221122201727815"></p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://Konjacor.github.io">Konjacer</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://konjacor.github.io/2022/10/28/RabbitMQ%E5%85%A5%E9%97%A8/">https://konjacor.github.io/2022/10/28/RabbitMQ%E5%85%A5%E9%97%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Konjacor.github.io" target="_blank">孤舟</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><a class="post-meta__tags" href="/tags/RabbitMQ/">RabbitMQ</a></div><div class="post_share"><div class="social-share" data-image="/img/background.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/01/Maven/"><img class="prev-cover" src="/img/background.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Maven</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="next-cover" src="/img/background.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/xiaozhai.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Konjacer</div><div class="author-info__description">仰望星空，脚踏实地，寻觅纯粹，奔向自由</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">87</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Konjacor" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1175590069@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/Konjacor" target="_blank" title="Gitee"><i class="fa-solid fa-g"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MQ%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">MQ的相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMQ"><span class="toc-number">1.1.</span> <span class="toc-text">什么是MQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8MQ"><span class="toc-number">1.2.</span> <span class="toc-text">为什么要用MQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E5%89%8A-%E6%B6%88-%E5%B3%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">流量削(消)峰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E8%A7%A3%E8%80%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">应用解耦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="toc-number">1.2.3.</span> <span class="toc-text">异步处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MQ%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">MQ的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ActiveMQ"><span class="toc-number">1.3.1.</span> <span class="toc-text">ActiveMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka"><span class="toc-number">1.3.2.</span> <span class="toc-text">Kafka</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RocketMQ"><span class="toc-number">1.3.3.</span> <span class="toc-text">RocketMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ"><span class="toc-number">1.3.4.</span> <span class="toc-text">RabbitMQ</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MQ%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">1.4.</span> <span class="toc-text">MQ的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">Kafka</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RocketMQ-1"><span class="toc-number">1.4.2.</span> <span class="toc-text">RocketMQ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RabbitMQ-1"><span class="toc-number">1.4.3.</span> <span class="toc-text">RabbitMQ</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ-2"><span class="toc-number">2.</span> <span class="toc-text">RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">RabbitMQ的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.</span> <span class="toc-text">四大核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">2.2.1.</span> <span class="toc-text">生产者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">2.2.2.</span> <span class="toc-text">交换机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">2.2.3.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">2.2.4.</span> <span class="toc-text">消费者</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E6%A0%B8%E5%BF%83%E9%83%A8%E5%88%86"><span class="toc-number">2.3.</span> <span class="toc-text">RabbitMQ核心部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.4.</span> <span class="toc-text">相关名词介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">2.5.</span> <span class="toc-text">安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E7%BD%91%E5%9C%B0%E5%9D%80"><span class="toc-number">2.5.1.</span> <span class="toc-text">官网地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD"><span class="toc-number">2.5.2.</span> <span class="toc-text">文件下载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E6%96%87%E4%BB%B6-%E5%88%86%E5%88%AB%E6%8C%89%E7%85%A7%E4%BB%A5%E4%B8%8B%E9%A1%BA%E5%BA%8F%E5%AE%89%E8%A3%85"><span class="toc-number">2.5.3.</span> <span class="toc-text">安装文件(分别按照以下顺序安装)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E6%8C%89%E7%85%A7%E4%BB%A5%E4%B8%8B%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%89"><span class="toc-number">2.5.4.</span> <span class="toc-text">常用命令（按照以下顺序执行）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E7%94%A8%E6%88%B7"><span class="toc-number">2.5.5.</span> <span class="toc-text">添加一个新的用户</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E6%AC%A1%E5%88%A9%E7%94%A8admin%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95"><span class="toc-number">2.5.6.</span> <span class="toc-text">再次利用admin用户登录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE%E5%91%BD%E4%BB%A4"><span class="toc-number">2.5.7.</span> <span class="toc-text">重置命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hello-World"><span class="toc-number">3.</span> <span class="toc-text">Hello World</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96"><span class="toc-number">3.1.</span> <span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85"><span class="toc-number">3.2.</span> <span class="toc-text">消息生产者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">3.3.</span> <span class="toc-text">消息消费者</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Work-Queues"><span class="toc-number">4.</span> <span class="toc-text">Work Queues</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E5%88%86%E5%8F%91%E6%B6%88%E6%81%AF"><span class="toc-number">4.1.</span> <span class="toc-text">轮询分发消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E5%8F%96%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">4.1.1.</span> <span class="toc-text">抽取工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%A4%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">启动两个工作线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E5%8F%91%E9%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.1.3.</span> <span class="toc-text">启动一个发送线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E5%B1%95%E7%A4%BA"><span class="toc-number">4.1.4.</span> <span class="toc-text">结果展示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94"><span class="toc-number">4.2.</span> <span class="toc-text">消息应答</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">4.2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%BA%94%E7%AD%94"><span class="toc-number">4.2.2.</span> <span class="toc-text">自动应答</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E6%B6%88%E6%81%AF%E5%BA%94%E7%AD%94%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.3.</span> <span class="toc-text">手动消息应答的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%BA%94%E7%AD%94%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0Multiple%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-number">4.2.4.</span> <span class="toc-text">手动应答方法参数Multiple的解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%87%AA%E5%8A%A8%E9%87%8D%E6%96%B0%E5%85%A5%E9%98%9F"><span class="toc-number">4.2.5.</span> <span class="toc-text">消息自动重新入队</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%89%8B%E5%8A%A8%E5%BA%94%E7%AD%94%E4%BB%A3%E7%A0%81"><span class="toc-number">4.2.6.</span> <span class="toc-text">消息手动应答代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%BA%94%E7%AD%94%E6%95%88%E6%9E%9C%E6%BC%94%E7%A4%BA"><span class="toc-number">4.2.7.</span> <span class="toc-text">手动应答效果演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">4.3.</span> <span class="toc-text">RabbitMQ持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">4.3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">4.3.2.</span> <span class="toc-text">队列如何实现持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">4.3.3.</span> <span class="toc-text">消息实现持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%85%AC%E5%B9%B3%E5%88%86%E5%8F%91"><span class="toc-number">4.3.4.</span> <span class="toc-text">不公平分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%8F%96%E5%80%BC"><span class="toc-number">4.3.5.</span> <span class="toc-text">预取值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4"><span class="toc-number">5.</span> <span class="toc-text">发布确认</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">发布确认原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number">5.2.</span> <span class="toc-text">发布确认的策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.1.</span> <span class="toc-text">开启发布确认的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83"><span class="toc-number">5.2.2.</span> <span class="toc-text">单个确认发布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83"><span class="toc-number">5.2.3.</span> <span class="toc-text">批量确认发布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%A1%AE%E8%AE%A4%E5%8F%91%E5%B8%83"><span class="toc-number">5.2.4.</span> <span class="toc-text">异步确认发布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E6%9C%AA%E7%A1%AE%E8%AE%A4%E6%B6%88%E6%81%AF"><span class="toc-number">5.2.5.</span> <span class="toc-text">如何处理异步未确认消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8A3%E7%A7%8D%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E9%80%9F%E5%BA%A6%E5%AF%B9%E6%AF%94"><span class="toc-number">5.2.6.</span> <span class="toc-text">以上3种发布确认速度对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA-1"><span class="toc-number">6.</span> <span class="toc-text">交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Exchange%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.</span> <span class="toc-text">Exchange简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Exchanges%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.1.</span> <span class="toc-text">Exchanges概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exchanges%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.2.</span> <span class="toc-text">Exchanges的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%8Dexchange"><span class="toc-number">6.1.3.</span> <span class="toc-text">无名exchange</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E6%97%B6%E9%98%9F%E5%88%97"><span class="toc-number">6.2.</span> <span class="toc-text">临时队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%EF%BC%88bindings%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">绑定（bindings）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fanout-Exchange-%E6%89%87%E5%87%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">6.4.</span> <span class="toc-text">Fanout Exchange(扇出交换机)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Fanout%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.4.1.</span> <span class="toc-text">Fanout介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fanout%E5%AE%9E%E6%88%98"><span class="toc-number">6.4.2.</span> <span class="toc-text">Fanout实战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Direct-Exchange-%E7%9B%B4%E6%8E%A5%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">6.5.</span> <span class="toc-text">Direct Exchange(直接交换机)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE"><span class="toc-number">6.5.1.</span> <span class="toc-text">回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Direct-Exchange%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.5.2.</span> <span class="toc-text">Direct Exchange介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%91%E5%AE%9A"><span class="toc-number">6.5.3.</span> <span class="toc-text">多重绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-number">6.5.4.</span> <span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Topic-Exchange-%E4%B8%BB%E9%A2%98%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">6.6.</span> <span class="toc-text">Topic Exchange(主题交换机)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%8B%E5%89%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">6.6.1.</span> <span class="toc-text">之前类型的交换机存在的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Topic-Exchange%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-number">6.6.2.</span> <span class="toc-text">Topic Exchange的要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Topic-Exchange%E5%8C%B9%E9%85%8D%E6%A1%88%E4%BE%8B"><span class="toc-number">6.6.3.</span> <span class="toc-text">Topic Exchange匹配案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98-1"><span class="toc-number">6.6.4.</span> <span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Header-Exchange-%E6%A0%87%E9%A2%98-x2F-%E9%A6%96%E9%83%A8%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">6.7.</span> <span class="toc-text">Header Exchange(标题&#x2F;首部交换机)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text">死信队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">7.1.</span> <span class="toc-text">死信的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E7%9A%84%E6%9D%A5%E6%BA%90"><span class="toc-number">7.2.</span> <span class="toc-text">死信的来源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E5%AE%9E%E6%88%98"><span class="toc-number">7.3.</span> <span class="toc-text">死信实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">7.3.1.</span> <span class="toc-text">代码架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AFTTL%E8%BF%87%E6%9C%9F%E9%80%A0%E6%88%90%E7%9A%84%E6%AD%BB%E4%BF%A1"><span class="toc-number">7.3.2.</span> <span class="toc-text">消息TTL过期造成的死信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E8%BE%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6%E9%80%A0%E6%88%90%E6%AD%BB%E4%BF%A1"><span class="toc-number">7.3.3.</span> <span class="toc-text">队列达到最大长度造成死信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%A2%AB%E6%8B%92%E9%80%A0%E6%88%90%E7%9A%84%E6%AD%BB%E4%BF%A1"><span class="toc-number">7.3.4.</span> <span class="toc-text">消息被拒造成的死信</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">8.</span> <span class="toc-text">延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E6%A6%82%E5%BF%B5"><span class="toc-number">8.1.</span> <span class="toc-text">延迟队列概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.2.</span> <span class="toc-text">延迟队列使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RabbitMQ%E4%B8%AD%E7%9A%84TTL"><span class="toc-number">8.3.</span> <span class="toc-text">RabbitMQ中的TTL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E8%AE%BE%E7%BD%AETTL"><span class="toc-number">8.3.1.</span> <span class="toc-text">队列设置TTL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%AE%BE%E7%BD%AETTL"><span class="toc-number">8.3.2.</span> <span class="toc-text">消息设置TTL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E8%AE%BE%E7%BD%AETTL%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.3.3.</span> <span class="toc-text">两种设置TTL方式的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%90%88SpringBoot"><span class="toc-number">8.4.</span> <span class="toc-text">整合SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="toc-number">8.4.1.</span> <span class="toc-text">创建项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96"><span class="toc-number">8.4.2.</span> <span class="toc-text">添加依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">8.4.3.</span> <span class="toc-text">修改配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0Swagger%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-number">8.4.4.</span> <span class="toc-text">添加Swagger配置类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AE%E9%98%9F%E5%88%97%E7%9A%84TTL%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">8.5.</span> <span class="toc-text">通过设置队列的TTL实现延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%9B%BE-1"><span class="toc-number">8.5.1.</span> <span class="toc-text">代码架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B1%BB%E4%BB%A3%E7%A0%81"><span class="toc-number">8.5.2.</span> <span class="toc-text">配置文件类代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81"><span class="toc-number">8.5.3.</span> <span class="toc-text">消息生产者代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81"><span class="toc-number">8.5.4.</span> <span class="toc-text">消息消费者代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">8.5.5.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AE%E6%B6%88%E6%81%AF%E7%9A%84TTL%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">8.6.</span> <span class="toc-text">通过设置消息的TTL实现延迟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%9B%BE-2"><span class="toc-number">8.6.1.</span> <span class="toc-text">代码架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B1%BB%E4%BB%A3%E7%A0%81-1"><span class="toc-number">8.6.2.</span> <span class="toc-text">配置文件类代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81-1"><span class="toc-number">8.6.3.</span> <span class="toc-text">消息生产者代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-1"><span class="toc-number">8.6.4.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rabbitmq%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E4%B8%8A%E8%BF%B0%E9%97%AE%E9%A2%98"><span class="toc-number">8.7.</span> <span class="toc-text">Rabbitmq插件实现延迟队列解决上述问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E6%8F%92%E4%BB%B6"><span class="toc-number">8.7.1.</span> <span class="toc-text">安装延时队列插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%9B%BE-3"><span class="toc-number">8.7.2.</span> <span class="toc-text">代码架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%B1%BB%E4%BB%A3%E7%A0%81-2"><span class="toc-number">8.7.3.</span> <span class="toc-text">配置文件类代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81-2"><span class="toc-number">8.7.4.</span> <span class="toc-text">消息生产者代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81-1"><span class="toc-number">8.7.5.</span> <span class="toc-text">消息消费者代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-2"><span class="toc-number">8.7.6.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E9%AB%98%E7%BA%A7"><span class="toc-number">9.</span> <span class="toc-text">发布确认高级</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E7%A1%AE%E8%AE%A4%E7%9A%84SpringBoot%E7%89%88%E6%9C%AC"><span class="toc-number">9.1.</span> <span class="toc-text">发布确认的SpringBoot版本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%E6%96%B9%E6%A1%88"><span class="toc-number">9.1.1.</span> <span class="toc-text">确认机制方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%9B%BE-4"><span class="toc-number">9.1.2.</span> <span class="toc-text">代码架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">9.1.3.</span> <span class="toc-text">配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-number">9.1.4.</span> <span class="toc-text">添加配置类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85-1"><span class="toc-number">9.1.5.</span> <span class="toc-text">消息生产者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.1.6.</span> <span class="toc-text">回调接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E8%80%85-1"><span class="toc-number">9.1.7.</span> <span class="toc-text">消息消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90"><span class="toc-number">9.1.8.</span> <span class="toc-text">结果分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E9%80%80%E6%B6%88%E6%81%AF"><span class="toc-number">9.2.</span> <span class="toc-text">回退消息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mandatory%E5%8F%82%E6%95%B0"><span class="toc-number">9.2.1.</span> <span class="toc-text">Mandatory参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A3%E7%A0%81-3"><span class="toc-number">9.2.2.</span> <span class="toc-text">消息生产者代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E6%8E%A5%E5%8F%A3-1"><span class="toc-number">9.2.3.</span> <span class="toc-text">回调接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90-1"><span class="toc-number">9.2.4.</span> <span class="toc-text">结果分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">9.3.</span> <span class="toc-text">备份交换机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%9E%B6%E6%9E%84%E5%9B%BE-5"><span class="toc-number">9.3.1.</span> <span class="toc-text">代码架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E7%B1%BB"><span class="toc-number">9.3.2.</span> <span class="toc-text">修改配置类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E8%AD%A6%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">9.3.3.</span> <span class="toc-text">报警消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">9.3.4.</span> <span class="toc-text">测试注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90-2"><span class="toc-number">9.3.5.</span> <span class="toc-text">结果分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">10.</span> <span class="toc-text">RabbitMQ其他知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%82%E7%AD%89%E6%80%A7"><span class="toc-number">10.1.</span> <span class="toc-text">幂等性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">10.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-number">10.1.2.</span> <span class="toc-text">消息重复消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">10.1.3.</span> <span class="toc-text">解决思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E7%AB%AF%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E4%BF%9D%E9%9A%9C"><span class="toc-number">10.1.4.</span> <span class="toc-text">消费端的幂等性保障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%94%AF%E4%B8%80ID-%E6%8C%87%E7%BA%B9%E7%A0%81%E6%9C%BA%E5%88%B6"><span class="toc-number">10.1.5.</span> <span class="toc-text">唯一ID+指纹码机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">10.1.6.</span> <span class="toc-text">Redis原子性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">10.2.</span> <span class="toc-text">优先级队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">10.2.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">10.2.2.</span> <span class="toc-text">如何添加优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98-2"><span class="toc-number">10.2.3.</span> <span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97"><span class="toc-number">10.3.</span> <span class="toc-text">惰性队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">10.3.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">10.3.2.</span> <span class="toc-text">队列的两种模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%BC%80%E9%94%80%E5%AF%B9%E6%AF%94"><span class="toc-number">10.3.3.</span> <span class="toc-text">内存开销对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RabbitMQ%E9%9B%86%E7%BE%A4"><span class="toc-number">11.</span> <span class="toc-text">RabbitMQ集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#clustering-%E4%BD%BF%E7%94%A8%E9%9B%86%E7%BE%A4"><span class="toc-number">11.1.</span> <span class="toc-text">clustering(使用集群)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%9B%86%E7%BE%A4%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">11.1.1.</span> <span class="toc-text">使用集群的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4%EF%BC%88%E4%B8%89%E5%8F%B0%E6%9C%BA%E5%99%A8%EF%BC%89"><span class="toc-number">11.1.2.</span> <span class="toc-text">搭建步骤（三台机器）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E9%98%9F%E5%88%97-Mirror-Queue"><span class="toc-number">11.2.</span> <span class="toc-text">镜像队列(Mirror Queue)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">11.2.1.</span> <span class="toc-text">使用镜像队列的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-number">11.2.2.</span> <span class="toc-text">搭建步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Haproxy-Keepalive%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">11.3.</span> <span class="toc-text">Haproxy+Keepalive实现高可用负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-number">11.3.1.</span> <span class="toc-text">整体架构图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Haproxy%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">11.3.2.</span> <span class="toc-text">Haproxy实现负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">11.3.3.</span> <span class="toc-text">搭建步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Keepalived%E5%AE%9E%E7%8E%B0%E5%8F%8C%E6%9C%BA-%E4%B8%BB%E5%A4%87-%E7%83%AD%E5%A4%87-%E7%83%AD%E5%A4%87%E4%BB%BD"><span class="toc-number">11.4.</span> <span class="toc-text">Keepalived实现双机(主备)热备(热备份)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4-2"><span class="toc-number">11.4.1.</span> <span class="toc-text">搭建步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Federation-Exchange%EF%BC%88%E8%81%94%E9%82%A6%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%89"><span class="toc-number">11.5.</span> <span class="toc-text">Federation Exchange（联邦交换机）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%83%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">11.5.1.</span> <span class="toc-text">使用它的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4-3"><span class="toc-number">11.5.2.</span> <span class="toc-text">搭建步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Federation-Queue%EF%BC%88%E8%81%94%E9%82%A6%E9%98%9F%E5%88%97%EF%BC%89"><span class="toc-number">11.6.</span> <span class="toc-text">Federation Queue（联邦队列）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%83%E7%9A%84%E5%8E%9F%E5%9B%A0-1"><span class="toc-number">11.6.1.</span> <span class="toc-text">使用它的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4-4"><span class="toc-number">11.6.2.</span> <span class="toc-text">搭建步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shovel"><span class="toc-number">11.7.</span> <span class="toc-text">Shovel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%83%E7%9A%84%E5%8E%9F%E5%9B%A0-2"><span class="toc-number">11.7.1.</span> <span class="toc-text">使用它的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%AD%A5%E9%AA%A4-5"><span class="toc-number">11.7.2.</span> <span class="toc-text">搭建步骤</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/18/IT%E8%BF%90%E7%BB%B4%E5%89%8D%E6%B2%BF/" title="IT运维前沿"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IT运维前沿"/></a><div class="content"><a class="title" href="/2024/09/18/IT%E8%BF%90%E7%BB%B4%E5%89%8D%E6%B2%BF/" title="IT运维前沿">IT运维前沿</a><time datetime="2024-09-18T02:04:08.000Z" title="发表于 2024-09-18 10:04:08">2024-09-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/05/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E5%AD%A6%E5%A4%A7%E7%BA%B2/" title="C语言与数据结构教学大纲"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言与数据结构教学大纲"/></a><div class="content"><a class="title" href="/2024/07/05/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%95%99%E5%AD%A6%E5%A4%A7%E7%BA%B2/" title="C语言与数据结构教学大纲">C语言与数据结构教学大纲</a><time datetime="2024-07-05T10:19:21.000Z" title="发表于 2024-07-05 18:19:21">2024-07-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/14/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E9%A1%B9%E7%9B%AE-%E5%90%88%E4%BD%9C%E5%8A%9E%E5%AD%A6%E8%AF%84%E4%BC%B0%E5%B9%B3%E5%8F%B0/" title="实验室项目-合作办学评估平台"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实验室项目-合作办学评估平台"/></a><div class="content"><a class="title" href="/2024/06/14/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E9%A1%B9%E7%9B%AE-%E5%90%88%E4%BD%9C%E5%8A%9E%E5%AD%A6%E8%AF%84%E4%BC%B0%E5%B9%B3%E5%8F%B0/" title="实验室项目-合作办学评估平台">实验室项目-合作办学评估平台</a><time datetime="2024-06-14T02:15:32.000Z" title="发表于 2024-06-14 10:15:32">2024-06-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/23/%E8%88%B8%E6%96%8B%E5%BF%83%E6%B3%95/" title="舸斋心法"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="舸斋心法"/></a><div class="content"><a class="title" href="/2024/04/23/%E8%88%B8%E6%96%8B%E5%BF%83%E6%B3%95/" title="舸斋心法">舸斋心法</a><time datetime="2024-04-23T15:20:13.000Z" title="发表于 2024-04-23 23:20:13">2024-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/03/15/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" title="离散数学"><img src="/img/background.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="离散数学"/></a><div class="content"><a class="title" href="/2024/03/15/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/" title="离散数学">离散数学</a><time datetime="2024-03-15T09:54:51.000Z" title="发表于 2024-03-15 17:54:51">2024-03-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/background.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By Konjacer</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>